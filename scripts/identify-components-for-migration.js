/**
 * Component Migration Analyzer
 * 
 * This script analyzes React components to identify those that use legacy
 * services directly and should be migrated to the new service architecture.
 * 
 * Usage:
 *   node scripts/identify-components-for-migration.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name using ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '..');
const componentsDir = path.join(rootDir, 'src/components');

// Legacy service patterns to look for
const legacyServicePatterns = [
  'ElementalCalculator',
  'AstrologicalService',
  'AlchemicalService',
  'AlchemicalTransformationService',
  'ChakraService',
  'IngredientFilterService',
  'IngredientService',
  'LocalRecipeService',
  'NutritionService',
  'RecipeElementalService',
  'RecipeFinder',
  'RecommendationAdapter',
  'RecommendationService',
  'SpoonacularService',
  'WiccanCorrespondenceService'
];

// Define priority levels based on service dependencies
const servicePriorities = {
  'ElementalCalculator': 'High',
  'AstrologicalService': 'High',
  'AlchemicalService': 'Medium',
  'IngredientFilterService': 'Medium',
  'IngredientService': 'Medium',
  'LocalRecipeService': 'Medium',
  'RecipeElementalService': 'Medium',
  'RecommendationService': 'Low',
  'ChakraService': 'Low',
  'AlchemicalTransformationService': 'Low',
  'WiccanCorrespondenceService': 'Low'
};

// Results storage
const componentsToMigrate = [];

/**
 * Find files in a directory recursively
 */
function findFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stats = fs.statSync(filePath);

    if (stats.isDirectory()) {
      findFiles(filePath, fileList);
    } else if (stats.isFile() && /\.(tsx|jsx)$/.test(file) && !/\.test\.(tsx|jsx)$/.test(file)) {
      fileList.push(filePath);
    }
  });

  return fileList;
}

/**
 * Analyze a component file for legacy service imports
 */
function analyzeComponent(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const relativePath = path.relative(rootDir, filePath);
  const componentName = path.basename(filePath).replace(/\.(tsx|jsx)$/, '');
  
  // Find imports
  const importRegex = /import\s+.*?from\s+['"]@\/services\/([^'"]+)['"]/g;
  const importMatches = [...content.matchAll(importRegex)];
  
  // Find used services
  const usedServices = [];
  legacyServicePatterns.forEach(service => {
    if (content.includes(service)) {
      usedServices.push(service);
    }
  });
  
  // Only include components that import or use legacy services
  if (importMatches.length > 0 || usedServices.length > 0) {
    // Determine priority
    let highestPriority = 'Low';
    usedServices.forEach(service => {
      const servicePriority = servicePriorities[service] || 'Low';
      if (servicePriority === 'High' && highestPriority !== 'High') {
        highestPriority = 'High';
      } else if (servicePriority === 'Medium' && highestPriority === 'Low') {
        highestPriority = 'Medium';
      }
    });
    
    componentsToMigrate.push({
      component: componentName,
      path: relativePath,
      servicesUsed: usedServices,
      priority: highestPriority
    });
  }
}

/**
 * Main function
 */
function main() {
  console.log('Identifying components for Phase 3 migration...');
  
  // Find all component files
  const componentFiles = findFiles(componentsDir);
  console.log(`Found ${componentFiles.length} component files to analyze.`);
  
  // Analyze each component
  componentFiles.forEach(file => {
    analyzeComponent(file);
  });
  
  // Sort components by priority
  componentsToMigrate.sort((a, b) => {
    const priorityOrder = { 'High': 0, 'Medium': 1, 'Low': 2 };
    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });
  
  // Output results
  console.log(`\nIdentified ${componentsToMigrate.length} components to migrate:`);
  console.log('\n| Component | Services Used | Priority | Path |');
  console.log('|-----------|--------------|----------|------|');
  
  componentsToMigrate.forEach(item => {
    console.log(`| ${item.component} | ${item.servicesUsed.join(', ')} | ${item.priority} | ${item.path} |`);
  });
  
  // Generate markdown file
  const markdown = `# Components to Migrate in Phase 3
  
This file was automatically generated by the component migration analyzer.

## Components Using Legacy Services

| Component | Services Used | Priority | Path |
|-----------|--------------|----------|------|
${componentsToMigrate.map(item => `| ${item.component} | ${item.servicesUsed.join(', ')} | ${item.priority} | ${item.path} |`).join('\n')}

## Migration Priorities

- **High Priority**: Core utility components with minimal dependencies
- **Medium Priority**: Feature components that depend on high-priority components
- **Low Priority**: Complex components with multiple dependencies

`;

  // Write markdown to file
  fs.writeFileSync(path.join(rootDir, 'src/docs/components-to-migrate.md'), markdown);
  console.log('\nResults saved to src/docs/components-to-migrate.md');
}

// Run the main function
main(); 