#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|2591Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|2888Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|5760Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|6702Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|6999Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|9871Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |12737Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|14331Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|14628Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|17500Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|18442Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|18739Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|21611Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |24477Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|28646Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|28943Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|31815Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|32757Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|33054Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|35926Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |38792Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|41031Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|41328Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|44200Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|45142Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|45439Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|48311Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |51177Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|52771Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|53068Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|55940Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|56882Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|57179Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|60051Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |62917Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|67086Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|67383Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|70255Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|water|71197Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|water|71494Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|74366Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |77232Earth#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|1288Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|1585Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |4457Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(fire|5399Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(fire|5696Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |8568Water#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(638Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(935Fire#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');

// Target files (focus on ingredientRecommendation.ts first)
const targetFiles = [
  path.resolve(__dirname, '../../src/utils/recommendation/ingredientRecommendation.ts'),
];

// Patterns to fix
const fixPatterns = [
  // Fix direct property access for fire, water, earth, Air
  {
    find: /(\w+)\.(Fire|Water|Earth|Air)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix direct property access in conditions
  {
    find: /if\s*\(\s*(\w+)\.(Fire|Water|Earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |water|earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |earth|Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); |Air)(\s*[><]=?|\s*===?|\s*!==?|\s*&&|\s*\|\|)/g,
    replace: (match, obj, prop, operator) => {
      return `if ((${obj}?.${prop} || 0)${operator}`;
    }
  },
  
  // Fix async function return types
  {
    find: /async\s+function\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, funcName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async function ${funcName}(...args): Promise<any> {`;
    }
  },
  
  // Fix async method return types
  {
    find: /async\s+(\w+)\([^)]*\)\s*{/g,
    replace: (match, methodName) => {
      // Skip if it already has a return type
      if (match.includes(': Promise<')) {
        return match;
      }
      return `async ${methodName}(...args): Promise<any> {`;
    }
  },
  
  // Add missing await keywords to Promise returning functions
  {
    find: /(\w+)\.then\(/g,
    replace: (match, obj) => {
      return `(await ${obj}).then(`;
    }
  },
  
  // Fix direct access to flavor properties
  {
    find: /(\w+)\.(bitter|sweet|sour|salty|umami)(\s*[+\-*/]?=|\s*\|\||\s*\?\?|\s*[><]=?|\s*===?|\s*!==?|\s*[+\-*/]|\s*$|\s*;|\s*,)/g,
    replace: (match, obj, prop, operator) => {
      return `(${obj}?.${prop} || 0)${operator}`;
    }
  }
];

/**
 * Fix elemental property access issues in a file
 */
function fixFile(filePath, isDryRun) {
  console.log(`Processing ${filePath}...`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let originalContent = content;
    let changeCount = 0;
    
    // Apply each pattern
    for (const pattern of fixPatterns) {
      const beforeCount = content.match(pattern.find)?.length || 0;
      content = content.replace(pattern.find, pattern.replace);
      const afterCount = content.match(pattern.find)?.length || 0;
      const patternChanges = beforeCount - afterCount;
      if (patternChanges > 0) {
        console.log(`  Applied pattern: ${pattern.find.toString().slice(0, 40)}... (${patternChanges} changes)`);
        changeCount += patternChanges;
      }
    }
    
    // Write changes
    if (content !== originalContent) {
      if (isDryRun) {
        console.log(`  Would make ${changeCount} changes (dry run)`);
      } else {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Made ${changeCount} changes`);
      }
    } else {
      console.log('  No changes needed');
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

/**
 * Main execution function
 */
function main() {
  console.log(`Running in ${isDryRun ? 'DRY RUN' : 'LIVE'} mode`);
  
  // Process each file
  for (const filePath of targetFiles) {
    if (fs.existsSync(filePath)) {
      fixFile(filePath, isDryRun);
    } else {
      console.error(`File not found: ${filePath}`);
    }
  }
}

// Run the script
main(); 