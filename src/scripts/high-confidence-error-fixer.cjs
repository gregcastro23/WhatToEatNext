#!/usr/bin/env node

/**
 * High-Confidence Error Fixer
 *
 * Systematically fixes the 1,067 high-confidence errors:
 * - TS18046: 'unknown' type errors (851 errors)
 * - TS2571: Object is unknown errors (216 errors)
 */

const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

class HighConfidenceErrorFixer {
  constructor() {
    this.fixedCount = 0;
    this.skippedCount = 0;
    this.errorCount = 0;
    this.backupDir = ".high-confidence-fixes-backup";
  }

  async executeFixCampaign() {
    console.log("üöÄ Starting High-Confidence Error Fix Campaign");
    console.log("Target: 1,067 TS18046 and TS2571 errors\n");

    // Create backup directory
    this.createBackupDirectory();

    // Get all high-confidence errors
    const errors = this.getHighConfidenceErrors();
    console.log(`üìä Found ${errors.length} high-confidence errors to fix\n`);

    // Group errors by file for efficient processing
    const errorsByFile = this.groupErrorsByFile(errors);
    console.log(`üìÅ Processing ${Object.keys(errorsByFile).length} files\n`);

    // Process each file
    for (const [filePath, fileErrors] of Object.entries(errorsByFile)) {
      await this.processFile(filePath, fileErrors);
    }

    // Generate summary report
    this.generateSummaryReport();
  }

  createBackupDirectory() {
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
    }
  }

  getHighConfidenceErrors() {
    try {
      const output = execSync("yarn tsc --noEmit --skipLibCheck 2>&1", {
        encoding: "utf8",
        stdio: "pipe",
      });
      return [];
    } catch (error) {
      const errorLines = error.stdout
        .split("\n")
        .filter(
          (line) =>
            line.includes("error TS18046") || line.includes("error TS2571"),
        )
        .map((line) => this.parseErrorLine(line))
        .filter(Boolean);

      return errorLines;
    }
  }

  parseErrorLine(line) {
    const match = line.match(/^(.+?)\((\d+),(\d+)\): error (TS\d+): (.+)$/);
    if (!match) return null;

    const [, filePath, lineNum, colNum, errorCode, message] = match;
    return {
      filePath: filePath.trim(),
      line: parseInt(lineNum),
      column: parseInt(colNum),
      errorCode,
      message: message.trim(),
    };
  }

  groupErrorsByFile(errors) {
    const grouped = {};
    for (const error of errors) {
      if (!grouped[error.filePath]) {
        grouped[error.filePath] = [];
      }
      grouped[error.filePath].push(error);
    }
    return grouped;
  }

  async processFile(filePath, errors) {
    console.log(`üîß Processing: ${filePath} (${errors.length} errors)`);

    try {
      // Create backup
      this.createFileBackup(filePath);

      // Read file content
      const content = fs.readFileSync(filePath, "utf8");
      let modifiedContent = content;

      // Sort errors by line number (descending) to avoid line number shifts
      const sortedErrors = errors.sort((a, b) => b.line - a.line);

      // Apply fixes
      for (const error of sortedErrors) {
        const fixResult = this.applyFix(modifiedContent, error);
        if (fixResult.success) {
          modifiedContent = fixResult.content;
          this.fixedCount++;
          console.log(`  ‚úÖ Fixed ${error.errorCode} at line ${error.line}`);
        } else {
          this.skippedCount++;
          console.log(
            `  ‚ö†Ô∏è  Skipped ${error.errorCode} at line ${error.line}: ${fixResult.reason}`,
          );
        }
      }

      // Write modified content if changes were made
      if (modifiedContent !== content) {
        fs.writeFileSync(filePath, modifiedContent);
        console.log(`  üíæ Saved changes to ${filePath}`);
      }
    } catch (error) {
      this.errorCount++;
      console.error(`  ‚ùå Error processing ${filePath}:`, error.message);
    }

    console.log("");
  }

  createFileBackup(filePath) {
    const backupPath = path.join(this.backupDir, filePath.replace(/\//g, "_"));
    const backupDir = path.dirname(backupPath);

    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    fs.copyFileSync(filePath, backupPath);
  }

  applyFix(content, error) {
    const lines = content.split("\n");
    const errorLine = lines[error.line - 1];

    if (!errorLine) {
      return { success: false, reason: "Line not found" };
    }

    let fixedLine = errorLine;
    let success = false;

    if (error.errorCode === "TS18046") {
      // Fix 'unknown' type errors
      const fixResult = this.fixUnknownTypeError(errorLine, error);
      if (fixResult.success) {
        fixedLine = fixResult.line;
        success = true;
      }
    } else if (error.errorCode === "TS2571") {
      // Fix 'object is unknown' errors
      const fixResult = this.fixObjectUnknownError(errorLine, error);
      if (fixResult.success) {
        fixedLine = fixResult.line;
        success = true;
      }
    }

    if (success) {
      lines[error.line - 1] = fixedLine;
      return { success: true, content: lines.join("\n") };
    }

    return { success: false, reason: "No applicable fix pattern" };
  }

  fixUnknownTypeError(line, error) {
    // Common patterns for TS18046 fixes
    const patterns = [
      // Pattern: 'msg' is of type 'unknown'
      {
        regex: /(\w+)\s+is\s+of\s+type\s+'unknown'/,
        fix: (match, varName) => {
          // Add type assertion
          if (line.includes(`${varName}.`)) {
            return line.replace(
              new RegExp(`${varName}\\.`),
              `(${varName} as Record<string, unknown>).`,
            );
          }
          return null;
        },
      },

      // Pattern: Variable access on unknown
      {
        regex: /(\w+)\.(\w+)/,
        fix: (match, objName, propName) => {
          if (error.message.includes(`'${objName}' is of type 'unknown'`)) {
            return line.replace(
              `${objName}.${propName}`,
              `(${objName} as Record<string, unknown>).${propName}`,
            );
          }
          return null;
        },
      },

      // Pattern: Function call on unknown
      {
        regex: /(\w+)\(/,
        fix: (match, funcName) => {
          if (error.message.includes(`'${funcName}' is of type 'unknown'`)) {
            return line.replace(`${funcName}(`, `(${funcName} as Function)(`);
          }
          return null;
        },
      },
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern.regex);
      if (match) {
        const fixedLine = pattern.fix(match, ...match.slice(1));
        if (fixedLine) {
          return { success: true, line: fixedLine };
        }
      }
    }

    return { success: false };
  }

  fixObjectUnknownError(line, error) {
    // Common patterns for TS2571 fixes
    const patterns = [
      // Pattern: Object is of type 'unknown'
      {
        regex: /(\w+)\s*\[/,
        fix: (match, objName) => {
          return line.replace(
            `${objName}[`,
            `(${objName} as Record<string, unknown>)[`,
          );
        },
      },

      // Pattern: Property access on unknown object
      {
        regex: /(\w+)\.(\w+)/,
        fix: (match, objName, propName) => {
          return line.replace(
            `${objName}.${propName}`,
            `(${objName} as Record<string, unknown>).${propName}`,
          );
        },
      },

      // Pattern: Method call on unknown object
      {
        regex: /(\w+)\.(\w+)\(/,
        fix: (match, objName, methodName) => {
          return line.replace(
            `${objName}.${methodName}(`,
            `(${objName} as any).${methodName}(`,
          );
        },
      },
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern.regex);
      if (match) {
        const fixedLine = pattern.fix(match, ...match.slice(1));
        if (fixedLine && fixedLine !== line) {
          return { success: true, line: fixedLine };
        }
      }
    }

    return { success: false };
  }

  generateSummaryReport() {
    const report = {
      timestamp: new Date().toISOString(),
      campaign: "High-Confidence Error Fixes",
      results: {
        fixed: this.fixedCount,
        skipped: this.skippedCount,
        errors: this.errorCount,
        total: this.fixedCount + this.skippedCount + this.errorCount,
      },
      successRate: Math.round(
        (this.fixedCount /
          (this.fixedCount + this.skippedCount + this.errorCount)) *
          100,
      ),
      backupLocation: this.backupDir,
    };

    // Write report
    fs.writeFileSync(
      "high-confidence-fixes-report.json",
      JSON.stringify(report, null, 2),
    );

    // Display summary
    console.log("\n" + "=".repeat(80));
    console.log("üìä HIGH-CONFIDENCE ERROR FIX CAMPAIGN SUMMARY");
    console.log("=".repeat(80));
    console.log(`\n‚úÖ Fixed: ${this.fixedCount} errors`);
    console.log(`‚ö†Ô∏è  Skipped: ${this.skippedCount} errors`);
    console.log(`‚ùå Errors: ${this.errorCount} errors`);
    console.log(`üìà Success Rate: ${report.successRate}%`);
    console.log(`\nüíæ Backups saved to: ${this.backupDir}`);
    console.log(`üìÑ Report saved to: high-confidence-fixes-report.json`);
    console.log("\nüîç Run TypeScript check to verify fixes:");
    console.log("   yarn tsc --noEmit --skipLibCheck");
    console.log("=".repeat(80));
  }
}

// Execute fix campaign
async function main() {
  const fixer = new HighConfidenceErrorFixer();
  await fixer.executeFixCampaign();
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { HighConfidenceErrorFixer };
