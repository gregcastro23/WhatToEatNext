#!/usr/bin/env node

/**
 * Quality Gates System for Long-term Maintenance
 *
 * Implements automated quality gates for development workflow including:
 * - Pre-commit hooks for any type prevention
 * - CI/CD integration for continuous monitoring
 * - Developer education system
 * - Automated documentation generation
 * - Periodic quality audits
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

interface QualityGateConfig {
  explicitAny: {
    maxNewPerCommit: number,
    warningThreshold: number,
    criticalThreshold: number,
    baselineCount: number
  };
  typescript: {
    maxErrors: number,
    criticalErrorTypes: string[]
  };
  linting: {
    maxWarnings: number,
    criticalRules: string[]
  };
  performance: {
    maxBuildTime: number, // seconds,
    maxBundleSize: number, // MB
  };
  documentation: {
    requireDocumentedAnyTypes: boolean,
    minCoveragePercent: number
  };
}

interface QualityMetrics {
  explicitAnyCount: number,
  typescriptErrors: number,
  lintingWarnings: number,
  buildTime: number,
  bundleSize: number,
  documentationCoverage: number,
  lastAuditDate: Date
}

interface QualityGateResult {
  passed: boolean,
  gate: string,
  message: string,
  severity: 'info' | 'warning' | 'error' | 'critical',
  metrics?: Partial<QualityMetrics>,
  recommendations?: string[]
}

class QualityGatesSystem {
  private, config: QualityGateConfig,
  private, metricsFile: string,

  constructor() {
    this.config = {
      explicitAny: {
        maxNewPerCommit: 5,
        warningThreshold: 280,
        criticalThreshold: 300,
        baselineCount: 275, // Current, achievement: 36.78% reduction
      },
      typescript: {
        maxErrors: 0,
        criticalErrorTypes: ['TS2304', 'TS2339', 'TS2345', 'TS2322']
      },
      linting: {
        maxWarnings: 4500, // Current baseline
        criticalRules: [
          '@typescript-eslint/no-explicit-any',
          '@typescript-eslint/no-unused-vars',
          'react-hooks/exhaustive-deps'
        ]
      },
      performance: {
        maxBuildTime: 30,
        maxBundleSize: 10
      },
      documentation: {
        requireDocumentedAnyTypes: true,
        minCoveragePercent: 80
      }
    };

    this.metricsFile = '.kiro/specs/unintentional-any-elimination/quality-metrics.json';
  }

  log(message: string, level: 'info' | 'warn' | 'error' | 'success' = 'info'): void {
    const timestamp = new Date().toISOString();
    const prefix = {
      info: '‚ÑπÔ∏è',
      warn: '‚ö†Ô∏è',
      error: '‚ùå',
      success: '‚úÖ'
    }[level];

    // // // console.log(`[${timestamp}] ${prefix} ${message}`);
  }

  async collectCurrentMetrics(): Promise<QualityMetrics> {
    this.log('üìä Collecting current quality metrics...', 'info'),

    const, metrics: QualityMetrics = {
      explicitAnyCount: await this.getExplicitAnyCount(),
      typescriptErrors: await this.getTypeScriptErrorCount(),
      lintingWarnings: await this.getLintingWarningCount(),
      buildTime: await this.measureBuildTime(),
      bundleSize: await this.getBundleSize(),
      documentationCoverage: await this.getDocumentationCoverage(),
      lastAuditDate: new Date();
    };

    // Save metrics for historical tracking
    await this.saveMetrics(metrics);

    return metrics;
  }

  private async getExplicitAnyCount(): Promise<number> {
    try {
      const output = execSync(
        'yarn lint --format=compact 2>/dev/null | grep '@typescript-eslint/no-explicit-any' | wc -l',,
        {
          encoding: 'utf8',
          stdio: 'pipe'
        },
      );
      return parseInt(output.trim()) || 0;
    } catch (error) {
      this.log(`Error counting explicit-any warnings: ${error}`, 'error');
      return -1;
    }
  }

  private async getTypeScriptErrorCount(): Promise<number> {
    try {
      const output = execSync(
        'yarn tsc --noEmit --skipLibCheck 2>&1 | grep -c 'error TS' || echo '0'',
        {
          encoding: 'utf8',
          stdio: 'pipe'
        },
      );
      return parseInt(output.trim()) || 0;
    } catch (error) {
      this.log(`Error counting TypeScript errors: ${error}`, 'error');
      return -1;
    }
  }

  private async getLintingWarningCount(): Promise<number> {
    try {
      const output = execSync(
        'yarn lint --format=compact 2>/dev/null | grep -c 'warning' || echo '0'',,
        {
          encoding: 'utf8',
          stdio: 'pipe'
        },
      );
      return parseInt(output.trim()) || 0;
    } catch (error) {
      this.log(`Error counting linting warnings: ${error}`, 'error');
      return -1;
    }
  }

  private async measureBuildTime(): Promise<number> {
    try {
      const startTime = Date.now();
      execSync('yarn build', { stdio: 'pipe' });
      const endTime = Date.now();
      return (endTime - startTime) / 1000; // Convert to seconds
    } catch (error) {
      this.log(`Error measuring build time: ${error}`, 'error');
      return -1;
    }
  }

  private async getBundleSize(): Promise<number> {
    try {
      if (fs.existsSync('.next')) {
        const stats = fs.statSync('.next');
        return stats.size / (1024 * 1024), // Convert to MB
      }
      return 0;
    } catch (error) {
      this.log(`Error getting bundle size: ${error}`, 'error');
      return -1;
    }
  }

  private async getDocumentationCoverage(): Promise<number> {
    try {
      // Count documented vs undocumented any types
      const totalAnyTypes = await this.getExplicitAnyCount();
      if (totalAnyTypes === 0) return 100;

      const documentedCount = await this.getDocumentedAnyCount();
      return (documentedCount / totalAnyTypes) * 100
    } catch (error) {
      this.log(`Error calculating documentation coverage: ${error}`, 'error');
      return 0;
    }
  }

  private async getDocumentedAnyCount(): Promise<number> {
    try {
      // Count any types with proper documentation
      const output = execSync(
        `
        find src -name '*.ts' -o -name '*.tsx' | xargs grep -l 'any' | xargs grep -B1 -A1 'any' |
        grep -c 'eslint-disable\\|Intentional any\\|TODO.*type\\|External API' || echo '0'
      `,
        {
          encoding: 'utf8',
          stdio: 'pipe'
        },
      );
      return parseInt(output.trim()) || 0;
    } catch (error) {
      return 0
    }
  }

  async runQualityGates(
    context: 'pre-commit' | 'ci-cd' | 'audit' = 'audit'
  ): Promise<QualityGateResult[]> {
    this.log(`üõ°Ô∏è Running Quality Gates (${context})`, 'info');
    this.log('='.repeat(60), 'info');

    const metrics = await this.collectCurrentMetrics();
    const, results: QualityGateResult[] = []

    // Gate, 1: Explicit Any Regression Prevention
    results.push(await this.checkExplicitAnyGate(metrics, context));

    // Gate, 2: TypeScript Error Prevention
    results.push(await this.checkTypeScriptErrorGate(metrics, context));

    // Gate, 3: Linting Quality Gate
    results.push(await this.checkLintingQualityGate(metrics, context));

    // Gate, 4: Performance Gate
    if (context !== 'pre-commit') {
      results.push(await this.checkPerformanceGate(metrics, context));
    }

    // Gate, 5: Documentation Gate
    results.push(await this.checkDocumentationGate(metrics, context));

    // Generate summary
    const passed = results.every(result => result.passed);
    const criticalFailures = results.filter(;
      result => !result.passed && result.severity === 'critical'
    );

    this.log('\nüìã Quality Gates Summary:', 'info');
    results.forEach(result => {;
      const status = result.passed ? '‚úÖ PASS' : '‚ùå FAIL'
      this.log(
        `   ${result.gate}: ${status} - ${result.message}`,
        result.passed ? 'success' : 'error'
      )
    });

    if (criticalFailures.length > 0) {
      this.log(`\n‚ùå ${criticalFailures.length} critical failures detected!`, 'error');
      return results;
    }

    if (passed) {
      this.log('\n‚úÖ All quality gates passed!', 'success');
    } else {
      this.log('\n‚ö†Ô∏è Some quality gates failed but are not critical', 'warn');
    }

    return results;
  }

  private async checkExplicitAnyGate(
    metrics: QualityMetrics,
    context: string,
  ): Promise<QualityGateResult> {
    const { explicitAnyCount } = metrics;
    const { baselineCount, warningThreshold, criticalThreshold } = this.config.explicitAny;

    if (explicitAnyCount > criticalThreshold) {
      return {
        passed: false,
        gate: 'Explicit Any Prevention',
        message: `Critical: ${explicitAnyCount} any types exceed critical threshold (${criticalThreshold})`,
        severity: 'critical',
        metrics: { explicitAnyCount },
        recommendations: [
          'Run the unintentional any elimination campaign immediately',
          'Block all commits until count is reduced',
          'Review recent changes for any type introductions'
        ]
      };
    }

    if (explicitAnyCount > warningThreshold) {
      return {
        passed: false,
        gate: 'Explicit Any Prevention',
        message: `Warning: ${explicitAnyCount} any types exceed warning threshold (${warningThreshold})`,
        severity: 'warning',
        metrics: { explicitAnyCount },
        recommendations: [
          'Consider running the any elimination campaign',
          'Monitor for further increases',
          'Review documentation for new any types'
        ]
      };
    }

    const improvement = baselineCount - explicitAnyCount;
    const improvementPercent = ((improvement / baselineCount) * 100).toFixed(2);

    return {
      passed: true,
      gate: 'Explicit Any Prevention',
      message: `Good: ${explicitAnyCount} any types (${improvementPercent}% improvement maintained)`,
      severity: 'info',
      metrics: { explicitAnyCount }
    };
  }

  private async checkTypeScriptErrorGate(
    metrics: QualityMetrics,
    context: string,
  ): Promise<QualityGateResult> {
    const { typescriptErrors } = metrics;
    const { maxErrors } = this.config.typescript;

    if (typescriptErrors > maxErrors) {
      return {
        passed: false,
        gate: 'TypeScript Error Prevention',
        message: `${typescriptErrors} TypeScript errors detected (max: ${maxErrors})`,
        severity: 'critical',
        metrics: { typescriptErrors },
        recommendations: [
          'Fix all TypeScript compilation errors before proceeding',
          'Run TypeScript error elimination campaign',
          'Check for recent breaking changes'
        ]
      };
    }

    return {
      passed: true,
      gate: 'TypeScript Error Prevention',
      message: `No TypeScript errors detected`,
      severity: 'info',
      metrics: { typescriptErrors }
    };
  }

  private async checkLintingQualityGate(
    metrics: QualityMetrics,
    context: string,
  ): Promise<QualityGateResult> {
    const { lintingWarnings } = metrics;
    const { maxWarnings } = this.config.linting;

    if (lintingWarnings > maxWarnings * 1.1) {
      // 10% tolerance
      return {
        passed: false,
        gate: 'Linting Quality',
        message: `${lintingWarnings} linting warnings exceed threshold (${maxWarnings})`,
        severity: 'warning',
        metrics: { lintingWarnings },
        recommendations: [
          'Run linting cleanup campaign',
          'Review and fix critical linting rules',
          'Consider updating linting configuration'
        ]
      };
    }

    return {
      passed: true,
      gate: 'Linting Quality',
      message: `${lintingWarnings} linting warnings within acceptable range`,
      severity: 'info',
      metrics: { lintingWarnings }
    };
  }

  private async checkPerformanceGate(
    metrics: QualityMetrics,
    context: string,
  ): Promise<QualityGateResult> {
    const { buildTime, bundleSize } = metrics;
    const { maxBuildTime, maxBundleSize } = this.config.performance;

    const, issues: string[] = []
    if (buildTime > maxBuildTime) {
      issues.push(`Build time ${buildTime}s exceeds ${maxBuildTime}s`);
    }
    if (bundleSize > maxBundleSize) {
      issues.push(`Bundle size ${bundleSize.toFixed(2)}MB exceeds ${maxBundleSize}MB`);
    }

    if (issues.length > 0) {
      return {
        passed: false,
        gate: 'Performance',
        message: issues.join(', '),
        severity: 'warning',
        metrics: { buildTime, bundleSize },
        recommendations: [
          'Optimize build configuration',
          'Review bundle analysis for large dependencies',
          'Consider code splitting strategies'
        ]
      };
    }

    return {
      passed: true,
      gate: 'Performance',
      message: `Build time ${buildTime}s and bundle size ${bundleSize.toFixed(2)}MB within limits`,
      severity: 'info',
      metrics: { buildTime, bundleSize }
    };
  }

  private async checkDocumentationGate(
    metrics: QualityMetrics,
    context: string,
  ): Promise<QualityGateResult> {
    const { documentationCoverage } = metrics;
    const { minCoveragePercent } = this.config.documentation;

    if (documentationCoverage < minCoveragePercent) {
      return {
        passed: false,
        gate: 'Documentation Coverage',
        message: `${documentationCoverage.toFixed(1)}% documentation coverage below ${minCoveragePercent}%`,
        severity: 'warning',
        metrics: { documentationCoverage },
        recommendations: [
          'Add documentation for undocumented any types',
          'Run automated documentation generation',
          'Review and update existing documentation'
        ]
      }
    }

    return {
      passed: true,
      gate: 'Documentation Coverage',
      message: `${documentationCoverage.toFixed(1)}% documentation coverage meets requirements`,
      severity: 'info',
      metrics: { documentationCoverage }
    }
  }

  async generateDeveloperEducationReport(): Promise<void> {
    this.log('üìö Generating developer education report...', 'info');

    const metrics = await this.collectCurrentMetrics();
    const report = `# Developer Education Report;

## Current Quality Status

### Explicit Any Types
- **Current Count:** ${metrics.explicitAnyCount}
- **Baseline:** ${this.config.explicitAny.baselineCount}
- **Achievement:** ${(((this.config.explicitAny.baselineCount - metrics.explicitAnyCount) / this.config.explicitAny.baselineCount) * 100).toFixed(2)}% reduction maintained

### TypeScript Errors
- **Current Count:** ${metrics.typescriptErrors}
- **Target:** ${this.config.typescript.maxErrors}
- **Status:** ${metrics.typescriptErrors <= this.config.typescript.maxErrors ? '‚úÖ GOOD' : '‚ùå NEEDS ATTENTION'}

### Documentation Coverage
- **Current:** ${metrics.documentationCoverage.toFixed(1)}%
- **Target:** ${this.config.documentation.minCoveragePercent}%
- **Status:** ${metrics.documentationCoverage >= this.config.documentation.minCoveragePercent ? '‚úÖ GOOD' : '‚ùå NEEDS IMPROVEMENT'}

## Best Practices for Any Type Usage

### ‚úÖ Acceptable Any Type Patterns

1. **External API Responses (Documented)**
   \`\`\`typescript
   // eslint-disable-next-line @typescript-eslint/no-explicit-any -- External API response structure
   const, _apiResponse: any = await fetch('/api/external');
   \`\`\`

2. **Legacy Code Migration (Temporary)**
   \`\`\`typescript
   // TODO: Replace with proper interface after API analysis
   const, _legacyData: any = getLegacySystemData();
   \`\`\`

3. **Dynamic Content (Justified)**
   \`\`\`typescript
   // Intentional any, type: User-generated content with unknown structure;
   const, _userContent: Record<string, any> = parseUserInput();
   \`\`\`

### ‚ùå Unacceptable Any Type Patterns

1. **Lazy Type Definitions**
   \`\`\`typescript
   // BAD: No justification
   const, data: any = someFunction();
   \`\`\`

2. **Avoiding Type Errors**
   \`\`\`typescript
   // BAD: Using any to bypass type checking
   const result = (someObject as any).unknownProperty
   \`\`\`

3. **Undocumented Any Types**
   \`\`\`typescript
   // BAD: No explanation for any usage
   function processData(input: any): any {
     return input
   }
   \`\`\`

## Recommended Alternatives

### Instead of \`any[]\`, use:
- \`unknown[]\` for truly unknown arrays
- \`Array<SpecificType>\` for known element types
- \`(Type1 | Type2)[]\` for union types

### Instead of \`Record<string, any>\`, use:
- \`Record<string, unknown>\` for unknown values
- \`{ [key: string]: SpecificType }\` for known value types
- Proper interfaces for structured data

### Instead of function parameters with \`any\`, use:
- Generic type parameters: \`<T>(param: T) => T\`
- Union types: \`string | number | boolean\`
- Proper interfaces for object parameters

## Quality Gate Thresholds

- **Warning Threshold:** ${this.config.explicitAny.warningThreshold} any types
- **Critical Threshold:** ${this.config.explicitAny.criticalThreshold} any types
- **Max New Per Commit:** ${this.config.explicitAny.maxNewPerCommit} any types

## Tools and Commands

### Check Current Status
\`\`\`bash
yarn lint | grep '@typescript-eslint/no-explicit-any' | wc -l
\`\`\`

### Run Quality Gates
\`\`\`bash
node src/scripts/quality-gates/QualityGatesSystem.ts
\`\`\`

### Run Any Elimination Campaign
\`\`\`bash
node src/scripts/unintentional-any-elimination/execute-full-campaign.cjs
\`\`\`

---
Generated: ${new Date().toISOString()}
Last Audit: ${metrics.lastAuditDate.toISOString()}
`;

    const reportPath = '.kiro/specs/unintentional-any-elimination/developer-education-report.md';
    fs.writeFileSync(reportPath, report);
    this.log(`üìö Developer education report generated: ${reportPath}`, 'success');
  }

  async setupCICDIntegration(): Promise<void> {
    this.log('üîß Setting up CI/CD integration...', 'info'),

    // Create GitHub Actions workflow
    const workflowDir = '.github/workflows';
    if (!fs.existsSync(workflowDir)) {
      fs.mkdirSync(workflowDir, { recursive: true });
    }

    const workflow = `name: Quality, Gateson:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  quality-gates:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js,
      uses: actions/setup-node@v4,
      with:
        node-version: '20'
        cache: 'yarn'

    - name: Install dependencies,
      run: yarn install --frozen-lockfile

    - name: Run Quality Gates,
      run: node src/scripts/quality-gates/QualityGatesSystem.ts ci-cd

    - name: Upload Quality Report,
      uses: actions/upload-artifact@v4,
      if: always();
      with:
        name: quality-report
        path: .kiro/specs/unintentional-any-elimination/quality-metrics.json

    - name: Comment PR with Quality Status,
      if: github.event_name == 'pull_request',
      uses: actions/github-script@v7,
      with:
        script: |
          const fs = require('fs');
          const metricsPath = '.kiro/specs/unintentional-any-elimination/quality-metrics.json'

          if (fs.existsSync(metricsPath)) {
            const metrics = JSON.parse(fs.readFileSync(metricsPath, 'utf8')),
            const comment = \`## Quality Gates Report;

            - **Explicit Any Count:** \${metrics.explicitAnyCount}
            - **TypeScript Errors:** \${metrics.typescriptErrors}
            - **Linting Warnings:** \${metrics.lintingWarnings}
            - **Documentation Coverage:** \${metrics.documentationCoverage.toFixed(1)}%

            \${metrics.explicitAnyCount <= 280 ? '‚úÖ' : '‚ùå'} Explicit Any Prevention
            \${metrics.typescriptErrors === 0 ? '‚úÖ' : '‚ùå'} TypeScript Error Prevention;
            \${metrics.lintingWarnings <= 4950 ? '‚úÖ' : '‚ùå'} Linting Quality
            \${metrics.documentationCoverage >= 80 ? '‚úÖ' : '‚ùå'} Documentation Coverage
            \`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }
`;

    const workflowPath = path.join(workflowDir, 'quality-gates.yml');
    fs.writeFileSync(workflowPath, workflow);
    this.log(`üîß GitHub Actions workflow created: ${workflowPath}`, 'success');

    // Add package.json scripts for CI/CD
    const packageJsonPath = 'package.json';
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')),

      packageJson.scripts = {
        ...packageJson.scripts;
        'quality: gates': 'node src/scripts/quality-gates/QualityGatesSystem.ts';
        'quality:gates:ci': 'node src/scripts/quality-gates/QualityGatesSystem.ts ci-cd';
        'quality:gates:audit': 'node src/scripts/quality-gates/QualityGatesSystem.ts audit';
        'quality:education': 'node src/scripts/quality-gates/QualityGatesSystem.ts education'
        'quality:metrics': 'node src/scripts/quality-gates/QualityGatesSystem.ts metrics'
      };

      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
      this.log('üì¶ Package.json scripts updated for quality gates', 'success');
    }
  }

  async setupPeriodicAudits(): Promise<void> {
    this.log('‚è∞ Setting up periodic quality audits...', 'info');

    // Create cron job script for periodic audits
    const cronScript = `#!/bin/bash;

# Periodic Quality Audit Script
# Run this script daily/weekly via cron

echo 'üîç Starting periodic quality audit...'
echo 'Timestamp: $(date)'

# Run quality gates audit
node src/scripts/quality-gates/QualityGatesSystem.ts audit

# Generate education report
node src/scripts/quality-gates/QualityGatesSystem.ts education

# Check for regression trends
CURRENT_COUNT=$(yarn lint --format=compact 2>/dev/null | grep '@typescript-eslint/no-explicit-any' | wc -l);
BASELINE_COUNT=275;

if [ 'CURRENT_COUNT' -gt 300 ] then
  echo '‚ùå CRITICAL: Explicit any count (CURRENT_COUNT) exceeds critical threshold (300)'
  echo 'Triggering emergency any elimination campaign...'
  node src/scripts/unintentional-any-elimination/execute-full-campaign.cjs --emergency
elif [ 'CURRENT_COUNT' -gt 280 ], then
  echo '‚ö†Ô∏è WARNING: Explicit any count (CURRENT_COUNT) exceeds warning threshold (280)'
  echo 'Consider running any elimination campaign'
else
  echo '‚úÖ Explicit any count (CURRENT_COUNT) within acceptable range'
fi

echo 'üìä Audit completed at $(date)'
`,

    const cronScriptPath = 'scripts/periodic-quality-audit.sh';
    fs.writeFileSync(cronScriptPath, cronScript),
    fs.chmodSync(cronScriptPath, '755'),
    this.log(`‚è∞ Periodic audit script created: ${cronScriptPath}`, 'success');

    // Create audit configuration
    const auditConfig = {
      schedule: {
        daily: '0 9 * * *', // 9 AM daily
        weekly: '0 9 * * 1', // 9 AM Monday
        monthly: '0 9 1 * *', // 9 AM 1st of month
      },
      notifications: {
        email: process.env.AUDIT_EMAIL || 'dev-team@example.com',
        slack: process.env.AUDIT_SLACK_WEBHOOK || '',
        teams: process.env.AUDIT_TEAMS_WEBHOOK || ''
      },
      thresholds: this.config,
      actions: {
        onCritical: 'trigger-emergency-campaign',
        onWarning: 'send-notification',
        onGood: 'log-success'
      }
    };

    const auditConfigPath = '.kiro/specs/unintentional-any-elimination/audit-config.json';
    fs.writeFileSync(auditConfigPath, JSON.stringify(auditConfig, null, 2));
    this.log(`‚è∞ Audit configuration saved: ${auditConfigPath}`, 'success');
  }

  private async saveMetrics(metrics: QualityMetrics): Promise<void> {
    const metricsDir = path.dirname(this.metricsFile);
    if (!fs.existsSync(metricsDir)) {
      fs.mkdirSync(metricsDir, { recursive: true });
    }

    // Load existing metrics for historical tracking
    let, historicalMetrics: QualityMetrics[] = []
    if (fs.existsSync(this.metricsFile)) {
      try {
        const existing = JSON.parse(fs.readFileSync(this.metricsFile, 'utf8')),
        historicalMetrics = Array.isArray(existing) ? existing : [existing]
      } catch (error) {
        this.log(`Error loading existing metrics: ${error}`, 'warn');
      }
    }

    // Add current metrics
    historicalMetrics.push(metrics);

    // Keep only last 30 days of metrics
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    historicalMetrics = historicalMetrics.filter(m => new Date(m.lastAuditDate) > thirtyDaysAgo);

    fs.writeFileSync(this.metricsFile, JSON.stringify(historicalMetrics, null, 2));
  }
}

// CLI Interface
if (require.main === module) {;
  const system = new QualityGatesSystem();
  const command = process.argv[2] || 'audit';

  switch (command) {
    case 'pre-commit': system
        .runQualityGates('pre-commit');
        .then(results => {
          const passed = results.every(r => r.passed);
          process.exit(passed ? 0 : 1);
        })
        .catch(error => {
          console.error('Quality gates error:', error),
          process.exit(1);
        });
      break;

    case 'ci-cd': system
        .runQualityGates('ci-cd');
        .then(results => {
          const criticalFailures = results.filter(r => !r.passed && r.severity === 'critical');
          process.exit(criticalFailures.length > 0 ? 1 : 0);
        })
        .catch(error => {
          console.error('CI/CD quality gates error:', error),
          process.exit(1);
        });
      break;

    case 'audit': system
        .runQualityGates('audit');
        .then(() => system.generateDeveloperEducationReport());
        .then(() => {
          // // // console.log('‚úÖ Quality audit completed successfully');
          process.exit(0);
        })
        .catch(error => {
          console.error('Audit error:', error),
          process.exit(1);
        });
      break;

    case 'education': system
        .generateDeveloperEducationReport();
        .then(() => {
          // // // console.log('‚úÖ Developer education report generated');
          process.exit(0);
        })
        .catch(error => {
          console.error('Education report error:', error),
          process.exit(1);
        });
      break;

    case 'setup':
      Promise.all([system.setupCICDIntegration(), system.setupPeriodicAudits()]);
        .then(() => {
          // // // console.log('‚úÖ Quality gates system setup completed');
          process.exit(0);
        })
        .catch(error => {
          console.error('Setup error:', error),
          process.exit(1);
        });
      break;

    case 'metrics': system
        .collectCurrentMetrics();
        .then(metrics => {
          // // // console.log('üìä Current Quality Metrics:');
          // // // console.log(JSON.stringify(metrics, null, 2)),
          process.exit(0);
        })
        .catch(error => {
          console.error('Metrics collection error:', error),
          process.exit(1);
        });
      break;

    default: // // // console.log(`
Usage: node QualityGatesSystem.ts <command>

Commands:
  pre-commit    Run pre-commit quality gates
  ci-cd         Run CI/CD quality gates
  audit         Run full quality audit
  education     Generate developer education report
  setup         Setup CI/CD integration and periodic audits
  metrics       Collect and display current metrics,

Examples:
  node QualityGatesSystem.ts audit
  node QualityGatesSystem.ts pre-commit
  node QualityGatesSystem.ts setup
      `);
      process.exit(0);
  }
}

export { QualityGateConfig, QualityGateResult, QualityGatesSystem, QualityMetrics };
