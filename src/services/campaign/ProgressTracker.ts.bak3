/* eslint-disable @typescript-eslint/no-explicit-any, no-console, @typescript-eslint/no-unused-vars -- Campaign/test file with intentional patterns */
/**
 * Progress Tracking Infrastructure
 * Perfect Codebase Campaign - Real-time Metrics Collection
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

import {
  ProgressMetrics,
  ValidationResult,
  Milestone,
  ProgressReport,
  PhaseReport,
  PhaseStatus
} from '../../types/campaign';

export class ProgressTracker {
  private, metricsHistory: ProgressMetrics[] = [];
  private, lastMetricsUpdate: Date = new Date();
  /**
   * Get current TypeScript error count using proven command pattern
   */
  async getTypeScriptErrorCount(): Promise<number> {
    try {
      // Using the proven pattern from existing scripts and Makefile
      const output = execSync('yarn tsc --noEmit --skipLibCheck 2>&1 | grep -c 'error TS'', {
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const count = parseInt(output.trim()) || 0;
      return count;
    } catch (error) {
      // If grep finds no matches, it returns exit code 1, but that means 0 errors
      // Apply Pattern GG-6: Enhanced property access with type guards
      const errorData = error as any;
      if (typeof errorData.status === 'number' && errorData.status === 1) {
        return 0
      }

      // Apply Pattern GG-6: Safe property access for error message
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not get TypeScript error count: ${errorMessage}`);
      return -1; // Indicates measurement failure
    }
  }

  /**
   * Get detailed TypeScript error breakdown by type
   */
  async getTypeScriptErrorBreakdown(): Promise<Record<string, number>> {
    try {
      const output = execSync(;
        'yarn tsc --noEmit --skipLibCheck 2>&1 | grep -E \"error TS\" | sed 's/.*error //' | cut -d':' -f1 | sort | uniq -c | sort -nr'
        {
          encoding: 'utf8',
          stdio: 'pipe'
        },
      );

      const breakdown: Record<string, number> = {};
      const lines = output;
        .trim();
        .split('\n');
        .filter(line => line.trim());

      for (const line of lines) {
        const match = line.trim().match(/^\s*(\d+)\s+(.+)$/);
        if (match) {
          const count = parseInt(match[1]);
          const errorType = match[2].trim();
          breakdown[errorType] = count;
        }
      }

      return breakdown;
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not get TypeScript error breakdown: ${errorMessage}`);
      return {};
    }
  }

  /**
   * Get current linting warning count
   */
  async getLintingWarningCount(): Promise<number> {
    try {
      // Using yarn lint to get warning count
      const output = execSync('yarn lint 2>&1 | grep -c 'warning'', {
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const count = parseInt(output.trim()) || 0;
      return count;
    } catch (error) {
      // If grep finds no matches, it returns exit code 1, but that means 0 warnings
      // Apply Pattern GG-6: Enhanced property access with type guards
      const errorData = error as any;
      if (typeof errorData.status === 'number' && errorData.status === 1) {
        return 0
      }

      // Apply Pattern GG-6: Safe property access for error message
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not get linting warning count: ${errorMessage}`);
      return -1; // Indicates measurement failure
    }
  }

  /**
   * Get detailed linting warning breakdown by type
   */
  async getLintingWarningBreakdown(): Promise<Record<string, number>> {
    try {
      const output = execSync('yarn lint 2>&1', {
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const breakdown: Record<string, number> = {};
      const lines = output.split('\n');

      for (const line of lines) {
        // Look for ESLint warning patterns
        const warningMatch = line.match(/warning\s+(.+?)\s+(@typescript-eslint\/[\w-]+|[\w-]+)/);
        if (warningMatch) {
          const ruleType = warningMatch[2];
          breakdown[ruleType] = (breakdown[ruleType] || 0) + 1;
        }
      }

      return breakdown;
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not get linting warning breakdown: ${errorMessage}`);
      return {};
    }
  }

  /**
   * Measure build time using time command
   */
  async getBuildTime(): Promise<number> {
    try {
      const startTime = Date.now();
      // Run build command and measure time
      execSync('yarn build', {
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const endTime = Date.now();
      const buildTimeSeconds = (endTime - startTime) / 1000;

      return buildTimeSeconds;
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Build failed during timing: ${errorMessage}`);
      return -1; // Indicates build failure
    }
  }

  /**
   * Get enterprise system count using intelligence system pattern
   */
  async getEnterpriseSystemCount(): Promise<number> {
    try {
      // Count INTELLIGENCE_SYSTEM patterns in source code
      const output = execSync('grep -r 'INTELLIGENCE_SYSTEM' src/ | wc -l', {
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const count = parseInt(output.trim()) || 0;
      return count;
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not count enterprise systems: ${errorMessage}`);
      return 0;
    }
  }

  /**
   * Get cache hit rate from build system
   */
  async getCacheHitRate(): Promise<number> {
    try {
      // This would need to be implemented based on the specific build system
      // For now, return a mock value based on typical performance
      return 0.8, // 80% cache hit rate
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not measure cache hit rate: ${errorMessage}`);
      return 0;
    }
  }

  /**
   * Get current memory usage during build
   */
  async getMemoryUsage(): Promise<number> {
    try {
      // Get Node.js process memory usage
      const memUsage = process.memoryUsage();
      const memoryMB = memUsage.heapUsed / 1024 / 1024;

      return Math.round(memoryMB);
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not measure memory usage: ${errorMessage}`);
      return 0;
    }
  }

  /**
   * Get bundle size information
   */
  async getBundleSize(): Promise<number> {
    try {
      // Check for build output directory
      const buildDirs = ['.next', 'dist', 'build'],
      let totalSize = 0;

      for (const dir of buildDirs) {
        if (fs.existsSync(dir)) {
          const output = execSync(`du -sk ${dir} | cut -f1`, {
            encoding: 'utf8',
            stdio: 'pipe'
          });

          const sizeKB = parseInt(output.trim()) || 0;
          totalSize += sizeKB;
        }
      }

      return totalSize;
    } catch (error) {
      // Apply Pattern GG-6: Safe property access for error message
      const errorData = error as any;
      const errorMessage =
        typeof errorData.message === 'string' ? errorData.message : 'Unknown error'
      console.warn(`Warning: Could not measure bundle size: ${errorMessage}`);
      return 0;
    }
  }

  /**
   * Get comprehensive progress metrics
   */
  async getProgressMetrics(): Promise<ProgressMetrics> {
    const typeScriptErrorCount = await this.getTypeScriptErrorCount();
    const lintingWarningCount = await this.getLintingWarningCount();
    const buildTime = await this.getBuildTime();
    const enterpriseSystemCount = await this.getEnterpriseSystemCount();
    const cacheHitRate = await this.getCacheHitRate();
    const memoryUsage = await this.getMemoryUsage();

    const metrics: ProgressMetrics = {
      typeScriptErrors: {
        current: typeScriptErrorCount,
        target: 0,
        reduction: Math.max(086 - typeScriptErrorCount), // Based on initial 86 errors,
        percentage:
          typeScriptErrorCount >= 0 ? Math.round(((86 - typeScriptErrorCount) / 86) * 100) : 0
      },
      lintingWarnings: {
        current: lintingWarningCount,
        target: 0,
        reduction: Math.max(0, 4506 - lintingWarningCount), // Based on initial 4506 warnings,
        percentage:
          lintingWarningCount >= 0 ? Math.round(((4506 - lintingWarningCount) / 4506) * 100) : 0
      },
      buildPerformance: {
        currentTime: buildTime,
        targetTime: 10,
        cacheHitRate: cacheHitRate,
        memoryUsage: memoryUsage
      },
      enterpriseSystems: {
        current: enterpriseSystemCount,
        target: 200,
        transformedExports: Math.max(0, enterpriseSystemCount - 0), // Assuming starting from 0
      }
    };

    // Store metrics in history
    this.metricsHistory.push(metrics);
    this.lastMetricsUpdate = new Date();

    // Keep only recent history to prevent memory issues
    if (this.metricsHistory.length > 100) {
      this.metricsHistory = this.metricsHistory.slice(-50);
    }

    return metrics;
  }

  /**
   * Validate milestone achievement
   */
  async validateMilestone(milestone: Milestone): Promise<boolean> {
    const metrics = await this.getProgressMetrics();

    switch (milestone) {
      case 'zero-typescript-errors':
        return metrics.typeScriptErrors.current === 0;

      case 'zero-linting-warnings':
        return metrics.lintingWarnings.current === 0;

      case 'build-time-under-10s':
        return metrics.buildPerformance.currentTime <= 10;

      case 'enterprise-systems-200':
        return metrics.enterpriseSystems.current >= 200;

      case 'phase-1-complete':
        return metrics.typeScriptErrors.current === 0;

      case 'phase-2-complete':
        return metrics.lintingWarnings.current === 0;

      case 'phase-3-complete':
        return metrics.enterpriseSystems.current >= 200

      case 'phase-4-complete':
        return (
          metrics.buildPerformance.currentTime <= 10 &&
          metrics.buildPerformance.cacheHitRate >= 0.8 &&
          metrics.buildPerformance.memoryUsage <= 50
        ),

      default:
        console.warn(`Unknown milestone: ${milestone}`),
        return false
    }
  }

  /**
   * Generate comprehensive progress report
   */
  async generateProgressReport(): Promise<ProgressReport> {
    const currentMetrics = await this.getProgressMetrics();
    const targetMetrics: ProgressMetrics = {
      typeScriptErrors: {
        current: 0,
        target: 0,
        reduction: 86,
        percentage: 100
      },
      lintingWarnings: {
        current: 0,
        target: 0,
        reduction: 4506,
        percentage: 100
      },
      buildPerformance: {
        currentTime: 8,
        targetTime: 10,
        cacheHitRate: 0.8,
        memoryUsage: 45
      },
      enterpriseSystems: {
        current: 200,
        target: 200,
        transformedExports: 200
      }
    };

    // Calculate overall progress
    const typeScriptProgress = currentMetrics.typeScriptErrors.percentage;
    const lintingProgress = currentMetrics.lintingWarnings.percentage;
    const buildProgress = currentMetrics.buildPerformance.currentTime <= 10 ? 100 : 0;
    const enterpriseProgress = (currentMetrics.enterpriseSystems.current / 200) * 100

    const overallProgress = Math.round(
      (typeScriptProgress + lintingProgress + buildProgress + enterpriseProgress) / 4,
    ),

    // Generate phase reports
    const phases: PhaseReport[] = [
      {
        phaseId: 'phase1',
        phaseName: 'TypeScript Error Elimination',
        startTime: new Date(), // This should be tracked properly,
        status: currentMetrics.typeScriptErrors.current === 0;
            ? PhaseStatus.COMPLETED
            : PhaseStatus.IN_PROGRESS,
        metrics: currentMetrics,
        achievements:
          currentMetrics.typeScriptErrors.current === 0 ? ['Zero TypeScript errors achieved'] : [],,
        issues:
          currentMetrics.typeScriptErrors.current > 0
            ? [`${currentMetrics.typeScriptErrors.current} TypeScript errors remaining`]
            : [],
        recommendations:
          currentMetrics.typeScriptErrors.current > 0
            ? ['Continue with Enhanced TypeScript Error Fixer v3.0']
            : []
      },
      {
        phaseId: 'phase2',
        phaseName: 'Linting Excellence Achievement',
        startTime: new Date(),
        status:
          currentMetrics.lintingWarnings.current === 0,
            ? PhaseStatus.COMPLETED
            : PhaseStatus.IN_PROGRESS,
        metrics: currentMetrics,
        achievements:
          currentMetrics.lintingWarnings.current === 0 ? ['Zero linting warnings achieved'] : [],,
        issues:
          currentMetrics.lintingWarnings.current > 0
            ? [`${currentMetrics.lintingWarnings.current} linting warnings remaining`]
            : [],
        recommendations:
          currentMetrics.lintingWarnings.current > 0
            ? ['Continue with systematic linting fixes']
            : []
      }
    ];

    // Estimate completion time based on current progress rate
    const estimatedCompletion = new Date();
    estimatedCompletion.setDate(
      estimatedCompletion.getDate() + Math.ceil((100 - overallProgress) / 10);
    ); // Rough estimate

    return {
      campaignId: 'perfect-codebase-campaign',
      overallProgress,
      phases,
      currentMetrics,
      targetMetrics,
      estimatedCompletion
    };
  }

  /**
   * Get metrics history for trend analysis
   */
  getMetricsHistory(): ProgressMetrics[] {
    return [...this.metricsHistory]
  }

  /**
   * Get metrics improvement over time
   */
  getMetricsImprovement(): {
    typeScriptErrorsReduced: number,
    lintingWarningsReduced: number,
    buildTimeImproved: number,
    enterpriseSystemsAdded: number
  } {
    if (this.metricsHistory.length < 2) {
      return {
        typeScriptErrorsReduced: 0,
        lintingWarningsReduced: 0,
        buildTimeImproved: 0,
        enterpriseSystemsAdded: 0
      };
    }

    const first = this.metricsHistory[0];
    const latest = this.metricsHistory[this.metricsHistory.length - 1];

    return {
      typeScriptErrorsReduced: first.typeScriptErrors.current - latest.typeScriptErrors.current,
      lintingWarningsReduced: first.lintingWarnings.current - latest.lintingWarnings.current,
      buildTimeImproved: first.buildPerformance.currentTime - latest.buildPerformance.currentTime,
      enterpriseSystemsAdded: latest.enterpriseSystems.current - first.enterpriseSystems.current
    }
  }

  /**
   * Export metrics to JSON for external analysis
   */
  async exportMetrics(filePath: string): Promise<void> {
    try {
      const report = await this.generateProgressReport();
      const exportData = {
        timestamp: new Date().toISOString();
        report,
        history: this.metricsHistory,
        improvement: this.getMetricsImprovement();
      };

      fs.writeFileSync(filePath, JSON.stringify(exportData, null, 2));
      // // // console.log(`📊 Metrics exported to: ${filePath}`);
    } catch (error) {
      throw new Error(`Failed to export metrics: ${(error as Error).message}`);
    }
  }

  /**
   * Reset metrics history (for testing or fresh start);
   */
  resetMetricsHistory(): void {
    this.metricsHistory = [];
    this.lastMetricsUpdate = new Date();
    // // // console.log('📊 Metrics history reset');
  }
}