#!/usr/bin/env node

/**
 * Unused Variable Mass Eliminator - Phase 3B
 * Advanced strategy for eliminating unused variable warnings
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

class UnusedVariableMassEliminator {
  constructor() {
    this.processedFiles = 0;
    this.eliminatedVariables = 0;
    this.targetReduction = 500; // Target 500 warning reduction
  }

  log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }

  getWarningCount() {
    try {
      const output = execSync(
        'yarn lint --max-warnings=10000 2>&1 | grep "‚úñ.*problems" | tail -1',
        {
          encoding: "utf8",
          stdio: "pipe",
        },
      );

      const match = output.match(
        /‚úñ \d+ problems \(\d+ errors, (\d+) warnings\)/,
      );
      return match ? parseInt(match[1]) : 0;
    } catch (error) {
      return 0;
    }
  }

  async eliminateUnusedVariables() {
    this.log("Starting comprehensive unused variable elimination...");

    const files = require("glob").sync("src/**/*.{ts,tsx}", {
      ignore: ["src/**/*.test.*", "src/**/*.spec.*", "src/**/__tests__/**"],
    });

    let eliminated = 0;
    for (const file of files) {
      try {
        const content = fs.readFileSync(file, "utf8");
        const lines = content.split("\n");
        let modified = false;

        const newLines = lines.map((line) => {
          // Pattern 1: Unused destructured variables
          if (line.match(/^\s*const\s*{\s*[^}]+\s*}\s*=/)) {
            const destructureMatch = line.match(
              /^\s*const\s*{\s*([^}]+)\s*}\s*=/,
            );
            if (destructureMatch) {
              const variables = destructureMatch[1]
                .split(",")
                .map((v) => v.trim());
              const modifiedVars = variables.map((varDecl) => {
                const varName = varDecl.split(":")[0].trim();
                // Skip if already prefixed or is a domain critical variable
                if (
                  !varName.startsWith("_") &&
                  ![
                    "element",
                    "planet",
                    "sign",
                    "recipe",
                    "ingredient",
                    "calculation",
                  ].some((d) => varName.toLowerCase().includes(d))
                ) {
                  // Check if variable is used elsewhere in file
                  const usagePattern = new RegExp(`\\b${varName}\\b`, "g");
                  const usageCount = (content.match(usagePattern) || []).length;

                  if (usageCount <= 2) {
                    // Only declaration + destructure
                    eliminated++;
                    modified = true;
                    return varDecl.replace(varName, `_${varName}`);
                  }
                }
                return varDecl;
              });

              if (modified) {
                return line.replace(
                  destructureMatch[1],
                  modifiedVars.join(", "),
                );
              }
            }
          }

          // Pattern 2: Unused function parameters
          if (line.match(/^\s*(const|function|export\s+function)\s+\w+\s*\(/)) {
            const funcMatch = line.match(
              /^\s*(const|function|export\s+function)\s+(\w+)\s*\(([^)]*)\)/,
            );
            if (funcMatch && funcMatch[3]) {
              const params = funcMatch[3].split(",").map((p) => p.trim());
              const modifiedParams = params.map((param) => {
                const paramName = param.split(":")[0].trim();
                if (
                  !paramName.startsWith("_") &&
                  paramName !== "children" &&
                  paramName !== "props"
                ) {
                  // Simple heuristic: if parameter isn't used in function body
                  const funcBodyStart = content.indexOf(line);
                  const funcBodyEnd = content.indexOf("}", funcBodyStart);
                  const funcBody = content.slice(funcBodyStart, funcBodyEnd);

                  const usagePattern = new RegExp(`\\b${paramName}\\b`, "g");
                  const usageCount = (funcBody.match(usagePattern) || [])
                    .length;

                  if (usageCount <= 1) {
                    // Only the parameter declaration
                    eliminated++;
                    modified = true;
                    return param.replace(paramName, `_${paramName}`);
                  }
                }
                return param;
              });

              if (modified) {
                return line.replace(funcMatch[3], modifiedParams.join(", "));
              }
            }
          }

          // Pattern 3: Unused imported variables
          if (line.match(/^import\s*{[^}]+}\s*from/)) {
            const importMatch = line.match(/^import\s*{([^}]+)}\s*from/);
            if (importMatch) {
              const imports = importMatch[1].split(",").map((i) => i.trim());
              const modifiedImports = imports.map((imp) => {
                const importName = imp.split(" as ")[0].trim();
                if (!importName.startsWith("_")) {
                  // Check if import is used
                  const usagePattern = new RegExp(`\\b${importName}\\b`, "g");
                  const usageCount = (content.match(usagePattern) || []).length;

                  if (usageCount <= 1) {
                    // Only the import declaration
                    eliminated++;
                    modified = true;
                    return `_${imp}`;
                  }
                }
                return imp;
              });

              if (modified) {
                return line.replace(importMatch[1], modifiedImports.join(", "));
              }
            }
          }

          return line;
        });

        if (modified) {
          fs.writeFileSync(file, newLines.join("\n"));
          this.processedFiles++;
        }
      } catch (error) {
        // Skip file on error
      }
    }

    this.eliminatedVariables = eliminated;
    this.log(
      `Eliminated ${eliminated} unused variables across ${this.processedFiles} files`,
    );
    return eliminated;
  }

  async execute() {
    this.log("Starting Unused Variable Mass Elimination - Phase 3B");

    const initialWarnings = this.getWarningCount();
    this.log(`Initial warnings: ${initialWarnings}`);

    // Execute elimination
    await this.eliminateUnusedVariables();

    const finalWarnings = this.getWarningCount();
    const reduction = initialWarnings - finalWarnings;
    const reductionPercent = ((reduction / initialWarnings) * 100).toFixed(1);

    this.log("\n=== Phase 3B Results ===");
    this.log(`Initial warnings: ${initialWarnings}`);
    this.log(`Final warnings: ${finalWarnings}`);
    this.log(`Warnings reduced: ${reduction}`);
    this.log(`Reduction percentage: ${reductionPercent}%`);
    this.log(`Variables eliminated: ${this.eliminatedVariables}`);
    this.log(`Files processed: ${this.processedFiles}`);

    return {
      initialWarnings,
      finalWarnings,
      reduction,
      reductionPercent: parseFloat(reductionPercent),
      eliminated: this.eliminatedVariables,
    };
  }
}

if (require.main === module) {
  const eliminator = new UnusedVariableMassEliminator();
  eliminator
    .execute()
    .then((results) => {
      if (results.reduction > 0) {
        console.log(
          `\nüéâ Success! Reduced ${results.reduction} warnings (${results.reductionPercent}%)`,
        );
      } else {
        console.log("\nüìä Analysis complete - Alternative strategies needed");
      }
      process.exit(0);
    })
    .catch((error) => {
      console.error("‚ùå Elimination failed:", error.message);
      process.exit(1);
    });
}

module.exports = UnusedVariableMassEliminator;
