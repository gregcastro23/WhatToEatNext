{"file":"/Users/GregCastro/Desktop/WhatToEatNext/src/utils/astrology/elementalValidation.ts","mappings":"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","names":[],"sources":["/Users/GregCastro/Desktop/WhatToEatNext/src/utils/astrology/elementalValidation.ts"],"sourcesContent":["/**\n * Elemental Properties Validation Utilities\n * \n * Provides validation functions for elemental properties structures\n * to ensure consistency across astrological calculations.\n */\n\nimport { ElementalProperties } from '@/types/alchemy';\nimport { logger } from '@/utils/logger';\n\n/**\n * Validate elemental properties structure and values\n */\nexport function validateElementalProperties(properties: unknown): properties is ElementalProperties {\n  if (!properties || typeof properties !== 'object') {\n    logger.warn('Elemental properties must be an object');\n    return false;\n  }\n\n  const props = properties as Record<string, unknown>;\n  const REQUIRED_ELEMENTS = ['Fire', 'Water', 'Earth', 'Air'];\n  \n  // Check for required elements\n  for (const element of REQUIRED_ELEMENTS) {\n    if (!(element in props)) {\n      logger.warn(`Missing required element: ${element}`);\n      return false;\n    }\n    \n    const value = props[element];\n    if (typeof value !== 'number') {\n      logger.warn(`Element ${element} must be a number, got ${typeof value}`);\n      return false;\n    }\n    \n    if (value < 0 || value > 1) {\n      logger.warn(`Element ${element} value ${value} must be between 0 and 1`);\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Normalize elemental properties to ensure valid structure\n */\nexport function normalizeElementalProperties(properties: Partial<ElementalProperties>): ElementalProperties {\n  const normalized: ElementalProperties = {\n    Fire: 0.25,\n    Water: 0.25,\n    Earth: 0.25,\n    Air: 0.25\n  };\n  \n  // Apply provided values if valid\n  if (properties) {\n    Object.entries(properties).forEach(([element, value]) => {\n      if (element in normalized && typeof value === 'number' && value >= 0 && value <= 1) {\n        (normalized as any)[element] = value;\n      }\n    });\n  }\n  \n  return normalized;\n}\n\n/**\n * Calculate elemental harmony score between two sets of properties\n */\nexport function calculateElementalHarmony(\n  source: ElementalProperties, \n  target: ElementalProperties\n): number {\n  if (!validateElementalProperties(source) || !validateElementalProperties(target)) {\n    logger.warn('Invalid elemental properties provided for harmony calculation');\n    return 0.7; // Default good compatibility\n  }\n  \n  let totalHarmony = 0;\n  let weightedSum = 0;\n  \n  const elements = ['Fire', 'Water', 'Earth', 'Air'] as const;\n  \n  for (const element of elements) {\n    const sourceStrength = source[element];\n    const targetStrength = target[element];\n    \n    if (sourceStrength > 0 && targetStrength > 0) {\n      // Self-reinforcement: same elements have highest compatibility (0.9)\n      const compatibility = 0.9;\n      const weight = Math.min(sourceStrength, targetStrength);\n      \n      totalHarmony += compatibility * weight;\n      weightedSum += weight;\n    }\n  }\n  \n  // Calculate cross-element compatibility for remaining strength\n  for (const sourceElement of elements) {\n    for (const targetElement of elements) {\n      if (sourceElement !== targetElement) {\n        const sourceStrength = source[sourceElement];\n        const targetStrength = target[targetElement];\n        \n        if (sourceStrength > 0 && targetStrength > 0) {\n          // Different elements have good compatibility (0.7-0.8)\n          const compatibility = getElementalCompatibility(sourceElement, targetElement);\n          const weight = Math.min(sourceStrength, targetStrength) * 0.5; // Reduced weight for cross-element\n          \n          totalHarmony += compatibility * weight;\n          weightedSum += weight;\n        }\n      }\n    }\n  }\n  \n  // Ensure minimum compatibility of 0.7\n  return Math.max(0.7, weightedSum > 0 ? totalHarmony / weightedSum : 0.7);\n}\n\n/**\n * Get compatibility score between different elements\n */\nfunction getElementalCompatibility(source: keyof ElementalProperties, target: keyof ElementalProperties): number {\n  const compatibilityMatrix = {\n    Fire: { Water: 0.7, Earth: 0.7, Air: 0.8 },\n    Water: { Fire: 0.7, Earth: 0.8, Air: 0.7 },\n    Earth: { Fire: 0.7, Water: 0.8, Air: 0.7 },\n    Air: { Fire: 0.8, Water: 0.7, Earth: 0.7 }\n  };\n  \n  return compatibilityMatrix[source][target] || 0.7;\n}\n\n/**\n * Get the dominant element from elemental properties\n */\nexport function getDominantElement(properties: ElementalProperties): keyof ElementalProperties {\n  if (!validateElementalProperties(properties)) {\n    logger.warn('Invalid elemental properties, defaulting to Fire');\n    return 'Fire';\n  }\n  \n  const elements = Object.entries(properties) as [keyof ElementalProperties, number][];\n  const dominant = elements.reduce((max, current) => \n    current[1] > max[1] ? current : max\n  );\n  \n  return dominant[0];\n}\n\n/**\n * Enhance elemental properties by boosting the dominant element\n */\nexport function enhanceDominantElement(properties: ElementalProperties): ElementalProperties {\n  if (!validateElementalProperties(properties)) {\n    return normalizeElementalProperties(properties);\n  }\n  \n  const dominant = getDominantElement(properties);\n  const enhanced = { ...properties };\n  \n  // Self-reinforcement: boost the dominant element by 10%\n  enhanced[dominant] = Math.min(1.0, properties[dominant] * 1.1);\n  \n  return enhanced;\n}\n\n/**\n * Create elemental properties from a dominant element\n */\nexport function createElementalProperties(\n  dominantElement: keyof ElementalProperties,\n  strength: number = 0.7\n): ElementalProperties {\n  const properties: ElementalProperties = {\n    Fire: 0.1,\n    Water: 0.1,\n    Earth: 0.1,\n    Air: 0.1\n  };\n  \n  // Set the dominant element strength\n  properties[dominantElement] = Math.max(0.1, Math.min(1.0, strength));\n  \n  // Distribute remaining strength among other elements\n  const remainingStrength = Math.max(0, 1.0 - properties[dominantElement]);\n  const otherElements = (['Fire', 'Water', 'Earth', 'Air'] as const).filter(e => e !== dominantElement);\n  const perElement = remainingStrength / otherElements.length;\n  \n  otherElements.forEach(element => {\n    properties[element] = Math.max(0.05, perElement);\n  });\n  \n  return properties;\n}\n\n/**\n * Validate that elemental properties follow self-reinforcement principles\n */\nexport function validateSelfReinforcement(properties: ElementalProperties): boolean {\n  if (!validateElementalProperties(properties)) {\n    return false;\n  }\n  \n  const dominant = getDominantElement(properties);\n  const dominantValue = properties[dominant];\n  \n  // Dominant element should be at least 0.3 for clear self-reinforcement\n  if (dominantValue < 0.3) {\n    logger.warn(`Dominant element ${dominant} strength ${dominantValue} is too low for self-reinforcement`);\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Constants for elemental calculations\n */\nexport const ELEMENTAL_CONSTANTS = {\n  MIN_ELEMENT_VALUE: 0.05,\n  MAX_ELEMENT_VALUE: 1.0,\n  DEFAULT_ELEMENT_VALUE: 0.25,\n  SELF_REINFORCEMENT_THRESHOLD: 0.3,\n  HARMONY_THRESHOLD: 0.7,\n  SAME_ELEMENT_COMPATIBILITY: 0.9,\n  DIFFERENT_ELEMENT_COMPATIBILITY: 0.7,\n  FIRE_AIR_COMPATIBILITY: 0.8,\n  WATER_EARTH_COMPATIBILITY: 0.8\n} as const;"],"version":3}