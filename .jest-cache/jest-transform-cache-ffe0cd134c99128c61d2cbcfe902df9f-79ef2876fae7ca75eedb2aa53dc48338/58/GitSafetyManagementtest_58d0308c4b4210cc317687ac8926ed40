9fd5764fa5c49fa18d965a8addb4cf85
"use strict";
/**
 * Git Safety Management Tests
 * Perfect Codebase Campaign - Task 6.1 Implementation Tests
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock child_process for testing
jest.mock('child_process', () => ({
    execSync: jest.fn()
}));
// Mock fs for testing
jest.mock('fs', () => ({
    existsSync: jest.fn(),
    readFileSync: jest.fn(),
    writeFileSync: jest.fn(),
    mkdirSync: jest.fn()
}));
const SafetyProtocol_1 = require("./SafetyProtocol");
const fs = __importStar(require("fs"));
const { execSync } = require('child_process');
const mockFs = fs;
describe('Git Safety Management - Task 6.1', () => {
    let safetyProtocol;
    let mockSettings;
    beforeEach(() => {
        jest.clearAllMocks();
        mockSettings = {
            maxFilesPerBatch: 15,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7
        };
        // Mock git repository existence
        mockFs.existsSync.mockImplementation((path) => {
            if (path === '.git')
                return true;
            if (path.toString().includes('.kiro'))
                return false; // Don't load existing stash data
            return false;
        });
        // Mock git commands
        execSync.mockImplementation((command) => {
            if (command.includes('git status --porcelain'))
                return '';
            if (command.includes('git branch --show-current'))
                return 'main';
            if (command.includes('git stash push'))
                return 'Saved working directory';
            if (command.includes('git stash list --oneline'))
                return 'stash@{0}: campaign-test-1-2024-01-15T10-30-00-000Z: Test stash';
            if (command.includes('git stash list'))
                return 'stash@{0}: On main: campaign-test-1-2024-01-15T10-30-00-000Z: Test stash';
            if (command.includes('git stash apply'))
                return 'Applied stash';
            if (command.includes('git stash drop'))
                return 'Dropped stash';
            return '';
        });
        safetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
    });
    describe('Git Stash Creation with Descriptive Naming', () => {
        test('should create stash with descriptive naming conventions', async () => {
            const description = 'Before TypeScript error fixes';
            const phase = 'phase1';
            const stashId = await safetyProtocol.createStash(description, phase);
            expect(stashId).toMatch(/^campaign-phase1-\d+-\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}-\d{3}Z$/);
            expect(execSync).toHaveBeenCalledWith(expect.stringMatching(/git stash push -u -m "campaign-phase1-\d+-.*: Before TypeScript error fixes"/), expect.any(Object));
        });
        test('should create checkpoint stash with operation context', async () => {
            const operation = 'Enhanced Error Fixer v3.0';
            const phase = 'phase1';
            const stashId = await safetyProtocol.createCheckpointStash(operation, phase);
            expect(stashId).toMatch(/^campaign-phase1-\d+-/);
            expect(execSync).toHaveBeenCalledWith(expect.stringMatching(/git stash push -u -m ".*Checkpoint before Enhanced Error Fixer v3.0 in phase1"/), expect.any(Object));
        });
        test('should validate git state before creating stash', async () => {
            // Mock git validation failure
            mockFs.existsSync.mockImplementation((path) => {
                if (path === '.git')
                    return false;
                return true;
            });
            await expect(safetyProtocol.createStash('test')).rejects.toThrow('Git validation failed');
        });
        test('should handle stash creation failures gracefully', async () => {
            execSync.mockImplementation((command) => {
                if (command.includes('git stash push')) {
                    throw new Error('Git stash failed');
                }
                return '';
            });
            await expect(safetyProtocol.createStash('test')).rejects.toThrow('Failed to create git stash: Git stash failed');
        });
    });
    describe('Automatic Stash Application for Rollback Scenarios', () => {
        test('should apply specific stash by ID', async () => {
            // First create a stash
            const stashId = await safetyProtocol.createStash('test stash');
            // Then apply it
            await safetyProtocol.applyStash(stashId);
            expect(execSync).toHaveBeenCalledWith('git stash apply stash@{0}', expect.any(Object));
        });
        test('should automatically apply latest stash for rollback', async () => {
            // Create multiple stashes
            await safetyProtocol.createStash('first stash');
            await safetyProtocol.createStash('second stash');
            const appliedStashId = await safetyProtocol.autoApplyLatestStash();
            expect(appliedStashId).toMatch(/^campaign-\d+-/);
            expect(execSync).toHaveBeenCalledWith(expect.stringMatching(/git stash apply stash@\{\d+\}/), expect.any(Object));
        });
        test('should apply stash by phase for targeted rollbacks', async () => {
            // Create stashes for different phases
            await safetyProtocol.createStash('phase1 work', 'phase1');
            await safetyProtocol.createStash('phase2 work', 'phase2');
            const appliedStashId = await safetyProtocol.applyStashByPhase('phase1');
            expect(appliedStashId).toMatch(/^campaign-phase1-/);
        });
        test('should handle missing stash gracefully', async () => {
            await expect(safetyProtocol.applyStash('nonexistent-stash')).rejects.toThrow('Stash not found');
        });
        test('should handle no stashes available for auto-apply', async () => {
            await expect(safetyProtocol.autoApplyLatestStash()).rejects.toThrow('No stashes available for automatic rollback');
        });
    });
    describe('Stash Cleanup with Configurable Retention Policies', () => {
        test('should clean up old stashes based on retention policy', async () => {
            // Mock old stash data
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            // Mock file existence for this specific test
            mockFs.existsSync.mockImplementation((path) => {
                if (path === '.git')
                    return true;
                if (path.toString().includes('campaign-stashes.json'))
                    return true;
                return false;
            });
            mockFs.readFileSync.mockReturnValue(JSON.stringify({
                counter: 2,
                stashes: {
                    'old-stash-1': {
                        id: 'old-stash-1',
                        description: 'Old stash',
                        timestamp: oldDate.toISOString(),
                        branch: 'main',
                        ref: 'stash@{1}'
                    }
                }
            }));
            // Create new safety protocol to load the old stash
            const newSafetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
            await newSafetyProtocol.cleanupOldStashes();
            expect(execSync).toHaveBeenCalledWith('git stash drop stash@{1}', expect.any(Object));
        });
        test('should get stashes by phase', async () => {
            await safetyProtocol.createStash('phase1 work', 'phase1');
            await safetyProtocol.createStash('phase2 work', 'phase2');
            await safetyProtocol.createStash('more phase1 work', 'phase1');
            const phase1Stashes = await safetyProtocol.getStashesByPhase('phase1');
            expect(phase1Stashes).toHaveLength(2);
            expect(phase1Stashes.every(stash => stash.id.includes('-phase1-'))).toBe(true);
        });
        test('should provide stash statistics', async () => {
            // Create a fresh safety protocol to avoid interference from other tests
            const freshProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
            await freshProtocol.createStash('phase1 work', 'phase1');
            await freshProtocol.createStash('phase2 work', 'phase2');
            await freshProtocol.createStash('more phase1 work', 'phase1');
            const stats = freshProtocol.getStashStatistics();
            expect(stats.total).toBe(3);
            expect(stats.byPhase.phase1).toBe(2);
            expect(stats.byPhase.phase2).toBe(1);
            expect(stats.oldestStash).toBeInstanceOf(Date);
            expect(stats.newestStash).toBeInstanceOf(Date);
        });
    });
    describe('Stash Tracking Persistence', () => {
        test('should save stash tracking to persistent storage', async () => {
            await safetyProtocol.createStash('test stash');
            expect(mockFs.writeFileSync).toHaveBeenCalledWith(expect.stringMatching(/\.kiro[\/\\]campaign-stashes\.json$/), expect.stringContaining('"counter":'));
        });
        test('should load stash tracking from persistent storage', async () => {
            const mockStashData = {
                counter: 5,
                stashes: {
                    'test-stash': {
                        id: 'test-stash',
                        description: 'Test stash',
                        timestamp: new Date().toISOString(),
                        branch: 'main',
                        ref: 'stash@{0}'
                    }
                }
            };
            // Mock file existence for this specific test
            mockFs.existsSync.mockImplementation((path) => {
                if (path === '.git')
                    return true;
                if (path.toString().includes('campaign-stashes.json'))
                    return true;
                return false;
            });
            mockFs.readFileSync.mockReturnValue(JSON.stringify(mockStashData));
            const newSafetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
            const stashes = await newSafetyProtocol.listStashes();
            expect(stashes).toHaveLength(1);
            expect(stashes[0].id).toBe('test-stash');
        });
        test('should handle corrupted stash tracking file gracefully', async () => {
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('File corrupted');
            });
            // Should not throw, just log warning
            expect(() => new SafetyProtocol_1.SafetyProtocol(mockSettings)).not.toThrow();
        });
    });
    describe('Git State Validation', () => {
        test('should validate git repository state', async () => {
            const validation = await safetyProtocol.validateGitState();
            expect(validation.success).toBe(true);
            expect(validation.errors).toHaveLength(0);
        });
        test('should detect non-git repository', async () => {
            mockFs.existsSync.mockImplementation((path) => {
                if (path === '.git')
                    return false;
                return true;
            });
            const validation = await safetyProtocol.validateGitState();
            expect(validation.success).toBe(false);
            expect(validation.errors).toContain('Not a git repository');
        });
        test('should warn about uncommitted changes when auto-rollback disabled', async () => {
            execSync.mockImplementation((command) => {
                if (command.includes('git status --porcelain'))
                    return 'M modified-file.ts';
                return '';
            });
            const settingsWithoutAutoRollback = {
                ...mockSettings,
                automaticRollbackEnabled: false
            };
            const protocol = new SafetyProtocol_1.SafetyProtocol(settingsWithoutAutoRollback);
            const validation = await protocol.validateGitState();
            expect(validation.success).toBe(true);
            expect(validation.warnings).toContain('Uncommitted changes detected - consider creating a stash');
        });
    });
    describe('Safety Event Tracking', () => {
        test('should track stash creation events', async () => {
            await safetyProtocol.createStash('test stash');
            const events = safetyProtocol.getSafetyEvents();
            const stashEvent = events.find(e => e.action === 'STASH_CREATE');
            expect(stashEvent).toBeDefined();
            expect(stashEvent === null || stashEvent === void 0 ? void 0 : stashEvent.description).toContain('Git stash created');
        });
        test('should track stash application events', async () => {
            const stashId = await safetyProtocol.createStash('test stash');
            await safetyProtocol.applyStash(stashId);
            const events = safetyProtocol.getSafetyEvents();
            const applyEvent = events.find(e => e.action === 'STASH_APPLY');
            expect(applyEvent).toBeDefined();
            expect(applyEvent === null || applyEvent === void 0 ? void 0 : applyEvent.description).toContain('Git stash applied');
        });
        test('should track cleanup events', async () => {
            // Mock file existence for this specific test
            mockFs.existsSync.mockImplementation((path) => {
                if (path === '.git')
                    return true;
                if (path.toString().includes('campaign-stashes.json'))
                    return true;
                return false;
            });
            // Mock old stash
            mockFs.readFileSync.mockReturnValue(JSON.stringify({
                counter: 1,
                stashes: {
                    'old-stash': {
                        id: 'old-stash',
                        description: 'Old stash',
                        timestamp: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
                        branch: 'main',
                        ref: 'stash@{0}'
                    }
                }
            }));
            const newProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
            await newProtocol.cleanupOldStashes();
            const events = newProtocol.getSafetyEvents();
            const cleanupEvent = events.find(e => e.action === 'STASH_CLEANUP');
            expect(cleanupEvent).toBeDefined();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9HaXRTYWZldHlNYW5hZ2VtZW50LnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9ILGlDQUFpQztBQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ2hDLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0NBQ3BCLENBQUMsQ0FBQyxDQUFDO0FBRUosc0JBQXNCO0FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDckIsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDckIsWUFBWSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDdkIsYUFBYSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDeEIsU0FBUyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7Q0FDckIsQ0FBQyxDQUFDLENBQUM7QUFoQkoscURBQWtEO0FBRWxELHVDQUF5QjtBQWdCekIsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUM5QyxNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBRTVDLFFBQVEsQ0FBQyxrQ0FBa0MsRUFBRSxHQUFHLEVBQUU7SUFDaEQsSUFBSSxjQUE4QixDQUFDO0lBQ25DLElBQUksWUFBNEIsQ0FBQztJQUVqQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXJCLFlBQVksR0FBRztZQUNiLGdCQUFnQixFQUFFLEVBQUU7WUFDcEIsd0JBQXdCLEVBQUUsQ0FBQztZQUMzQix1QkFBdUIsRUFBRSxFQUFFO1lBQzNCLDBCQUEwQixFQUFFLElBQUk7WUFDaEMsd0JBQXdCLEVBQUUsSUFBSTtZQUM5QixrQkFBa0IsRUFBRSxDQUFDO1NBQ3RCLENBQUM7UUFFRixnQ0FBZ0M7UUFDaEMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLElBQVksRUFBRSxFQUFFO1lBQ3BELElBQUksSUFBSSxLQUFLLE1BQU07Z0JBQUUsT0FBTyxJQUFJLENBQUM7WUFDakMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztnQkFBRSxPQUFPLEtBQUssQ0FBQyxDQUFDLGlDQUFpQztZQUN0RixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUMsQ0FBQyxDQUFDO1FBRUgsb0JBQW9CO1FBQ3BCLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLE9BQWUsRUFBRSxFQUFFO1lBQzlDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQztnQkFBRSxPQUFPLEVBQUUsQ0FBQztZQUMxRCxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsMkJBQTJCLENBQUM7Z0JBQUUsT0FBTyxNQUFNLENBQUM7WUFDakUsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDO2dCQUFFLE9BQU8seUJBQXlCLENBQUM7WUFDekUsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDO2dCQUFFLE9BQU8saUVBQWlFLENBQUM7WUFDM0gsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDO2dCQUFFLE9BQU8sMEVBQTBFLENBQUM7WUFDMUgsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDO2dCQUFFLE9BQU8sZUFBZSxDQUFDO1lBQ2hFLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztnQkFBRSxPQUFPLGVBQWUsQ0FBQztZQUMvRCxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUMsQ0FBQyxDQUFDO1FBRUgsY0FBYyxHQUFHLElBQUksK0JBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNwRCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyw0Q0FBNEMsRUFBRSxHQUFHLEVBQUU7UUFDMUQsSUFBSSxDQUFDLHlEQUF5RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3pFLE1BQU0sV0FBVyxHQUFHLCtCQUErQixDQUFDO1lBQ3BELE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQztZQUV2QixNQUFNLE9BQU8sR0FBRyxNQUFNLGNBQWMsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRXJFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsa0VBQWtFLENBQUMsQ0FBQztZQUM1RixNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsb0JBQW9CLENBQ25DLE1BQU0sQ0FBQyxjQUFjLENBQUMsOEVBQThFLENBQUMsRUFDckcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FDbkIsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHVEQUF1RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3ZFLE1BQU0sU0FBUyxHQUFHLDJCQUEyQixDQUFDO1lBQzlDLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQztZQUV2QixNQUFNLE9BQU8sR0FBRyxNQUFNLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFN0UsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxvQkFBb0IsQ0FDbkMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxnRkFBZ0YsQ0FBQyxFQUN2RyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUNuQixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDakUsOEJBQThCO1lBQzlCLE1BQU0sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxJQUFZLEVBQUUsRUFBRTtnQkFDcEQsSUFBSSxJQUFJLEtBQUssTUFBTTtvQkFBRSxPQUFPLEtBQUssQ0FBQztnQkFDbEMsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sTUFBTSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDNUYsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsa0RBQWtELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDbEUsUUFBUSxDQUFDLGtCQUFrQixDQUFDLENBQUMsT0FBZSxFQUFFLEVBQUU7Z0JBQzlDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO29CQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7aUJBQ3JDO2dCQUNELE9BQU8sRUFBRSxDQUFDO1lBQ1osQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1FBQ25ILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsb0RBQW9ELEVBQUUsR0FBRyxFQUFFO1FBQ2xFLElBQUksQ0FBQyxtQ0FBbUMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNuRCx1QkFBdUI7WUFDdkIsTUFBTSxPQUFPLEdBQUcsTUFBTSxjQUFjLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRS9ELGdCQUFnQjtZQUNoQixNQUFNLGNBQWMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFekMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLG9CQUFvQixDQUNuQywyQkFBMkIsRUFDM0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FDbkIsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHNEQUFzRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3RFLDBCQUEwQjtZQUMxQixNQUFNLGNBQWMsQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDaEQsTUFBTSxjQUFjLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBRWpELE1BQU0sY0FBYyxHQUFHLE1BQU0sY0FBYyxDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFFbkUsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxvQkFBb0IsQ0FDbkMsTUFBTSxDQUFDLGNBQWMsQ0FBQywrQkFBK0IsQ0FBQyxFQUN0RCxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUNuQixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsb0RBQW9ELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDcEUsc0NBQXNDO1lBQ3RDLE1BQU0sY0FBYyxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDMUQsTUFBTSxjQUFjLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUUxRCxNQUFNLGNBQWMsR0FBRyxNQUFNLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV4RSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDdEQsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsd0NBQXdDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDeEQsTUFBTSxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ2xHLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLG1EQUFtRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ25FLE1BQU0sTUFBTSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1FBQ3JILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsb0RBQW9ELEVBQUUsR0FBRyxFQUFFO1FBQ2xFLElBQUksQ0FBQyx1REFBdUQsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN2RSxzQkFBc0I7WUFDdEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUMzQixPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWM7WUFFdkQsNkNBQTZDO1lBQzdDLE1BQU0sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxJQUFZLEVBQUUsRUFBRTtnQkFDcEQsSUFBSSxJQUFJLEtBQUssTUFBTTtvQkFBRSxPQUFPLElBQUksQ0FBQztnQkFDakMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUFDO29CQUFFLE9BQU8sSUFBSSxDQUFDO2dCQUNuRSxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFDakQsT0FBTyxFQUFFLENBQUM7Z0JBQ1YsT0FBTyxFQUFFO29CQUNQLGFBQWEsRUFBRTt3QkFDYixFQUFFLEVBQUUsYUFBYTt3QkFDakIsV0FBVyxFQUFFLFdBQVc7d0JBQ3hCLFNBQVMsRUFBRSxPQUFPLENBQUMsV0FBVyxFQUFFO3dCQUNoQyxNQUFNLEVBQUUsTUFBTTt3QkFDZCxHQUFHLEVBQUUsV0FBVztxQkFDakI7aUJBQ0Y7YUFDRixDQUFDLENBQUMsQ0FBQztZQUVKLG1EQUFtRDtZQUNuRCxNQUFNLGlCQUFpQixHQUFHLElBQUksK0JBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUUzRCxNQUFNLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFFNUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLDBCQUEwQixFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN4RixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyw2QkFBNkIsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3QyxNQUFNLGNBQWMsQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzFELE1BQU0sY0FBYyxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDMUQsTUFBTSxjQUFjLENBQUMsV0FBVyxDQUFDLGtCQUFrQixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRS9ELE1BQU0sYUFBYSxHQUFHLE1BQU0sY0FBYyxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXZFLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pGLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGlDQUFpQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ2pELHdFQUF3RTtZQUN4RSxNQUFNLGFBQWEsR0FBRyxJQUFJLCtCQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFdkQsTUFBTSxhQUFhLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN6RCxNQUFNLGFBQWEsQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3pELE1BQU0sYUFBYSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUU5RCxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUVqRCxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQy9DLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsNEJBQTRCLEVBQUUsR0FBRyxFQUFFO1FBQzFDLElBQUksQ0FBQyxrREFBa0QsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNsRSxNQUFNLGNBQWMsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFL0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxvQkFBb0IsQ0FDL0MsTUFBTSxDQUFDLGNBQWMsQ0FBQyxxQ0FBcUMsQ0FBQyxFQUM1RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQ3RDLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxvREFBb0QsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNwRSxNQUFNLGFBQWEsR0FBRztnQkFDcEIsT0FBTyxFQUFFLENBQUM7Z0JBQ1YsT0FBTyxFQUFFO29CQUNQLFlBQVksRUFBRTt3QkFDWixFQUFFLEVBQUUsWUFBWTt3QkFDaEIsV0FBVyxFQUFFLFlBQVk7d0JBQ3pCLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRTt3QkFDbkMsTUFBTSxFQUFFLE1BQU07d0JBQ2QsR0FBRyxFQUFFLFdBQVc7cUJBQ2pCO2lCQUNGO2FBQ0YsQ0FBQztZQUVGLDZDQUE2QztZQUM3QyxNQUFNLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLENBQUMsSUFBWSxFQUFFLEVBQUU7Z0JBQ3BELElBQUksSUFBSSxLQUFLLE1BQU07b0JBQUUsT0FBTyxJQUFJLENBQUM7Z0JBQ2pDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQztvQkFBRSxPQUFPLElBQUksQ0FBQztnQkFDbkUsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUVuRSxNQUFNLGlCQUFpQixHQUFHLElBQUksK0JBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMzRCxNQUFNLE9BQU8sR0FBRyxNQUFNLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO1lBRXRELE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsd0RBQXdELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDeEUsTUFBTSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUU7Z0JBQzFDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUNwQyxDQUFDLENBQUMsQ0FBQztZQUVILHFDQUFxQztZQUNyQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSwrQkFBYyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQy9ELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxFQUFFO1FBQ3BDLElBQUksQ0FBQyxzQ0FBc0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN0RCxNQUFNLFVBQVUsR0FBRyxNQUFNLGNBQWMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBRTNELE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3RDLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGtDQUFrQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ2xELE1BQU0sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxJQUFZLEVBQUUsRUFBRTtnQkFDcEQsSUFBSSxJQUFJLEtBQUssTUFBTTtvQkFBRSxPQUFPLEtBQUssQ0FBQztnQkFDbEMsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sVUFBVSxHQUFHLE1BQU0sY0FBYyxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFFM0QsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxtRUFBbUUsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNuRixRQUFRLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxPQUFlLEVBQUUsRUFBRTtnQkFDOUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLHdCQUF3QixDQUFDO29CQUFFLE9BQU8sb0JBQW9CLENBQUM7Z0JBQzVFLE9BQU8sRUFBRSxDQUFDO1lBQ1osQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLDJCQUEyQixHQUFHO2dCQUNsQyxHQUFHLFlBQVk7Z0JBQ2Ysd0JBQXdCLEVBQUUsS0FBSzthQUNoQyxDQUFDO1lBRUYsTUFBTSxRQUFRLEdBQUcsSUFBSSwrQkFBYyxDQUFDLDJCQUEyQixDQUFDLENBQUM7WUFDakUsTUFBTSxVQUFVLEdBQUcsTUFBTSxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUVyRCxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0QyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQywwREFBMEQsQ0FBQyxDQUFDO1FBQ3BHLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO1FBQ3JDLElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNwRCxNQUFNLGNBQWMsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFL0MsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ2hELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLGNBQWMsQ0FBQyxDQUFDO1lBRWpFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqQyxNQUFNLENBQUMsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLFdBQVcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHVDQUF1QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3ZELE1BQU0sT0FBTyxHQUFHLE1BQU0sY0FBYyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMvRCxNQUFNLGNBQWMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFekMsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ2hELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLGFBQWEsQ0FBQyxDQUFDO1lBRWhFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqQyxNQUFNLENBQUMsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLFdBQVcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLDZCQUE2QixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdDLDZDQUE2QztZQUM3QyxNQUFNLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLENBQUMsSUFBWSxFQUFFLEVBQUU7Z0JBQ3BELElBQUksSUFBSSxLQUFLLE1BQU07b0JBQUUsT0FBTyxJQUFJLENBQUM7Z0JBQ2pDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQztvQkFBRSxPQUFPLElBQUksQ0FBQztnQkFDbkUsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDLENBQUMsQ0FBQztZQUVILGlCQUFpQjtZQUNqQixNQUFNLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUNqRCxPQUFPLEVBQUUsQ0FBQztnQkFDVixPQUFPLEVBQUU7b0JBQ1AsV0FBVyxFQUFFO3dCQUNYLEVBQUUsRUFBRSxXQUFXO3dCQUNmLFdBQVcsRUFBRSxXQUFXO3dCQUN4QixTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUU7d0JBQ3hFLE1BQU0sRUFBRSxNQUFNO3dCQUNkLEdBQUcsRUFBRSxXQUFXO3FCQUNqQjtpQkFDRjthQUNGLENBQUMsQ0FBQyxDQUFDO1lBRUosTUFBTSxXQUFXLEdBQUcsSUFBSSwrQkFBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3JELE1BQU0sV0FBVyxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFFdEMsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQzdDLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLGVBQWUsQ0FBQyxDQUFDO1lBRXBFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNyQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9HaXRTYWZldHlNYW5hZ2VtZW50LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHaXQgU2FmZXR5IE1hbmFnZW1lbnQgVGVzdHNcbiAqIFBlcmZlY3QgQ29kZWJhc2UgQ2FtcGFpZ24gLSBUYXNrIDYuMSBJbXBsZW1lbnRhdGlvbiBUZXN0c1xuICovXG5cbmltcG9ydCB7IFNhZmV0eVByb3RvY29sIH0gZnJvbSAnLi9TYWZldHlQcm90b2NvbCc7XG5pbXBvcnQgeyBTYWZldHlTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3R5cGVzL2NhbXBhaWduJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbi8vIE1vY2sgY2hpbGRfcHJvY2VzcyBmb3IgdGVzdGluZ1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJywgKCkgPT4gKHtcbiAgZXhlY1N5bmM6IGplc3QuZm4oKVxufSkpO1xuXG4vLyBNb2NrIGZzIGZvciB0ZXN0aW5nXG5qZXN0Lm1vY2soJ2ZzJywgKCkgPT4gKHtcbiAgZXhpc3RzU3luYzogamVzdC5mbigpLFxuICByZWFkRmlsZVN5bmM6IGplc3QuZm4oKSxcbiAgd3JpdGVGaWxlU3luYzogamVzdC5mbigpLFxuICBta2RpclN5bmM6IGplc3QuZm4oKVxufSkpO1xuXG5jb25zdCB7IGV4ZWNTeW5jIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBtb2NrRnMgPSBmcyBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZnM+O1xuXG5kZXNjcmliZSgnR2l0IFNhZmV0eSBNYW5hZ2VtZW50IC0gVGFzayA2LjEnLCAoKSA9PiB7XG4gIGxldCBzYWZldHlQcm90b2NvbDogU2FmZXR5UHJvdG9jb2w7XG4gIGxldCBtb2NrU2V0dGluZ3M6IFNhZmV0eVNldHRpbmdzO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDE1LFxuICAgICAgYnVpbGRWYWxpZGF0aW9uRnJlcXVlbmN5OiA1LFxuICAgICAgdGVzdFZhbGlkYXRpb25GcmVxdWVuY3k6IDEwLFxuICAgICAgY29ycnVwdGlvbkRldGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICBhdXRvbWF0aWNSb2xsYmFja0VuYWJsZWQ6IHRydWUsXG4gICAgICBzdGFzaFJldGVudGlvbkRheXM6IDdcbiAgICB9O1xuXG4gICAgLy8gTW9jayBnaXQgcmVwb3NpdG9yeSBleGlzdGVuY2VcbiAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHBhdGggPT09ICcuZ2l0JykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAocGF0aC50b1N0cmluZygpLmluY2x1ZGVzKCcua2lybycpKSByZXR1cm4gZmFsc2U7IC8vIERvbid0IGxvYWQgZXhpc3Rpbmcgc3Rhc2ggZGF0YVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gTW9jayBnaXQgY29tbWFuZHNcbiAgICBleGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQ6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dpdCBzdGF0dXMgLS1wb3JjZWxhaW4nKSkgcmV0dXJuICcnO1xuICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dpdCBicmFuY2ggLS1zaG93LWN1cnJlbnQnKSkgcmV0dXJuICdtYWluJztcbiAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggcHVzaCcpKSByZXR1cm4gJ1NhdmVkIHdvcmtpbmcgZGlyZWN0b3J5JztcbiAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggbGlzdCAtLW9uZWxpbmUnKSkgcmV0dXJuICdzdGFzaEB7MH06IGNhbXBhaWduLXRlc3QtMS0yMDI0LTAxLTE1VDEwLTMwLTAwLTAwMFo6IFRlc3Qgc3Rhc2gnO1xuICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBsaXN0JykpIHJldHVybiAnc3Rhc2hAezB9OiBPbiBtYWluOiBjYW1wYWlnbi10ZXN0LTEtMjAyNC0wMS0xNVQxMC0zMC0wMC0wMDBaOiBUZXN0IHN0YXNoJztcbiAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggYXBwbHknKSkgcmV0dXJuICdBcHBsaWVkIHN0YXNoJztcbiAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggZHJvcCcpKSByZXR1cm4gJ0Ryb3BwZWQgc3Rhc2gnO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuXG4gICAgc2FmZXR5UHJvdG9jb2wgPSBuZXcgU2FmZXR5UHJvdG9jb2wobW9ja1NldHRpbmdzKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dpdCBTdGFzaCBDcmVhdGlvbiB3aXRoIERlc2NyaXB0aXZlIE5hbWluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgY3JlYXRlIHN0YXNoIHdpdGggZGVzY3JpcHRpdmUgbmFtaW5nIGNvbnZlbnRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSAnQmVmb3JlIFR5cGVTY3JpcHQgZXJyb3IgZml4ZXMnO1xuICAgICAgY29uc3QgcGhhc2UgPSAncGhhc2UxJztcblxuICAgICAgY29uc3Qgc3Rhc2hJZCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKGRlc2NyaXB0aW9uLCBwaGFzZSk7XG5cbiAgICAgIGV4cGVjdChzdGFzaElkKS50b01hdGNoKC9eY2FtcGFpZ24tcGhhc2UxLVxcZCstXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9LVxcZHsyfS1cXGR7Mn0tXFxkezN9WiQvKTtcbiAgICAgIGV4cGVjdChleGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvZ2l0IHN0YXNoIHB1c2ggLXUgLW0gXCJjYW1wYWlnbi1waGFzZTEtXFxkKy0uKjogQmVmb3JlIFR5cGVTY3JpcHQgZXJyb3IgZml4ZXNcIi8pLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY3JlYXRlIGNoZWNrcG9pbnQgc3Rhc2ggd2l0aCBvcGVyYXRpb24gY29udGV4dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICdFbmhhbmNlZCBFcnJvciBGaXhlciB2My4wJztcbiAgICAgIGNvbnN0IHBoYXNlID0gJ3BoYXNlMSc7XG5cbiAgICAgIGNvbnN0IHN0YXNoSWQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVDaGVja3BvaW50U3Rhc2gob3BlcmF0aW9uLCBwaGFzZSk7XG5cbiAgICAgIGV4cGVjdChzdGFzaElkKS50b01hdGNoKC9eY2FtcGFpZ24tcGhhc2UxLVxcZCstLyk7XG4gICAgICBleHBlY3QoZXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL2dpdCBzdGFzaCBwdXNoIC11IC1tIFwiLipDaGVja3BvaW50IGJlZm9yZSBFbmhhbmNlZCBFcnJvciBGaXhlciB2My4wIGluIHBoYXNlMVwiLyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB2YWxpZGF0ZSBnaXQgc3RhdGUgYmVmb3JlIGNyZWF0aW5nIHN0YXNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBnaXQgdmFsaWRhdGlvbiBmYWlsdXJlXG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gJy5naXQnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgndGVzdCcpKS5yZWplY3RzLnRvVGhyb3coJ0dpdCB2YWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzdGFzaCBjcmVhdGlvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBwdXNoJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdCBzdGFzaCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCd0ZXN0JykpLnJlamVjdHMudG9UaHJvdygnRmFpbGVkIHRvIGNyZWF0ZSBnaXQgc3Rhc2g6IEdpdCBzdGFzaCBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1dG9tYXRpYyBTdGFzaCBBcHBsaWNhdGlvbiBmb3IgUm9sbGJhY2sgU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhcHBseSBzcGVjaWZpYyBzdGFzaCBieSBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEZpcnN0IGNyZWF0ZSBhIHN0YXNoXG4gICAgICBjb25zdCBzdGFzaElkID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ3Rlc3Qgc3Rhc2gnKTtcbiAgICAgIFxuICAgICAgLy8gVGhlbiBhcHBseSBpdFxuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaChzdGFzaElkKTtcblxuICAgICAgZXhwZWN0KGV4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ2dpdCBzdGFzaCBhcHBseSBzdGFzaEB7MH0nLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYXV0b21hdGljYWxseSBhcHBseSBsYXRlc3Qgc3Rhc2ggZm9yIHJvbGxiYWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIHN0YXNoZXNcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdmaXJzdCBzdGFzaCcpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ3NlY29uZCBzdGFzaCcpO1xuXG4gICAgICBjb25zdCBhcHBsaWVkU3Rhc2hJZCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmF1dG9BcHBseUxhdGVzdFN0YXNoKCk7XG5cbiAgICAgIGV4cGVjdChhcHBsaWVkU3Rhc2hJZCkudG9NYXRjaCgvXmNhbXBhaWduLVxcZCstLyk7XG4gICAgICBleHBlY3QoZXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL2dpdCBzdGFzaCBhcHBseSBzdGFzaEBcXHtcXGQrXFx9LyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhcHBseSBzdGFzaCBieSBwaGFzZSBmb3IgdGFyZ2V0ZWQgcm9sbGJhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHN0YXNoZXMgZm9yIGRpZmZlcmVudCBwaGFzZXNcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdwaGFzZTEgd29yaycsICdwaGFzZTEnKTtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdwaGFzZTIgd29yaycsICdwaGFzZTInKTtcblxuICAgICAgY29uc3QgYXBwbGllZFN0YXNoSWQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5hcHBseVN0YXNoQnlQaGFzZSgncGhhc2UxJyk7XG5cbiAgICAgIGV4cGVjdChhcHBsaWVkU3Rhc2hJZCkudG9NYXRjaCgvXmNhbXBhaWduLXBoYXNlMS0vKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBzdGFzaCBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2goJ25vbmV4aXN0ZW50LXN0YXNoJykpLnJlamVjdHMudG9UaHJvdygnU3Rhc2ggbm90IGZvdW5kJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG5vIHN0YXNoZXMgYXZhaWxhYmxlIGZvciBhdXRvLWFwcGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmF1dG9BcHBseUxhdGVzdFN0YXNoKCkpLnJlamVjdHMudG9UaHJvdygnTm8gc3Rhc2hlcyBhdmFpbGFibGUgZm9yIGF1dG9tYXRpYyByb2xsYmFjaycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3Rhc2ggQ2xlYW51cCB3aXRoIENvbmZpZ3VyYWJsZSBSZXRlbnRpb24gUG9saWNpZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNsZWFuIHVwIG9sZCBzdGFzaGVzIGJhc2VkIG9uIHJldGVudGlvbiBwb2xpY3knLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIG9sZCBzdGFzaCBkYXRhXG4gICAgICBjb25zdCBvbGREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIG9sZERhdGUuc2V0RGF0ZShvbGREYXRlLmdldERhdGUoKSAtIDEwKTsgLy8gMTAgZGF5cyBvbGRcblxuICAgICAgLy8gTW9jayBmaWxlIGV4aXN0ZW5jZSBmb3IgdGhpcyBzcGVjaWZpYyB0ZXN0XG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gJy5naXQnKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHBhdGgudG9TdHJpbmcoKS5pbmNsdWRlcygnY2FtcGFpZ24tc3Rhc2hlcy5qc29uJykpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjb3VudGVyOiAyLFxuICAgICAgICBzdGFzaGVzOiB7XG4gICAgICAgICAgJ29sZC1zdGFzaC0xJzoge1xuICAgICAgICAgICAgaWQ6ICdvbGQtc3Rhc2gtMScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ09sZCBzdGFzaCcsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG9sZERhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICAgICAgcmVmOiAnc3Rhc2hAezF9J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBDcmVhdGUgbmV3IHNhZmV0eSBwcm90b2NvbCB0byBsb2FkIHRoZSBvbGQgc3Rhc2hcbiAgICAgIGNvbnN0IG5ld1NhZmV0eVByb3RvY29sID0gbmV3IFNhZmV0eVByb3RvY29sKG1vY2tTZXR0aW5ncyk7XG4gICAgICBcbiAgICAgIGF3YWl0IG5ld1NhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCk7XG5cbiAgICAgIGV4cGVjdChleGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2dpdCBzdGFzaCBkcm9wIHN0YXNoQHsxfScsIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2V0IHN0YXNoZXMgYnkgcGhhc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgncGhhc2UxIHdvcmsnLCAncGhhc2UxJyk7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgncGhhc2UyIHdvcmsnLCAncGhhc2UyJyk7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnbW9yZSBwaGFzZTEgd29yaycsICdwaGFzZTEnKTtcblxuICAgICAgY29uc3QgcGhhc2UxU3Rhc2hlcyA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmdldFN0YXNoZXNCeVBoYXNlKCdwaGFzZTEnKTtcblxuICAgICAgZXhwZWN0KHBoYXNlMVN0YXNoZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChwaGFzZTFTdGFzaGVzLmV2ZXJ5KHN0YXNoID0+IHN0YXNoLmlkLmluY2x1ZGVzKCctcGhhc2UxLScpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwcm92aWRlIHN0YXNoIHN0YXRpc3RpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYSBmcmVzaCBzYWZldHkgcHJvdG9jb2wgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGZyb20gb3RoZXIgdGVzdHNcbiAgICAgIGNvbnN0IGZyZXNoUHJvdG9jb2wgPSBuZXcgU2FmZXR5UHJvdG9jb2wobW9ja1NldHRpbmdzKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZnJlc2hQcm90b2NvbC5jcmVhdGVTdGFzaCgncGhhc2UxIHdvcmsnLCAncGhhc2UxJyk7XG4gICAgICBhd2FpdCBmcmVzaFByb3RvY29sLmNyZWF0ZVN0YXNoKCdwaGFzZTIgd29yaycsICdwaGFzZTInKTtcbiAgICAgIGF3YWl0IGZyZXNoUHJvdG9jb2wuY3JlYXRlU3Rhc2goJ21vcmUgcGhhc2UxIHdvcmsnLCAncGhhc2UxJyk7XG5cbiAgICAgIGNvbnN0IHN0YXRzID0gZnJlc2hQcm90b2NvbC5nZXRTdGFzaFN0YXRpc3RpY3MoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UucGhhc2UxKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UucGhhc2UyKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdFN0YXNoKS50b0JlSW5zdGFuY2VPZihEYXRlKTtcbiAgICAgIGV4cGVjdChzdGF0cy5uZXdlc3RTdGFzaCkudG9CZUluc3RhbmNlT2YoRGF0ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdGFzaCBUcmFja2luZyBQZXJzaXN0ZW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc2F2ZSBzdGFzaCB0cmFja2luZyB0byBwZXJzaXN0ZW50IHN0b3JhZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgndGVzdCBzdGFzaCcpO1xuXG4gICAgICBleHBlY3QobW9ja0ZzLndyaXRlRmlsZVN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcLmtpcm9bXFwvXFxcXF1jYW1wYWlnbi1zdGFzaGVzXFwuanNvbiQvKSxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1wiY291bnRlclwiOicpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGxvYWQgc3Rhc2ggdHJhY2tpbmcgZnJvbSBwZXJzaXN0ZW50IHN0b3JhZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU3Rhc2hEYXRhID0ge1xuICAgICAgICBjb3VudGVyOiA1LFxuICAgICAgICBzdGFzaGVzOiB7XG4gICAgICAgICAgJ3Rlc3Qtc3Rhc2gnOiB7XG4gICAgICAgICAgICBpZDogJ3Rlc3Qtc3Rhc2gnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHN0YXNoJyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICAgICAgICByZWY6ICdzdGFzaEB7MH0nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIGZpbGUgZXhpc3RlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlc3RcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSAnLmdpdCcpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAocGF0aC50b1N0cmluZygpLmluY2x1ZGVzKCdjYW1wYWlnbi1zdGFzaGVzLmpzb24nKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU3Rhc2hEYXRhKSk7XG5cbiAgICAgIGNvbnN0IG5ld1NhZmV0eVByb3RvY29sID0gbmV3IFNhZmV0eVByb3RvY29sKG1vY2tTZXR0aW5ncyk7XG4gICAgICBjb25zdCBzdGFzaGVzID0gYXdhaXQgbmV3U2FmZXR5UHJvdG9jb2wubGlzdFN0YXNoZXMoKTtcblxuICAgICAgZXhwZWN0KHN0YXNoZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChzdGFzaGVzWzBdLmlkKS50b0JlKCd0ZXN0LXN0YXNoJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGNvcnJ1cHRlZCBzdGFzaCB0cmFja2luZyBmaWxlIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBjb3JydXB0ZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgbm90IHRocm93LCBqdXN0IGxvZyB3YXJuaW5nXG4gICAgICBleHBlY3QoKCkgPT4gbmV3IFNhZmV0eVByb3RvY29sKG1vY2tTZXR0aW5ncykpLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHaXQgU3RhdGUgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgZ2l0IHJlcG9zaXRvcnkgc3RhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGV0ZWN0IG5vbi1naXQgcmVwb3NpdG9yeScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSAnLmdpdCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlR2l0U3RhdGUoKTtcblxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcnMpLnRvQ29udGFpbignTm90IGEgZ2l0IHJlcG9zaXRvcnknKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB3YXJuIGFib3V0IHVuY29tbWl0dGVkIGNoYW5nZXMgd2hlbiBhdXRvLXJvbGxiYWNrIGRpc2FibGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dpdCBzdGF0dXMgLS1wb3JjZWxhaW4nKSkgcmV0dXJuICdNIG1vZGlmaWVkLWZpbGUudHMnO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2V0dGluZ3NXaXRob3V0QXV0b1JvbGxiYWNrID0ge1xuICAgICAgICAuLi5tb2NrU2V0dGluZ3MsXG4gICAgICAgIGF1dG9tYXRpY1JvbGxiYWNrRW5hYmxlZDogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3RvY29sID0gbmV3IFNhZmV0eVByb3RvY29sKHNldHRpbmdzV2l0aG91dEF1dG9Sb2xsYmFjayk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgcHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24ud2FybmluZ3MpLnRvQ29udGFpbignVW5jb21taXR0ZWQgY2hhbmdlcyBkZXRlY3RlZCAtIGNvbnNpZGVyIGNyZWF0aW5nIGEgc3Rhc2gnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhZmV0eSBFdmVudCBUcmFja2luZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdHJhY2sgc3Rhc2ggY3JlYXRpb24gZXZlbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ3Rlc3Qgc3Rhc2gnKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG4gICAgICBjb25zdCBzdGFzaEV2ZW50ID0gZXZlbnRzLmZpbmQoZSA9PiBlLmFjdGlvbiA9PT0gJ1NUQVNIX0NSRUFURScpO1xuXG4gICAgICBleHBlY3Qoc3Rhc2hFdmVudCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzdGFzaEV2ZW50Py5kZXNjcmlwdGlvbikudG9Db250YWluKCdHaXQgc3Rhc2ggY3JlYXRlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRyYWNrIHN0YXNoIGFwcGxpY2F0aW9uIGV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoSWQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgndGVzdCBzdGFzaCcpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaChzdGFzaElkKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG4gICAgICBjb25zdCBhcHBseUV2ZW50ID0gZXZlbnRzLmZpbmQoZSA9PiBlLmFjdGlvbiA9PT0gJ1NUQVNIX0FQUExZJyk7XG5cbiAgICAgIGV4cGVjdChhcHBseUV2ZW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGFwcGx5RXZlbnQ/LmRlc2NyaXB0aW9uKS50b0NvbnRhaW4oJ0dpdCBzdGFzaCBhcHBsaWVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdHJhY2sgY2xlYW51cCBldmVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGZpbGUgZXhpc3RlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlc3RcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSAnLmdpdCcpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAocGF0aC50b1N0cmluZygpLmluY2x1ZGVzKCdjYW1wYWlnbi1zdGFzaGVzLmpzb24nKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIG9sZCBzdGFzaFxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjb3VudGVyOiAxLFxuICAgICAgICBzdGFzaGVzOiB7XG4gICAgICAgICAgJ29sZC1zdGFzaCc6IHtcbiAgICAgICAgICAgIGlkOiAnb2xkLXN0YXNoJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnT2xkIHN0YXNoJyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDEwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSwgLy8gMTAgZGF5cyBvbGRcbiAgICAgICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICAgICAgcmVmOiAnc3Rhc2hAezB9J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCBuZXdQcm90b2NvbCA9IG5ldyBTYWZldHlQcm90b2NvbChtb2NrU2V0dGluZ3MpO1xuICAgICAgYXdhaXQgbmV3UHJvdG9jb2wuY2xlYW51cE9sZFN0YXNoZXMoKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gbmV3UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG4gICAgICBjb25zdCBjbGVhbnVwRXZlbnQgPSBldmVudHMuZmluZChlID0+IGUuYWN0aW9uID09PSAnU1RBU0hfQ0xFQU5VUCcpO1xuXG4gICAgICBleHBlY3QoY2xlYW51cEV2ZW50KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==