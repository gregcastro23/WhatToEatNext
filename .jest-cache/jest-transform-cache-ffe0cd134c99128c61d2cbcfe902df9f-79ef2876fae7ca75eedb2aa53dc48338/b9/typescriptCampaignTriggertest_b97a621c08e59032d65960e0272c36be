90f449490a82c5a3e650420e2a7948f2
"use strict";
/**
 * Tests for TypeScript Campaign Trigger
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Mock child_process
jest.mock('child_process', () => ({
    execSync: jest.fn()
}));
// Mock the logger
jest.mock('../logger', () => ({
    logger: {
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn(),
        debug: jest.fn()
    }
}));
const typescriptCampaignTrigger_1 = require("../typescriptCampaignTrigger");
const child_process_1 = require("child_process");
const mockExecSync = child_process_1.execSync;
describe('TypeScript Campaign Trigger', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe('analyzeTypeScriptErrors', () => {
        it('should analyze errors and recommend standard campaign for medium error count', async () => {
            // Mock TypeScript output with 150 errors (above medium threshold)
            const mockTscOutput = Array.from({ length: 150 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.shouldTrigger).toBe(true);
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.STANDARD);
            expect(result.errorAnalysis.totalErrors).toBe(150);
            expect(result.safetyLevel).toBe(typescriptCampaignTrigger_1.SafetyLevel.MEDIUM);
            expect(result.recommendations.length).toBeGreaterThan(0);
        });
        it('should recommend aggressive campaign for high error count', async () => {
            // Mock TypeScript output with 250 errors (above high threshold)
            const mockTscOutput = Array.from({ length: 250 }, (_, i) => `src/test${i}.ts(10,5): error TS2352: Conversion of type 'string' to type 'number'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.shouldTrigger).toBe(true);
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.AGGRESSIVE);
            expect(result.errorAnalysis.totalErrors).toBe(250);
            expect(result.safetyLevel).toBe(typescriptCampaignTrigger_1.SafetyLevel.HIGH);
        });
        it('should recommend emergency campaign for critical error count', async () => {
            // Mock TypeScript output with 600 errors (above critical threshold)
            const mockTscOutput = Array.from({ length: 600 }, (_, i) => `src/test${i}.ts(10,5): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.shouldTrigger).toBe(true);
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.EMERGENCY);
            expect(result.errorAnalysis.totalErrors).toBe(600);
            expect(result.safetyLevel).toBe(typescriptCampaignTrigger_1.SafetyLevel.MAXIMUM);
        });
        it('should not trigger campaign for low error count', async () => {
            // Mock TypeScript output with 50 errors (below medium threshold)
            const mockTscOutput = Array.from({ length: 50 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.shouldTrigger).toBe(false);
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.MONITORING);
            expect(result.errorAnalysis.totalErrors).toBe(50);
        });
        it('should handle no errors gracefully', async () => {
            // Mock empty TypeScript output (no errors)
            mockExecSync.mockReturnValue('');
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.shouldTrigger).toBe(false);
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.MONITORING);
            expect(result.errorAnalysis.totalErrors).toBe(0);
            expect(result.recommendations.length).toBe(0);
        });
        it('should categorize different error types correctly', async () => {
            const mockTscOutput = [
                'src/test1.ts(10,5): error TS2352: Conversion of type \'string\' to type \'number\'.',
                'src/test2.ts(15,10): error TS2304: Cannot find name \'undefined_var\'.',
                'src/test3.ts(20,15): error TS2345: Argument of type \'string\' is not assignable.',
                'src/test4.ts(25,20): error TS2698: Spread types may only be created from object types.',
                'src/test5.ts(30,25): error TS2362: The left-hand side of an arithmetic operation.',
                'src/test6.ts(35,30): error TS9999: Some other error type.'
            ].join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.errorAnalysis.totalErrors).toBe(6);
            expect(result.errorAnalysis.errorsByCategory[typescriptCampaignTrigger_1.ErrorCategory.TS2352]).toHaveLength(1);
            expect(result.errorAnalysis.errorsByCategory[typescriptCampaignTrigger_1.ErrorCategory.TS2304]).toHaveLength(1);
            expect(result.errorAnalysis.errorsByCategory[typescriptCampaignTrigger_1.ErrorCategory.TS2345]).toHaveLength(1);
            expect(result.errorAnalysis.errorsByCategory[typescriptCampaignTrigger_1.ErrorCategory.TS2698]).toHaveLength(1);
            expect(result.errorAnalysis.errorsByCategory[typescriptCampaignTrigger_1.ErrorCategory.TS2362]).toHaveLength(1);
            expect(result.errorAnalysis.errorsByCategory[typescriptCampaignTrigger_1.ErrorCategory.OTHER]).toHaveLength(1);
        });
        it('should identify high-impact files', async () => {
            // Mock errors with multiple errors in same file
            const mockTscOutput = Array.from({ length: 10 }, (_, i) => `src/high-impact-file.ts(${10 + i},5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.errorAnalysis.highImpactFiles.length).toBeGreaterThan(0);
            expect(result.errorAnalysis.highImpactFiles[0].filePath).toBe('src/high-impact-file.ts');
            expect(result.errorAnalysis.highImpactFiles[0].errorCount).toBe(10);
        });
        it('should handle TypeScript compilation errors gracefully', async () => {
            // Mock execSync throwing an error (which is normal for tsc with errors)
            const error = new Error('Command failed');
            error.stdout = 'src/test.ts(10,5): error TS2304: Cannot find name \'test\'.';
            mockExecSync.mockImplementation(() => {
                throw error;
            });
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.errorAnalysis.totalErrors).toBe(1);
            expect(result.shouldTrigger).toBe(false); // 1 error is below threshold
        });
        it('should handle complete TypeScript failure gracefully', async () => {
            // Mock execSync throwing an error with no stdout
            mockExecSync.mockImplementation(() => {
                throw new Error('Complete failure');
            });
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            // Should return safe defaults
            expect(result.shouldTrigger).toBe(false);
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.MONITORING);
            expect(result.errorAnalysis.totalErrors).toBe(-1);
            expect(result.safetyLevel).toBe(typescriptCampaignTrigger_1.SafetyLevel.MAXIMUM);
        });
    });
    describe('getCurrentTypeScriptErrorCount', () => {
        it('should return correct error count', async () => {
            const mockTscOutput = Array.from({ length: 25 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const count = await (0, typescriptCampaignTrigger_1.getCurrentTypeScriptErrorCount)();
            expect(count).toBe(25);
        });
        it('should return 0 for no errors', async () => {
            mockExecSync.mockReturnValue('');
            const count = await (0, typescriptCampaignTrigger_1.getCurrentTypeScriptErrorCount)();
            expect(count).toBe(0);
        });
        it('should return -1 on failure', async () => {
            mockExecSync.mockImplementation(() => {
                throw new Error('Command failed');
            });
            const count = await (0, typescriptCampaignTrigger_1.getCurrentTypeScriptErrorCount)();
            expect(count).toBe(-1);
        });
    });
    describe('checkCampaignTriggerConditions', () => {
        it('should return true when error count exceeds threshold', async () => {
            const mockTscOutput = Array.from({ length: 150 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const shouldTrigger = await (0, typescriptCampaignTrigger_1.checkCampaignTriggerConditions)();
            expect(shouldTrigger).toBe(true);
        });
        it('should return false when error count is below threshold', async () => {
            const mockTscOutput = Array.from({ length: 50 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const shouldTrigger = await (0, typescriptCampaignTrigger_1.checkCampaignTriggerConditions)();
            expect(shouldTrigger).toBe(false);
        });
        it('should return false on error', async () => {
            mockExecSync.mockImplementation(() => {
                throw new Error('Command failed');
            });
            const shouldTrigger = await (0, typescriptCampaignTrigger_1.checkCampaignTriggerConditions)();
            expect(shouldTrigger).toBe(false);
        });
    });
    describe('Error Parsing', () => {
        it('should parse TypeScript error format correctly', async () => {
            const mockTscOutput = 'src/components/test.tsx(45,12): error TS2304: Cannot find name \'UndefinedVariable\'.';
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.errorAnalysis.totalErrors).toBe(1);
            const error = result.errorAnalysis.priorityRanking[0];
            expect(error.filePath).toBe('src/components/test.tsx');
            expect(error.line).toBe(45);
            expect(error.column).toBe(12);
            expect(error.code).toBe('TS2304');
            expect(error.category).toBe(typescriptCampaignTrigger_1.ErrorCategory.TS2304);
            expect(error.message).toBe('Cannot find name \'UndefinedVariable\'.');
        });
        it('should ignore non-error lines', async () => {
            const mockTscOutput = [
                'Found 5 errors watching for file changes.',
                'src/test.ts(10,5): error TS2304: Cannot find name \'test\'.',
                'Compilation complete. Watching for file changes.',
                'src/test2.ts(15,10): error TS2352: Conversion error.'
            ].join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.errorAnalysis.totalErrors).toBe(2);
        });
    });
    describe('Batch Scheduling', () => {
        it('should create appropriate batch sizes for different error categories', async () => {
            const mockTscOutput = [
                ...Array.from({ length: 50 }, (_, i) => `src/test${i}.ts(10,5): error TS2352: Conversion error.`),
                ...Array.from({ length: 30 }, (_, i) => `src/test${i}.ts(15,10): error TS2304: Cannot find name.`),
                ...Array.from({ length: 20 }, (_, i) => `src/test${i}.ts(20,15): error TS2345: Argument error.`)
            ].join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.batchSchedule.batches.length).toBeGreaterThan(0);
            expect(result.batchSchedule.totalEstimatedTime).toBeGreaterThan(0);
            // Should have different batch sizes for different categories
            const batchSizes = result.batchSchedule.batches.map(b => b.batchSize);
            expect(new Set(batchSizes).size).toBeGreaterThan(1); // Multiple different batch sizes
        });
        it('should include safety protocols based on campaign mode', async () => {
            const mockTscOutput = Array.from({ length: 600 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            expect(result.campaignMode).toBe(typescriptCampaignTrigger_1.CampaignMode.EMERGENCY);
            expect(result.batchSchedule.safetyProtocols.length).toBeGreaterThan(0);
            expect(result.batchSchedule.safetyProtocols[0].name).toContain('Emergency');
        });
    });
    describe('Performance', () => {
        it('should complete analysis within reasonable time', async () => {
            const mockTscOutput = Array.from({ length: 100 }, (_, i) => `src/test${i}.ts(10,5): error TS2304: Cannot find name 'test${i}'.`).join('\n');
            mockExecSync.mockReturnValue(mockTscOutput);
            const startTime = Date.now();
            const result = await (0, typescriptCampaignTrigger_1.analyzeTypeScriptErrors)();
            const duration = Date.now() - startTime;
            expect(duration).toBeLessThan(5000); // Should complete within 5 seconds
            expect(result).toBeDefined();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy91dGlscy9fX3Rlc3RzX18vdHlwZXNjcmlwdENhbXBhaWduVHJpZ2dlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7QUFXSCxxQkFBcUI7QUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNoQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUNwQixDQUFDLENBQUMsQ0FBQztBQUVKLGtCQUFrQjtBQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzVCLE1BQU0sRUFBRTtRQUNOLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNoQixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtLQUNqQjtDQUNGLENBQUMsQ0FBQyxDQUFDO0FBdEJKLDRFQU9zQztBQWlCdEMsaURBQXlDO0FBRXpDLE1BQU0sWUFBWSxHQUFHLHdCQUFnRCxDQUFDO0FBRXRFLFFBQVEsQ0FBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUU7SUFDM0MsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyx5QkFBeUIsRUFBRSxHQUFHLEVBQUU7UUFDdkMsRUFBRSxDQUFDLDhFQUE4RSxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzVGLGtFQUFrRTtZQUNsRSxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ3pELFdBQVcsQ0FBQyxrREFBa0QsQ0FBQyxJQUFJLENBQ3BFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWIsWUFBWSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUU1QyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUEsbURBQXVCLEdBQUUsQ0FBQztZQUUvQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN4QyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyx3Q0FBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hELE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNuRCxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyx1Q0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BELE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzRCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywyREFBMkQsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN6RSxnRUFBZ0U7WUFDaEUsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUN6RCxXQUFXLENBQUMsd0VBQXdFLENBQ3JGLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWIsWUFBWSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUU1QyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUEsbURBQXVCLEdBQUUsQ0FBQztZQUUvQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN4QyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyx3Q0FBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzFELE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNuRCxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyx1Q0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BELENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDhEQUE4RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzVFLG9FQUFvRTtZQUNwRSxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ3pELFdBQVcsQ0FBQyxxR0FBcUcsQ0FDbEgsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLHdDQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDekQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ25ELE1BQU0sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLHVDQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkQsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0QsaUVBQWlFO1lBQ2pFLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDeEQsV0FBVyxDQUFDLGtEQUFrRCxDQUFDLElBQUksQ0FDcEUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLHdDQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDMUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG9DQUFvQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ2xELDJDQUEyQztZQUMzQyxZQUFZLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWpDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLHdDQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDMUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxtREFBbUQsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNqRSxNQUFNLGFBQWEsR0FBRztnQkFDcEIscUZBQXFGO2dCQUNyRix3RUFBd0U7Z0JBQ3hFLG1GQUFtRjtnQkFDbkYsd0ZBQXdGO2dCQUN4RixtRkFBbUY7Z0JBQ25GLDJEQUEyRDthQUM1RCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUViLFlBQVksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFNUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFBLG1EQUF1QixHQUFFLENBQUM7WUFFL0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLHlDQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMseUNBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwRixNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyx5Q0FBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BGLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLHlDQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMseUNBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwRixNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyx5Q0FBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JGLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG1DQUFtQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ2pELGdEQUFnRDtZQUNoRCxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ3hELDJCQUEyQixFQUFFLEdBQUcsQ0FBQyw0Q0FBNEMsQ0FBQyxJQUFJLENBQ25GLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWIsWUFBWSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUU1QyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUEsbURBQXVCLEdBQUUsQ0FBQztZQUUvQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQztZQUN6RixNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RFLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLHdEQUF3RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3RFLHdFQUF3RTtZQUN4RSxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBUSxDQUFDO1lBQ2pELEtBQUssQ0FBQyxNQUFNLEdBQUcsNkRBQTZELENBQUM7WUFDN0UsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtnQkFDbkMsTUFBTSxLQUFLLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRCxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLDZCQUE2QjtRQUN6RSxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxzREFBc0QsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNwRSxpREFBaUQ7WUFDakQsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtnQkFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ3RDLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFBLG1EQUF1QixHQUFFLENBQUM7WUFFL0MsOEJBQThCO1lBQzlCLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLHdDQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDMUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsdUNBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLGdDQUFnQyxFQUFFLEdBQUcsRUFBRTtRQUM5QyxFQUFFLENBQUMsbUNBQW1DLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDakQsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUN4RCxXQUFXLENBQUMsa0RBQWtELENBQUMsSUFBSSxDQUNwRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUViLFlBQVksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFNUMsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFBLDBEQUE4QixHQUFFLENBQUM7WUFFckQsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6QixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywrQkFBK0IsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3QyxZQUFZLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWpDLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBQSwwREFBOEIsR0FBRSxDQUFDO1lBRXJELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsNkJBQTZCLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDM0MsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtnQkFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFBLDBEQUE4QixHQUFFLENBQUM7WUFFckQsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxFQUFFO1FBQzlDLEVBQUUsQ0FBQyx1REFBdUQsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNyRSxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ3pELFdBQVcsQ0FBQyxrREFBa0QsQ0FBQyxJQUFJLENBQ3BFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWIsWUFBWSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUU1QyxNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUEsMERBQThCLEdBQUUsQ0FBQztZQUU3RCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLHlEQUF5RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3ZFLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDeEQsV0FBVyxDQUFDLGtEQUFrRCxDQUFDLElBQUksQ0FDcEUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVDLE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBQSwwREFBOEIsR0FBRSxDQUFDO1lBRTdELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsOEJBQThCLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDNUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtnQkFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxhQUFhLEdBQUcsTUFBTSxJQUFBLDBEQUE4QixHQUFFLENBQUM7WUFFN0QsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUU7UUFDN0IsRUFBRSxDQUFDLGdEQUFnRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzlELE1BQU0sYUFBYSxHQUFHLHVGQUF1RixDQUFDO1lBRTlHLFlBQVksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFNUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFBLG1EQUF1QixHQUFFLENBQUM7WUFFL0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRWpELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RELE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUM7WUFDdkQsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDNUIsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMseUNBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1FBQ3hFLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtCQUErQixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdDLE1BQU0sYUFBYSxHQUFHO2dCQUNwQiwyQ0FBMkM7Z0JBQzNDLDZEQUE2RDtnQkFDN0Qsa0RBQWtEO2dCQUNsRCxzREFBc0Q7YUFDdkQsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsRUFBRTtRQUNoQyxFQUFFLENBQUMsc0VBQXNFLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDcEYsTUFBTSxhQUFhLEdBQUc7Z0JBQ3BCLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyw0Q0FBNEMsQ0FBQztnQkFDakcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLDZDQUE2QyxDQUFDO2dCQUNsRyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsMkNBQTJDLENBQUM7YUFDakcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFbkUsNkRBQTZEO1lBQzdELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUN0RSxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsaUNBQWlDO1FBQ3hGLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLHdEQUF3RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3RFLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDekQsV0FBVyxDQUFDLGtEQUFrRCxDQUFDLElBQUksQ0FDcEUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLHdDQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDekQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RSxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsYUFBYSxFQUFFLEdBQUcsRUFBRTtRQUMzQixFQUFFLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0QsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUN6RCxXQUFXLENBQUMsa0RBQWtELENBQUMsSUFBSSxDQUNwRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUViLFlBQVksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFNUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzdCLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBQSxtREFBdUIsR0FBRSxDQUFDO1lBQy9DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUM7WUFFeEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLG1DQUFtQztZQUN4RSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvdXRpbHMvX190ZXN0c19fL3R5cGVzY3JpcHRDYW1wYWlnblRyaWdnZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3RzIGZvciBUeXBlU2NyaXB0IENhbXBhaWduIFRyaWdnZXJcbiAqL1xuXG5pbXBvcnQgeyBcbiAgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMsXG4gIGdldEN1cnJlbnRUeXBlU2NyaXB0RXJyb3JDb3VudCxcbiAgY2hlY2tDYW1wYWlnblRyaWdnZXJDb25kaXRpb25zLFxuICBDYW1wYWlnbk1vZGUsXG4gIEVycm9yQ2F0ZWdvcnksXG4gIFNhZmV0eUxldmVsXG59IGZyb20gJy4uL3R5cGVzY3JpcHRDYW1wYWlnblRyaWdnZXInO1xuXG4vLyBNb2NrIGNoaWxkX3Byb2Nlc3Ncbmplc3QubW9jaygnY2hpbGRfcHJvY2VzcycsICgpID0+ICh7XG4gIGV4ZWNTeW5jOiBqZXN0LmZuKClcbn0pKTtcblxuLy8gTW9jayB0aGUgbG9nZ2VyXG5qZXN0Lm1vY2soJy4uL2xvZ2dlcicsICgpID0+ICh7XG4gIGxvZ2dlcjoge1xuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICBkZWJ1ZzogamVzdC5mbigpXG4gIH1cbn0pKTtcblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcblxuY29uc3QgbW9ja0V4ZWNTeW5jID0gZXhlY1N5bmMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZXhlY1N5bmM+O1xuXG5kZXNjcmliZSgnVHlwZVNjcmlwdCBDYW1wYWlnbiBUcmlnZ2VyJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2FuYWx5emVUeXBlU2NyaXB0RXJyb3JzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYW5hbHl6ZSBlcnJvcnMgYW5kIHJlY29tbWVuZCBzdGFuZGFyZCBjYW1wYWlnbiBmb3IgbWVkaXVtIGVycm9yIGNvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBUeXBlU2NyaXB0IG91dHB1dCB3aXRoIDE1MCBlcnJvcnMgKGFib3ZlIG1lZGl1bSB0aHJlc2hvbGQpXG4gICAgICBjb25zdCBtb2NrVHNjT3V0cHV0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTUwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYHNyYy90ZXN0JHtpfS50cygxMCw1KTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd0ZXN0JHtpfScuYFxuICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrVHNjT3V0cHV0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zaG91bGRUcmlnZ2VyKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jYW1wYWlnbk1vZGUpLnRvQmUoQ2FtcGFpZ25Nb2RlLlNUQU5EQVJEKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy50b3RhbEVycm9ycykudG9CZSgxNTApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zYWZldHlMZXZlbCkudG9CZShTYWZldHlMZXZlbC5NRURJVU0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZWNvbW1lbmRhdGlvbnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlY29tbWVuZCBhZ2dyZXNzaXZlIGNhbXBhaWduIGZvciBoaWdoIGVycm9yIGNvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBUeXBlU2NyaXB0IG91dHB1dCB3aXRoIDI1MCBlcnJvcnMgKGFib3ZlIGhpZ2ggdGhyZXNob2xkKVxuICAgICAgY29uc3QgbW9ja1RzY091dHB1dCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1MCB9LCAoXywgaSkgPT4gXG4gICAgICAgIGBzcmMvdGVzdCR7aX0udHMoMTAsNSk6IGVycm9yIFRTMjM1MjogQ29udmVyc2lvbiBvZiB0eXBlICdzdHJpbmcnIHRvIHR5cGUgJ251bWJlcicuYFxuICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrVHNjT3V0cHV0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zaG91bGRUcmlnZ2VyKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jYW1wYWlnbk1vZGUpLnRvQmUoQ2FtcGFpZ25Nb2RlLkFHR1JFU1NJVkUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvckFuYWx5c2lzLnRvdGFsRXJyb3JzKS50b0JlKDI1MCk7XG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eUxldmVsKS50b0JlKFNhZmV0eUxldmVsLkhJR0gpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWNvbW1lbmQgZW1lcmdlbmN5IGNhbXBhaWduIGZvciBjcml0aWNhbCBlcnJvciBjb3VudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgVHlwZVNjcmlwdCBvdXRwdXQgd2l0aCA2MDAgZXJyb3JzIChhYm92ZSBjcml0aWNhbCB0aHJlc2hvbGQpXG4gICAgICBjb25zdCBtb2NrVHNjT3V0cHV0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNjAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYHNyYy90ZXN0JHtpfS50cygxMCw1KTogZXJyb3IgVFMyMzQ1OiBBcmd1bWVudCBvZiB0eXBlICdzdHJpbmcnIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHBhcmFtZXRlciBvZiB0eXBlICdudW1iZXInLmBcbiAgICAgICkuam9pbignXFxuJyk7XG4gICAgICBcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUobW9ja1RzY091dHB1dCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emVUeXBlU2NyaXB0RXJyb3JzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc2hvdWxkVHJpZ2dlcikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2FtcGFpZ25Nb2RlKS50b0JlKENhbXBhaWduTW9kZS5FTUVSR0VOQ1kpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvckFuYWx5c2lzLnRvdGFsRXJyb3JzKS50b0JlKDYwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eUxldmVsKS50b0JlKFNhZmV0eUxldmVsLk1BWElNVU0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgdHJpZ2dlciBjYW1wYWlnbiBmb3IgbG93IGVycm9yIGNvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBUeXBlU2NyaXB0IG91dHB1dCB3aXRoIDUwIGVycm9ycyAoYmVsb3cgbWVkaXVtIHRocmVzaG9sZClcbiAgICAgIGNvbnN0IG1vY2tUc2NPdXRwdXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1MCB9LCAoXywgaSkgPT4gXG4gICAgICAgIGBzcmMvdGVzdCR7aX0udHMoMTAsNSk6IGVycm9yIFRTMjMwNDogQ2Fubm90IGZpbmQgbmFtZSAndGVzdCR7aX0nLmBcbiAgICAgICkuam9pbignXFxuJyk7XG4gICAgICBcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUobW9ja1RzY091dHB1dCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emVUeXBlU2NyaXB0RXJyb3JzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc2hvdWxkVHJpZ2dlcikudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNhbXBhaWduTW9kZSkudG9CZShDYW1wYWlnbk1vZGUuTU9OSVRPUklORyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yQW5hbHlzaXMudG90YWxFcnJvcnMpLnRvQmUoNTApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm8gZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGVtcHR5IFR5cGVTY3JpcHQgb3V0cHV0IChubyBlcnJvcnMpXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zaG91bGRUcmlnZ2VyKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2FtcGFpZ25Nb2RlKS50b0JlKENhbXBhaWduTW9kZS5NT05JVE9SSU5HKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy50b3RhbEVycm9ycykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucmVjb21tZW5kYXRpb25zLmxlbmd0aCkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2F0ZWdvcml6ZSBkaWZmZXJlbnQgZXJyb3IgdHlwZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1RzY091dHB1dCA9IFtcbiAgICAgICAgJ3NyYy90ZXN0MS50cygxMCw1KTogZXJyb3IgVFMyMzUyOiBDb252ZXJzaW9uIG9mIHR5cGUgXFwnc3RyaW5nXFwnIHRvIHR5cGUgXFwnbnVtYmVyXFwnLicsXG4gICAgICAgICdzcmMvdGVzdDIudHMoMTUsMTApOiBlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgXFwndW5kZWZpbmVkX3ZhclxcJy4nLFxuICAgICAgICAnc3JjL3Rlc3QzLnRzKDIwLDE1KTogZXJyb3IgVFMyMzQ1OiBBcmd1bWVudCBvZiB0eXBlIFxcJ3N0cmluZ1xcJyBpcyBub3QgYXNzaWduYWJsZS4nLFxuICAgICAgICAnc3JjL3Rlc3Q0LnRzKDI1LDIwKTogZXJyb3IgVFMyNjk4OiBTcHJlYWQgdHlwZXMgbWF5IG9ubHkgYmUgY3JlYXRlZCBmcm9tIG9iamVjdCB0eXBlcy4nLFxuICAgICAgICAnc3JjL3Rlc3Q1LnRzKDMwLDI1KTogZXJyb3IgVFMyMzYyOiBUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYW4gYXJpdGhtZXRpYyBvcGVyYXRpb24uJyxcbiAgICAgICAgJ3NyYy90ZXN0Ni50cygzNSwzMCk6IGVycm9yIFRTOTk5OTogU29tZSBvdGhlciBlcnJvciB0eXBlLidcbiAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICBcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUobW9ja1RzY091dHB1dCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emVUeXBlU2NyaXB0RXJyb3JzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy50b3RhbEVycm9ycykudG9CZSg2KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy5lcnJvcnNCeUNhdGVnb3J5W0Vycm9yQ2F0ZWdvcnkuVFMyMzUyXSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvckFuYWx5c2lzLmVycm9yc0J5Q2F0ZWdvcnlbRXJyb3JDYXRlZ29yeS5UUzIzMDRdKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yQW5hbHlzaXMuZXJyb3JzQnlDYXRlZ29yeVtFcnJvckNhdGVnb3J5LlRTMjM0NV0pLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy5lcnJvcnNCeUNhdGVnb3J5W0Vycm9yQ2F0ZWdvcnkuVFMyNjk4XSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvckFuYWx5c2lzLmVycm9yc0J5Q2F0ZWdvcnlbRXJyb3JDYXRlZ29yeS5UUzIzNjJdKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yQW5hbHlzaXMuZXJyb3JzQnlDYXRlZ29yeVtFcnJvckNhdGVnb3J5Lk9USEVSXSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpZGVudGlmeSBoaWdoLWltcGFjdCBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZXJyb3JzIHdpdGggbXVsdGlwbGUgZXJyb3JzIGluIHNhbWUgZmlsZVxuICAgICAgY29uc3QgbW9ja1RzY091dHB1dCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYHNyYy9oaWdoLWltcGFjdC1maWxlLnRzKCR7MTAgKyBpfSw1KTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd0ZXN0JHtpfScuYFxuICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrVHNjT3V0cHV0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvckFuYWx5c2lzLmhpZ2hJbXBhY3RGaWxlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy5oaWdoSW1wYWN0RmlsZXNbMF0uZmlsZVBhdGgpLnRvQmUoJ3NyYy9oaWdoLWltcGFjdC1maWxlLnRzJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yQW5hbHlzaXMuaGlnaEltcGFjdEZpbGVzWzBdLmVycm9yQ291bnQpLnRvQmUoMTApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgVHlwZVNjcmlwdCBjb21waWxhdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZXhlY1N5bmMgdGhyb3dpbmcgYW4gZXJyb3IgKHdoaWNoIGlzIG5vcm1hbCBmb3IgdHNjIHdpdGggZXJyb3JzKVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbW1hbmQgZmFpbGVkJykgYXMgYW55O1xuICAgICAgZXJyb3Iuc3Rkb3V0ID0gJ3NyYy90ZXN0LnRzKDEwLDUpOiBlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgXFwndGVzdFxcJy4nO1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emVUeXBlU2NyaXB0RXJyb3JzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy50b3RhbEVycm9ycykudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2hvdWxkVHJpZ2dlcikudG9CZShmYWxzZSk7IC8vIDEgZXJyb3IgaXMgYmVsb3cgdGhyZXNob2xkXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV0ZSBUeXBlU2NyaXB0IGZhaWx1cmUgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZXhlY1N5bmMgdGhyb3dpbmcgYW4gZXJyb3Igd2l0aCBubyBzdGRvdXRcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBsZXRlIGZhaWx1cmUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplVHlwZVNjcmlwdEVycm9ycygpO1xuXG4gICAgICAvLyBTaG91bGQgcmV0dXJuIHNhZmUgZGVmYXVsdHNcbiAgICAgIGV4cGVjdChyZXN1bHQuc2hvdWxkVHJpZ2dlcikudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNhbXBhaWduTW9kZSkudG9CZShDYW1wYWlnbk1vZGUuTU9OSVRPUklORyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yQW5hbHlzaXMudG90YWxFcnJvcnMpLnRvQmUoLTEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zYWZldHlMZXZlbCkudG9CZShTYWZldHlMZXZlbC5NQVhJTVVNKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEN1cnJlbnRUeXBlU2NyaXB0RXJyb3JDb3VudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb3JyZWN0IGVycm9yIGNvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1RzY091dHB1dCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1IH0sIChfLCBpKSA9PiBcbiAgICAgICAgYHNyYy90ZXN0JHtpfS50cygxMCw1KTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd0ZXN0JHtpfScuYFxuICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrVHNjT3V0cHV0KTtcblxuICAgICAgY29uc3QgY291bnQgPSBhd2FpdCBnZXRDdXJyZW50VHlwZVNjcmlwdEVycm9yQ291bnQoKTtcblxuICAgICAgZXhwZWN0KGNvdW50KS50b0JlKDI1KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDAgZm9yIG5vIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCBjb3VudCA9IGF3YWl0IGdldEN1cnJlbnRUeXBlU2NyaXB0RXJyb3JDb3VudCgpO1xuXG4gICAgICBleHBlY3QoY291bnQpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiAtMSBvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tbWFuZCBmYWlsZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb3VudCA9IGF3YWl0IGdldEN1cnJlbnRUeXBlU2NyaXB0RXJyb3JDb3VudCgpO1xuXG4gICAgICBleHBlY3QoY291bnQpLnRvQmUoLTEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2hlY2tDYW1wYWlnblRyaWdnZXJDb25kaXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiBlcnJvciBjb3VudCBleGNlZWRzIHRocmVzaG9sZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tUc2NPdXRwdXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBgc3JjL3Rlc3Qke2l9LnRzKDEwLDUpOiBlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgJ3Rlc3Qke2l9Jy5gXG4gICAgICApLmpvaW4oJ1xcbicpO1xuICAgICAgXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKG1vY2tUc2NPdXRwdXQpO1xuXG4gICAgICBjb25zdCBzaG91bGRUcmlnZ2VyID0gYXdhaXQgY2hlY2tDYW1wYWlnblRyaWdnZXJDb25kaXRpb25zKCk7XG5cbiAgICAgIGV4cGVjdChzaG91bGRUcmlnZ2VyKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiBlcnJvciBjb3VudCBpcyBiZWxvdyB0aHJlc2hvbGQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVHNjT3V0cHV0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBgc3JjL3Rlc3Qke2l9LnRzKDEwLDUpOiBlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgJ3Rlc3Qke2l9Jy5gXG4gICAgICApLmpvaW4oJ1xcbicpO1xuICAgICAgXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKG1vY2tUc2NPdXRwdXQpO1xuXG4gICAgICBjb25zdCBzaG91bGRUcmlnZ2VyID0gYXdhaXQgY2hlY2tDYW1wYWlnblRyaWdnZXJDb25kaXRpb25zKCk7XG5cbiAgICAgIGV4cGVjdChzaG91bGRUcmlnZ2VyKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIG9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tbWFuZCBmYWlsZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzaG91bGRUcmlnZ2VyID0gYXdhaXQgY2hlY2tDYW1wYWlnblRyaWdnZXJDb25kaXRpb25zKCk7XG5cbiAgICAgIGV4cGVjdChzaG91bGRUcmlnZ2VyKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFBhcnNpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwYXJzZSBUeXBlU2NyaXB0IGVycm9yIGZvcm1hdCBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVHNjT3V0cHV0ID0gJ3NyYy9jb21wb25lbnRzL3Rlc3QudHN4KDQ1LDEyKTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lIFxcJ1VuZGVmaW5lZFZhcmlhYmxlXFwnLic7XG4gICAgICBcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUobW9ja1RzY091dHB1dCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emVUeXBlU2NyaXB0RXJyb3JzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JBbmFseXNpcy50b3RhbEVycm9ycykudG9CZSgxKTtcbiAgICAgIFxuICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuZXJyb3JBbmFseXNpcy5wcmlvcml0eVJhbmtpbmdbMF07XG4gICAgICBleHBlY3QoZXJyb3IuZmlsZVBhdGgpLnRvQmUoJ3NyYy9jb21wb25lbnRzL3Rlc3QudHN4Jyk7XG4gICAgICBleHBlY3QoZXJyb3IubGluZSkudG9CZSg0NSk7XG4gICAgICBleHBlY3QoZXJyb3IuY29sdW1uKS50b0JlKDEyKTtcbiAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdUUzIzMDQnKTtcbiAgICAgIGV4cGVjdChlcnJvci5jYXRlZ29yeSkudG9CZShFcnJvckNhdGVnb3J5LlRTMjMwNCk7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZSgnQ2Fubm90IGZpbmQgbmFtZSBcXCdVbmRlZmluZWRWYXJpYWJsZVxcJy4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaWdub3JlIG5vbi1lcnJvciBsaW5lcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tUc2NPdXRwdXQgPSBbXG4gICAgICAgICdGb3VuZCA1IGVycm9ycyB3YXRjaGluZyBmb3IgZmlsZSBjaGFuZ2VzLicsXG4gICAgICAgICdzcmMvdGVzdC50cygxMCw1KTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lIFxcJ3Rlc3RcXCcuJyxcbiAgICAgICAgJ0NvbXBpbGF0aW9uIGNvbXBsZXRlLiBXYXRjaGluZyBmb3IgZmlsZSBjaGFuZ2VzLicsXG4gICAgICAgICdzcmMvdGVzdDIudHMoMTUsMTApOiBlcnJvciBUUzIzNTI6IENvbnZlcnNpb24gZXJyb3IuJ1xuICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrVHNjT3V0cHV0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvckFuYWx5c2lzLnRvdGFsRXJyb3JzKS50b0JlKDIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmF0Y2ggU2NoZWR1bGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhcHByb3ByaWF0ZSBiYXRjaCBzaXplcyBmb3IgZGlmZmVyZW50IGVycm9yIGNhdGVnb3JpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVHNjT3V0cHV0ID0gW1xuICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiA1MCB9LCAoXywgaSkgPT4gYHNyYy90ZXN0JHtpfS50cygxMCw1KTogZXJyb3IgVFMyMzUyOiBDb252ZXJzaW9uIGVycm9yLmApLFxuICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiAzMCB9LCAoXywgaSkgPT4gYHNyYy90ZXN0JHtpfS50cygxNSwxMCk6IGVycm9yIFRTMjMwNDogQ2Fubm90IGZpbmQgbmFtZS5gKSxcbiAgICAgICAgLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogMjAgfSwgKF8sIGkpID0+IGBzcmMvdGVzdCR7aX0udHMoMjAsMTUpOiBlcnJvciBUUzIzNDU6IEFyZ3VtZW50IGVycm9yLmApXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKG1vY2tUc2NPdXRwdXQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplVHlwZVNjcmlwdEVycm9ycygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJhdGNoU2NoZWR1bGUuYmF0Y2hlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYmF0Y2hTY2hlZHVsZS50b3RhbEVzdGltYXRlZFRpbWUpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhdmUgZGlmZmVyZW50IGJhdGNoIHNpemVzIGZvciBkaWZmZXJlbnQgY2F0ZWdvcmllc1xuICAgICAgY29uc3QgYmF0Y2hTaXplcyA9IHJlc3VsdC5iYXRjaFNjaGVkdWxlLmJhdGNoZXMubWFwKGIgPT4gYi5iYXRjaFNpemUpO1xuICAgICAgZXhwZWN0KG5ldyBTZXQoYmF0Y2hTaXplcykuc2l6ZSkudG9CZUdyZWF0ZXJUaGFuKDEpOyAvLyBNdWx0aXBsZSBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBzYWZldHkgcHJvdG9jb2xzIGJhc2VkIG9uIGNhbXBhaWduIG1vZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVHNjT3V0cHV0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNjAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYHNyYy90ZXN0JHtpfS50cygxMCw1KTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd0ZXN0JHtpfScuYFxuICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrVHNjT3V0cHV0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZVR5cGVTY3JpcHRFcnJvcnMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jYW1wYWlnbk1vZGUpLnRvQmUoQ2FtcGFpZ25Nb2RlLkVNRVJHRU5DWSk7XG4gICAgICBleHBlY3QocmVzdWx0LmJhdGNoU2NoZWR1bGUuc2FmZXR5UHJvdG9jb2xzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5iYXRjaFNjaGVkdWxlLnNhZmV0eVByb3RvY29sc1swXS5uYW1lKS50b0NvbnRhaW4oJ0VtZXJnZW5jeScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb21wbGV0ZSBhbmFseXNpcyB3aXRoaW4gcmVhc29uYWJsZSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1RzY091dHB1dCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gXG4gICAgICAgIGBzcmMvdGVzdCR7aX0udHMoMTAsNSk6IGVycm9yIFRTMjMwNDogQ2Fubm90IGZpbmQgbmFtZSAndGVzdCR7aX0nLmBcbiAgICAgICkuam9pbignXFxuJyk7XG4gICAgICBcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUobW9ja1RzY091dHB1dCk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplVHlwZVNjcmlwdEVycm9ycygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiA1IHNlY29uZHNcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9