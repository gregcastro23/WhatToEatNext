26ce7819674e3715626a067966eeee54
"use strict";
/**
 * Integration Tests for Safety Protocol with Corruption Simulation
 * Perfect Codebase Campaign - Safety Protocol Integration Testing
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('child_process');
jest.mock('fs');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const campaign_1 = require("../../../../types/campaign");
const CampaignController_1 = require("../../CampaignController");
const ProgressTracker_1 = require("../../ProgressTracker");
const SafetyProtocol_1 = require("../../SafetyProtocol");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('Safety Protocol Integration Tests', () => {
    let safetyProtocol;
    let campaignController;
    let progressTracker;
    let mockSafetySettings;
    let mockConfig;
    beforeEach(() => {
        mockSafetySettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7
        };
        mockConfig = {
            phases: [
                {
                    id: 'test-phase',
                    name: 'Test Phase',
                    description: 'Test phase for safety protocol integration',
                    tools: [
                        {
                            scriptPath: 'scripts/test-script.js',
                            parameters: { maxFile, s: 10, autoFix: true },
                            batchSize: 10,
                            safetyLevel: campaign_1.SafetyLevel.HIGH
                        },
                    ],
                    successCriteria: { typeScriptError, s: 0 },
                    safetyCheckpoints: []
                },
            ],
            safetySettings: mockSafetySettings,
            progressTargets: { typeScriptError, s: 0, lintingWarnings: 0, buildTime: 10, enterpriseSystems: 200 },
            toolConfiguration: { enhancedErrorFixer: 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js',
                explicitAnyFixer: 'scripts/typescript-fixes/fix-explicit-any-systematic.js',
                unusedVariablesFixer: 'scripts/typescript-fixes/fix-unused-variables-enhanced.js',
                consoleStatementFixer: 'scripts/lint-fixes/fix-console-statements-only.js'
            },
        };
        safetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSafetySettings);
        campaignController = new CampaignController_1.CampaignController(mockConfig);
        progressTracker = new ProgressTracker_1.ProgressTracker();
        // Reset mocks
        jest.clearAllMocks();
        // Default mock implementations
        mockExecSync.mockReturnValue('');
        mockFs.existsSync.mockReturnValue(true);
        mockFs.readFileSync.mockReturnValue('valid content');
        mockFs.writeFileSync.mockImplementation(() => { });
    });
    describe('Corruption Detection and Recovery', () => {
        describe('Git Merge Conflict Simulation', () => {
            it('should detect and handle git merge conflicts', async () => {
                const corruptedContent = `
          function test() : any {
          <<<<<<< HEAD;
            return 'version 1';
          =======
            return 'version 2';
          >>>>>>> branch
          }
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.CRITICAL);
                expect(report.recommendedAction).toBe(campaign_1.RecoveryAction.EMERGENCY_RESTORE);
                expect(report.corruptionPatterns.some(p => p.description.includes('Git merge conflict'))).toBe(true);
            });
            it('should trigger emergency rollback for critical corruption', async () => {
                const corruptedContent = '<<<<<<< HEAD\nconflict\n=======\nother\n>>>>>>> branch';
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                // Create a stash first
                mockExecSync.mockImplementation(command => {
                    const cmd = command.toString();
                    if (cmd.includes('git stash push'))
                        return '';
                    if (cmd.includes('git stash list'))
                        return 'stash@{0}: emergency-stash';
                    if (cmd.includes('git stash apply'))
                        return '';
                    if (cmd.includes('git status --porcelain'))
                        return '';
                    if (cmd.includes('git branch --show-current'))
                        return 'main';
                    return '';
                });
                const stashId = await safetyProtocol.createStash('Emergency stash');
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                if (report.severity === campaign_1.CorruptionSeverity.CRITICAL) {
                    await safetyProtocol.emergencyRollback();
                }
                expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash apply'), expect.any(Object));
            });
        });
        describe('Import/Export Corruption Simulation', () => {
            it('should detect corrupted import statements', async () => {
                const corruptedContent = `;
          import @/types from './types';
          import @/services from './services';
          import { } from './empty';
          import something from "undefined";
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectImportExportCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.length).toBeGreaterThan(0);
            });
            it('should detect double commas in destructuring', async () => {
                const corruptedContent = `;
import type type Something, { ab } from './module';
          export { x,, y };
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectImportExportCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.some(p => p.description.includes('Double comma'))).toBe(true);
            });
            it('should detect duplicate keywords in imports', async () => {
                const corruptedContent = `;
          export default default value;
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectImportExportCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            });
        });
        describe('Syntax Corruption Simulation', () => {
            it('should detect unbalanced brackets', async () => {
                const corruptedContent = `
          function test() : any {
            if (condition != null) {
              return 'missing closing brace';
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            });
            it('should detect incomplete statements', async () => {
                const corruptedContent = `
          export
          import
          function;
          const
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            });
        });
        describe('TypeScript Syntax Validation', () => {
            it('should validate syntax using TypeScript compiler', async () => {
                mockExecSync.mockReturnValue('No errors found');
                const report = await safetyProtocol.validateSyntaxWithTypeScript(['test-file.ts']);
                expect(mockExecSync).toHaveBeenCalledWith('yarn tsc --noEmit --skipLibCheck 2>&1', expect.any(Object));
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
            });
            it('should detect TypeScript syntax errors', async () => {
                mockExecSync.mockReturnValue(`
          test-file.ts(105): error TS1005: Unexpected token 'function'
          test-file.ts(1510): error TS1109: Expression expected
        `);
                const report = await safetyProtocol.validateSyntaxWithTypeScript(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.some(p => p.pattern === 'TYPESCRIPT_SYNTAX_ERROR')).toBe(true);
            });
            it('should handle TypeScript compilation failures', async () => {
                mockExecSync.mockImplementation(() => {
                    const error = new Error('TypeScript compilation failed');
                    error.stdout = 'Unexpected token at line 5';
                    throw error;
                });
                const report = await safetyProtocol.validateSyntaxWithTypeScript(['test-file.ts']);
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.some(p => p.pattern === 'TYPESCRIPT_COMPILATION_ERROR')).toBe(true);
            });
        });
    });
    describe('Real-time Monitoring Integration', () => {
        beforeEach(() => {
            jest.useFakeTimers();
        });
        afterEach(() => {
            jest.useRealTimers();
        });
        it('should monitor files in real-time during script execution', async () => {
            const testFiles = ['file1.ts', 'file2.ts'];
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: [],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.LOW,
                recommendedAction: campaign_1.RecoveryAction.CONTINUE
            });
            safetyProtocol.startRealTimeMonitoring(testFiles, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            expect(safetyProtocol.detectCorruption).toHaveBeenCalledWith(testFiles);
            safetyProtocol.stopRealTimeMonitoring();
        });
        it('should trigger emergency rollback on critical corruption during monitoring', async () => {
            const testFiles = ['file1.ts'];
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: ['file1.ts'],
                corruptionPatterns: [
                    {
                        pattern: 'CRITICAL_CORRUPTION',
                        description: 'Critical corruption detected',
                        files: ['file1.ts']
                    },
                ],
                severity: campaign_1.CorruptionSeverity.CRITICAL,
                recommendedAction: campaign_1.RecoveryAction.EMERGENCY_RESTORE
            });
            jest.spyOn(safetyProtocol, 'emergencyRollback').mockResolvedValue();
            safetyProtocol.startRealTimeMonitoring(testFiles, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // Wait for async operations
            await new Promise(resolve => setTimeout(resolve, 0));
            expect(safetyProtocol.emergencyRollback).toHaveBeenCalled();
        });
        it('should record safety events during real-time monitoring', async () => {
            const testFiles = ['file1.ts'];
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: ['file1.ts'],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.MEDIUM,
                recommendedAction: campaign_1.RecoveryAction.RETRY
            });
            safetyProtocol.startRealTimeMonitoring(testFiles, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // Wait for async operations
            await new Promise(resolve => setTimeout(resolve, 0));
            const events = safetyProtocol.getSafetyEvents();
            expect(events.some(e => e.type === campaign_1.SafetyEventType.CORRUPTION_DETECTED)).toBe(true);
            safetyProtocol.stopRealTimeMonitoring();
        });
    });
    describe('Git Operations Integration', () => {
        beforeEach(() => {
            mockExecSync.mockImplementation(command => {
                const cmd = command.toString();
                if (cmd.includes('git status --porcelain'))
                    return '';
                if (cmd.includes('git stash push'))
                    return '';
                if (cmd.includes('git stash list'))
                    return 'stash@{0}: test-stash';
                if (cmd.includes('git stash apply'))
                    return '';
                if (cmd.includes('git branch --show-current'))
                    return 'main';
                return '';
            });
        });
        it('should create and manage git stashes throughout campaign', async () => {
            // Create multiple stashes for different phases
            const stash1 = await safetyProtocol.createStash('Phase 1 checkpoint', 'phase1');
            const stash2 = await safetyProtocol.createStash('Phase 2 checkpoint', 'phase2');
            expect(stash1).toMatch(/^campaign-phase1-\d+-/);
            expect(stash2).toMatch(/^campaign-phase2-\d+-/);
            const stashes = await safetyProtocol.listStashes();
            expect(stashes.length).toBe(2);
        });
        it('should apply stashes by phase for targeted rollbacks', async () => {
            // Create stashes for different phases
            await safetyProtocol.createStash('Phase 1 checkpoint', 'phase1');
            await safetyProtocol.createStash('Phase 2 checkpoint', 'phase2');
            await safetyProtocol.createStash('Another Phase 1 checkpoint', 'phase1');
            // Apply latest Phase 1 stash
            const appliedStashId = await safetyProtocol.applyStashByPhase('phase1');
            expect(appliedStashId).toMatch(/^campaign-phase1-\d+-/);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash apply'), expect.any(Object));
        });
        it('should validate git state before operations', async () => {
            const validation = await safetyProtocol.validateGitState();
            expect(validation.success).toBe(true);
            expect(mockExecSync).toHaveBeenCalledWith('git status --porcelain', expect.any(Object));
        });
        it('should handle git operation failures gracefully', async () => {
            mockExecSync.mockImplementation(command => {
                if (command.toString().includes('git stash push')) {
                    throw new Error('Git stash failed');
                }
                return '';
            });
            await expect(safetyProtocol.createStash('Test stash')).rejects.toThrow('Failed to create git stash: Git stash failed');
            const events = safetyProtocol.getSafetyEvents();
            expect(events.some(e => e.type === campaign_1.SafetyEventType.EMERGENCY_RECOVERY)).toBe(true);
        });
    });
    describe('Stash Management and Cleanup', () => {
        beforeEach(() => {
            mockExecSync.mockImplementation(command => {
                const cmd = command.toString();
                if (cmd.includes('git status --porcelain'))
                    return '';
                if (cmd.includes('git stash push'))
                    return '';
                if (cmd.includes('git stash list'))
                    return 'stash@{0}: test-stash';
                if (cmd.includes('git stash drop'))
                    return '';
                if (cmd.includes('git branch --show-current'))
                    return 'main';
                return '';
            });
        });
        it('should cleanup old stashes based on retention policy', async () => {
            // Create old stashes
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            const recentDate = new Date();
            recentDate.setDate(recentDate.getDate() - 3); // 3 days old
            // Manually add stashes to simulate age
            const oldStash = {
                id: 'old-stash',
                description: 'Old stash',
                timestamp: oldDate,
                branch: 'main',
                ref: 'stash@{1}',
            };
            const recentStash = {
                id: 'recent-stash',
                description: 'Recent stash',
                timestamp: recentDate,
                branch: 'main',
                ref: 'stash@{0}',
            };
            safetyProtocol.stashes.set('old-stash', oldStash);
            safetyProtocol.stashes.set('recent-stash', recentStash);
            await safetyProtocol.cleanupOldStashes();
            const stashes = await safetyProtocol.listStashes();
            expect(stashes.some(s => s.id === 'old-stash')).toBe(false);
            expect(stashes.some(s => s.id === 'recent-stash')).toBe(true);
        });
        it('should generate stash statistics for reporting', async () => {
            // Create stashes for different phases
            await safetyProtocol.createStash('Phase 1 checkpoint', 'phase1');
            await safetyProtocol.createStash('Phase 2 checkpoint', 'phase2');
            await safetyProtocol.createStash('Another Phase 1 checkpoint', 'phase1');
            const stats = safetyProtocol.getStashStatistics();
            expect(stats.total).toBe(3);
            expect(stats.byPhase.phase1).toBe(2);
            expect(stats.byPhase.phase2).toBe(1);
            expect(stats.oldestStash).toBeInstanceOf(Date);
            expect(stats.newestStash).toBeInstanceOf(Date);
        });
    });
    describe('Integration with Campaign Controller', () => {
        it('should integrate safety protocols with phase execution', async () => {
            const phase = mockConfig.phases[0];
            // Mock successful execution with safety protocols
            jest.spyOn(campaignController, 'createSafetyCheckpoint').mockResolvedValue('checkpoint-1');
            jest.spyOn(campaignController, 'getCurrentMetrics').mockResolvedValue({
                typeScriptErrors: { current: 0, target: 0, reduction: 86, percentage: 100 },
                lintingWarnings: { current: 4506, target: 0, reduction: 0, percentage: 0 },
                buildPerformance: { currentTim, e: 8.5, targetTime: 10, cacheHitRate: 0.8, memoryUsage: 45 },
                enterpriseSystems: { current: 0, target: 200, transformedExports: 0 },
            });
            const result = await campaignController.executePhase(phase);
            expect(result.success).toBe(true);
            expect(result.safetyEvents.length).toBeGreaterThan(0);
            expect(campaignController['createSafetyCheckpoint']).toHaveBeenCalled();
        });
        it('should handle rollback scenarios during phase execution', async () => {
            const phase = mockConfig.phases[0];
            // Mock validation failure that triggers rollback
            jest.spyOn(campaignController, 'validatePhaseProgress').mockResolvedValue({
                success: false,
                errors: ['Corruption detected'],
                warnings: []
            });
            jest.spyOn(campaignController, 'rollbackToCheckpoint').mockResolvedValue();
            await expect(campaignController.executePhase(phase)).rejects.toThrow('Tool execution failed: Corruption detected');
            expect(campaignController.rollbackToCheckpoint).toHaveBeenCalled();
        });
    });
    describe('File System Integration', () => {
        it('should handle file read errors during corruption detection', async () => {
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('Permission denied');
            });
            const report = await safetyProtocol.detectCorruption(['protected-file.ts']);
            expect(report.detectedFiles).toContain('protected-file.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.pattern === 'FILE_READ_ERROR')).toBe(true);
        });
        it('should skip non-existent files gracefully', async () => {
            mockFs.existsSync.mockReturnValue(false);
            const report = await safetyProtocol.detectCorruption(['non-existent.ts']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
        it('should handle mixed file types appropriately', async () => {
            const files = ['script.ts', 'style.css', 'config.json', 'readme.md'];
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue('valid content');
            const report = await safetyProtocol.detectImportExportCorruption(files);
            // Should only process TypeScript/JavaScript files
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
    });
    describe('Safety Event Tracking', () => {
        it('should track safety events throughout integration scenarios', async () => {
            // Create stash
            await safetyProtocol.createStash('Test stash');
            // Detect corruption
            mockFs.readFileSync.mockReturnValue('<<<<<<< HEAD\nconflict\n>>>>>>> branch');
            await safetyProtocol.detectCorruption(['test-file.ts']);
            // Apply stash
            await safetyProtocol.applyStash((await safetyProtocol.listStashes())[0].id);
            const events = safetyProtocol.getSafetyEvents();
            expect(events.some(e => e.type === campaign_1.SafetyEventType.CHECKPOINT_CREATED)).toBe(true);
            expect(events.some(e => e.type === campaign_1.SafetyEventType.CORRUPTION_DETECTED)).toBe(true);
            expect(events.some(e => e.type === campaign_1.SafetyEventType.ROLLBACK_TRIGGERED)).toBe(true);
        });
        it('should maintain event history with proper severity levels', async () => {
            // Generate events of different severities
            await safetyProtocol.createStash('Info event'); // INFO
            mockFs.readFileSync.mockReturnValue('<<<<<<< HEAD\nconflict\n>>>>>>> branch');
            await safetyProtocol.detectCorruption(['test-file.ts']); // CRITICAL
            const events = safetyProtocol.getSafetyEvents();
            const severities = events.map(e => e.severity);
            expect(severities).toContain(campaign_1.SafetyEventSeverity.INFO);
            expect(severities).toContain(campaign_1.SafetyEventSeverity.CRITICAL);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5yZXNpbGllbnQtZXNsaW50LWJhY2t1cC0xNzU3NDc4ODEzMzkzL3NyY19zZXJ2aWNlc19jYW1wYWlnbl9fX3Rlc3RzX19faW50ZWdyYXRpb25fU2FmZXR5UHJvdG9jb2wuaW50ZWdyYXRpb24udGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JILG9CQUFvQjtBQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFsQmhCLGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFFekIseURBUW9DO0FBQ3BDLGlFQUE4RDtBQUM5RCwyREFBd0Q7QUFDeEQseURBQXNEO0FBTXRELE1BQU0sWUFBWSxHQUFRLHdCQUFnRCxDQUFDO0FBQzNFLE1BQU0sTUFBTSxHQUFRLEVBQTRCLENBQUM7QUFFakQsUUFBUSxDQUFDLG1DQUFtQyxFQUFFLEdBQUcsRUFBRTtJQUNqRCxJQUFJLGNBQThCLENBQUM7SUFDbkMsSUFBSSxrQkFBc0MsQ0FBQztJQUMzQyxJQUFJLGVBQWdDLENBQUM7SUFDckMsSUFBSSxrQkFBa0MsQ0FBQztJQUN2QyxJQUFJLFVBQTBCLENBQUM7SUFFL0IsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLGtCQUFrQixHQUFHO1lBQ25CLGdCQUFnQixFQUFFLEVBQUU7WUFDcEIsd0JBQXdCLEVBQUUsQ0FBQztZQUMzQix1QkFBdUIsRUFBRSxFQUFFO1lBQzNCLDBCQUEwQixFQUFFLElBQUk7WUFDaEMsd0JBQXdCLEVBQUUsSUFBSTtZQUM5QixrQkFBa0IsRUFBRSxDQUFDO1NBQ3RCLENBQUM7UUFFRixVQUFVLEdBQUc7WUFDWCxNQUFNLEVBQUU7Z0JBQ047b0JBQ0UsRUFBRSxFQUFFLFlBQVk7b0JBQ2hCLElBQUksRUFBRSxZQUFZO29CQUNsQixXQUFXLEVBQUUsNENBQTRD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QUFDLFdBQVc7WUFFcEUsTUFBTSxNQUFNLEdBQVEsY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3JELE1BQU0sVUFBVSxHQUFRLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFcEQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyw4QkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN2RCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDLDhCQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvR3JlZ0Nhc3Ryby9EZXNrdG9wL1doYXRUb0VhdE5leHQvLnJlc2lsaWVudC1lc2xpbnQtYmFja3VwLTE3NTc0Nzg4MTMzOTMvc3JjX3NlcnZpY2VzX2NhbXBhaWduX19fdGVzdHNfX19pbnRlZ3JhdGlvbl9TYWZldHlQcm90b2NvbC5pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZWdyYXRpb24gVGVzdHMgZm9yIFNhZmV0eSBQcm90b2NvbCB3aXRoIENvcnJ1cHRpb24gU2ltdWxhdGlvblxuICogUGVyZmVjdCBDb2RlYmFzZSBDYW1wYWlnbiAtIFNhZmV0eSBQcm90b2NvbCBJbnRlZ3JhdGlvbiBUZXN0aW5nXG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcblxuaW1wb3J0IHtcbiAgU2FmZXR5U2V0dGluZ3MsXG4gIENvcnJ1cHRpb25TZXZlcml0eSxcbiAgUmVjb3ZlcnlBY3Rpb24sXG4gIFNhZmV0eUV2ZW50VHlwZSxcbiAgU2FmZXR5RXZlbnRTZXZlcml0eSxcbiAgQ2FtcGFpZ25Db25maWcsXG4gIFNhZmV0eUxldmVsLFxufSBmcm9tICcuLi8uLi8uLi8uLi90eXBlcy9jYW1wYWlnbic7XG5pbXBvcnQgeyBDYW1wYWlnbkNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi9DYW1wYWlnbkNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vUHJvZ3Jlc3NUcmFja2VyJztcbmltcG9ydCB7IFNhZmV0eVByb3RvY29sIH0gZnJvbSAnLi4vLi4vU2FmZXR5UHJvdG9jb2wnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJyk7XG5qZXN0Lm1vY2soJ2ZzJyk7XG5cbmNvbnN0IG1vY2tFeGVjU3luYzogYW55ID0gZXhlY1N5bmMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZXhlY1N5bmM+O1xuY29uc3QgbW9ja0ZzOiBhbnkgPSBmcyBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZnM+O1xuXG5kZXNjcmliZSgnU2FmZXR5IFByb3RvY29sIEludGVncmF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgc2FmZXR5UHJvdG9jb2w6IFNhZmV0eVByb3RvY29sO1xuICBsZXQgY2FtcGFpZ25Db250cm9sbGVyOiBDYW1wYWlnbkNvbnRyb2xsZXI7XG4gIGxldCBwcm9ncmVzc1RyYWNrZXI6IFByb2dyZXNzVHJhY2tlcjtcbiAgbGV0IG1vY2tTYWZldHlTZXR0aW5nczogU2FmZXR5U2V0dGluZ3M7XG4gIGxldCBtb2NrQ29uZmlnOiBDYW1wYWlnbkNvbmZpZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrU2FmZXR5U2V0dGluZ3MgPSB7XG4gICAgICBtYXhGaWxlc1BlckJhdGNoOiAyNSxcbiAgICAgIGJ1aWxkVmFsaWRhdGlvbkZyZXF1ZW5jeTogNSxcbiAgICAgIHRlc3RWYWxpZGF0aW9uRnJlcXVlbmN5OiAxMCxcbiAgICAgIGNvcnJ1cHRpb25EZXRlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgYXV0b21hdGljUm9sbGJhY2tFbmFibGVkOiB0cnVlLFxuICAgICAgc3Rhc2hSZXRlbnRpb25EYXlzOiA3XG4gICAgfTtcblxuICAgIG1vY2tDb25maWcgPSB7XG4gICAgICBwaGFzZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndGVzdC1waGFzZScsXG4gICAgICAgICAgbmFtZTogJ1Rlc3QgUGhhc2UnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBwaGFzZSBmb3Igc2FmZXR5IHByb3RvY29sIGludGVncmF0aW9uJyxcbiAgICAgICAgICB0b29sczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzY3JpcHRQYXRoOiAnc2NyaXB0cy90ZXN0LXNjcmlwdC5qcycsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHsgbWF4RmlsZSwgczogMTAsIGF1dG9GaXg6IHRydWUgfSxcbiAgICAgICAgICAgICAgYmF0Y2hTaXplOiAxMCxcbiAgICAgICAgICAgICAgc2FmZXR5TGV2ZWw6IFNhZmV0eUxldmVsLkhJR0hcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdWNjZXNzQ3JpdGVyaWE6IHsgdHlwZVNjcmlwdEVycm9yLCBzOiAwIH0sXG4gICAgICAgICAgc2FmZXR5Q2hlY2twb2ludHM6IFtdXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgc2FmZXR5U2V0dGluZ3M6IG1vY2tTYWZldHlTZXR0aW5ncyxcbiAgICAgIHByb2dyZXNzVGFyZ2V0czogeyB0eXBlU2NyaXB0RXJyb3IsIHM6IDAsIGxpbnRpbmdXYXJuaW5nczogMCwgYnVpbGRUaW1lOiAxMCwgZW50ZXJwcmlzZVN5c3RlbXM6IDIwMCB9LFxuICAgICAgdG9vbENvbmZpZ3VyYXRpb246IHsgZW5oYW5jZWRFcnJvckZpeGVyOiAnc2NyaXB0cy90eXBlc2NyaXB0LWZpeGVzL2ZpeC10eXBlc2NyaXB0LWVycm9ycy1lbmhhbmNlZC12My5qcycsXG4gICAgICAgIGV4cGxpY2l0QW55Rml4ZXI6ICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LWV4cGxpY2l0LWFueS1zeXN0ZW1hdGljLmpzJyxcbiAgICAgICAgdW51c2VkVmFyaWFibGVzRml4ZXI6ICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LXVudXNlZC12YXJpYWJsZXMtZW5oYW5jZWQuanMnLFxuICAgICAgICBjb25zb2xlU3RhdGVtZW50Rml4ZXI6ICdzY3JpcHRzL2xpbnQtZml4ZXMvZml4LWNvbnNvbGUtc3RhdGVtZW50cy1vbmx5LmpzJ1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgc2FmZXR5UHJvdG9jb2wgPSBuZXcgU2FmZXR5UHJvdG9jb2wobW9ja1NhZmV0eVNldHRpbmdzKTtcbiAgICBjYW1wYWlnbkNvbnRyb2xsZXIgPSBuZXcgQ2FtcGFpZ25Db250cm9sbGVyKG1vY2tDb25maWcpO1xuICAgIHByb2dyZXNzVHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoKTtcblxuICAgIC8vIFJlc2V0IG1vY2tzXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG5cbiAgICAvLyBEZWZhdWx0IG1vY2sgaW1wbGVtZW50YXRpb25zXG4gICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG4gICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCd2YWxpZCBjb250ZW50Jyk7XG4gICAgbW9ja0ZzLndyaXRlRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvcnJ1cHRpb24gRGV0ZWN0aW9uIGFuZCBSZWNvdmVyeScsICgpID0+IHtcbiAgICBkZXNjcmliZSgnR2l0IE1lcmdlIENvbmZsaWN0IFNpbXVsYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCBhbmQgaGFuZGxlIGdpdCBtZXJnZSBjb25mbGljdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvcnJ1cHRlZENvbnRlbnQ6IGFueSA9IGBcbiAgICAgICAgICBmdW5jdGlvbiB0ZXN0KCkgOiBhbnkge1xuICAgICAgICAgIDw8PDw8PDwgSEVBRDtcbiAgICAgICAgICAgIHJldHVybiAndmVyc2lvbiAxJztcbiAgICAgICAgICA9PT09PT09XG4gICAgICAgICAgICByZXR1cm4gJ3ZlcnNpb24gMic7XG4gICAgICAgICAgPj4+Pj4+PiBicmFuY2hcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoY29ycnVwdGVkQ29udGVudCk7XG5cbiAgICAgICAgY29uc3QgcmVwb3J0OiBhbnkgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsndGVzdC1maWxlLnRzJ10pO1xuXG4gICAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCd0ZXN0LWZpbGUudHMnKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnJlY29tbWVuZGVkQWN0aW9uKS50b0JlKFJlY292ZXJ5QWN0aW9uLkVNRVJHRU5DWV9SRVNUT1JFKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0dpdCBtZXJnZSBjb25mbGljdCcpKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHRyaWdnZXIgZW1lcmdlbmN5IHJvbGxiYWNrIGZvciBjcml0aWNhbCBjb3JydXB0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb3JydXB0ZWRDb250ZW50OiBhbnkgPSAnPDw8PDw8PCBIRUFEXFxuY29uZmxpY3RcXG49PT09PT09XFxub3RoZXJcXG4+Pj4+Pj4+IGJyYW5jaCc7XG4gICAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGNvcnJ1cHRlZENvbnRlbnQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHN0YXNoIGZpcnN0XG4gICAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oY29tbWFuZCA9PiB7XG4gICAgICAgICAgY29uc3QgY21kOiBhbnkgPSBjb21tYW5kLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXNoIHB1c2gnKSkgcmV0dXJuICcnO1xuICAgICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBsaXN0JykpIHJldHVybiAnc3Rhc2hAezB9OiBlbWVyZ2VuY3ktc3Rhc2gnO1xuICAgICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBhcHBseScpKSByZXR1cm4gJyc7XG4gICAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXR1cyAtLXBvcmNlbGFpbicpKSByZXR1cm4gJyc7XG4gICAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IGJyYW5jaCAtLXNob3ctY3VycmVudCcpKSByZXR1cm4gJ21haW4nO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3Rhc2hJZDogYW55ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ0VtZXJnZW5jeSBzdGFzaCcpO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydDogYW55ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ3Rlc3QtZmlsZS50cyddKTtcblxuICAgICAgICBpZiAocmVwb3J0LnNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpIHtcbiAgICAgICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5lbWVyZ2VuY3lSb2xsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2dpdCBzdGFzaCBhcHBseScpLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnSW1wb3J0L0V4cG9ydCBDb3JydXB0aW9uIFNpbXVsYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCBjb3JydXB0ZWQgaW1wb3J0IHN0YXRlbWVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvcnJ1cHRlZENvbnRlbnQ6IGFueSA9IGA7XG4gICAgICAgICAgaW1wb3J0IEAvdHlwZXMgZnJvbSAnLi90eXBlcyc7XG4gICAgICAgICAgaW1wb3J0IEAvc2VydmljZXMgZnJvbSAnLi9zZXJ2aWNlcyc7XG4gICAgICAgICAgaW1wb3J0IHsgfSBmcm9tICcuL2VtcHR5JztcbiAgICAgICAgICBpbXBvcnQgc29tZXRoaW5nIGZyb20gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgYDtcblxuICAgICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShjb3JydXB0ZWRDb250ZW50KTtcblxuICAgICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBkZXRlY3QgZG91YmxlIGNvbW1hcyBpbiBkZXN0cnVjdHVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb3JydXB0ZWRDb250ZW50OiBhbnkgPSBgO1xuaW1wb3J0IHR5cGUgdHlwZSBTb21ldGhpbmcsIHsgYWIgfSBmcm9tICcuL21vZHVsZSc7XG4gICAgICAgICAgZXhwb3J0IHsgeCwsIHkgfTtcbiAgICAgICAgYDtcblxuICAgICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShjb3JydXB0ZWRDb250ZW50KTtcblxuICAgICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0RvdWJsZSBjb21tYScpKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCBkdXBsaWNhdGUga2V5d29yZHMgaW4gaW1wb3J0cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ycnVwdGVkQ29udGVudDogYW55ID0gYDtcbiAgICAgICAgICBleHBvcnQgZGVmYXVsdCBkZWZhdWx0IHZhbHVlO1xuICAgICAgICBgO1xuXG4gICAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGNvcnJ1cHRlZENvbnRlbnQpO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydDogYW55ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0SW1wb3J0RXhwb3J0Q29ycnVwdGlvbihbJ3Rlc3QtZmlsZS50cyddKTtcblxuICAgICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbigndGVzdC1maWxlLnRzJyk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkhJR0gpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnU3ludGF4IENvcnJ1cHRpb24gU2ltdWxhdGlvbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZGV0ZWN0IHVuYmFsYW5jZWQgYnJhY2tldHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvcnJ1cHRlZENvbnRlbnQ6IGFueSA9IGBcbiAgICAgICAgICBmdW5jdGlvbiB0ZXN0KCkgOiBhbnkge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnbWlzc2luZyBjbG9zaW5nIGJyYWNlJztcbiAgICAgICAgYDtcblxuICAgICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShjb3JydXB0ZWRDb250ZW50KTtcblxuICAgICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCBpbmNvbXBsZXRlIHN0YXRlbWVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvcnJ1cHRlZENvbnRlbnQgPSBgXG4gICAgICAgICAgZXhwb3J0XG4gICAgICAgICAgaW1wb3J0XG4gICAgICAgICAgZnVuY3Rpb247XG4gICAgICAgICAgY29uc3RcbiAgICAgICAgYDtcblxuICAgICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShjb3JydXB0ZWRDb250ZW50KTtcblxuICAgICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1R5cGVTY3JpcHQgU3ludGF4IFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN5bnRheCB1c2luZyBUeXBlU2NyaXB0IGNvbXBpbGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCdObyBlcnJvcnMgZm91bmQnKTtcblxuICAgICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3lhcm4gdHNjIC0tbm9FbWl0IC0tc2tpcExpYkNoZWNrIDI+JjEnLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZGV0ZWN0IFR5cGVTY3JpcHQgc3ludGF4IGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZShgXG4gICAgICAgICAgdGVzdC1maWxlLnRzKDEwNSk6IGVycm9yIFRTMTAwNTogVW5leHBlY3RlZCB0b2tlbiAnZnVuY3Rpb24nXG4gICAgICAgICAgdGVzdC1maWxlLnRzKDE1MTApOiBlcnJvciBUUzExMDk6IEV4cHJlc3Npb24gZXhwZWN0ZWRcbiAgICAgICAgYCk7XG5cbiAgICAgICAgY29uc3QgcmVwb3J0OiBhbnkgPSBhd2FpdCBzYWZldHlQcm90b2NvbC52YWxpZGF0ZVN5bnRheFdpdGhUeXBlU2NyaXB0KFsndGVzdC1maWxlLnRzJ10pO1xuXG4gICAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCd0ZXN0LWZpbGUudHMnKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLnBhdHRlcm4gPT09ICdUWVBFU0NSSVBUX1NZTlRBWF9FUlJPUicpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIFR5cGVTY3JpcHQgY29tcGlsYXRpb24gZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ1R5cGVTY3JpcHQgY29tcGlsYXRpb24gZmFpbGVkJykgYXMgdW5rbm93bjtcbiAgICAgICAgICAoZXJyb3IgYXMgYW55KS5zdGRvdXQgPSAnVW5leHBlY3RlZCB0b2tlbiBhdCBsaW5lIDUnO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLnBhdHRlcm4gPT09ICdUWVBFU0NSSVBUX0NPTVBJTEFUSU9OX0VSUk9SJykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlYWwtdGltZSBNb25pdG9yaW5nIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1vbml0b3IgZmlsZXMgaW4gcmVhbC10aW1lIGR1cmluZyBzY3JpcHQgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEZpbGVzOiBhbnkgPSBbJ2ZpbGUxLnRzJywgJ2ZpbGUyLnRzJ107XG5cbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdkZXRlY3RDb3JydXB0aW9uJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkZXRlY3RlZEZpbGVzOiBbXSxcbiAgICAgICAgY29ycnVwdGlvblBhdHRlcm5zOiBbXSxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5MT1csXG4gICAgICAgIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5DT05USU5VRVxuICAgICAgfSk7XG5cbiAgICAgIHNhZmV0eVByb3RvY29sLnN0YXJ0UmVhbFRpbWVNb25pdG9yaW5nKHRlc3RGaWxlcywgMTAwMCk7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCB0aW1lIHRvIHRyaWdnZXIgbW9uaXRvcmluZ1xuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuXG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEZpbGVzKTtcblxuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RvcFJlYWxUaW1lTW9uaXRvcmluZygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmlnZ2VyIGVtZXJnZW5jeSByb2xsYmFjayBvbiBjcml0aWNhbCBjb3JydXB0aW9uIGR1cmluZyBtb25pdG9yaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEZpbGVzOiBhbnkgPSBbJ2ZpbGUxLnRzJ107XG5cbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdkZXRlY3RDb3JydXB0aW9uJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkZXRlY3RlZEZpbGVzOiBbJ2ZpbGUxLnRzJ10sXG4gICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhdHRlcm46ICdDUklUSUNBTF9DT1JSVVBUSU9OJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ3JpdGljYWwgY29ycnVwdGlvbiBkZXRlY3RlZCcsXG4gICAgICAgICAgICBmaWxlczogWydmaWxlMS50cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCxcbiAgICAgICAgcmVjb21tZW5kZWRBY3Rpb246IFJlY292ZXJ5QWN0aW9uLkVNRVJHRU5DWV9SRVNUT1JFXG4gICAgICB9KTtcblxuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2VtZXJnZW5jeVJvbGxiYWNrJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcblxuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RhcnRSZWFsVGltZU1vbml0b3JpbmcodGVzdEZpbGVzLCAxMDAwKTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHRpbWUgdG8gdHJpZ2dlciBtb25pdG9yaW5nXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG5cbiAgICAgIGV4cGVjdChzYWZldHlQcm90b2NvbC5lbWVyZ2VuY3lSb2xsYmFjaykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWNvcmQgc2FmZXR5IGV2ZW50cyBkdXJpbmcgcmVhbC10aW1lIG1vbml0b3JpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RmlsZXM6IGFueSA9IFsnZmlsZTEudHMnXTtcblxuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2RldGVjdENvcnJ1cHRpb24nKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRldGVjdGVkRmlsZXM6IFsnZmlsZTEudHMnXSxcbiAgICAgICAgY29ycnVwdGlvblBhdHRlcm5zOiBbXSxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU0sXG4gICAgICAgIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5SRVRSWVxuICAgICAgfSk7XG5cbiAgICAgIHNhZmV0eVByb3RvY29sLnN0YXJ0UmVhbFRpbWVNb25pdG9yaW5nKHRlc3RGaWxlcywgMTAwMCk7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCB0aW1lIHRvIHRyaWdnZXIgbW9uaXRvcmluZ1xuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuXG4gICAgICAvLyBXYWl0IGZvciBhc3luYyBvcGVyYXRpb25zXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuXG4gICAgICBjb25zdCBldmVudHM6IGFueSA9IHNhZmV0eVByb3RvY29sLmdldFNhZmV0eUV2ZW50cygpO1xuICAgICAgZXhwZWN0KGV2ZW50cy5zb21lKGUgPT4gZS50eXBlID09PSBTYWZldHlFdmVudFR5cGUuQ09SUlVQVElPTl9ERVRFQ1RFRCkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIHNhZmV0eVByb3RvY29sLnN0b3BSZWFsVGltZU1vbml0b3JpbmcoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dpdCBPcGVyYXRpb25zIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbihjb21tYW5kID0+IHtcbiAgICAgICAgY29uc3QgY21kOiBhbnkgPSBjb21tYW5kLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGF0dXMgLS1wb3JjZWxhaW4nKSkgcmV0dXJuICcnO1xuICAgICAgICBpZiAoY21kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggcHVzaCcpKSByZXR1cm4gJyc7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBsaXN0JykpIHJldHVybiAnc3Rhc2hAezB9OiB0ZXN0LXN0YXNoJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXNoIGFwcGx5JykpIHJldHVybiAnJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IGJyYW5jaCAtLXNob3ctY3VycmVudCcpKSByZXR1cm4gJ21haW4nO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGFuZCBtYW5hZ2UgZ2l0IHN0YXNoZXMgdGhyb3VnaG91dCBjYW1wYWlnbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBzdGFzaGVzIGZvciBkaWZmZXJlbnQgcGhhc2VzXG4gICAgICBjb25zdCBzdGFzaDE6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdQaGFzZSAxIGNoZWNrcG9pbnQnLCAncGhhc2UxJyk7XG4gICAgICBjb25zdCBzdGFzaDI6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdQaGFzZSAyIGNoZWNrcG9pbnQnLCAncGhhc2UyJyk7XG5cbiAgICAgIGV4cGVjdChzdGFzaDEpLnRvTWF0Y2goL15jYW1wYWlnbi1waGFzZTEtXFxkKy0vKTtcbiAgICAgIGV4cGVjdChzdGFzaDIpLnRvTWF0Y2goL15jYW1wYWlnbi1waGFzZTItXFxkKy0vKTtcblxuICAgICAgY29uc3Qgc3Rhc2hlczogYW55ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wubGlzdFN0YXNoZXMoKTtcbiAgICAgIGV4cGVjdChzdGFzaGVzLmxlbmd0aCkudG9CZSgyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgc3Rhc2hlcyBieSBwaGFzZSBmb3IgdGFyZ2V0ZWQgcm9sbGJhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHN0YXNoZXMgZm9yIGRpZmZlcmVudCBwaGFzZXNcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdQaGFzZSAxIGNoZWNrcG9pbnQnLCAncGhhc2UxJyk7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnUGhhc2UgMiBjaGVja3BvaW50JywgJ3BoYXNlMicpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ0Fub3RoZXIgUGhhc2UgMSBjaGVja3BvaW50JywgJ3BoYXNlMScpO1xuXG4gICAgICAvLyBBcHBseSBsYXRlc3QgUGhhc2UgMSBzdGFzaFxuICAgICAgY29uc3QgYXBwbGllZFN0YXNoSWQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2hCeVBoYXNlKCdwaGFzZTEnKTtcblxuICAgICAgZXhwZWN0KGFwcGxpZWRTdGFzaElkKS50b01hdGNoKC9eY2FtcGFpZ24tcGhhc2UxLVxcZCstLyk7XG4gICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nQ29udGFpbmluZygnZ2l0IHN0YXNoIGFwcGx5JyksIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGdpdCBzdGF0ZSBiZWZvcmUgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb246IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlR2l0U3RhdGUoKTtcblxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdnaXQgc3RhdHVzIC0tcG9yY2VsYWluJywgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGdpdCBvcGVyYXRpb24gZmFpbHVyZXMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oY29tbWFuZCA9PiB7XG4gICAgICAgIGlmIChjb21tYW5kLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ2dpdCBzdGFzaCBwdXNoJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdCBzdGFzaCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdUZXN0IHN0YXNoJykpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgZ2l0IHN0YXNoOiBHaXQgc3Rhc2ggZmFpbGVkJyxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGV2ZW50czogYW55ID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09IFNhZmV0eUV2ZW50VHlwZS5FTUVSR0VOQ1lfUkVDT1ZFUlkpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3Rhc2ggTWFuYWdlbWVudCBhbmQgQ2xlYW51cCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oY29tbWFuZCA9PiB7XG4gICAgICAgIGNvbnN0IGNtZDogYW55ID0gY29tbWFuZC50b1N0cmluZygpO1xuICAgICAgICBpZiAoY21kLmluY2x1ZGVzKCdnaXQgc3RhdHVzIC0tcG9yY2VsYWluJykpIHJldHVybiAnJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXNoIHB1c2gnKSkgcmV0dXJuICcnO1xuICAgICAgICBpZiAoY21kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggbGlzdCcpKSByZXR1cm4gJ3N0YXNoQHswfTogdGVzdC1zdGFzaCc7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBkcm9wJykpIHJldHVybiAnJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IGJyYW5jaCAtLXNob3ctY3VycmVudCcpKSByZXR1cm4gJ21haW4nO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYW51cCBvbGQgc3Rhc2hlcyBiYXNlZCBvbiByZXRlbnRpb24gcG9saWN5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIG9sZCBzdGFzaGVzXG4gICAgICBjb25zdCBvbGREYXRlOiBhbnkgPSBuZXcgRGF0ZSgpO1xuICAgICAgb2xkRGF0ZS5zZXREYXRlKG9sZERhdGUuZ2V0RGF0ZSgpIC0gMTApOyAvLyAxMCBkYXlzIG9sZFxuXG4gICAgICBjb25zdCByZWNlbnREYXRlOiBhbnkgPSBuZXcgRGF0ZSgpO1xuICAgICAgcmVjZW50RGF0ZS5zZXREYXRlKHJlY2VudERhdGUuZ2V0RGF0ZSgpIC0gMyk7IC8vIDMgZGF5cyBvbGRcblxuICAgICAgLy8gTWFudWFsbHkgYWRkIHN0YXNoZXMgdG8gc2ltdWxhdGUgYWdlXG4gICAgICBjb25zdCBvbGRTdGFzaDogYW55ID0ge1xuICBpZDogJ29sZC1zdGFzaCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnT2xkIHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBvbGREYXRlLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezF9JyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlY2VudFN0YXNoOiBhbnkgPSB7XG4gIGlkOiAncmVjZW50LXN0YXNoJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZWNlbnQgc3Rhc2gnLFxuICAgICAgICB0aW1lc3RhbXA6IHJlY2VudERhdGUsXG4gICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICByZWY6ICdzdGFzaEB7MH0nLFxuICAgICAgfTtcblxuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ29sZC1zdGFzaCcsIG9sZFN0YXNoKTtcbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnN0YXNoZXMuc2V0KCdyZWNlbnQtc3Rhc2gnLCByZWNlbnRTdGFzaCk7XG5cbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCk7XG5cbiAgICAgIGNvbnN0IHN0YXNoZXM6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmxpc3RTdGFzaGVzKCk7XG4gICAgICBleHBlY3Qoc3Rhc2hlcy5zb21lKHMgPT4gcy5pZCA9PT0gJ29sZC1zdGFzaCcpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChzdGFzaGVzLnNvbWUocyA9PiBzLmlkID09PSAncmVjZW50LXN0YXNoJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHN0YXNoIHN0YXRpc3RpY3MgZm9yIHJlcG9ydGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBzdGFzaGVzIGZvciBkaWZmZXJlbnQgcGhhc2VzXG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnUGhhc2UgMSBjaGVja3BvaW50JywgJ3BoYXNlMScpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1BoYXNlIDIgY2hlY2twb2ludCcsICdwaGFzZTInKTtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdBbm90aGVyIFBoYXNlIDEgY2hlY2twb2ludCcsICdwaGFzZTEnKTtcblxuICAgICAgY29uc3Qgc3RhdHM6IGFueSA9IHNhZmV0eVByb3RvY29sLmdldFN0YXNoU3RhdGlzdGljcygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMudG90YWwpLnRvQmUoMyk7XG4gICAgICBleHBlY3Qoc3RhdHMuYnlQaGFzZS5waGFzZTEpLnRvQmUoMik7XG4gICAgICBleHBlY3Qoc3RhdHMuYnlQaGFzZS5waGFzZTIpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMub2xkZXN0U3Rhc2gpLnRvQmVJbnN0YW5jZU9mKERhdGUpO1xuICAgICAgZXhwZWN0KHN0YXRzLm5ld2VzdFN0YXNoKS50b0JlSW5zdGFuY2VPZihEYXRlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVncmF0aW9uIHdpdGggQ2FtcGFpZ24gQ29udHJvbGxlcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGludGVncmF0ZSBzYWZldHkgcHJvdG9jb2xzIHdpdGggcGhhc2UgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGhhc2U6IGFueSA9IG1vY2tDb25maWcucGhhc2VzWzBdO1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgZXhlY3V0aW9uIHdpdGggc2FmZXR5IHByb3RvY29sc1xuICAgICAgamVzdC5zcHlPbihjYW1wYWlnbkNvbnRyb2xsZXIgYXMgdW5rbm93biwgJ2NyZWF0ZVNhZmV0eUNoZWNrcG9pbnQnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnY2hlY2twb2ludC0xJyk7XG4gICAgICBqZXN0LnNweU9uKGNhbXBhaWduQ29udHJvbGxlciBhcyB1bmtub3duLCAnZ2V0Q3VycmVudE1ldHJpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHR5cGVTY3JpcHRFcnJvcnM6IHsgY3VycmVudDogMCwgdGFyZ2V0OiAwLCByZWR1Y3Rpb246IDg2LCBwZXJjZW50YWdlOiAxMDAgfSxcbiAgICAgICAgbGludGluZ1dhcm5pbmdzOiB7IGN1cnJlbnQ6IDQ1MDYsIHRhcmdldDogMCwgcmVkdWN0aW9uOiAwLCBwZXJjZW50YWdlOiAwIH0sXG4gICAgICAgIGJ1aWxkUGVyZm9ybWFuY2U6IHsgY3VycmVudFRpbSwgZTogOC41LCB0YXJnZXRUaW1lOiAxMCwgY2FjaGVIaXRSYXRlOiAwLjgsIG1lbW9yeVVzYWdlOiA0NSB9LFxuICAgICAgICBlbnRlcnByaXNlU3lzdGVtczogeyBjdXJyZW50OiAwLCB0YXJnZXQ6IDIwMCwgdHJhbnNmb3JtZWRFeHBvcnRzOiAwIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSBhd2FpdCBjYW1wYWlnbkNvbnRyb2xsZXIuZXhlY3V0ZVBoYXNlKHBoYXNlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zYWZldHlFdmVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoY2FtcGFpZ25Db250cm9sbGVyWydjcmVhdGVTYWZldHlDaGVja3BvaW50J10pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJvbGxiYWNrIHNjZW5hcmlvcyBkdXJpbmcgcGhhc2UgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGhhc2U6IGFueSA9IG1vY2tDb25maWcucGhhc2VzWzBdO1xuXG4gICAgICAvLyBNb2NrIHZhbGlkYXRpb24gZmFpbHVyZSB0aGF0IHRyaWdnZXJzIHJvbGxiYWNrXG4gICAgICBqZXN0LnNweU9uKGNhbXBhaWduQ29udHJvbGxlciBhcyB1bmtub3duLCAndmFsaWRhdGVQaGFzZVByb2dyZXNzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBbJ0NvcnJ1cHRpb24gZGV0ZWN0ZWQnXSxcbiAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICB9KTtcblxuICAgICAgamVzdC5zcHlPbihjYW1wYWlnbkNvbnRyb2xsZXIsICdyb2xsYmFja1RvQ2hlY2twb2ludCcpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChjYW1wYWlnbkNvbnRyb2xsZXIuZXhlY3V0ZVBoYXNlKHBoYXNlKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnVG9vbCBleGVjdXRpb24gZmFpbGVkOiBDb3JydXB0aW9uIGRldGVjdGVkJyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChjYW1wYWlnbkNvbnRyb2xsZXIucm9sbGJhY2tUb0NoZWNrcG9pbnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbGUgU3lzdGVtIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbGUgcmVhZCBlcnJvcnMgZHVyaW5nIGNvcnJ1cHRpb24gZGV0ZWN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Blcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVwb3J0OiBhbnkgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsncHJvdGVjdGVkLWZpbGUudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdwcm90ZWN0ZWQtZmlsZS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucy5zb21lKHAgPT4gcC5wYXR0ZXJuID09PSAnRklMRV9SRUFEX0VSUk9SJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgbm9uLWV4aXN0ZW50IGZpbGVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXBvcnQ6IGFueSA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWydub24tZXhpc3RlbnQudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgZmlsZSB0eXBlcyBhcHByb3ByaWF0ZWx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZXM6IGFueSA9IFsnc2NyaXB0LnRzJywgJ3N0eWxlLmNzcycsICdjb25maWcuanNvbicsICdyZWFkbWUubWQnXTtcblxuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3ZhbGlkIGNvbnRlbnQnKTtcblxuICAgICAgY29uc3QgcmVwb3J0OiBhbnkgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RJbXBvcnRFeHBvcnRDb3JydXB0aW9uKGZpbGVzKTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkgcHJvY2VzcyBUeXBlU2NyaXB0L0phdmFTY3JpcHQgZmlsZXNcbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FmZXR5IEV2ZW50IFRyYWNraW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdHJhY2sgc2FmZXR5IGV2ZW50cyB0aHJvdWdob3V0IGludGVncmF0aW9uIHNjZW5hcmlvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBzdGFzaFxuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKTtcblxuICAgICAgLy8gRGV0ZWN0IGNvcnJ1cHRpb25cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCc8PDw8PDw8IEhFQURcXG5jb25mbGljdFxcbj4+Pj4+Pj4gYnJhbmNoJyk7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsndGVzdC1maWxlLnRzJ10pO1xuXG4gICAgICAvLyBBcHBseSBzdGFzaFxuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCgoYXdhaXQgc2FmZXR5UHJvdG9jb2wubGlzdFN0YXNoZXMoKSlbMF0uaWQpO1xuXG4gICAgICBjb25zdCBldmVudHM6IGFueSA9IHNhZmV0eVByb3RvY29sLmdldFNhZmV0eUV2ZW50cygpO1xuXG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09IFNhZmV0eUV2ZW50VHlwZS5DSEVDS1BPSU5UX0NSRUFURUQpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGV2ZW50cy5zb21lKGUgPT4gZS50eXBlID09PSBTYWZldHlFdmVudFR5cGUuQ09SUlVQVElPTl9ERVRFQ1RFRCkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09IFNhZmV0eUV2ZW50VHlwZS5ST0xMQkFDS19UUklHR0VSRUQpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBldmVudCBoaXN0b3J5IHdpdGggcHJvcGVyIHNldmVyaXR5IGxldmVscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEdlbmVyYXRlIGV2ZW50cyBvZiBkaWZmZXJlbnQgc2V2ZXJpdGllc1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ0luZm8gZXZlbnQnKTsgLy8gSU5GT1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnPDw8PDw8PCBIRUFEXFxuY29uZmxpY3RcXG4+Pj4+Pj4+IGJyYW5jaCcpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ3Rlc3QtZmlsZS50cyddKTsgLy8gQ1JJVElDQUxcblxuICAgICAgY29uc3QgZXZlbnRzOiBhbnkgPSBzYWZldHlQcm90b2NvbC5nZXRTYWZldHlFdmVudHMoKTtcbiAgICAgIGNvbnN0IHNldmVyaXRpZXM6IGFueSA9IGV2ZW50cy5tYXAoZSA9PiBlLnNldmVyaXR5KTtcblxuICAgICAgZXhwZWN0KHNldmVyaXRpZXMpLnRvQ29udGFpbihTYWZldHlFdmVudFNldmVyaXR5LklORk8pO1xuICAgICAgZXhwZWN0KHNldmVyaXRpZXMpLnRvQ29udGFpbihTYWZldHlFdmVudFNldmVyaXR5LkNSSVRJQ0FMKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==