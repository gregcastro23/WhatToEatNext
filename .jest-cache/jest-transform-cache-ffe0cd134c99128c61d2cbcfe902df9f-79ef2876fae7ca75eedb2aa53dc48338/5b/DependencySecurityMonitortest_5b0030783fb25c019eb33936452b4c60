3ae3ead99b9887248afc1c098d660c03
"use strict";
/**
 * Dependency Security Monitor Tests
 * Comprehensive test suite for dependency and security monitoring functionality
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('fs');
jest.mock('child_process');
jest.mock('../../utils/logger');
const DependencySecurityMonitor_1 = require("./DependencySecurityMonitor");
const fs = __importStar(require("fs"));
const child_process_1 = require("child_process");
const mockFs = fs;
const mockExecSync = child_process_1.execSync;
describe('DependencySecurityMonitor', () => {
    let dependencyMonitor;
    let testConfig;
    beforeEach(() => {
        testConfig = {
            ...DependencySecurityMonitor_1.DEFAULT_DEPENDENCY_SECURITY_CONFIG,
            maxDependenciesPerBatch: 5,
            safetyValidationEnabled: true
        };
        dependencyMonitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(testConfig);
        // Reset mocks
        jest.clearAllMocks();
    });
    describe('scanSecurityVulnerabilities', () => {
        test('detects and categorizes security vulnerabilities', async () => {
            const auditOutput = JSON.stringify({
                vulnerabilities: {
                    'lodash': {
                        severity: 'high',
                        via: [{
                                source: 'CVE-2021-23337',
                                title: 'Command Injection in lodash',
                                range: '>=1.0.0 <4.17.21'
                            }],
                        range: '>=1.0.0 <4.17.21',
                        fixAvailable: {
                            version: '4.17.21'
                        }
                    },
                    'axios': {
                        severity: 'critical',
                        via: [{
                                source: 'CVE-2021-3749',
                                title: 'Regular Expression Denial of Service in axios',
                                range: '>=0.8.1 <0.21.2'
                            }],
                        range: '>=0.8.1 <0.21.2',
                        fixAvailable: {
                            version: '0.21.2'
                        }
                    }
                }
            });
            mockExecSync.mockReturnValue(auditOutput);
            const securityReport = await dependencyMonitor.scanSecurityVulnerabilities();
            expect(securityReport.vulnerabilities).toHaveLength(2);
            expect(securityReport.summary.critical).toBe(1);
            expect(securityReport.summary.high).toBe(1);
            expect(securityReport.summary.total).toBe(2);
            const lodashVuln = securityReport.vulnerabilities.find(v => v.packageName === 'lodash');
            expect(lodashVuln).toBeDefined();
            expect(lodashVuln === null || lodashVuln === void 0 ? void 0 : lodashVuln.severity).toBe('high');
            expect(lodashVuln === null || lodashVuln === void 0 ? void 0 : lodashVuln.patchAvailable).toBe(true);
            expect(lodashVuln === null || lodashVuln === void 0 ? void 0 : lodashVuln.fixedVersion).toBe('4.17.21');
        });
        test('handles npm audit errors gracefully', async () => {
            mockExecSync.mockImplementation(() => {
                throw new Error('npm audit failed');
            });
            const securityReport = await dependencyMonitor.scanSecurityVulnerabilities();
            expect(securityReport.vulnerabilities).toHaveLength(0);
            expect(securityReport.summary.total).toBe(0);
            expect(securityReport.recommendations).toContain('Failed to scan for vulnerabilities. Please run npm audit manually.');
        });
        test('generates appropriate security recommendations', async () => {
            const auditOutput = JSON.stringify({
                vulnerabilities: {
                    'test-package': {
                        severity: 'critical',
                        via: [{ source: 'CVE-2021-0001', title: 'Test vulnerability' }],
                        fixAvailable: { version: '2.0.0' }
                    }
                }
            });
            mockExecSync.mockReturnValue(auditOutput);
            const securityReport = await dependencyMonitor.scanSecurityVulnerabilities();
            expect(securityReport.recommendations).toContain(expect.stringContaining('1 critical vulnerabilities found - immediate action required'));
            expect(securityReport.recommendations).toContain(expect.stringContaining('1 vulnerabilities have patches available'));
        });
    });
    describe('checkDependencyUpdates', () => {
        test('detects available dependency updates', async () => {
            const outdatedOutput = JSON.stringify({
                'lodash': {
                    current: '4.17.20',
                    wanted: '4.17.21',
                    latest: '4.17.21',
                    location: 'node_modules/lodash'
                },
                'react': {
                    current: '17.0.0',
                    wanted: '17.0.2',
                    latest: '18.0.0',
                    location: 'node_modules/react'
                }
            });
            const error = new Error('npm outdated found updates');
            error.stdout = outdatedOutput;
            mockExecSync.mockImplementation(() => {
                throw error;
            });
            const updateReport = await dependencyMonitor.checkDependencyUpdates();
            expect(updateReport.availableUpdates).toHaveLength(2);
            expect(updateReport.summary.total).toBe(2);
            const lodashUpdate = updateReport.availableUpdates.find(u => u.packageName === 'lodash');
            expect(lodashUpdate).toBeDefined();
            expect(lodashUpdate === null || lodashUpdate === void 0 ? void 0 : lodashUpdate.updateType).toBe('patch');
            expect(lodashUpdate === null || lodashUpdate === void 0 ? void 0 : lodashUpdate.breakingChanges).toBe(false);
            const reactUpdate = updateReport.availableUpdates.find(u => u.packageName === 'react');
            expect(reactUpdate).toBeDefined();
            expect(reactUpdate === null || reactUpdate === void 0 ? void 0 : reactUpdate.updateType).toBe('major');
            expect(reactUpdate === null || reactUpdate === void 0 ? void 0 : reactUpdate.breakingChanges).toBe(true);
        });
        test('handles no updates available', async () => {
            mockExecSync.mockReturnValue('{}');
            const updateReport = await dependencyMonitor.checkDependencyUpdates();
            expect(updateReport.availableUpdates).toHaveLength(0);
            expect(updateReport.summary.total).toBe(0);
        });
    });
    describe('applySecurityPatches', () => {
        test('applies security patches for critical vulnerabilities', async () => {
            const config = {
                ...testConfig,
                autoUpdateEnabled: true,
                securityThresholds: {
                    ...testConfig.securityThresholds,
                    autoFixCritical: true
                }
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(config);
            const vulnerabilities = [
                {
                    packageName: 'lodash',
                    currentVersion: '4.17.20',
                    vulnerableVersions: '>=1.0.0 <4.17.21',
                    severity: 'critical',
                    cve: 'CVE-2021-23337',
                    description: 'Command Injection',
                    fixedVersion: '4.17.21',
                    patchAvailable: true
                }
            ];
            mockExecSync.mockReturnValue('');
            const appliedUpdates = await monitor.applySecurityPatches(vulnerabilities);
            expect(appliedUpdates).toHaveLength(1);
            expect(appliedUpdates[0].packageName).toBe('lodash');
            expect(appliedUpdates[0].securityFix).toBe(true);
            expect(mockExecSync).toHaveBeenCalledWith('npm install lodash@4.17.21', expect.any(Object));
        });
        test('skips excluded packages', async () => {
            const config = {
                ...testConfig,
                autoUpdateEnabled: true,
                excludedPackages: ['lodash'],
                securityThresholds: {
                    ...testConfig.securityThresholds,
                    autoFixCritical: true
                }
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(config);
            const vulnerabilities = [
                {
                    packageName: 'lodash',
                    currentVersion: '4.17.20',
                    vulnerableVersions: '>=1.0.0 <4.17.21',
                    severity: 'critical',
                    cve: 'CVE-2021-23337',
                    description: 'Command Injection',
                    fixedVersion: '4.17.21',
                    patchAvailable: true
                }
            ];
            const appliedUpdates = await monitor.applySecurityPatches(vulnerabilities);
            expect(appliedUpdates).toHaveLength(0);
            expect(mockExecSync).not.toHaveBeenCalled();
        });
        test('respects security threshold settings', async () => {
            const config = {
                ...testConfig,
                autoUpdateEnabled: true,
                securityThresholds: {
                    ...testConfig.securityThresholds,
                    autoFixCritical: false,
                    autoFixHigh: false
                }
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(config);
            const vulnerabilities = [
                {
                    packageName: 'lodash',
                    currentVersion: '4.17.20',
                    vulnerableVersions: '>=1.0.0 <4.17.21',
                    severity: 'high',
                    cve: 'CVE-2021-23337',
                    description: 'Command Injection',
                    fixedVersion: '4.17.21',
                    patchAvailable: true
                }
            ];
            const appliedUpdates = await monitor.applySecurityPatches(vulnerabilities);
            expect(appliedUpdates).toHaveLength(0);
        });
    });
    describe('applySafeUpdates', () => {
        test('applies safe patch updates', async () => {
            const config = {
                ...testConfig,
                autoUpdateEnabled: true
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(config);
            const availableUpdates = [
                {
                    packageName: 'lodash',
                    currentVersion: '4.17.20',
                    latestVersion: '4.17.21',
                    updateType: 'patch',
                    breakingChanges: false,
                    securityFix: false,
                    testingRequired: false
                }
            ];
            mockExecSync.mockReturnValue('');
            const appliedUpdates = await monitor.applySafeUpdates(availableUpdates);
            expect(appliedUpdates).toHaveLength(1);
            expect(mockExecSync).toHaveBeenCalledWith('npm install lodash@4.17.21', expect.any(Object));
        });
        test('skips major updates requiring manual approval', async () => {
            const config = {
                ...testConfig,
                autoUpdateEnabled: true,
                updateStrategies: [
                    {
                        name: 'Default',
                        description: 'Default strategy',
                        pattern: /.*/,
                        updateType: 'minor',
                        requiresManualApproval: true,
                        testingRequired: false
                    }
                ]
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(config);
            const availableUpdates = [
                {
                    packageName: 'react',
                    currentVersion: '17.0.0',
                    latestVersion: '18.0.0',
                    updateType: 'major',
                    breakingChanges: true,
                    securityFix: false,
                    testingRequired: true
                }
            ];
            const appliedUpdates = await monitor.applySafeUpdates(availableUpdates);
            expect(appliedUpdates).toHaveLength(0);
            expect(mockExecSync).not.toHaveBeenCalledWith(expect.stringContaining('npm install react@18.0.0'), expect.any(Object));
        });
    });
    describe('runCompatibilityTests', () => {
        test('runs build and test commands successfully', async () => {
            mockExecSync.mockReturnValue('');
            const result = await dependencyMonitor.runCompatibilityTests();
            expect(result).toBe(true);
            expect(mockExecSync).toHaveBeenCalledWith('npm run build', expect.any(Object));
            expect(mockExecSync).toHaveBeenCalledWith('npm test', expect.any(Object));
        });
        test('returns false when tests fail', async () => {
            mockExecSync
                .mockReturnValueOnce('') // Build succeeds
                .mockImplementationOnce(() => {
                throw new Error('Tests failed');
            });
            const result = await dependencyMonitor.runCompatibilityTests();
            expect(result).toBe(false);
        });
        test('returns false when build fails', async () => {
            mockExecSync.mockImplementation(() => {
                throw new Error('Build failed');
            });
            const result = await dependencyMonitor.runCompatibilityTests();
            expect(result).toBe(false);
        });
    });
    describe('executeDependencySecurityMonitoring', () => {
        test('executes complete monitoring workflow', async () => {
            const packageJson = {
                dependencies: { lodash: '4.17.20' },
                devDependencies: { jest: '29.0.0' }
            };
            mockFs.readFileSync.mockReturnValue(JSON.stringify(packageJson));
            // Mock npm audit (no vulnerabilities)
            mockExecSync.mockReturnValueOnce(JSON.stringify({ vulnerabilities: {} }));
            // Mock npm outdated (no updates)
            mockExecSync.mockReturnValueOnce('{}');
            const result = await dependencyMonitor.executeDependencySecurityMonitoring();
            expect(result.dependenciesScanned).toBe(2);
            expect(result.vulnerabilitiesFound).toBe(0);
            expect(result.updatesAvailable).toBe(0);
            expect(result.errors).toHaveLength(0);
        });
        test('handles security scan and update workflow', async () => {
            const config = {
                ...testConfig,
                autoUpdateEnabled: true,
                securityThresholds: {
                    ...testConfig.securityThresholds,
                    autoFixCritical: true
                }
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(config);
            const packageJson = {
                dependencies: { lodash: '4.17.20' }
            };
            mockFs.readFileSync.mockReturnValue(JSON.stringify(packageJson));
            // Mock npm audit with vulnerability
            const auditOutput = JSON.stringify({
                vulnerabilities: {
                    'lodash': {
                        severity: 'critical',
                        via: [{ source: 'CVE-2021-23337', title: 'Test vuln' }],
                        fixAvailable: { version: '4.17.21' }
                    }
                }
            });
            mockExecSync.mockReturnValueOnce(auditOutput);
            // Mock npm outdated
            const outdatedError = new Error('Updates available');
            outdatedError.stdout = JSON.stringify({
                'lodash': {
                    current: '4.17.20',
                    latest: '4.17.21'
                }
            });
            mockExecSync.mockImplementationOnce(() => { throw outdatedError; });
            // Mock security patch application
            mockExecSync.mockReturnValueOnce(''); // npm install for security patch
            // Mock compatibility tests
            mockExecSync.mockReturnValueOnce(''); // npm run build
            mockExecSync.mockReturnValueOnce(''); // npm test
            const result = await monitor.executeDependencySecurityMonitoring();
            expect(result.vulnerabilitiesFound).toBe(1);
            expect(result.updatesAvailable).toBe(1);
            expect(result.securityPatchesApplied).toBe(1);
            expect(result.compatibilityTestsPassed).toBe(true);
        });
        test('handles errors gracefully', async () => {
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('Package.json not found');
            });
            const result = await dependencyMonitor.executeDependencySecurityMonitoring();
            expect(result.dependenciesScanned).toBe(0);
            expect(result.errors.length).toBeGreaterThan(0);
        });
    });
    describe('update type determination', () => {
        test('correctly identifies major updates', () => {
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(testConfig);
            // Access private method through any cast for testing
            const determineUpdateType = monitor.determineUpdateType;
            expect(determineUpdateType('1.0.0', '2.0.0')).toBe('major');
            expect(determineUpdateType('17.0.0', '18.0.0')).toBe('major');
        });
        test('correctly identifies minor updates', () => {
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(testConfig);
            const determineUpdateType = monitor.determineUpdateType;
            expect(determineUpdateType('1.0.0', '1.1.0')).toBe('minor');
            expect(determineUpdateType('17.0.0', '17.1.0')).toBe('minor');
        });
        test('correctly identifies patch updates', () => {
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(testConfig);
            const determineUpdateType = monitor.determineUpdateType;
            expect(determineUpdateType('1.0.0', '1.0.1')).toBe('patch');
            expect(determineUpdateType('17.0.0', '17.0.1')).toBe('patch');
        });
    });
    describe('configuration validation', () => {
        test('uses default configuration when not provided', () => {
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(DependencySecurityMonitor_1.DEFAULT_DEPENDENCY_SECURITY_CONFIG);
            expect(monitor).toBeDefined();
        });
        test('respects custom configuration', () => {
            const customConfig = {
                maxDependenciesPerBatch: 5,
                safetyValidationEnabled: false,
                autoUpdateEnabled: true,
                securityScanEnabled: false,
                compatibilityTestingEnabled: false,
                updateStrategies: [],
                securityThresholds: {
                    critical: 0,
                    high: 0,
                    moderate: 0,
                    low: 0,
                    autoFixCritical: false,
                    autoFixHigh: false
                },
                excludedPackages: ['react', 'next']
            };
            const monitor = new DependencySecurityMonitor_1.DependencySecurityMonitor(customConfig);
            expect(monitor).toBeDefined();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9EZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1ILG9CQUFvQjtBQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBUGhDLDJFQUFzSTtBQUN0SSx1Q0FBeUI7QUFDekIsaURBQXlDO0FBT3pDLE1BQU0sTUFBTSxHQUFHLEVBQTRCLENBQUM7QUFDNUMsTUFBTSxZQUFZLEdBQUcsd0JBQWdELENBQUM7QUFFdEUsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtJQUN6QyxJQUFJLGlCQUE0QyxDQUFDO0lBQ2pELElBQUksVUFBb0MsQ0FBQztJQUV6QyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsVUFBVSxHQUFHO1lBQ1gsR0FBRyw4REFBa0M7WUFDckMsdUJBQXVCLEVBQUUsQ0FBQztZQUMxQix1QkFBdUIsRUFBRSxJQUFJO1NBQzlCLENBQUM7UUFDRixpQkFBaUIsR0FBRyxJQUFJLHFEQUF5QixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTlELGNBQWM7UUFDZCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsNkJBQTZCLEVBQUUsR0FBRyxFQUFFO1FBQzNDLElBQUksQ0FBQyxrREFBa0QsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNsRSxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUNqQyxlQUFlLEVBQUU7b0JBQ2YsUUFBUSxFQUFFO3dCQUNSLFFBQVEsRUFBRSxNQUFNO3dCQUNoQixHQUFHLEVBQUUsQ0FB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LEVBQUUsR0FBRyxFQUFFO1lBQ3hELE1BQU0sT0FBTyxHQUFHLElBQUkscURBQXlCLENBQUMsOERBQWtDLENBQUMsQ0FBQztZQUNsRixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsK0JBQStCLEVBQUUsR0FBRyxFQUFFO1lBQ3pDLE1BQU0sWUFBWSxHQUE2QjtnQkFDN0MsdUJBQXVCLEVBQUUsQ0FBQztnQkFDMUIsdUJBQXVCLEVBQUUsS0FBSztnQkFDOUIsaUJBQWlCLEVBQUUsSUFBSTtnQkFDdkIsbUJBQW1CLEVBQUUsS0FBSztnQkFDMUIsMkJBQTJCLEVBQUUsS0FBSztnQkFDbEMsZ0JBQWdCLEVBQUUsRUFBRTtnQkFDcEIsa0JBQWtCLEVBQUU7b0JBQ2xCLFFBQVEsRUFBRSxDQUFDO29CQUNYLElBQUksRUFBRSxDQUFDO29CQUNQLFFBQVEsRUFBRSxDQUFDO29CQUNYLEdBQUcsRUFBRSxDQUFDO29CQUNOLGVBQWUsRUFBRSxLQUFLO29CQUN0QixXQUFXLEVBQUUsS0FBSztpQkFDbkI7Z0JBQ0QsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDO2FBQ3BDLENBQUM7WUFFRixNQUFNLE9BQU8sR0FBRyxJQUFJLHFEQUF5QixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzVELE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNoQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9EZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXBlbmRlbmN5IFNlY3VyaXR5IE1vbml0b3IgVGVzdHNcbiAqIENvbXByZWhlbnNpdmUgdGVzdCBzdWl0ZSBmb3IgZGVwZW5kZW5jeSBhbmQgc2VjdXJpdHkgbW9uaXRvcmluZyBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IHsgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvciwgREVGQVVMVF9ERVBFTkRFTkNZX1NFQ1VSSVRZX0NPTkZJRywgRGVwZW5kZW5jeVNlY3VyaXR5Q29uZmlnIH0gZnJvbSAnLi9EZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ2ZzJyk7XG5qZXN0Lm1vY2soJ2NoaWxkX3Byb2Nlc3MnKTtcbmplc3QubW9jaygnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5cbmNvbnN0IG1vY2tGcyA9IGZzIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBmcz47XG5jb25zdCBtb2NrRXhlY1N5bmMgPSBleGVjU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBleGVjU3luYz47XG5cbmRlc2NyaWJlKCdEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yJywgKCkgPT4ge1xuICBsZXQgZGVwZW5kZW5jeU1vbml0b3I6IERlcGVuZGVuY3lTZWN1cml0eU1vbml0b3I7XG4gIGxldCB0ZXN0Q29uZmlnOiBEZXBlbmRlbmN5U2VjdXJpdHlDb25maWc7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdGVzdENvbmZpZyA9IHtcbiAgICAgIC4uLkRFRkFVTFRfREVQRU5ERU5DWV9TRUNVUklUWV9DT05GSUcsXG4gICAgICBtYXhEZXBlbmRlbmNpZXNQZXJCYXRjaDogNSxcbiAgICAgIHNhZmV0eVZhbGlkYXRpb25FbmFibGVkOiB0cnVlXG4gICAgfTtcbiAgICBkZXBlbmRlbmN5TW9uaXRvciA9IG5ldyBEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yKHRlc3RDb25maWcpO1xuICAgIFxuICAgIC8vIFJlc2V0IG1vY2tzXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzY2FuU2VjdXJpdHlWdWxuZXJhYmlsaXRpZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnZGV0ZWN0cyBhbmQgY2F0ZWdvcml6ZXMgc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXVkaXRPdXRwdXQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZ1bG5lcmFiaWxpdGllczoge1xuICAgICAgICAgICdsb2Rhc2gnOiB7XG4gICAgICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICAgICAgdmlhOiBbe1xuICAgICAgICAgICAgICBzb3VyY2U6ICdDVkUtMjAyMS0yMzMzNycsXG4gICAgICAgICAgICAgIHRpdGxlOiAnQ29tbWFuZCBJbmplY3Rpb24gaW4gbG9kYXNoJyxcbiAgICAgICAgICAgICAgcmFuZ2U6ICc+PTEuMC4wIDw0LjE3LjIxJ1xuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICByYW5nZTogJz49MS4wLjAgPDQuMTcuMjEnLFxuICAgICAgICAgICAgZml4QXZhaWxhYmxlOiB7XG4gICAgICAgICAgICAgIHZlcnNpb246ICc0LjE3LjIxJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2F4aW9zJzoge1xuICAgICAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgICAgICB2aWE6IFt7XG4gICAgICAgICAgICAgIHNvdXJjZTogJ0NWRS0yMDIxLTM3NDknLFxuICAgICAgICAgICAgICB0aXRsZTogJ1JlZ3VsYXIgRXhwcmVzc2lvbiBEZW5pYWwgb2YgU2VydmljZSBpbiBheGlvcycsXG4gICAgICAgICAgICAgIHJhbmdlOiAnPj0wLjguMSA8MC4yMS4yJ1xuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICByYW5nZTogJz49MC44LjEgPDAuMjEuMicsXG4gICAgICAgICAgICBmaXhBdmFpbGFibGU6IHtcbiAgICAgICAgICAgICAgdmVyc2lvbjogJzAuMjEuMidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKGF1ZGl0T3V0cHV0KTtcblxuICAgICAgY29uc3Qgc2VjdXJpdHlSZXBvcnQgPSBhd2FpdCBkZXBlbmRlbmN5TW9uaXRvci5zY2FuU2VjdXJpdHlWdWxuZXJhYmlsaXRpZXMoKTtcblxuICAgICAgZXhwZWN0KHNlY3VyaXR5UmVwb3J0LnZ1bG5lcmFiaWxpdGllcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHNlY3VyaXR5UmVwb3J0LnN1bW1hcnkuY3JpdGljYWwpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc2VjdXJpdHlSZXBvcnQuc3VtbWFyeS5oaWdoKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHNlY3VyaXR5UmVwb3J0LnN1bW1hcnkudG90YWwpLnRvQmUoMik7XG4gICAgICBcbiAgICAgIGNvbnN0IGxvZGFzaFZ1bG4gPSBzZWN1cml0eVJlcG9ydC52dWxuZXJhYmlsaXRpZXMuZmluZCh2ID0+IHYucGFja2FnZU5hbWUgPT09ICdsb2Rhc2gnKTtcbiAgICAgIGV4cGVjdChsb2Rhc2hWdWxuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZGFzaFZ1bG4/LnNldmVyaXR5KS50b0JlKCdoaWdoJyk7XG4gICAgICBleHBlY3QobG9kYXNoVnVsbj8ucGF0Y2hBdmFpbGFibGUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobG9kYXNoVnVsbj8uZml4ZWRWZXJzaW9uKS50b0JlKCc0LjE3LjIxJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIG5wbSBhdWRpdCBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25wbSBhdWRpdCBmYWlsZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZWN1cml0eVJlcG9ydCA9IGF3YWl0IGRlcGVuZGVuY3lNb25pdG9yLnNjYW5TZWN1cml0eVZ1bG5lcmFiaWxpdGllcygpO1xuXG4gICAgICBleHBlY3Qoc2VjdXJpdHlSZXBvcnQudnVsbmVyYWJpbGl0aWVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3Qoc2VjdXJpdHlSZXBvcnQuc3VtbWFyeS50b3RhbCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzZWN1cml0eVJlcG9ydC5yZWNvbW1lbmRhdGlvbnMpLnRvQ29udGFpbignRmFpbGVkIHRvIHNjYW4gZm9yIHZ1bG5lcmFiaWxpdGllcy4gUGxlYXNlIHJ1biBucG0gYXVkaXQgbWFudWFsbHkuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdnZW5lcmF0ZXMgYXBwcm9wcmlhdGUgc2VjdXJpdHkgcmVjb21tZW5kYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXVkaXRPdXRwdXQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZ1bG5lcmFiaWxpdGllczoge1xuICAgICAgICAgICd0ZXN0LXBhY2thZ2UnOiB7XG4gICAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgIHZpYTogW3sgc291cmNlOiAnQ1ZFLTIwMjEtMDAwMScsIHRpdGxlOiAnVGVzdCB2dWxuZXJhYmlsaXR5JyB9XSxcbiAgICAgICAgICAgIGZpeEF2YWlsYWJsZTogeyB2ZXJzaW9uOiAnMi4wLjAnIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKGF1ZGl0T3V0cHV0KTtcblxuICAgICAgY29uc3Qgc2VjdXJpdHlSZXBvcnQgPSBhd2FpdCBkZXBlbmRlbmN5TW9uaXRvci5zY2FuU2VjdXJpdHlWdWxuZXJhYmlsaXRpZXMoKTtcblxuICAgICAgZXhwZWN0KHNlY3VyaXR5UmVwb3J0LnJlY29tbWVuZGF0aW9ucykudG9Db250YWluKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnMSBjcml0aWNhbCB2dWxuZXJhYmlsaXRpZXMgZm91bmQgLSBpbW1lZGlhdGUgYWN0aW9uIHJlcXVpcmVkJylcbiAgICAgICk7XG4gICAgICBleHBlY3Qoc2VjdXJpdHlSZXBvcnQucmVjb21tZW5kYXRpb25zKS50b0NvbnRhaW4oXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCcxIHZ1bG5lcmFiaWxpdGllcyBoYXZlIHBhdGNoZXMgYXZhaWxhYmxlJylcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjaGVja0RlcGVuZGVuY3lVcGRhdGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RldGVjdHMgYXZhaWxhYmxlIGRlcGVuZGVuY3kgdXBkYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG91dGRhdGVkT3V0cHV0ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAnbG9kYXNoJzoge1xuICAgICAgICAgIGN1cnJlbnQ6ICc0LjE3LjIwJyxcbiAgICAgICAgICB3YW50ZWQ6ICc0LjE3LjIxJyxcbiAgICAgICAgICBsYXRlc3Q6ICc0LjE3LjIxJyxcbiAgICAgICAgICBsb2NhdGlvbjogJ25vZGVfbW9kdWxlcy9sb2Rhc2gnXG4gICAgICAgIH0sXG4gICAgICAgICdyZWFjdCc6IHtcbiAgICAgICAgICBjdXJyZW50OiAnMTcuMC4wJyxcbiAgICAgICAgICB3YW50ZWQ6ICcxNy4wLjInLFxuICAgICAgICAgIGxhdGVzdDogJzE4LjAuMCcsXG4gICAgICAgICAgbG9jYXRpb246ICdub2RlX21vZHVsZXMvcmVhY3QnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignbnBtIG91dGRhdGVkIGZvdW5kIHVwZGF0ZXMnKSBhcyBhbnk7XG4gICAgICBlcnJvci5zdGRvdXQgPSBvdXRkYXRlZE91dHB1dDtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVSZXBvcnQgPSBhd2FpdCBkZXBlbmRlbmN5TW9uaXRvci5jaGVja0RlcGVuZGVuY3lVcGRhdGVzKCk7XG5cbiAgICAgIGV4cGVjdCh1cGRhdGVSZXBvcnQuYXZhaWxhYmxlVXBkYXRlcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHVwZGF0ZVJlcG9ydC5zdW1tYXJ5LnRvdGFsKS50b0JlKDIpO1xuICAgICAgXG4gICAgICBjb25zdCBsb2Rhc2hVcGRhdGUgPSB1cGRhdGVSZXBvcnQuYXZhaWxhYmxlVXBkYXRlcy5maW5kKHUgPT4gdS5wYWNrYWdlTmFtZSA9PT0gJ2xvZGFzaCcpO1xuICAgICAgZXhwZWN0KGxvZGFzaFVwZGF0ZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChsb2Rhc2hVcGRhdGU/LnVwZGF0ZVR5cGUpLnRvQmUoJ3BhdGNoJyk7XG4gICAgICBleHBlY3QobG9kYXNoVXBkYXRlPy5icmVha2luZ0NoYW5nZXMpLnRvQmUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZWFjdFVwZGF0ZSA9IHVwZGF0ZVJlcG9ydC5hdmFpbGFibGVVcGRhdGVzLmZpbmQodSA9PiB1LnBhY2thZ2VOYW1lID09PSAncmVhY3QnKTtcbiAgICAgIGV4cGVjdChyZWFjdFVwZGF0ZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZWFjdFVwZGF0ZT8udXBkYXRlVHlwZSkudG9CZSgnbWFqb3InKTtcbiAgICAgIGV4cGVjdChyZWFjdFVwZGF0ZT8uYnJlYWtpbmdDaGFuZ2VzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBubyB1cGRhdGVzIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3t9Jyk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZVJlcG9ydCA9IGF3YWl0IGRlcGVuZGVuY3lNb25pdG9yLmNoZWNrRGVwZW5kZW5jeVVwZGF0ZXMoKTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZVJlcG9ydC5hdmFpbGFibGVVcGRhdGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QodXBkYXRlUmVwb3J0LnN1bW1hcnkudG90YWwpLnRvQmUoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhcHBseVNlY3VyaXR5UGF0Y2hlcycsICgpID0+IHtcbiAgICB0ZXN0KCdhcHBsaWVzIHNlY3VyaXR5IHBhdGNoZXMgZm9yIGNyaXRpY2FsIHZ1bG5lcmFiaWxpdGllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgLi4udGVzdENvbmZpZyxcbiAgICAgICAgYXV0b1VwZGF0ZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNlY3VyaXR5VGhyZXNob2xkczoge1xuICAgICAgICAgIC4uLnRlc3RDb25maWcuc2VjdXJpdHlUaHJlc2hvbGRzLFxuICAgICAgICAgIGF1dG9GaXhDcml0aWNhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbW9uaXRvciA9IG5ldyBEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yKGNvbmZpZyk7XG5cbiAgICAgIGNvbnN0IHZ1bG5lcmFiaWxpdGllcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhY2thZ2VOYW1lOiAnbG9kYXNoJyxcbiAgICAgICAgICBjdXJyZW50VmVyc2lvbjogJzQuMTcuMjAnLFxuICAgICAgICAgIHZ1bG5lcmFibGVWZXJzaW9uczogJz49MS4wLjAgPDQuMTcuMjEnLFxuICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnIGFzIGNvbnN0LFxuICAgICAgICAgIGN2ZTogJ0NWRS0yMDIxLTIzMzM3JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbW1hbmQgSW5qZWN0aW9uJyxcbiAgICAgICAgICBmaXhlZFZlcnNpb246ICc0LjE3LjIxJyxcbiAgICAgICAgICBwYXRjaEF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgYXBwbGllZFVwZGF0ZXMgPSBhd2FpdCBtb25pdG9yLmFwcGx5U2VjdXJpdHlQYXRjaGVzKHZ1bG5lcmFiaWxpdGllcyk7XG5cbiAgICAgIGV4cGVjdChhcHBsaWVkVXBkYXRlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGFwcGxpZWRVcGRhdGVzWzBdLnBhY2thZ2VOYW1lKS50b0JlKCdsb2Rhc2gnKTtcbiAgICAgIGV4cGVjdChhcHBsaWVkVXBkYXRlc1swXS5zZWN1cml0eUZpeCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnbnBtIGluc3RhbGwgbG9kYXNoQDQuMTcuMjEnLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdza2lwcyBleGNsdWRlZCBwYWNrYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgLi4udGVzdENvbmZpZyxcbiAgICAgICAgYXV0b1VwZGF0ZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGV4Y2x1ZGVkUGFja2FnZXM6IFsnbG9kYXNoJ10sXG4gICAgICAgIHNlY3VyaXR5VGhyZXNob2xkczoge1xuICAgICAgICAgIC4uLnRlc3RDb25maWcuc2VjdXJpdHlUaHJlc2hvbGRzLFxuICAgICAgICAgIGF1dG9GaXhDcml0aWNhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbW9uaXRvciA9IG5ldyBEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yKGNvbmZpZyk7XG5cbiAgICAgIGNvbnN0IHZ1bG5lcmFiaWxpdGllcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhY2thZ2VOYW1lOiAnbG9kYXNoJyxcbiAgICAgICAgICBjdXJyZW50VmVyc2lvbjogJzQuMTcuMjAnLFxuICAgICAgICAgIHZ1bG5lcmFibGVWZXJzaW9uczogJz49MS4wLjAgPDQuMTcuMjEnLFxuICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnIGFzIGNvbnN0LFxuICAgICAgICAgIGN2ZTogJ0NWRS0yMDIxLTIzMzM3JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbW1hbmQgSW5qZWN0aW9uJyxcbiAgICAgICAgICBmaXhlZFZlcnNpb246ICc0LjE3LjIxJyxcbiAgICAgICAgICBwYXRjaEF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBhcHBsaWVkVXBkYXRlcyA9IGF3YWl0IG1vbml0b3IuYXBwbHlTZWN1cml0eVBhdGNoZXModnVsbmVyYWJpbGl0aWVzKTtcblxuICAgICAgZXhwZWN0KGFwcGxpZWRVcGRhdGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncmVzcGVjdHMgc2VjdXJpdHkgdGhyZXNob2xkIHNldHRpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAuLi50ZXN0Q29uZmlnLFxuICAgICAgICBhdXRvVXBkYXRlRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc2VjdXJpdHlUaHJlc2hvbGRzOiB7XG4gICAgICAgICAgLi4udGVzdENvbmZpZy5zZWN1cml0eVRocmVzaG9sZHMsXG4gICAgICAgICAgYXV0b0ZpeENyaXRpY2FsOiBmYWxzZSxcbiAgICAgICAgICBhdXRvRml4SGlnaDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvcihjb25maWcpO1xuXG4gICAgICBjb25zdCB2dWxuZXJhYmlsaXRpZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBwYWNrYWdlTmFtZTogJ2xvZGFzaCcsXG4gICAgICAgICAgY3VycmVudFZlcnNpb246ICc0LjE3LjIwJyxcbiAgICAgICAgICB2dWxuZXJhYmxlVmVyc2lvbnM6ICc+PTEuMC4wIDw0LjE3LjIxJyxcbiAgICAgICAgICBzZXZlcml0eTogJ2hpZ2gnIGFzIGNvbnN0LFxuICAgICAgICAgIGN2ZTogJ0NWRS0yMDIxLTIzMzM3JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbW1hbmQgSW5qZWN0aW9uJyxcbiAgICAgICAgICBmaXhlZFZlcnNpb246ICc0LjE3LjIxJyxcbiAgICAgICAgICBwYXRjaEF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBhcHBsaWVkVXBkYXRlcyA9IGF3YWl0IG1vbml0b3IuYXBwbHlTZWN1cml0eVBhdGNoZXModnVsbmVyYWJpbGl0aWVzKTtcblxuICAgICAgZXhwZWN0KGFwcGxpZWRVcGRhdGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhcHBseVNhZmVVcGRhdGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2FwcGxpZXMgc2FmZSBwYXRjaCB1cGRhdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAuLi50ZXN0Q29uZmlnLFxuICAgICAgICBhdXRvVXBkYXRlRW5hYmxlZDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvcihjb25maWcpO1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVVcGRhdGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcGFja2FnZU5hbWU6ICdsb2Rhc2gnLFxuICAgICAgICAgIGN1cnJlbnRWZXJzaW9uOiAnNC4xNy4yMCcsXG4gICAgICAgICAgbGF0ZXN0VmVyc2lvbjogJzQuMTcuMjEnLFxuICAgICAgICAgIHVwZGF0ZVR5cGU6ICdwYXRjaCcgYXMgY29uc3QsXG4gICAgICAgICAgYnJlYWtpbmdDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgICBzZWN1cml0eUZpeDogZmFsc2UsXG4gICAgICAgICAgdGVzdGluZ1JlcXVpcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgYXBwbGllZFVwZGF0ZXMgPSBhd2FpdCBtb25pdG9yLmFwcGx5U2FmZVVwZGF0ZXMoYXZhaWxhYmxlVXBkYXRlcyk7XG5cbiAgICAgIGV4cGVjdChhcHBsaWVkVXBkYXRlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICducG0gaW5zdGFsbCBsb2Rhc2hANC4xNy4yMScsXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3NraXBzIG1ham9yIHVwZGF0ZXMgcmVxdWlyaW5nIG1hbnVhbCBhcHByb3ZhbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgLi4udGVzdENvbmZpZyxcbiAgICAgICAgYXV0b1VwZGF0ZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHVwZGF0ZVN0cmF0ZWdpZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRGVmYXVsdCcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0RlZmF1bHQgc3RyYXRlZ3knLFxuICAgICAgICAgICAgcGF0dGVybjogLy4qLyxcbiAgICAgICAgICAgIHVwZGF0ZVR5cGU6ICdtaW5vcicgYXMgY29uc3QsXG4gICAgICAgICAgICByZXF1aXJlc01hbnVhbEFwcHJvdmFsOiB0cnVlLFxuICAgICAgICAgICAgdGVzdGluZ1JlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvcihjb25maWcpO1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVVcGRhdGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcGFja2FnZU5hbWU6ICdyZWFjdCcsXG4gICAgICAgICAgY3VycmVudFZlcnNpb246ICcxNy4wLjAnLFxuICAgICAgICAgIGxhdGVzdFZlcnNpb246ICcxOC4wLjAnLFxuICAgICAgICAgIHVwZGF0ZVR5cGU6ICdtYWpvcicgYXMgY29uc3QsXG4gICAgICAgICAgYnJlYWtpbmdDaGFuZ2VzOiB0cnVlLFxuICAgICAgICAgIHNlY3VyaXR5Rml4OiBmYWxzZSxcbiAgICAgICAgICB0ZXN0aW5nUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgY29uc3QgYXBwbGllZFVwZGF0ZXMgPSBhd2FpdCBtb25pdG9yLmFwcGx5U2FmZVVwZGF0ZXMoYXZhaWxhYmxlVXBkYXRlcyk7XG5cbiAgICAgIGV4cGVjdChhcHBsaWVkVXBkYXRlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykubm90LnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnbnBtIGluc3RhbGwgcmVhY3RAMTguMC4wJyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3J1bkNvbXBhdGliaWxpdHlUZXN0cycsICgpID0+IHtcbiAgICB0ZXN0KCdydW5zIGJ1aWxkIGFuZCB0ZXN0IGNvbW1hbmRzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZXBlbmRlbmN5TW9uaXRvci5ydW5Db21wYXRpYmlsaXR5VGVzdHMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCducG0gcnVuIGJ1aWxkJywgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCducG0gdGVzdCcsIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyZXR1cm5zIGZhbHNlIHdoZW4gdGVzdHMgZmFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luY1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gQnVpbGQgc3VjY2VlZHNcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4geyAvLyBUZXN0IGZhaWxzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0cyBmYWlsZWQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlcGVuZGVuY3lNb25pdG9yLnJ1bkNvbXBhdGliaWxpdHlUZXN0cygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHVybnMgZmFsc2Ugd2hlbiBidWlsZCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1aWxkIGZhaWxlZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlcGVuZGVuY3lNb25pdG9yLnJ1bkNvbXBhdGliaWxpdHlUZXN0cygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2V4ZWN1dGVEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ2V4ZWN1dGVzIGNvbXBsZXRlIG1vbml0b3Jpbmcgd29ya2Zsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IHtcbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7IGxvZGFzaDogJzQuMTcuMjAnIH0sXG4gICAgICAgIGRldkRlcGVuZGVuY2llczogeyBqZXN0OiAnMjkuMC4wJyB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShwYWNrYWdlSnNvbikpO1xuICAgICAgXG4gICAgICAvLyBNb2NrIG5wbSBhdWRpdCAobm8gdnVsbmVyYWJpbGl0aWVzKVxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZU9uY2UoSlNPTi5zdHJpbmdpZnkoeyB2dWxuZXJhYmlsaXRpZXM6IHt9IH0pKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBucG0gb3V0ZGF0ZWQgKG5vIHVwZGF0ZXMpXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlT25jZSgne30nKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVwZW5kZW5jeU1vbml0b3IuZXhlY3V0ZURlcGVuZGVuY3lTZWN1cml0eU1vbml0b3JpbmcoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5kZXBlbmRlbmNpZXNTY2FubmVkKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52dWxuZXJhYmlsaXRpZXNGb3VuZCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXBkYXRlc0F2YWlsYWJsZSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIHNlY3VyaXR5IHNjYW4gYW5kIHVwZGF0ZSB3b3JrZmxvdycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgLi4udGVzdENvbmZpZyxcbiAgICAgICAgYXV0b1VwZGF0ZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNlY3VyaXR5VGhyZXNob2xkczoge1xuICAgICAgICAgIC4uLnRlc3RDb25maWcuc2VjdXJpdHlUaHJlc2hvbGRzLFxuICAgICAgICAgIGF1dG9GaXhDcml0aWNhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbW9uaXRvciA9IG5ldyBEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yKGNvbmZpZyk7XG5cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0ge1xuICAgICAgICBkZXBlbmRlbmNpZXM6IHsgbG9kYXNoOiAnNC4xNy4yMCcgfVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24pKTtcblxuICAgICAgLy8gTW9jayBucG0gYXVkaXQgd2l0aCB2dWxuZXJhYmlsaXR5XG4gICAgICBjb25zdCBhdWRpdE91dHB1dCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdnVsbmVyYWJpbGl0aWVzOiB7XG4gICAgICAgICAgJ2xvZGFzaCc6IHtcbiAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgdmlhOiBbeyBzb3VyY2U6ICdDVkUtMjAyMS0yMzMzNycsIHRpdGxlOiAnVGVzdCB2dWxuJyB9XSxcbiAgICAgICAgICAgIGZpeEF2YWlsYWJsZTogeyB2ZXJzaW9uOiAnNC4xNy4yMScgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlT25jZShhdWRpdE91dHB1dCk7XG5cbiAgICAgIC8vIE1vY2sgbnBtIG91dGRhdGVkXG4gICAgICBjb25zdCBvdXRkYXRlZEVycm9yID0gbmV3IEVycm9yKCdVcGRhdGVzIGF2YWlsYWJsZScpIGFzIGFueTtcbiAgICAgIG91dGRhdGVkRXJyb3Iuc3Rkb3V0ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAnbG9kYXNoJzoge1xuICAgICAgICAgIGN1cnJlbnQ6ICc0LjE3LjIwJyxcbiAgICAgICAgICBsYXRlc3Q6ICc0LjE3LjIxJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHsgdGhyb3cgb3V0ZGF0ZWRFcnJvcjsgfSk7XG5cbiAgICAgIC8vIE1vY2sgc2VjdXJpdHkgcGF0Y2ggYXBwbGljYXRpb25cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKTsgLy8gbnBtIGluc3RhbGwgZm9yIHNlY3VyaXR5IHBhdGNoXG5cbiAgICAgIC8vIE1vY2sgY29tcGF0aWJpbGl0eSB0ZXN0c1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpOyAvLyBucG0gcnVuIGJ1aWxkXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlT25jZSgnJyk7IC8vIG5wbSB0ZXN0XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vbml0b3IuZXhlY3V0ZURlcGVuZGVuY3lTZWN1cml0eU1vbml0b3JpbmcoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52dWxuZXJhYmlsaXRpZXNGb3VuZCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXBkYXRlc0F2YWlsYWJsZSkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2VjdXJpdHlQYXRjaGVzQXBwbGllZCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGF0aWJpbGl0eVRlc3RzUGFzc2VkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrYWdlLmpzb24gbm90IGZvdW5kJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVwZW5kZW5jeU1vbml0b3IuZXhlY3V0ZURlcGVuZGVuY3lTZWN1cml0eU1vbml0b3JpbmcoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5kZXBlbmRlbmNpZXNTY2FubmVkKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd1cGRhdGUgdHlwZSBkZXRlcm1pbmF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ2NvcnJlY3RseSBpZGVudGlmaWVzIG1ham9yIHVwZGF0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb25pdG9yID0gbmV3IERlcGVuZGVuY3lTZWN1cml0eU1vbml0b3IodGVzdENvbmZpZyk7XG4gICAgICBcbiAgICAgIC8vIEFjY2VzcyBwcml2YXRlIG1ldGhvZCB0aHJvdWdoIGFueSBjYXN0IGZvciB0ZXN0aW5nXG4gICAgICBjb25zdCBkZXRlcm1pbmVVcGRhdGVUeXBlID0gKG1vbml0b3IgYXMgYW55KS5kZXRlcm1pbmVVcGRhdGVUeXBlO1xuICAgICAgXG4gICAgICBleHBlY3QoZGV0ZXJtaW5lVXBkYXRlVHlwZSgnMS4wLjAnLCAnMi4wLjAnKSkudG9CZSgnbWFqb3InKTtcbiAgICAgIGV4cGVjdChkZXRlcm1pbmVVcGRhdGVUeXBlKCcxNy4wLjAnLCAnMTguMC4wJykpLnRvQmUoJ21ham9yJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjb3JyZWN0bHkgaWRlbnRpZmllcyBtaW5vciB1cGRhdGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9uaXRvciA9IG5ldyBEZXBlbmRlbmN5U2VjdXJpdHlNb25pdG9yKHRlc3RDb25maWcpO1xuICAgICAgY29uc3QgZGV0ZXJtaW5lVXBkYXRlVHlwZSA9IChtb25pdG9yIGFzIGFueSkuZGV0ZXJtaW5lVXBkYXRlVHlwZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRldGVybWluZVVwZGF0ZVR5cGUoJzEuMC4wJywgJzEuMS4wJykpLnRvQmUoJ21pbm9yJyk7XG4gICAgICBleHBlY3QoZGV0ZXJtaW5lVXBkYXRlVHlwZSgnMTcuMC4wJywgJzE3LjEuMCcpKS50b0JlKCdtaW5vcicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnY29ycmVjdGx5IGlkZW50aWZpZXMgcGF0Y2ggdXBkYXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvcih0ZXN0Q29uZmlnKTtcbiAgICAgIGNvbnN0IGRldGVybWluZVVwZGF0ZVR5cGUgPSAobW9uaXRvciBhcyBhbnkpLmRldGVybWluZVVwZGF0ZVR5cGU7XG4gICAgICBcbiAgICAgIGV4cGVjdChkZXRlcm1pbmVVcGRhdGVUeXBlKCcxLjAuMCcsICcxLjAuMScpKS50b0JlKCdwYXRjaCcpO1xuICAgICAgZXhwZWN0KGRldGVybWluZVVwZGF0ZVR5cGUoJzE3LjAuMCcsICcxNy4wLjEnKSkudG9CZSgncGF0Y2gnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbmZpZ3VyYXRpb24gdmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCd1c2VzIGRlZmF1bHQgY29uZmlndXJhdGlvbiB3aGVuIG5vdCBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvcihERUZBVUxUX0RFUEVOREVOQ1lfU0VDVVJJVFlfQ09ORklHKTtcbiAgICAgIGV4cGVjdChtb25pdG9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncmVzcGVjdHMgY3VzdG9tIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21Db25maWc6IERlcGVuZGVuY3lTZWN1cml0eUNvbmZpZyA9IHtcbiAgICAgICAgbWF4RGVwZW5kZW5jaWVzUGVyQmF0Y2g6IDUsXG4gICAgICAgIHNhZmV0eVZhbGlkYXRpb25FbmFibGVkOiBmYWxzZSxcbiAgICAgICAgYXV0b1VwZGF0ZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNlY3VyaXR5U2NhbkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb21wYXRpYmlsaXR5VGVzdGluZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB1cGRhdGVTdHJhdGVnaWVzOiBbXSxcbiAgICAgICAgc2VjdXJpdHlUaHJlc2hvbGRzOiB7XG4gICAgICAgICAgY3JpdGljYWw6IDAsXG4gICAgICAgICAgaGlnaDogMCxcbiAgICAgICAgICBtb2RlcmF0ZTogMCxcbiAgICAgICAgICBsb3c6IDAsXG4gICAgICAgICAgYXV0b0ZpeENyaXRpY2FsOiBmYWxzZSxcbiAgICAgICAgICBhdXRvRml4SGlnaDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgZXhjbHVkZWRQYWNrYWdlczogWydyZWFjdCcsICduZXh0J11cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgRGVwZW5kZW5jeVNlY3VyaXR5TW9uaXRvcihjdXN0b21Db25maWcpO1xuICAgICAgZXhwZWN0KG1vbml0b3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9