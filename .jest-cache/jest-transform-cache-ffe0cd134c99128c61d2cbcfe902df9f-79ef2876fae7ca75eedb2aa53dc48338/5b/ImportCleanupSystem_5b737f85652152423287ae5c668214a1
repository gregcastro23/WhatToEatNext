81c0a1c25d8952ab3dbfdbc528fac575
"use strict";
/**
 * Import Cleanup System
 * Automated import detection, removal, and organization system
 * Part of the Kiro Optimization Campaign System
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_IMPORT_CLEANUP_CONFIG = exports.ImportCleanupSystem = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const logger_1 = require("../../utils/logger");
class ImportCleanupSystem {
    config;
    processedFiles = new Set();
    constructor(config) {
        this.config = config;
    }
    /**
     * Execute comprehensive import cleanup
     */
    async executeCleanup(targetFiles) {
        const startTime = Date.now();
        logger_1.logger.info('Starting import cleanup system execution');
        try {
            // Get files to process
            const filesToProcess = targetFiles || (await this.getTypeScriptFiles());
            const batchedFiles = this.batchFiles(filesToProcess);
            let totalResult = {
                filesProcessed: [],
                unusedImportsRemoved: 0,
                importsOrganized: 0,
                styleViolationsFixed: 0,
                buildValidationPassed: true,
                errors: [],
                warnings: [],
            };
            // Process files in batches
            for (let i = 0; i < batchedFiles.length; i++) {
                const batch = batchedFiles[i];
                logger_1.logger.info(`Processing batch ${i + 1}/${batchedFiles.length} (${batch.length} files)`);
                const batchResult = await this.processBatch(batch);
                totalResult = this.mergeBatchResults(totalResult, batchResult);
                // Validate build after each batch if enabled
                if (this.config.safetyValidationEnabled &&
                    (i + 1) % this.config.buildValidationFrequency === 0) {
                    const buildValid = await this.validateBuild();
                    if (!buildValid) {
                        totalResult.buildValidationPassed = false;
                        totalResult.errors.push(`Build validation failed after batch ${i + 1}`);
                        break;
                    }
                }
            }
            const executionTime = Date.now() - startTime;
            logger_1.logger.info(`Import cleanup completed in ${executionTime}ms`, {
                filesProcessed: totalResult.filesProcessed.length,
                unusedImportsRemoved: totalResult.unusedImportsRemoved,
                importsOrganized: totalResult.importsOrganized,
            });
            return totalResult;
        }
        catch (error) {
            logger_1.logger.error('Import cleanup system failed', error);
            return {
                filesProcessed: [],
                unusedImportsRemoved: 0,
                importsOrganized: 0,
                styleViolationsFixed: 0,
                buildValidationPassed: false,
                errors: [error.message],
                warnings: [],
            };
        }
    }
    /**
     * Detect unused imports across the codebase
     */
    async detectUnusedImports(filePaths) {
        const files = filePaths || (await this.getTypeScriptFiles());
        const unusedImports = [];
        for (const filePath of files) {
            try {
                const fileUnusedImports = await this.detectUnusedImportsInFile(filePath);
                unusedImports.push(...fileUnusedImports);
            }
            catch (error) {
                logger_1.logger.warn(`Failed to analyze imports in ${filePath}`, error);
            }
        }
        return unusedImports;
    }
    /**
     * Remove unused imports from files
     */
    async removeUnusedImports(filePaths) {
        let removedCount = 0;
        for (const filePath of filePaths) {
            try {
                const removed = await this.removeUnusedImportsFromFile(filePath);
                removedCount += removed;
                this.processedFiles.add(filePath);
            }
            catch (error) {
                logger_1.logger.error(`Failed to remove unused imports from ${filePath}`, error);
            }
        }
        return removedCount;
    }
    /**
     * Organize imports according to style rules
     */
    async organizeImports(filePaths) {
        let organizedCount = 0;
        for (const filePath of filePaths) {
            try {
                const organized = await this.organizeImportsInFile(filePath);
                if (organized) {
                    organizedCount++;
                    this.processedFiles.add(filePath);
                }
            }
            catch (error) {
                logger_1.logger.error(`Failed to organize imports in ${filePath}`, error);
            }
        }
        return organizedCount;
    }
    /**
     * Enforce import style consistency
     */
    async enforceImportStyle(filePaths) {
        let fixedCount = 0;
        for (const filePath of filePaths) {
            try {
                const fixed = await this.enforceImportStyleInFile(filePath);
                if (fixed) {
                    fixedCount++;
                    this.processedFiles.add(filePath);
                }
            }
            catch (error) {
                logger_1.logger.error(`Failed to enforce import style in ${filePath}`, error);
            }
        }
        return fixedCount;
    }
    // Private implementation methods
    async processBatch(filePaths) {
        const result = {
            filesProcessed: [],
            unusedImportsRemoved: 0,
            importsOrganized: 0,
            styleViolationsFixed: 0,
            buildValidationPassed: true,
            errors: [],
            warnings: [],
        };
        // Step 1: Remove unused imports
        try {
            result.unusedImportsRemoved = await this.removeUnusedImports(filePaths);
        }
        catch (error) {
            result.errors.push(`Unused import removal failed: ${error.message}`);
        }
        // Step 2: Organize imports
        if (this.config.organizationRules.groupExternalImports ||
            this.config.organizationRules.groupInternalImports) {
            try {
                result.importsOrganized = await this.organizeImports(filePaths);
            }
            catch (error) {
                result.errors.push(`Import organization failed: ${error.message}`);
            }
        }
        // Step 3: Enforce style consistency
        if (this.config.importStyleEnforcement) {
            try {
                result.styleViolationsFixed = await this.enforceImportStyle(filePaths);
            }
            catch (error) {
                result.errors.push(`Import style enforcement failed: ${error.message}`);
            }
        }
        result.filesProcessed = Array.from(this.processedFiles);
        return result;
    }
    async detectUnusedImportsInFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        const unusedImports = [];
        // Parse import statements
        const importRegex = /^import\s+(?:type\s+)?(?:\{([^}]+)\}|\*\s+as\s+(\w+)|(\w+))\s+from\s+['"]([^'"]+)['"];?/;
        const typeImportRegex = /^import\s+type\s+/;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            const match = line.match(importRegex);
            if (match) {
                const isTypeImport = typeImportRegex.test(line);
                const importStatement = line;
                // Extract imported names
                let importedNames = [];
                if (match[1]) {
                    // Named imports: { name1, name2 }
                    importedNames = match[1].split(',').map(name => name.trim());
                }
                else if (match[2]) {
                    // Namespace import: * as name
                    importedNames = [match[2]];
                }
                else if (match[3]) {
                    // Default import: name
                    importedNames = [match[3]];
                }
                // Check if each imported name is used
                for (const importName of importedNames) {
                    if (!this.isImportUsed(content, importName, i)) {
                        unusedImports.push({
                            filePath,
                            importName,
                            importLine: i + 1,
                            importStatement,
                            isTypeImport,
                        });
                    }
                }
            }
        }
        return unusedImports;
    }
    isImportUsed(content, importName, importLineIndex) {
        const lines = content.split('\n');
        // Remove the import line from consideration
        const contentWithoutImport = lines.filter((_, index) => index !== importLineIndex).join('\n');
        // Check for usage patterns
        const usagePatterns = [
            new RegExp(`\\b${importName}\\b`, 'g'),
            new RegExp(`\\b${importName}\\.`, 'g'),
            new RegExp(`\\b${importName}\\(`, 'g'),
            new RegExp(`<${importName}\\b`, 'g'),
            new RegExp(`extends\\s+${importName}\\b`, 'g'),
            new RegExp(`implements\\s+${importName}\\b`, 'g'),
            new RegExp(`:\\s*${importName}\\b`, 'g'), // Type annotation
        ];
        return usagePatterns.some(pattern => pattern.test(contentWithoutImport));
    }
    async removeUnusedImportsFromFile(filePath) {
        const unusedImports = await this.detectUnusedImportsInFile(filePath);
        if (unusedImports.length === 0) {
            return 0;
        }
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        let removedCount = 0;
        // Group unused imports by line
        const unusedByLine = new Map();
        for (const unused of unusedImports) {
            const lineIndex = unused.importLine - 1;
            if (!unusedByLine.has(lineIndex)) {
                unusedByLine.set(lineIndex, []);
            }
            unusedByLine.get(lineIndex)?.push(unused);
        }
        // Process lines in reverse order to maintain line numbers
        const sortedLines = Array.from(unusedByLine.keys()).sort((a, b) => b - a);
        for (const lineIndex of sortedLines) {
            const lineUnused = unusedByLine.get(lineIndex);
            if (!lineUnused)
                continue;
            const originalLine = lines[lineIndex];
            // If all imports on this line are unused, remove the entire line
            const allImportsOnLine = this.extractAllImportsFromLine(originalLine);
            const allUnused = allImportsOnLine.every(imp => lineUnused.some(unused => unused.importName === imp));
            if (allUnused) {
                lines.splice(lineIndex, 1);
                removedCount += lineUnused.length;
            }
            else {
                // Remove only specific unused imports from the line
                let modifiedLine = originalLine;
                for (const unused of lineUnused) {
                    modifiedLine = this.removeImportFromLine(modifiedLine, unused.importName);
                    removedCount++;
                }
                lines[lineIndex] = modifiedLine;
            }
        }
        // Write the modified content back
        fs.writeFileSync(filePath, lines.join('\n'), 'utf8');
        return removedCount;
    }
    extractAllImportsFromLine(line) {
        const importRegex = /^import\s+(?:type\s+)?(?:\{([^}]+)\}|\*\s+as\s+(\w+)|(\w+))\s+from/;
        const match = line.match(importRegex);
        if (!match)
            return [];
        if (match[1]) {
            // Named imports
            return match[1].split(',').map(name => name.trim());
        }
        else if (match[2]) {
            // Namespace import
            return [match[2]];
        }
        else if (match[3]) {
            // Default import
            return [match[3]];
        }
        return [];
    }
    removeImportFromLine(line, importName) {
        // Handle different import patterns
        const patterns = [
            // Remove from named imports: { name1, name2, name3 } -> { name1, name3 }
            {
                regex: new RegExp(`\\{([^}]*?)\\b${importName}\\b,?([^}]*?)\\}`, 'g'),
                replacement: (match, before, after) => {
                    const cleanBefore = before.replace(/,\s*$/, '').trim();
                    const cleanAfter = after.replace(/^\s*,/, '').trim();
                    const combined = [cleanBefore, cleanAfter].filter(Boolean).join(', ');
                    return `{${combined}}`;
                },
            },
        ];
        let modifiedLine = line;
        for (const pattern of patterns) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- High-risk domain requiring flexibility
            modifiedLine = modifiedLine.replace(pattern.regex, pattern.replacement);
        }
        return modifiedLine;
    }
    async organizeImportsInFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        // Find import section
        const importLines = [];
        const importRegex = /^import\s+/;
        const typeImportRegex = /^import\s+type\s+/;
        const externalImportRegex = /from\s+['"](?![@./])/;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (importRegex.test(line)) {
                importLines.push({
                    line: lines[i],
                    index: i,
                    isExternal: externalImportRegex.test(line),
                    isType: typeImportRegex.test(line),
                });
            }
            else if (line && !line.startsWith('//') && !line.startsWith('/*')) {
                // Stop at first non-import, non-comment line
                break;
            }
        }
        if (importLines.length === 0) {
            return false;
        }
        // Organize imports according to rules
        const organizedImports = this.organizeImportLines(importLines);
        // Check if organization changed anything
        const originalImportSection = importLines.map(imp => imp.line).join('\n');
        const organizedImportSection = organizedImports.join('\n');
        if (originalImportSection === organizedImportSection) {
            return false;
        }
        // Replace import section
        const firstImportIndex = importLines[0].index;
        const lastImportIndex = importLines[importLines.length - 1].index;
        const newLines = [
            ...lines.slice(0, firstImportIndex),
            ...organizedImports,
            ...lines.slice(lastImportIndex + 1),
        ];
        fs.writeFileSync(filePath, newLines.join('\n'), 'utf8');
        return true;
    }
    organizeImportLines(importLines) {
        const { organizationRules } = this.config;
        const organized = [];
        // Separate imports by type
        const externalImports = importLines.filter(imp => imp.isExternal);
        const internalImports = importLines.filter(imp => !imp.isExternal);
        // Sort function
        const sortImports = (imports) => {
            if (organizationRules.sortAlphabetically) {
                return imports.sort((a, b) => a.line.localeCompare(b.line));
            }
            return imports;
        };
        // Separate type imports if configured
        if (organizationRules.separateTypeImports) {
            const externalTypeImports = sortImports(externalImports.filter(imp => imp.isType));
            const externalValueImports = sortImports(externalImports.filter(imp => !imp.isType));
            const internalTypeImports = sortImports(internalImports.filter(imp => imp.isType));
            const internalValueImports = sortImports(internalImports.filter(imp => !imp.isType));
            // Add external imports
            if (organizationRules.groupExternalImports) {
                organized.push(...externalTypeImports.map(imp => imp.line));
                if (externalTypeImports.length > 0 && externalValueImports.length > 0) {
                    organized.push(''); // Empty line between type and value imports
                }
                organized.push(...externalValueImports.map(imp => imp.line));
                if ((externalTypeImports.length > 0 || externalValueImports.length > 0) &&
                    (internalTypeImports.length > 0 || internalValueImports.length > 0)) {
                    organized.push(''); // Empty line between external and internal
                }
            }
            // Add internal imports
            if (organizationRules.groupInternalImports) {
                organized.push(...internalTypeImports.map(imp => imp.line));
                if (internalTypeImports.length > 0 && internalValueImports.length > 0) {
                    organized.push(''); // Empty line between type and value imports
                }
                organized.push(...internalValueImports.map(imp => imp.line));
            }
        }
        else {
            // Don't separate type imports
            if (organizationRules.groupExternalImports) {
                organized.push(...sortImports(externalImports).map(imp => imp.line));
                if (externalImports.length > 0 && internalImports.length > 0) {
                    organized.push(''); // Empty line between external and internal
                }
            }
            if (organizationRules.groupInternalImports) {
                organized.push(...sortImports(internalImports).map(imp => imp.line));
            }
        }
        return organized;
    }
    async enforceImportStyleInFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        let modified = false;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (/^import\s+/.test(line.trim())) {
                const styledLine = this.applyImportStyle(line);
                if (styledLine !== line) {
                    lines[i] = styledLine;
                    modified = true;
                }
            }
        }
        if (modified) {
            fs.writeFileSync(filePath, lines.join('\n'), 'utf8');
        }
        return modified;
    }
    applyImportStyle(line) {
        const { organizationRules } = this.config;
        let styledLine = line;
        // Enforce trailing commas in multi-line imports
        if (organizationRules.enforceTrailingCommas) {
            styledLine = styledLine.replace(/\{\s*([^}]+[^,])\s*\}/g, (match, imports) => {
                if (imports.includes(',')) {
                    return `{ ${imports.trim()}, }`;
                }
                return match;
            });
        }
        // Enforce line length limits
        if (organizationRules.maxLineLength && styledLine.length > organizationRules.maxLineLength) {
            // Break long import lines
            const importMatch = styledLine.match(/^(\s*import\s+(?:type\s+)?\{)([^}]+)(\}\s+from\s+.+)$/);
            if (importMatch) {
                const [, prefix, imports, suffix] = importMatch;
                const importList = imports.split(',').map(imp => imp.trim());
                if (importList.length > 1) {
                    const formattedImports = importList.map(imp => `  ${imp}`).join(',\n');
                    styledLine = `${prefix}\n${formattedImports}\n${suffix}`;
                }
            }
        }
        return styledLine;
    }
    async getTypeScriptFiles() {
        try {
            const output = (0, child_process_1.execSync)('find src -name "*.ts" -o -name "*.tsx" | grep -v __tests__ | grep -v .test. | grep -v .spec.', { encoding: 'utf8', stdio: 'pipe' });
            return output.trim().split('\n').filter(Boolean);
        }
        catch (error) {
            logger_1.logger.error('Failed to get TypeScript files', error);
            return [];
        }
    }
    batchFiles(files) {
        const batches = [];
        for (let i = 0; i < files.length; i += this.config.maxFilesPerBatch) {
            batches.push(files.slice(i, i + this.config.maxFilesPerBatch));
        }
        return batches;
    }
    async validateBuild() {
        try {
            (0, child_process_1.execSync)('yarn tsc --noEmit --skipLibCheck', {
                encoding: 'utf8',
                stdio: 'pipe',
                timeout: 30000,
            });
            return true;
        }
        catch (error) {
            logger_1.logger.warn('Build validation failed during import cleanup', error);
            return false;
        }
    }
    mergeBatchResults(total, batch) {
        return {
            filesProcessed: [...total.filesProcessed, ...batch.filesProcessed],
            unusedImportsRemoved: total.unusedImportsRemoved + batch.unusedImportsRemoved,
            importsOrganized: total.importsOrganized + batch.importsOrganized,
            styleViolationsFixed: total.styleViolationsFixed + batch.styleViolationsFixed,
            buildValidationPassed: total.buildValidationPassed && batch.buildValidationPassed,
            errors: [...total.errors, ...batch.errors],
            warnings: [...total.warnings, ...batch.warnings],
        };
    }
}
exports.ImportCleanupSystem = ImportCleanupSystem;
/**
 * Default configuration for import cleanup
 */
exports.DEFAULT_IMPORT_CLEANUP_CONFIG = {
    maxFilesPerBatch: 20,
    safetyValidationEnabled: true,
    buildValidationFrequency: 5,
    importStyleEnforcement: true,
    organizationRules: {
        groupExternalImports: true,
        groupInternalImports: true,
        sortAlphabetically: true,
        separateTypeImports: true,
        enforceTrailingCommas: true,
        maxLineLength: 100,
    },
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5jb25zb2xpZGF0aW9uLWJhY2t1cHMtMjAyNS0wOC0yM1QxNy01NC0xMC0wOTJaL3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9JbXBvcnRDbGVhbnVwU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFHekIsK0NBQTRDO0FBcUM1QyxNQUFhLG1CQUFtQjtJQUN0QixNQUFNLENBQXNCO0lBQzVCLGNBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUVoRCxZQUFZLE1BQTJCO1FBQ3JDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxjQUFjLENBQUMsV0FBc0I7UUFDekMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzdCLGVBQU0sQ0FBQyxJQUFJLENBQUMsMENBQTBDLENBQUMsQ0FBQztRQUV4RCxJQUFJO1lBQ0YsdUJBQXVCO1lBQ3ZCLE1BQU0sY0FBYyxHQUFHLFdBQVcsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQztZQUN4RSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBRXJELElBQUksV0FBVyxHQUF3QjtnQkFDckMsY0FBYyxFQUFFLEVBQUU7Z0JBQ2xCLG9CQUFvQixFQUFFLENBQUM7Z0JBQ3ZCLGdCQUFnQixFQUFFLENBQUM7Z0JBQ25CLG9CQUFvQixFQUFFLENBQUM7Z0JBQ3ZCLHFCQUFxQixFQUFFLElBQUk7Z0JBQzNCLE1BQU0sRUFBRSxFQUFFO2dCQUNWLFFBQVEsRUFBRSxFQUFFO2FBQ2IsQ0FBQztZQUVGLDJCQUEyQjtZQUMzQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdB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QUFFLENBQUMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQztTQUNqRCxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBOWtCRCxrREE4a0JDO0FBRUQ7O0dBRUc7QUFDVSxRQUFBLDZCQUE2QixHQUF3QjtJQUNoRSxnQkFBZ0IsRUFBRSxFQUFFO0lBQ3BCLHVCQUF1QixFQUFFLElBQUk7SUFDN0Isd0JBQXdCLEVBQUUsQ0FBQztJQUMzQixzQkFBc0IsRUFBRSxJQUFJO0lBQzVCLGlCQUFpQixFQUFFO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7UUFDMUIsb0JBQW9CLEVBQUUsSUFBSTtRQUMxQixrQkFBa0IsRUFBRSxJQUFJO1FBQ3hCLG1CQUFtQixFQUFFLElBQUk7UUFDekIscUJBQXFCLEVBQUUsSUFBSTtRQUMzQixhQUFhLEVBQUUsR0FBRztLQUNuQjtDQUNGLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5jb25zb2xpZGF0aW9uLWJhY2t1cHMtMjAyNS0wOC0yM1QxNy01NC0xMC0wOTJaL3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9JbXBvcnRDbGVhbnVwU3lzdGVtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW1wb3J0IENsZWFudXAgU3lzdGVtXG4gKiBBdXRvbWF0ZWQgaW1wb3J0IGRldGVjdGlvbiwgcmVtb3ZhbCwgYW5kIG9yZ2FuaXphdGlvbiBzeXN0ZW1cbiAqIFBhcnQgb2YgdGhlIEtpcm8gT3B0aW1pemF0aW9uIENhbXBhaWduIFN5c3RlbVxuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydENsZWFudXBDb25maWcge1xuICBtYXhGaWxlc1BlckJhdGNoOiBudW1iZXI7XG4gIHNhZmV0eVZhbGlkYXRpb25FbmFibGVkOiBib29sZWFuO1xuICBidWlsZFZhbGlkYXRpb25GcmVxdWVuY3k6IG51bWJlcjtcbiAgaW1wb3J0U3R5bGVFbmZvcmNlbWVudDogYm9vbGVhbjtcbiAgb3JnYW5pemF0aW9uUnVsZXM6IEltcG9ydE9yZ2FuaXphdGlvblJ1bGVzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydE9yZ2FuaXphdGlvblJ1bGVzIHtcbiAgZ3JvdXBFeHRlcm5hbEltcG9ydHM6IGJvb2xlYW47XG4gIGdyb3VwSW50ZXJuYWxJbXBvcnRzOiBib29sZWFuO1xuICBzb3J0QWxwaGFiZXRpY2FsbHk6IGJvb2xlYW47XG4gIHNlcGFyYXRlVHlwZUltcG9ydHM6IGJvb2xlYW47XG4gIGVuZm9yY2VUcmFpbGluZ0NvbW1hczogYm9vbGVhbjtcbiAgbWF4TGluZUxlbmd0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydENsZWFudXBSZXN1bHQge1xuICBmaWxlc1Byb2Nlc3NlZDogc3RyaW5nW107XG4gIHVudXNlZEltcG9ydHNSZW1vdmVkOiBudW1iZXI7XG4gIGltcG9ydHNPcmdhbml6ZWQ6IG51bWJlcjtcbiAgc3R5bGVWaW9sYXRpb25zRml4ZWQ6IG51bWJlcjtcbiAgYnVpbGRWYWxpZGF0aW9uUGFzc2VkOiBib29sZWFuO1xuICBlcnJvcnM6IHN0cmluZ1tdO1xuICB3YXJuaW5nczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVW51c2VkSW1wb3J0IHtcbiAgZmlsZVBhdGg6IHN0cmluZztcbiAgaW1wb3J0TmFtZTogc3RyaW5nO1xuICBpbXBvcnRMaW5lOiBudW1iZXI7XG4gIGltcG9ydFN0YXRlbWVudDogc3RyaW5nO1xuICBpc1R5cGVJbXBvcnQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBJbXBvcnRDbGVhbnVwU3lzdGVtIHtcbiAgcHJpdmF0ZSBjb25maWc6IEltcG9ydENsZWFudXBDb25maWc7XG4gIHByaXZhdGUgcHJvY2Vzc2VkRmlsZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSW1wb3J0Q2xlYW51cENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgY29tcHJlaGVuc2l2ZSBpbXBvcnQgY2xlYW51cFxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZUNsZWFudXAodGFyZ2V0RmlsZXM/OiBzdHJpbmdbXSk6IFByb21pc2U8SW1wb3J0Q2xlYW51cFJlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGltcG9ydCBjbGVhbnVwIHN5c3RlbSBleGVjdXRpb24nKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZmlsZXMgdG8gcHJvY2Vzc1xuICAgICAgY29uc3QgZmlsZXNUb1Byb2Nlc3MgPSB0YXJnZXRGaWxlcyB8fCAoYXdhaXQgdGhpcy5nZXRUeXBlU2NyaXB0RmlsZXMoKSk7XG4gICAgICBjb25zdCBiYXRjaGVkRmlsZXMgPSB0aGlzLmJhdGNoRmlsZXMoZmlsZXNUb1Byb2Nlc3MpO1xuXG4gICAgICBsZXQgdG90YWxSZXN1bHQ6IEltcG9ydENsZWFudXBSZXN1bHQgPSB7XG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiBbXSxcbiAgICAgICAgdW51c2VkSW1wb3J0c1JlbW92ZWQ6IDAsXG4gICAgICAgIGltcG9ydHNPcmdhbml6ZWQ6IDAsXG4gICAgICAgIHN0eWxlVmlvbGF0aW9uc0ZpeGVkOiAwLFxuICAgICAgICBidWlsZFZhbGlkYXRpb25QYXNzZWQ6IHRydWUsXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFByb2Nlc3MgZmlsZXMgaW4gYmF0Y2hlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVkRmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVkRmlsZXNbaV07XG4gICAgICAgIGxvZ2dlci5pbmZvKGBQcm9jZXNzaW5nIGJhdGNoICR7aSArIDF9LyR7YmF0Y2hlZEZpbGVzLmxlbmd0aH0gKCR7YmF0Y2gubGVuZ3RofSBmaWxlcylgKTtcblxuICAgICAgICBjb25zdCBiYXRjaFJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0JhdGNoKGJhdGNoKTtcbiAgICAgICAgdG90YWxSZXN1bHQgPSB0aGlzLm1lcmdlQmF0Y2hSZXN1bHRzKHRvdGFsUmVzdWx0LCBiYXRjaFJlc3VsdCk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgYnVpbGQgYWZ0ZXIgZWFjaCBiYXRjaCBpZiBlbmFibGVkXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmNvbmZpZy5zYWZldHlWYWxpZGF0aW9uRW5hYmxlZCAmJlxuICAgICAgICAgIChpICsgMSkgJSB0aGlzLmNvbmZpZy5idWlsZFZhbGlkYXRpb25GcmVxdWVuY3kgPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgYnVpbGRWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVCdWlsZCgpO1xuICAgICAgICAgIGlmICghYnVpbGRWYWxpZCkge1xuICAgICAgICAgICAgdG90YWxSZXN1bHQuYnVpbGRWYWxpZGF0aW9uUGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0b3RhbFJlc3VsdC5lcnJvcnMucHVzaChgQnVpbGQgdmFsaWRhdGlvbiBmYWlsZWQgYWZ0ZXIgYmF0Y2ggJHtpICsgMX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGxvZ2dlci5pbmZvKGBJbXBvcnQgY2xlYW51cCBjb21wbGV0ZWQgaW4gJHtleGVjdXRpb25UaW1lfW1zYCwge1xuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogdG90YWxSZXN1bHQuZmlsZXNQcm9jZXNzZWQubGVuZ3RoLFxuICAgICAgICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogdG90YWxSZXN1bHQudW51c2VkSW1wb3J0c1JlbW92ZWQsXG4gICAgICAgIGltcG9ydHNPcmdhbml6ZWQ6IHRvdGFsUmVzdWx0LmltcG9ydHNPcmdhbml6ZWQsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdGFsUmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ltcG9ydCBjbGVhbnVwIHN5c3RlbSBmYWlsZWQnLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogW10sXG4gICAgICAgIHVudXNlZEltcG9ydHNSZW1vdmVkOiAwLFxuICAgICAgICBpbXBvcnRzT3JnYW5pemVkOiAwLFxuICAgICAgICBzdHlsZVZpb2xhdGlvbnNGaXhlZDogMCxcbiAgICAgICAgYnVpbGRWYWxpZGF0aW9uUGFzc2VkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBbKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlXSxcbiAgICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHVudXNlZCBpbXBvcnRzIGFjcm9zcyB0aGUgY29kZWJhc2VcbiAgICovXG4gIGFzeW5jIGRldGVjdFVudXNlZEltcG9ydHMoZmlsZVBhdGhzPzogc3RyaW5nW10pOiBQcm9taXNlPFVudXNlZEltcG9ydFtdPiB7XG4gICAgY29uc3QgZmlsZXMgPSBmaWxlUGF0aHMgfHwgKGF3YWl0IHRoaXMuZ2V0VHlwZVNjcmlwdEZpbGVzKCkpO1xuICAgIGNvbnN0IHVudXNlZEltcG9ydHM6IFVudXNlZEltcG9ydFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGZpbGVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlVW51c2VkSW1wb3J0cyA9IGF3YWl0IHRoaXMuZGV0ZWN0VW51c2VkSW1wb3J0c0luRmlsZShmaWxlUGF0aCk7XG4gICAgICAgIHVudXNlZEltcG9ydHMucHVzaCguLi5maWxlVW51c2VkSW1wb3J0cyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybihgRmFpbGVkIHRvIGFuYWx5emUgaW1wb3J0cyBpbiAke2ZpbGVQYXRofWAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW51c2VkSW1wb3J0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdW51c2VkIGltcG9ydHMgZnJvbSBmaWxlc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlVW51c2VkSW1wb3J0cyhmaWxlUGF0aHM6IHN0cmluZ1tdKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBsZXQgcmVtb3ZlZENvdW50ID0gMDtcblxuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZW1vdmVkID0gYXdhaXQgdGhpcy5yZW1vdmVVbnVzZWRJbXBvcnRzRnJvbUZpbGUoZmlsZVBhdGgpO1xuICAgICAgICByZW1vdmVkQ291bnQgKz0gcmVtb3ZlZDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRGaWxlcy5hZGQoZmlsZVBhdGgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcmVtb3ZlIHVudXNlZCBpbXBvcnRzIGZyb20gJHtmaWxlUGF0aH1gLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZWRDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcmdhbml6ZSBpbXBvcnRzIGFjY29yZGluZyB0byBzdHlsZSBydWxlc1xuICAgKi9cbiAgYXN5bmMgb3JnYW5pemVJbXBvcnRzKGZpbGVQYXRoczogc3RyaW5nW10pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGxldCBvcmdhbml6ZWRDb3VudCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGZpbGVQYXRocykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3JnYW5pemVkID0gYXdhaXQgdGhpcy5vcmdhbml6ZUltcG9ydHNJbkZpbGUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAob3JnYW5pemVkKSB7XG4gICAgICAgICAgb3JnYW5pemVkQ291bnQrKztcbiAgICAgICAgICB0aGlzLnByb2Nlc3NlZEZpbGVzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIG9yZ2FuaXplIGltcG9ydHMgaW4gJHtmaWxlUGF0aH1gLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZ2FuaXplZENvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZm9yY2UgaW1wb3J0IHN0eWxlIGNvbnNpc3RlbmN5XG4gICAqL1xuICBhc3luYyBlbmZvcmNlSW1wb3J0U3R5bGUoZmlsZVBhdGhzOiBzdHJpbmdbXSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgbGV0IGZpeGVkQ291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpeGVkID0gYXdhaXQgdGhpcy5lbmZvcmNlSW1wb3J0U3R5bGVJbkZpbGUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICBmaXhlZENvdW50Kys7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzZWRGaWxlcy5hZGQoZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBlbmZvcmNlIGltcG9ydCBzdHlsZSBpbiAke2ZpbGVQYXRofWAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZml4ZWRDb3VudDtcbiAgfVxuXG4gIC8vIFByaXZhdGUgaW1wbGVtZW50YXRpb24gbWV0aG9kc1xuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoKGZpbGVQYXRoczogc3RyaW5nW10pOiBQcm9taXNlPEltcG9ydENsZWFudXBSZXN1bHQ+IHtcbiAgICBjb25zdCByZXN1bHQ6IEltcG9ydENsZWFudXBSZXN1bHQgPSB7XG4gICAgICBmaWxlc1Byb2Nlc3NlZDogW10sXG4gICAgICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogMCxcbiAgICAgIGltcG9ydHNPcmdhbml6ZWQ6IDAsXG4gICAgICBzdHlsZVZpb2xhdGlvbnNGaXhlZDogMCxcbiAgICAgIGJ1aWxkVmFsaWRhdGlvblBhc3NlZDogdHJ1ZSxcbiAgICAgIGVycm9yczogW10sXG4gICAgICB3YXJuaW5nczogW10sXG4gICAgfTtcblxuICAgIC8vIFN0ZXAgMTogUmVtb3ZlIHVudXNlZCBpbXBvcnRzXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdC51bnVzZWRJbXBvcnRzUmVtb3ZlZCA9IGF3YWl0IHRoaXMucmVtb3ZlVW51c2VkSW1wb3J0cyhmaWxlUGF0aHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXN1bHQuZXJyb3JzLnB1c2goYFVudXNlZCBpbXBvcnQgcmVtb3ZhbCBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgMjogT3JnYW5pemUgaW1wb3J0c1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29uZmlnLm9yZ2FuaXphdGlvblJ1bGVzLmdyb3VwRXh0ZXJuYWxJbXBvcnRzIHx8XG4gICAgICB0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25SdWxlcy5ncm91cEludGVybmFsSW1wb3J0c1xuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0LmltcG9ydHNPcmdhbml6ZWQgPSBhd2FpdCB0aGlzLm9yZ2FuaXplSW1wb3J0cyhmaWxlUGF0aHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKGBJbXBvcnQgb3JnYW5pemF0aW9uIGZhaWxlZDogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RlcCAzOiBFbmZvcmNlIHN0eWxlIGNvbnNpc3RlbmN5XG4gICAgaWYgKHRoaXMuY29uZmlnLmltcG9ydFN0eWxlRW5mb3JjZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdC5zdHlsZVZpb2xhdGlvbnNGaXhlZCA9IGF3YWl0IHRoaXMuZW5mb3JjZUltcG9ydFN0eWxlKGZpbGVQYXRocyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goYEltcG9ydCBzdHlsZSBlbmZvcmNlbWVudCBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5maWxlc1Byb2Nlc3NlZCA9IEFycmF5LmZyb20odGhpcy5wcm9jZXNzZWRGaWxlcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZGV0ZWN0VW51c2VkSW1wb3J0c0luRmlsZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxVbnVzZWRJbXBvcnRbXT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCB1bnVzZWRJbXBvcnRzOiBVbnVzZWRJbXBvcnRbXSA9IFtdO1xuXG4gICAgLy8gUGFyc2UgaW1wb3J0IHN0YXRlbWVudHNcbiAgICBjb25zdCBpbXBvcnRSZWdleCA9XG4gICAgICAvXmltcG9ydFxccysoPzp0eXBlXFxzKyk/KD86XFx7KFtefV0rKVxcfXxcXCpcXHMrYXNcXHMrKFxcdyspfChcXHcrKSlcXHMrZnJvbVxccytbJ1wiXShbXidcIl0rKVsnXCJdOz8vO1xuICAgIGNvbnN0IHR5cGVJbXBvcnRSZWdleCA9IC9eaW1wb3J0XFxzK3R5cGVcXHMrLztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goaW1wb3J0UmVnZXgpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgaXNUeXBlSW1wb3J0ID0gdHlwZUltcG9ydFJlZ2V4LnRlc3QobGluZSk7XG4gICAgICAgIGNvbnN0IGltcG9ydFN0YXRlbWVudCA9IGxpbmU7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBpbXBvcnRlZCBuYW1lc1xuICAgICAgICBsZXQgaW1wb3J0ZWROYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgLy8gTmFtZWQgaW1wb3J0czogeyBuYW1lMSwgbmFtZTIgfVxuICAgICAgICAgIGltcG9ydGVkTmFtZXMgPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgIC8vIE5hbWVzcGFjZSBpbXBvcnQ6ICogYXMgbmFtZVxuICAgICAgICAgIGltcG9ydGVkTmFtZXMgPSBbbWF0Y2hbMl1dO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgLy8gRGVmYXVsdCBpbXBvcnQ6IG5hbWVcbiAgICAgICAgICBpbXBvcnRlZE5hbWVzID0gW21hdGNoWzNdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGVhY2ggaW1wb3J0ZWQgbmFtZSBpcyB1c2VkXG4gICAgICAgIGZvciAoY29uc3QgaW1wb3J0TmFtZSBvZiBpbXBvcnRlZE5hbWVzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzSW1wb3J0VXNlZChjb250ZW50LCBpbXBvcnROYW1lLCBpKSkge1xuICAgICAgICAgICAgdW51c2VkSW1wb3J0cy5wdXNoKHtcbiAgICAgICAgICAgICAgZmlsZVBhdGgsXG4gICAgICAgICAgICAgIGltcG9ydE5hbWUsXG4gICAgICAgICAgICAgIGltcG9ydExpbmU6IGkgKyAxLFxuICAgICAgICAgICAgICBpbXBvcnRTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgIGlzVHlwZUltcG9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bnVzZWRJbXBvcnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0ltcG9ydFVzZWQoY29udGVudDogc3RyaW5nLCBpbXBvcnROYW1lOiBzdHJpbmcsIGltcG9ydExpbmVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcblxuICAgIC8vIFJlbW92ZSB0aGUgaW1wb3J0IGxpbmUgZnJvbSBjb25zaWRlcmF0aW9uXG4gICAgY29uc3QgY29udGVudFdpdGhvdXRJbXBvcnQgPSBsaW5lcy5maWx0ZXIoKF8sIGluZGV4KSA9PiBpbmRleCAhPT0gaW1wb3J0TGluZUluZGV4KS5qb2luKCdcXG4nKTtcblxuICAgIC8vIENoZWNrIGZvciB1c2FnZSBwYXR0ZXJuc1xuICAgIGNvbnN0IHVzYWdlUGF0dGVybnMgPSBbXG4gICAgICBuZXcgUmVnRXhwKGBcXFxcYiR7aW1wb3J0TmFtZX1cXFxcYmAsICdnJyksIC8vIERpcmVjdCB1c2FnZVxuICAgICAgbmV3IFJlZ0V4cChgXFxcXGIke2ltcG9ydE5hbWV9XFxcXC5gLCAnZycpLCAvLyBQcm9wZXJ0eSBhY2Nlc3NcbiAgICAgIG5ldyBSZWdFeHAoYFxcXFxiJHtpbXBvcnROYW1lfVxcXFwoYCwgJ2cnKSwgLy8gRnVuY3Rpb24gY2FsbFxuICAgICAgbmV3IFJlZ0V4cChgPCR7aW1wb3J0TmFtZX1cXFxcYmAsICdnJyksIC8vIEpTWCBjb21wb25lbnRcbiAgICAgIG5ldyBSZWdFeHAoYGV4dGVuZHNcXFxccyske2ltcG9ydE5hbWV9XFxcXGJgLCAnZycpLCAvLyBDbGFzcyBleHRlbnNpb25cbiAgICAgIG5ldyBSZWdFeHAoYGltcGxlbWVudHNcXFxccyske2ltcG9ydE5hbWV9XFxcXGJgLCAnZycpLCAvLyBJbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAgICAgIG5ldyBSZWdFeHAoYDpcXFxccyoke2ltcG9ydE5hbWV9XFxcXGJgLCAnZycpLCAvLyBUeXBlIGFubm90YXRpb25cbiAgICBdO1xuXG4gICAgcmV0dXJuIHVzYWdlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChjb250ZW50V2l0aG91dEltcG9ydCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZW1vdmVVbnVzZWRJbXBvcnRzRnJvbUZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgdW51c2VkSW1wb3J0cyA9IGF3YWl0IHRoaXMuZGV0ZWN0VW51c2VkSW1wb3J0c0luRmlsZShmaWxlUGF0aCk7XG4gICAgaWYgKHVudXNlZEltcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cbiAgICAvLyBHcm91cCB1bnVzZWQgaW1wb3J0cyBieSBsaW5lXG4gICAgY29uc3QgdW51c2VkQnlMaW5lID0gbmV3IE1hcDxudW1iZXIsIFVudXNlZEltcG9ydFtdPigpO1xuICAgIGZvciAoY29uc3QgdW51c2VkIG9mIHVudXNlZEltcG9ydHMpIHtcbiAgICAgIGNvbnN0IGxpbmVJbmRleCA9IHVudXNlZC5pbXBvcnRMaW5lIC0gMTtcbiAgICAgIGlmICghdW51c2VkQnlMaW5lLmhhcyhsaW5lSW5kZXgpKSB7XG4gICAgICAgIHVudXNlZEJ5TGluZS5zZXQobGluZUluZGV4LCBbXSk7XG4gICAgICB9XG4gICAgICB1bnVzZWRCeUxpbmUuZ2V0KGxpbmVJbmRleCk/LnB1c2godW51c2VkKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGxpbmVzIGluIHJldmVyc2Ugb3JkZXIgdG8gbWFpbnRhaW4gbGluZSBudW1iZXJzXG4gICAgY29uc3Qgc29ydGVkTGluZXMgPSBBcnJheS5mcm9tKHVudXNlZEJ5TGluZS5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcblxuICAgIGZvciAoY29uc3QgbGluZUluZGV4IG9mIHNvcnRlZExpbmVzKSB7XG4gICAgICBjb25zdCBsaW5lVW51c2VkID0gdW51c2VkQnlMaW5lLmdldChsaW5lSW5kZXgpO1xuICAgICAgaWYgKCFsaW5lVW51c2VkKSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lID0gbGluZXNbbGluZUluZGV4XTtcblxuICAgICAgLy8gSWYgYWxsIGltcG9ydHMgb24gdGhpcyBsaW5lIGFyZSB1bnVzZWQsIHJlbW92ZSB0aGUgZW50aXJlIGxpbmVcbiAgICAgIGNvbnN0IGFsbEltcG9ydHNPbkxpbmUgPSB0aGlzLmV4dHJhY3RBbGxJbXBvcnRzRnJvbUxpbmUob3JpZ2luYWxMaW5lKTtcbiAgICAgIGNvbnN0IGFsbFVudXNlZCA9IGFsbEltcG9ydHNPbkxpbmUuZXZlcnkoaW1wID0+XG4gICAgICAgIGxpbmVVbnVzZWQuc29tZSh1bnVzZWQgPT4gdW51c2VkLmltcG9ydE5hbWUgPT09IGltcCksXG4gICAgICApO1xuXG4gICAgICBpZiAoYWxsVW51c2VkKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZShsaW5lSW5kZXgsIDEpO1xuICAgICAgICByZW1vdmVkQ291bnQgKz0gbGluZVVudXNlZC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgb25seSBzcGVjaWZpYyB1bnVzZWQgaW1wb3J0cyBmcm9tIHRoZSBsaW5lXG4gICAgICAgIGxldCBtb2RpZmllZExpbmUgPSBvcmlnaW5hbExpbmU7XG4gICAgICAgIGZvciAoY29uc3QgdW51c2VkIG9mIGxpbmVVbnVzZWQpIHtcbiAgICAgICAgICBtb2RpZmllZExpbmUgPSB0aGlzLnJlbW92ZUltcG9ydEZyb21MaW5lKG1vZGlmaWVkTGluZSwgdW51c2VkLmltcG9ydE5hbWUpO1xuICAgICAgICAgIHJlbW92ZWRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzW2xpbmVJbmRleF0gPSBtb2RpZmllZExpbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgdGhlIG1vZGlmaWVkIGNvbnRlbnQgYmFja1xuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGxpbmVzLmpvaW4oJ1xcbicpLCAndXRmOCcpO1xuICAgIHJldHVybiByZW1vdmVkQ291bnQ7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RBbGxJbXBvcnRzRnJvbUxpbmUobGluZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGltcG9ydFJlZ2V4ID0gL15pbXBvcnRcXHMrKD86dHlwZVxccyspPyg/OlxceyhbXn1dKylcXH18XFwqXFxzK2FzXFxzKyhcXHcrKXwoXFx3KykpXFxzK2Zyb20vO1xuICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChpbXBvcnRSZWdleCk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gW107XG5cbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgIC8vIE5hbWVkIGltcG9ydHNcbiAgICAgIHJldHVybiBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAvLyBOYW1lc3BhY2UgaW1wb3J0XG4gICAgICByZXR1cm4gW21hdGNoWzJdXTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAvLyBEZWZhdWx0IGltcG9ydFxuICAgICAgcmV0dXJuIFttYXRjaFszXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVJbXBvcnRGcm9tTGluZShsaW5lOiBzdHJpbmcsIGltcG9ydE5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gSGFuZGxlIGRpZmZlcmVudCBpbXBvcnQgcGF0dGVybnNcbiAgICBjb25zdCBwYXR0ZXJucyA9IFtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIG5hbWVkIGltcG9ydHM6IHsgbmFtZTEsIG5hbWUyLCBuYW1lMyB9IC0+IHsgbmFtZTEsIG5hbWUzIH1cbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IG5ldyBSZWdFeHAoYFxcXFx7KFtefV0qPylcXFxcYiR7aW1wb3J0TmFtZX1cXFxcYiw/KFtefV0qPylcXFxcfWAsICdnJyksXG4gICAgICAgIHJlcGxhY2VtZW50OiAobWF0Y2g6IHN0cmluZywgYmVmb3JlOiBzdHJpbmcsIGFmdGVyOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbkJlZm9yZSA9IGJlZm9yZS5yZXBsYWNlKC8sXFxzKiQvLCAnJykudHJpbSgpO1xuICAgICAgICAgIGNvbnN0IGNsZWFuQWZ0ZXIgPSBhZnRlci5yZXBsYWNlKC9eXFxzKiwvLCAnJykudHJpbSgpO1xuICAgICAgICAgIGNvbnN0IGNvbWJpbmVkID0gW2NsZWFuQmVmb3JlLCBjbGVhbkFmdGVyXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcbiAgICAgICAgICByZXR1cm4gYHske2NvbWJpbmVkfX1gO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgbGV0IG1vZGlmaWVkTGluZSA9IGxpbmU7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBIaWdoLXJpc2sgZG9tYWluIHJlcXVpcmluZyBmbGV4aWJpbGl0eVxuICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UocGF0dGVybi5yZWdleCwgcGF0dGVybi5yZXBsYWNlbWVudCBhcyBhbnkpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllZExpbmU7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG9yZ2FuaXplSW1wb3J0c0luRmlsZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuXG4gICAgLy8gRmluZCBpbXBvcnQgc2VjdGlvblxuICAgIGNvbnN0IGltcG9ydExpbmVzOiB7IGxpbmU6IHN0cmluZzsgaW5kZXg6IG51bWJlcjsgaXNFeHRlcm5hbDogYm9vbGVhbjsgaXNUeXBlOiBib29sZWFuIH1bXSA9IFtdO1xuICAgIGNvbnN0IGltcG9ydFJlZ2V4ID0gL15pbXBvcnRcXHMrLztcbiAgICBjb25zdCB0eXBlSW1wb3J0UmVnZXggPSAvXmltcG9ydFxccyt0eXBlXFxzKy87XG4gICAgY29uc3QgZXh0ZXJuYWxJbXBvcnRSZWdleCA9IC9mcm9tXFxzK1snXCJdKD8hW0AuL10pLztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICBpZiAoaW1wb3J0UmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICBpbXBvcnRMaW5lcy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBsaW5lc1tpXSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBpc0V4dGVybmFsOiBleHRlcm5hbEltcG9ydFJlZ2V4LnRlc3QobGluZSksXG4gICAgICAgICAgaXNUeXBlOiB0eXBlSW1wb3J0UmVnZXgudGVzdChsaW5lKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgJiYgIWxpbmUuc3RhcnRzV2l0aCgnLy8nKSAmJiAhbGluZS5zdGFydHNXaXRoKCcvKicpKSB7XG4gICAgICAgIC8vIFN0b3AgYXQgZmlyc3Qgbm9uLWltcG9ydCwgbm9uLWNvbW1lbnQgbGluZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW1wb3J0TGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT3JnYW5pemUgaW1wb3J0cyBhY2NvcmRpbmcgdG8gcnVsZXNcbiAgICBjb25zdCBvcmdhbml6ZWRJbXBvcnRzID0gdGhpcy5vcmdhbml6ZUltcG9ydExpbmVzKGltcG9ydExpbmVzKTtcblxuICAgIC8vIENoZWNrIGlmIG9yZ2FuaXphdGlvbiBjaGFuZ2VkIGFueXRoaW5nXG4gICAgY29uc3Qgb3JpZ2luYWxJbXBvcnRTZWN0aW9uID0gaW1wb3J0TGluZXMubWFwKGltcCA9PiBpbXAubGluZSkuam9pbignXFxuJyk7XG4gICAgY29uc3Qgb3JnYW5pemVkSW1wb3J0U2VjdGlvbiA9IG9yZ2FuaXplZEltcG9ydHMuam9pbignXFxuJyk7XG5cbiAgICBpZiAob3JpZ2luYWxJbXBvcnRTZWN0aW9uID09PSBvcmdhbml6ZWRJbXBvcnRTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSBpbXBvcnQgc2VjdGlvblxuICAgIGNvbnN0IGZpcnN0SW1wb3J0SW5kZXggPSBpbXBvcnRMaW5lc1swXS5pbmRleDtcbiAgICBjb25zdCBsYXN0SW1wb3J0SW5kZXggPSBpbXBvcnRMaW5lc1tpbXBvcnRMaW5lcy5sZW5ndGggLSAxXS5pbmRleDtcblxuICAgIGNvbnN0IG5ld0xpbmVzID0gW1xuICAgICAgLi4ubGluZXMuc2xpY2UoMCwgZmlyc3RJbXBvcnRJbmRleCksXG4gICAgICAuLi5vcmdhbml6ZWRJbXBvcnRzLFxuICAgICAgLi4ubGluZXMuc2xpY2UobGFzdEltcG9ydEluZGV4ICsgMSksXG4gICAgXTtcblxuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIG5ld0xpbmVzLmpvaW4oJ1xcbicpLCAndXRmOCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBvcmdhbml6ZUltcG9ydExpbmVzKFxuICAgIGltcG9ydExpbmVzOiB7IGxpbmU6IHN0cmluZzsgaXNFeHRlcm5hbDogYm9vbGVhbjsgaXNUeXBlOiBib29sZWFuIH1bXSxcbiAgKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHsgb3JnYW5pemF0aW9uUnVsZXMgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IG9yZ2FuaXplZDogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFNlcGFyYXRlIGltcG9ydHMgYnkgdHlwZVxuICAgIGNvbnN0IGV4dGVybmFsSW1wb3J0cyA9IGltcG9ydExpbmVzLmZpbHRlcihpbXAgPT4gaW1wLmlzRXh0ZXJuYWwpO1xuICAgIGNvbnN0IGludGVybmFsSW1wb3J0cyA9IGltcG9ydExpbmVzLmZpbHRlcihpbXAgPT4gIWltcC5pc0V4dGVybmFsKTtcblxuICAgIC8vIFNvcnQgZnVuY3Rpb25cbiAgICBjb25zdCBzb3J0SW1wb3J0cyA9IChpbXBvcnRzOiB0eXBlb2YgaW1wb3J0TGluZXMpID0+IHtcbiAgICAgIGlmIChvcmdhbml6YXRpb25SdWxlcy5zb3J0QWxwaGFiZXRpY2FsbHkpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydHMuc29ydCgoYSwgYikgPT4gYS5saW5lLmxvY2FsZUNvbXBhcmUoYi5saW5lKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1wb3J0cztcbiAgICB9O1xuXG4gICAgLy8gU2VwYXJhdGUgdHlwZSBpbXBvcnRzIGlmIGNvbmZpZ3VyZWRcbiAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMuc2VwYXJhdGVUeXBlSW1wb3J0cykge1xuICAgICAgY29uc3QgZXh0ZXJuYWxUeXBlSW1wb3J0cyA9IHNvcnRJbXBvcnRzKGV4dGVybmFsSW1wb3J0cy5maWx0ZXIoaW1wID0+IGltcC5pc1R5cGUpKTtcbiAgICAgIGNvbnN0IGV4dGVybmFsVmFsdWVJbXBvcnRzID0gc29ydEltcG9ydHMoZXh0ZXJuYWxJbXBvcnRzLmZpbHRlcihpbXAgPT4gIWltcC5pc1R5cGUpKTtcbiAgICAgIGNvbnN0IGludGVybmFsVHlwZUltcG9ydHMgPSBzb3J0SW1wb3J0cyhpbnRlcm5hbEltcG9ydHMuZmlsdGVyKGltcCA9PiBpbXAuaXNUeXBlKSk7XG4gICAgICBjb25zdCBpbnRlcm5hbFZhbHVlSW1wb3J0cyA9IHNvcnRJbXBvcnRzKGludGVybmFsSW1wb3J0cy5maWx0ZXIoaW1wID0+ICFpbXAuaXNUeXBlKSk7XG5cbiAgICAgIC8vIEFkZCBleHRlcm5hbCBpbXBvcnRzXG4gICAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMuZ3JvdXBFeHRlcm5hbEltcG9ydHMpIHtcbiAgICAgICAgb3JnYW5pemVkLnB1c2goLi4uZXh0ZXJuYWxUeXBlSW1wb3J0cy5tYXAoaW1wID0+IGltcC5saW5lKSk7XG4gICAgICAgIGlmIChleHRlcm5hbFR5cGVJbXBvcnRzLmxlbmd0aCA+IDAgJiYgZXh0ZXJuYWxWYWx1ZUltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9yZ2FuaXplZC5wdXNoKCcnKTsgLy8gRW1wdHkgbGluZSBiZXR3ZWVuIHR5cGUgYW5kIHZhbHVlIGltcG9ydHNcbiAgICAgICAgfVxuICAgICAgICBvcmdhbml6ZWQucHVzaCguLi5leHRlcm5hbFZhbHVlSW1wb3J0cy5tYXAoaW1wID0+IGltcC5saW5lKSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChleHRlcm5hbFR5cGVJbXBvcnRzLmxlbmd0aCA+IDAgfHwgZXh0ZXJuYWxWYWx1ZUltcG9ydHMubGVuZ3RoID4gMCkgJiZcbiAgICAgICAgICAoaW50ZXJuYWxUeXBlSW1wb3J0cy5sZW5ndGggPiAwIHx8IGludGVybmFsVmFsdWVJbXBvcnRzLmxlbmd0aCA+IDApXG4gICAgICAgICkge1xuICAgICAgICAgIG9yZ2FuaXplZC5wdXNoKCcnKTsgLy8gRW1wdHkgbGluZSBiZXR3ZWVuIGV4dGVybmFsIGFuZCBpbnRlcm5hbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBpbnRlcm5hbCBpbXBvcnRzXG4gICAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMuZ3JvdXBJbnRlcm5hbEltcG9ydHMpIHtcbiAgICAgICAgb3JnYW5pemVkLnB1c2goLi4uaW50ZXJuYWxUeXBlSW1wb3J0cy5tYXAoaW1wID0+IGltcC5saW5lKSk7XG4gICAgICAgIGlmIChpbnRlcm5hbFR5cGVJbXBvcnRzLmxlbmd0aCA+IDAgJiYgaW50ZXJuYWxWYWx1ZUltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9yZ2FuaXplZC5wdXNoKCcnKTsgLy8gRW1wdHkgbGluZSBiZXR3ZWVuIHR5cGUgYW5kIHZhbHVlIGltcG9ydHNcbiAgICAgICAgfVxuICAgICAgICBvcmdhbml6ZWQucHVzaCguLi5pbnRlcm5hbFZhbHVlSW1wb3J0cy5tYXAoaW1wID0+IGltcC5saW5lKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvbid0IHNlcGFyYXRlIHR5cGUgaW1wb3J0c1xuICAgICAgaWYgKG9yZ2FuaXphdGlvblJ1bGVzLmdyb3VwRXh0ZXJuYWxJbXBvcnRzKSB7XG4gICAgICAgIG9yZ2FuaXplZC5wdXNoKC4uLnNvcnRJbXBvcnRzKGV4dGVybmFsSW1wb3J0cykubWFwKGltcCA9PiBpbXAubGluZSkpO1xuICAgICAgICBpZiAoZXh0ZXJuYWxJbXBvcnRzLmxlbmd0aCA+IDAgJiYgaW50ZXJuYWxJbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcmdhbml6ZWQucHVzaCgnJyk7IC8vIEVtcHR5IGxpbmUgYmV0d2VlbiBleHRlcm5hbCBhbmQgaW50ZXJuYWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMuZ3JvdXBJbnRlcm5hbEltcG9ydHMpIHtcbiAgICAgICAgb3JnYW5pemVkLnB1c2goLi4uc29ydEltcG9ydHMoaW50ZXJuYWxJbXBvcnRzKS5tYXAoaW1wID0+IGltcC5saW5lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZ2FuaXplZDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZW5mb3JjZUltcG9ydFN0eWxlSW5GaWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBpZiAoL15pbXBvcnRcXHMrLy50ZXN0KGxpbmUudHJpbSgpKSkge1xuICAgICAgICBjb25zdCBzdHlsZWRMaW5lID0gdGhpcy5hcHBseUltcG9ydFN0eWxlKGxpbmUpO1xuICAgICAgICBpZiAoc3R5bGVkTGluZSAhPT0gbGluZSkge1xuICAgICAgICAgIGxpbmVzW2ldID0gc3R5bGVkTGluZTtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGxpbmVzLmpvaW4oJ1xcbicpLCAndXRmOCcpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllZDtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlJbXBvcnRTdHlsZShsaW5lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgb3JnYW5pemF0aW9uUnVsZXMgfSA9IHRoaXMuY29uZmlnO1xuICAgIGxldCBzdHlsZWRMaW5lID0gbGluZTtcblxuICAgIC8vIEVuZm9yY2UgdHJhaWxpbmcgY29tbWFzIGluIG11bHRpLWxpbmUgaW1wb3J0c1xuICAgIGlmIChvcmdhbml6YXRpb25SdWxlcy5lbmZvcmNlVHJhaWxpbmdDb21tYXMpIHtcbiAgICAgIHN0eWxlZExpbmUgPSBzdHlsZWRMaW5lLnJlcGxhY2UoL1xce1xccyooW159XStbXixdKVxccypcXH0vZywgKG1hdGNoLCBpbXBvcnRzKSA9PiB7XG4gICAgICAgIGlmIChpbXBvcnRzLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgICByZXR1cm4gYHsgJHtpbXBvcnRzLnRyaW0oKX0sIH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEVuZm9yY2UgbGluZSBsZW5ndGggbGltaXRzXG4gICAgaWYgKG9yZ2FuaXphdGlvblJ1bGVzLm1heExpbmVMZW5ndGggJiYgc3R5bGVkTGluZS5sZW5ndGggPiBvcmdhbml6YXRpb25SdWxlcy5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAvLyBCcmVhayBsb25nIGltcG9ydCBsaW5lc1xuICAgICAgY29uc3QgaW1wb3J0TWF0Y2ggPSBzdHlsZWRMaW5lLm1hdGNoKC9eKFxccyppbXBvcnRcXHMrKD86dHlwZVxccyspP1xceykoW159XSspKFxcfVxccytmcm9tXFxzKy4rKSQvKTtcbiAgICAgIGlmIChpbXBvcnRNYXRjaCkge1xuICAgICAgICBjb25zdCBbLCBwcmVmaXgsIGltcG9ydHMsIHN1ZmZpeF0gPSBpbXBvcnRNYXRjaDtcbiAgICAgICAgY29uc3QgaW1wb3J0TGlzdCA9IGltcG9ydHMuc3BsaXQoJywnKS5tYXAoaW1wID0+IGltcC50cmltKCkpO1xuXG4gICAgICAgIGlmIChpbXBvcnRMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRJbXBvcnRzID0gaW1wb3J0TGlzdC5tYXAoaW1wID0+IGAgICR7aW1wfWApLmpvaW4oJyxcXG4nKTtcbiAgICAgICAgICBzdHlsZWRMaW5lID0gYCR7cHJlZml4fVxcbiR7Zm9ybWF0dGVkSW1wb3J0c31cXG4ke3N1ZmZpeH1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlZExpbmU7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFR5cGVTY3JpcHRGaWxlcygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKFxuICAgICAgICAnZmluZCBzcmMgLW5hbWUgXCIqLnRzXCIgLW8gLW5hbWUgXCIqLnRzeFwiIHwgZ3JlcCAtdiBfX3Rlc3RzX18gfCBncmVwIC12IC50ZXN0LiB8IGdyZXAgLXYgLnNwZWMuJyxcbiAgICAgICAgeyBlbmNvZGluZzogJ3V0ZjgnLCBzdGRpbzogJ3BpcGUnIH0sXG4gICAgICApO1xuICAgICAgcmV0dXJuIG91dHB1dC50cmltKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IFR5cGVTY3JpcHQgZmlsZXMnLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBiYXRjaEZpbGVzKGZpbGVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdW10ge1xuICAgIGNvbnN0IGJhdGNoZXM6IHN0cmluZ1tdW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSArPSB0aGlzLmNvbmZpZy5tYXhGaWxlc1BlckJhdGNoKSB7XG4gICAgICBiYXRjaGVzLnB1c2goZmlsZXMuc2xpY2UoaSwgaSArIHRoaXMuY29uZmlnLm1heEZpbGVzUGVyQmF0Y2gpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhdGNoZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlQnVpbGQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKCd5YXJuIHRzYyAtLW5vRW1pdCAtLXNraXBMaWJDaGVjaycsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgdGltZW91dDogMzAwMDAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybignQnVpbGQgdmFsaWRhdGlvbiBmYWlsZWQgZHVyaW5nIGltcG9ydCBjbGVhbnVwJywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbWVyZ2VCYXRjaFJlc3VsdHMoXG4gICAgdG90YWw6IEltcG9ydENsZWFudXBSZXN1bHQsXG4gICAgYmF0Y2g6IEltcG9ydENsZWFudXBSZXN1bHQsXG4gICk6IEltcG9ydENsZWFudXBSZXN1bHQge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxlc1Byb2Nlc3NlZDogWy4uLnRvdGFsLmZpbGVzUHJvY2Vzc2VkLCAuLi5iYXRjaC5maWxlc1Byb2Nlc3NlZF0sXG4gICAgICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogdG90YWwudW51c2VkSW1wb3J0c1JlbW92ZWQgKyBiYXRjaC51bnVzZWRJbXBvcnRzUmVtb3ZlZCxcbiAgICAgIGltcG9ydHNPcmdhbml6ZWQ6IHRvdGFsLmltcG9ydHNPcmdhbml6ZWQgKyBiYXRjaC5pbXBvcnRzT3JnYW5pemVkLFxuICAgICAgc3R5bGVWaW9sYXRpb25zRml4ZWQ6IHRvdGFsLnN0eWxlVmlvbGF0aW9uc0ZpeGVkICsgYmF0Y2guc3R5bGVWaW9sYXRpb25zRml4ZWQsXG4gICAgICBidWlsZFZhbGlkYXRpb25QYXNzZWQ6IHRvdGFsLmJ1aWxkVmFsaWRhdGlvblBhc3NlZCAmJiBiYXRjaC5idWlsZFZhbGlkYXRpb25QYXNzZWQsXG4gICAgICBlcnJvcnM6IFsuLi50b3RhbC5lcnJvcnMsIC4uLmJhdGNoLmVycm9yc10sXG4gICAgICB3YXJuaW5nczogWy4uLnRvdGFsLndhcm5pbmdzLCAuLi5iYXRjaC53YXJuaW5nc10sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgaW1wb3J0IGNsZWFudXBcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU1QT1JUX0NMRUFOVVBfQ09ORklHOiBJbXBvcnRDbGVhbnVwQ29uZmlnID0ge1xuICBtYXhGaWxlc1BlckJhdGNoOiAyMCxcbiAgc2FmZXR5VmFsaWRhdGlvbkVuYWJsZWQ6IHRydWUsXG4gIGJ1aWxkVmFsaWRhdGlvbkZyZXF1ZW5jeTogNSxcbiAgaW1wb3J0U3R5bGVFbmZvcmNlbWVudDogdHJ1ZSxcbiAgb3JnYW5pemF0aW9uUnVsZXM6IHtcbiAgICBncm91cEV4dGVybmFsSW1wb3J0czogdHJ1ZSxcbiAgICBncm91cEludGVybmFsSW1wb3J0czogdHJ1ZSxcbiAgICBzb3J0QWxwaGFiZXRpY2FsbHk6IHRydWUsXG4gICAgc2VwYXJhdGVUeXBlSW1wb3J0czogdHJ1ZSxcbiAgICBlbmZvcmNlVHJhaWxpbmdDb21tYXM6IHRydWUsXG4gICAgbWF4TGluZUxlbmd0aDogMTAwLFxuICB9LFxufTtcbiJdLCJ2ZXJzaW9uIjozfQ==