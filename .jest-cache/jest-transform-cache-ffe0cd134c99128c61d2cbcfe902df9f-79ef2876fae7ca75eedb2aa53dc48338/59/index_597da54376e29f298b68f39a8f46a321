cf1d0b6e94f670bceb44f48bd7d56812
"use strict";
/**
 * Main cooking data entry point
 *
 * This file exports cooking methods from the new modular structure
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCookingMethodsBySustainability = exports.getCookingMethodsByTemperature = exports.getCookingMethodsByCategory = exports.getAllCookingMethodNames = exports.getCookingMethods = exports.getCookingMethod = exports.rawCookingMethods = exports.traditionalCookingMethods = exports.molecularCookingMethods = exports.wetCookingMethods = exports.dryCookingMethods = exports.allCookingMethods = exports.calculateModifiedElementalEffect = exports.getAstrologicalEffect = exports.cookingMethods = void 0;
// Export everything from the new methods system
__exportStar(require("./methods"), exports);
// Re-export methods from the methods module for backward compatibility
const methods_1 = require("./methods");
Object.defineProperty(exports, "allCookingMethods", { enumerable: true, get: function () { return methods_1.allCookingMethods; } });
// For backwards compatibility - provide cookingMethods export from the new allCookingMethods
exports.cookingMethods = methods_1.allCookingMethods;
/**
 * Get astrological effect for a cooking method (simplified version for backwards compatibility)
 */
const getAstrologicalEffect = (method, astroState) => {
    var _a, _b, _c;
    const methodData = methods_1.allCookingMethods[method];
    if (!methodData || !methodData.astrologicalInfluences)
        return 0.5;
    let effectScore = 0.5; // Neutral score as default
    // Check zodiac sign
    if (astroState.sunSign &&
        ((_a = methodData.astrologicalInfluences.favorableZodiac) === null || _a === void 0 ? void 0 : _a.includes(astroState.sunSign))) {
        effectScore += 0.2;
    }
    else if (astroState.sunSign &&
        ((_b = methodData.astrologicalInfluences.unfavorableZodiac) === null || _b === void 0 ? void 0 : _b.includes(astroState.sunSign))) {
        effectScore -= 0.2;
    }
    // Check lunar phase if available
    if (astroState.lunarPhase &&
        ((_c = methodData.astrologicalInfluences.lunarPhaseEffect) === null || _c === void 0 ? void 0 : _c[astroState.lunarPhase])) {
        effectScore *=
            methodData.astrologicalInfluences.lunarPhaseEffect[astroState.lunarPhase];
    }
    // Keep score within 0.0-1.0 range
    return Math.max(0.0, Math.min(1.0, effectScore));
};
exports.getAstrologicalEffect = getAstrologicalEffect;
/**
 * Calculate modified elemental effect for a cooking method (simplified version for backwards compatibility)
 */
const calculateModifiedElementalEffect = (method, astroState, duration, _temperature, _currentSeason) => {
    const methodData = methods_1.allCookingMethods[method];
    if (!methodData || !methodData.elementalEffect) {
        return { Fire: 0.25, Water: 0.25, Earth: 0.25, Air: 0.25 };
    }
    // Start with base elemental effect
    const baseEffect = { ...methodData.elementalEffect };
    // Apply duration modifier (simplified)
    const normalizedDuration = Math.min(1.0, duration / (methodData.duration.max || 60));
    if (normalizedDuration > 0.7) {
        // Longer cooking enhances Fire and reduces Water
        baseEffect.Fire = Math.min(1.0, (baseEffect.Fire || 0) * 1.2);
        baseEffect.Water = Math.max(0.0, (baseEffect.Water || 0) * 0.8);
    }
    // Return the modified effect
    return baseEffect;
};
exports.calculateModifiedElementalEffect = calculateModifiedElementalEffect;
const methods_2 = require("./methods");
Object.defineProperty(exports, "dryCookingMethods", { enumerable: true, get: function () { return methods_2.dryCookingMethods; } });
Object.defineProperty(exports, "wetCookingMethods", { enumerable: true, get: function () { return methods_2.wetCookingMethods; } });
Object.defineProperty(exports, "molecularCookingMethods", { enumerable: true, get: function () { return methods_2.molecularCookingMethods; } });
Object.defineProperty(exports, "traditionalCookingMethods", { enumerable: true, get: function () { return methods_2.traditionalCookingMethods; } });
Object.defineProperty(exports, "rawCookingMethods", { enumerable: true, get: function () { return methods_2.rawCookingMethods; } });
/**
 * Get a specific cooking method by name
 * @param name The name of the cooking method to retrieve
 * @returns The cooking method data or undefined if not found
 */
function getCookingMethod(name) {
    return methods_1.allCookingMethods[name] || methods_1.allCookingMethods[name.toLowerCase()];
}
exports.getCookingMethod = getCookingMethod;
/**
 * Get multiple cooking methods by name
 * @param names Array of cooking method names to retrieve
 * @returns Object containing the requested cooking methods (key: name, value: data)
 */
function getCookingMethods(names) {
    return names.reduce((methods, name) => {
        const method = getCookingMethod(name);
        if (method) {
            methods[name] = method;
        }
        return methods;
    }, {});
}
exports.getCookingMethods = getCookingMethods;
/**
 * Get all available cooking method names
 * @returns Array of all cooking method names
 */
function getAllCookingMethodNames() {
    return Object.keys(methods_1.allCookingMethods);
}
exports.getAllCookingMethodNames = getAllCookingMethodNames;
/**
 * Get cooking methods by category
 * @param category The category name: 'dry', 'wet', 'molecular', 'traditional', 'raw'
 * @returns Record of cooking methods in that category or empty object if category not found
 */
function getCookingMethodsByCategory(category) {
    switch (category.toLowerCase()) {
        case 'dry':
            return methods_2.dryCookingMethods;
        case 'wet':
            return methods_2.wetCookingMethods;
        case 'molecular':
            return methods_2.molecularCookingMethods;
        case 'traditional':
            return methods_2.traditionalCookingMethods;
        case 'raw':
            return methods_2.rawCookingMethods;
        default:
            return {};
    }
}
exports.getCookingMethodsByCategory = getCookingMethodsByCategory;
/**
 * Filter cooking methods by temperature range
 * @param minTemp Minimum temperature in Fahrenheit
 * @param maxTemp Maximum temperature in Fahrenheit
 * @returns Cooking methods that operate within the specified temperature range
 */
function getCookingMethodsByTemperature(minTemp, maxTemp) {
    return Object.entries(methods_1.allCookingMethods)
        .filter(([_, method]) => {
        // Apply safe type casting for method property access
        const methodData = method;
        // Check if the method has optimal temperatures and at least one falls within range
        if (!(methodData === null || methodData === void 0 ? void 0 : methodData.optimalTemperatures))
            return false;
        return Object.values(methodData.optimalTemperatures).some((temp) => {
            // Pattern KK-10: Final Arithmetic Elimination for data layer operations
            const numericTemp = Number(temp) || 0;
            const numericMinTemp = Number(minTemp) || 0;
            const numericMaxTemp = Number(maxTemp) || 999;
            return numericTemp >= numericMinTemp && numericTemp <= numericMaxTemp;
        });
    })
        .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
}
exports.getCookingMethodsByTemperature = getCookingMethodsByTemperature;
/**
 * Get cooking methods sorted by sustainability rating
 * @param descending Whether to sort in descending order (most sustainable first)
 * @returns Array of cooking methods sorted by sustainability rating
 */
function getCookingMethodsBySustainability(descending = true) {
    return Object.values(methods_1.allCookingMethods)
        .filter((method) => {
        // Apply safe type casting for method property access
        const methodData = method;
        return (methodData === null || methodData === void 0 ? void 0 : methodData.sustainabilityRating) !== undefined;
    })
        .sort((a, b) => {
        // Apply safe type casting for method property access
        const aData = a;
        const bData = b;
        const aRating = (aData === null || aData === void 0 ? void 0 : aData.sustainabilityRating) || 0;
        const bRating = (bData === null || bData === void 0 ? void 0 : bData.sustainabilityRating) || 0;
        return descending ? bRating - aRating : aRating - bRating;
    });
}
exports.getCookingMethodsBySustainability = getCookingMethodsBySustainability;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9kYXRhL2Nvb2tpbmcvaW5kZXgudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0dBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsZ0RBQWdEO0FBQ2hELDRDQUEwQjtBQUUxQix1RUFBdUU7QUFDdkUsdUNBTW1CO0FBZ0hqQixrR0FySEEsMkJBQWlCLE9BcUhBO0FBOUduQiw2RkFBNkY7QUFDaEYsUUFBQSxjQUFjLEdBQUcsMkJBQWlCLENBQUM7QUFVaEQ7O0dBRUc7QUFDSSxNQUFNLHFCQUFxQixHQUFHLENBQ25DLE1BQXFCLEVBQ3JCLFVBQTZCLEVBQ3JCLEVBQUU7O0lBQ1YsTUFBTSxVQUFVLEdBQUcsMkJBQWlCLENBQUMsTUFBbUQsQ0FBQyxDQUFDO0lBQzFGLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCO1FBQUUsT0FBTyxHQUFHLENBQUM7SUFFbEUsSUFBSSxXQUFXLEdBQUcsR0FBRyxDQUFDLENBQUMsMkJBQTJCO0lBRWxELG9CQUFvQjtJQUNwQixJQUNFLFVBQVUsQ0FBQyxPQUFPO1NBQ2xCLE1BQUEsVUFBVSxDQUFDLHNCQUFzQixDQUFDLGVBQWUsMENBQUUsUUFBUSxDQUN6RCxVQUFVLENBQUMsT0FBTyxDQUNuQixDQUFBLEVBQ0Q7UUFDQSxXQUFXLElBQUksR0FBRyxDQUFDO0tBQ3BCO1NBQU0sSUFDTCxVQUFVLENBQUMsT0FBTztTQUNsQixNQUFBLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQyxpQkFBaUIsMENBQUUsUUFBUSxDQUMzRCxVQUFVLENBQUMsT0FBTyxDQUNuQixDQUFBLEVBQ0Q7UUFDQSxXQUFXLElBQUksR0FBRyxDQUFDO0tBQ3BCO0lBRUQsaUNBQWlDO0lBQ2pDLElBQ0UsVUFBVSxDQUFDLFVBQVU7U0FDckIsTUFBQSxVQUFVLENBQUMsc0JBQXNCLENBQUMsZ0JBQWdCLDBDQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQSxFQUMzRTtRQUNBLFdBQVc7WUFD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dFRvRWF0TmV4dC9zcmMvZGF0YS9jb29raW5nL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFpbiBjb29raW5nIGRhdGEgZW50cnkgcG9pbnRcbiAqXG4gKiBUaGlzIGZpbGUgZXhwb3J0cyBjb29raW5nIG1ldGhvZHMgZnJvbSB0aGUgbmV3IG1vZHVsYXIgc3RydWN0dXJlXG4gKi9cblxuLy8gRXhwb3J0IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgbmV3IG1ldGhvZHMgc3lzdGVtXG5leHBvcnQgKiBmcm9tICcuL21ldGhvZHMnO1xuXG4vLyBSZS1leHBvcnQgbWV0aG9kcyBmcm9tIHRoZSBtZXRob2RzIG1vZHVsZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuaW1wb3J0IHtcbiAgYWxsQ29va2luZ01ldGhvZHMsXG4gIGdldE1ldGhvZHNCeUVsZW1lbnQsXG4gIGdldE1ldGhvZHNCeVBsYW5ldCxcbiAgZ2V0TWV0aG9kc0ZvckluZ3JlZGllbnRUeXBlLFxuICBnZXRNZXRob2RzRm9yWm9kaWFjU2lnbixcbn0gZnJvbSAnLi9tZXRob2RzJztcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IC0gcHJvdmlkZSBjb29raW5nTWV0aG9kcyBleHBvcnQgZnJvbSB0aGUgbmV3IGFsbENvb2tpbmdNZXRob2RzXG5leHBvcnQgY29uc3QgY29va2luZ01ldGhvZHMgPSBhbGxDb29raW5nTWV0aG9kcztcblxuLy8gRnVuY3Rpb25zIHByZXZpb3VzbHkgaW4gY29va2luZ01ldGhvZHMudHMgbm93IHJlaW1wbGVtZW50ZWQgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmltcG9ydCB0eXBlIHtcbiAgQ29va2luZ01ldGhvZCxcbiAgRWxlbWVudGFsUHJvcGVydGllcyxcbiAgQXN0cm9sb2dpY2FsU3RhdGUsXG4gIFNlYXNvbixcbn0gZnJvbSAnQC90eXBlcy9hbGNoZW15JztcblxuLyoqXG4gKiBHZXQgYXN0cm9sb2dpY2FsIGVmZmVjdCBmb3IgYSBjb29raW5nIG1ldGhvZCAoc2ltcGxpZmllZCB2ZXJzaW9uIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFzdHJvbG9naWNhbEVmZmVjdCA9IChcbiAgbWV0aG9kOiBDb29raW5nTWV0aG9kLFxuICBhc3Ryb1N0YXRlOiBBc3Ryb2xvZ2ljYWxTdGF0ZVxuKTogbnVtYmVyID0+IHtcbiAgY29uc3QgbWV0aG9kRGF0YSA9IGFsbENvb2tpbmdNZXRob2RzW21ldGhvZCBhcyB1bmtub3duIGFzIGtleW9mIHR5cGVvZiBhbGxDb29raW5nTWV0aG9kc107XG4gIGlmICghbWV0aG9kRGF0YSB8fCAhbWV0aG9kRGF0YS5hc3Ryb2xvZ2ljYWxJbmZsdWVuY2VzKSByZXR1cm4gMC41O1xuXG4gIGxldCBlZmZlY3RTY29yZSA9IDAuNTsgLy8gTmV1dHJhbCBzY29yZSBhcyBkZWZhdWx0XG5cbiAgLy8gQ2hlY2sgem9kaWFjIHNpZ25cbiAgaWYgKFxuICAgIGFzdHJvU3RhdGUuc3VuU2lnbiAmJlxuICAgIG1ldGhvZERhdGEuYXN0cm9sb2dpY2FsSW5mbHVlbmNlcy5mYXZvcmFibGVab2RpYWM/LmluY2x1ZGVzKFxuICAgICAgYXN0cm9TdGF0ZS5zdW5TaWduXG4gICAgKVxuICApIHtcbiAgICBlZmZlY3RTY29yZSArPSAwLjI7XG4gIH0gZWxzZSBpZiAoXG4gICAgYXN0cm9TdGF0ZS5zdW5TaWduICYmXG4gICAgbWV0aG9kRGF0YS5hc3Ryb2xvZ2ljYWxJbmZsdWVuY2VzLnVuZmF2b3JhYmxlWm9kaWFjPy5pbmNsdWRlcyhcbiAgICAgIGFzdHJvU3RhdGUuc3VuU2lnblxuICAgIClcbiAgKSB7XG4gICAgZWZmZWN0U2NvcmUgLT0gMC4yO1xuICB9XG5cbiAgLy8gQ2hlY2sgbHVuYXIgcGhhc2UgaWYgYXZhaWxhYmxlXG4gIGlmIChcbiAgICBhc3Ryb1N0YXRlLmx1bmFyUGhhc2UgJiZcbiAgICBtZXRob2REYXRhLmFzdHJvbG9naWNhbEluZmx1ZW5jZXMubHVuYXJQaGFzZUVmZmVjdD8uW2FzdHJvU3RhdGUubHVuYXJQaGFzZV1cbiAgKSB7XG4gICAgZWZmZWN0U2NvcmUgKj1cbiAgICAgIG1ldGhvZERhdGEuYXN0cm9sb2dpY2FsSW5mbHVlbmNlcy5sdW5hclBoYXNlRWZmZWN0W2FzdHJvU3RhdGUubHVuYXJQaGFzZV07XG4gIH1cblxuICAvLyBLZWVwIHNjb3JlIHdpdGhpbiAwLjAtMS4wIHJhbmdlXG4gIHJldHVybiBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgZWZmZWN0U2NvcmUpKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1vZGlmaWVkIGVsZW1lbnRhbCBlZmZlY3QgZm9yIGEgY29va2luZyBtZXRob2QgKHNpbXBsaWZpZWQgdmVyc2lvbiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVNb2RpZmllZEVsZW1lbnRhbEVmZmVjdCA9IChcbiAgbWV0aG9kOiBDb29raW5nTWV0aG9kLFxuICBhc3Ryb1N0YXRlOiBBc3Ryb2xvZ2ljYWxTdGF0ZSxcbiAgZHVyYXRpb246IG51bWJlcixcbiAgX3RlbXBlcmF0dXJlPzogbnVtYmVyLFxuICBfY3VycmVudFNlYXNvbj86IFNlYXNvblxuKTogRWxlbWVudGFsUHJvcGVydGllcyA9PiB7XG4gIGNvbnN0IG1ldGhvZERhdGEgPSBhbGxDb29raW5nTWV0aG9kc1ttZXRob2QgYXMgdW5rbm93biBhcyBrZXlvZiB0eXBlb2YgYWxsQ29va2luZ01ldGhvZHNdO1xuICBpZiAoIW1ldGhvZERhdGEgfHwgIW1ldGhvZERhdGEuZWxlbWVudGFsRWZmZWN0KSB7XG4gICAgcmV0dXJuIHsgRmlyZTogMC4yNSwgV2F0ZXI6IDAuMjUsIEVhcnRoOiAwLjI1LCBBaXI6IDAuMjUgfTtcbiAgfVxuXG4gIC8vIFN0YXJ0IHdpdGggYmFzZSBlbGVtZW50YWwgZWZmZWN0XG4gIGNvbnN0IGJhc2VFZmZlY3QgPSB7IC4uLm1ldGhvZERhdGEuZWxlbWVudGFsRWZmZWN0IH07XG5cbiAgLy8gQXBwbHkgZHVyYXRpb24gbW9kaWZpZXIgKHNpbXBsaWZpZWQpXG4gIGNvbnN0IG5vcm1hbGl6ZWREdXJhdGlvbiA9IE1hdGgubWluKFxuICAgIDEuMCxcbiAgICBkdXJhdGlvbiAvIChtZXRob2REYXRhLmR1cmF0aW9uLm1heCB8fCA2MClcbiAgKTtcbiAgaWYgKG5vcm1hbGl6ZWREdXJhdGlvbiA+IDAuNykge1xuICAgIC8vIExvbmdlciBjb29raW5nIGVuaGFuY2VzIEZpcmUgYW5kIHJlZHVjZXMgV2F0ZXJcbiAgICBiYXNlRWZmZWN0LkZpcmUgPSBNYXRoLm1pbigxLjAsIChiYXNlRWZmZWN0LkZpcmUgfHwgMCkgKiAxLjIpO1xuICAgIGJhc2VFZmZlY3QuV2F0ZXIgPSBNYXRoLm1heCgwLjAsIChiYXNlRWZmZWN0LldhdGVyIHx8IDApICogMC44KTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgZWZmZWN0XG4gIHJldHVybiBiYXNlRWZmZWN0O1xufTtcblxuLy8gRXhwb3J0IGludGVyZmFjZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBpbnRlcmZhY2UgQ29va2luZ1N0YXRlIHtcbiAgbWV0aG9kOiBDb29raW5nTWV0aG9kO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbiAgYXN0cm9sb2dpY2FsU3RhdGU6IEFzdHJvbG9naWNhbFN0YXRlO1xuICBtb2RpZmllcnM/OiB7XG4gICAgc2Vhc29uaW5ncz86IHN0cmluZ1tdO1xuICAgIHRlY2huaXF1ZXM/OiBzdHJpbmdbXTtcbiAgfTtcbn1cblxuaW1wb3J0IHtcbiAgZHJ5Q29va2luZ01ldGhvZHMsXG4gIHdldENvb2tpbmdNZXRob2RzLFxuICBtb2xlY3VsYXJDb29raW5nTWV0aG9kcyxcbiAgdHJhZGl0aW9uYWxDb29raW5nTWV0aG9kcyxcbiAgcmF3Q29va2luZ01ldGhvZHMsXG59IGZyb20gJy4vbWV0aG9kcyc7XG5cbmltcG9ydCB0eXBlIHsgQ29va2luZ01ldGhvZERhdGEgfSBmcm9tICdAL3R5cGVzL2Nvb2tpbmdNZXRob2QnO1xuXG4vLyBSZS1leHBvcnQgZXZlcnl0aGluZ1xuZXhwb3J0IHtcbiAgYWxsQ29va2luZ01ldGhvZHMsXG4gIGRyeUNvb2tpbmdNZXRob2RzLFxuICB3ZXRDb29raW5nTWV0aG9kcyxcbiAgbW9sZWN1bGFyQ29va2luZ01ldGhvZHMsXG4gIHRyYWRpdGlvbmFsQ29va2luZ01ldGhvZHMsXG4gIHJhd0Nvb2tpbmdNZXRob2RzLFxufTtcblxuLyoqXG4gKiBHZXQgYSBzcGVjaWZpYyBjb29raW5nIG1ldGhvZCBieSBuYW1lXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2luZyBtZXRob2QgdG8gcmV0cmlldmVcbiAqIEByZXR1cm5zIFRoZSBjb29raW5nIG1ldGhvZCBkYXRhIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb2tpbmdNZXRob2QobmFtZTogc3RyaW5nKTogQ29va2luZ01ldGhvZERhdGEgfCB1bmRlZmluZWQge1xuICByZXR1cm4gYWxsQ29va2luZ01ldGhvZHNbbmFtZV0gfHwgYWxsQ29va2luZ01ldGhvZHNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn1cblxuLyoqXG4gKiBHZXQgbXVsdGlwbGUgY29va2luZyBtZXRob2RzIGJ5IG5hbWVcbiAqIEBwYXJhbSBuYW1lcyBBcnJheSBvZiBjb29raW5nIG1ldGhvZCBuYW1lcyB0byByZXRyaWV2ZVxuICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBjb29raW5nIG1ldGhvZHMgKGtleTogbmFtZSwgdmFsdWU6IGRhdGEpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29raW5nTWV0aG9kcyhcbiAgbmFtZXM6IHN0cmluZ1tdXG4pOiBSZWNvcmQ8c3RyaW5nLCBDb29raW5nTWV0aG9kRGF0YT4ge1xuICByZXR1cm4gbmFtZXMucmVkdWNlKChtZXRob2RzLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gZ2V0Q29va2luZ01ldGhvZChuYW1lKTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBtZXRob2RzW25hbWVdID0gbWV0aG9kO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kcztcbiAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgQ29va2luZ01ldGhvZERhdGE+KTtcbn1cblxuLyoqXG4gKiBHZXQgYWxsIGF2YWlsYWJsZSBjb29raW5nIG1ldGhvZCBuYW1lc1xuICogQHJldHVybnMgQXJyYXkgb2YgYWxsIGNvb2tpbmcgbWV0aG9kIG5hbWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb29raW5nTWV0aG9kTmFtZXMoKTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMoYWxsQ29va2luZ01ldGhvZHMpO1xufVxuXG4vKipcbiAqIEdldCBjb29raW5nIG1ldGhvZHMgYnkgY2F0ZWdvcnlcbiAqIEBwYXJhbSBjYXRlZ29yeSBUaGUgY2F0ZWdvcnkgbmFtZTogJ2RyeScsICd3ZXQnLCAnbW9sZWN1bGFyJywgJ3RyYWRpdGlvbmFsJywgJ3JhdydcbiAqIEByZXR1cm5zIFJlY29yZCBvZiBjb29raW5nIG1ldGhvZHMgaW4gdGhhdCBjYXRlZ29yeSBvciBlbXB0eSBvYmplY3QgaWYgY2F0ZWdvcnkgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29raW5nTWV0aG9kc0J5Q2F0ZWdvcnkoXG4gIGNhdGVnb3J5OiBzdHJpbmdcbik6IFJlY29yZDxzdHJpbmcsIENvb2tpbmdNZXRob2REYXRhPiB7XG4gIHN3aXRjaCAoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2RyeSc6XG4gICAgICByZXR1cm4gZHJ5Q29va2luZ01ldGhvZHM7XG4gICAgY2FzZSAnd2V0JzpcbiAgICAgIHJldHVybiB3ZXRDb29raW5nTWV0aG9kcztcbiAgICBjYXNlICdtb2xlY3VsYXInOlxuICAgICAgcmV0dXJuIG1vbGVjdWxhckNvb2tpbmdNZXRob2RzO1xuICAgIGNhc2UgJ3RyYWRpdGlvbmFsJzpcbiAgICAgIHJldHVybiB0cmFkaXRpb25hbENvb2tpbmdNZXRob2RzO1xuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gcmF3Q29va2luZ01ldGhvZHM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEZpbHRlciBjb29raW5nIG1ldGhvZHMgYnkgdGVtcGVyYXR1cmUgcmFuZ2VcbiAqIEBwYXJhbSBtaW5UZW1wIE1pbmltdW0gdGVtcGVyYXR1cmUgaW4gRmFocmVuaGVpdFxuICogQHBhcmFtIG1heFRlbXAgTWF4aW11bSB0ZW1wZXJhdHVyZSBpbiBGYWhyZW5oZWl0XG4gKiBAcmV0dXJucyBDb29raW5nIG1ldGhvZHMgdGhhdCBvcGVyYXRlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRlbXBlcmF0dXJlIHJhbmdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29raW5nTWV0aG9kc0J5VGVtcGVyYXR1cmUoXG4gIG1pblRlbXA6IG51bWJlcixcbiAgbWF4VGVtcDogbnVtYmVyXG4pOiBSZWNvcmQ8c3RyaW5nLCBDb29raW5nTWV0aG9kRGF0YT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYWxsQ29va2luZ01ldGhvZHMpXG4gICAgLmZpbHRlcigoW18sIG1ldGhvZF0pID0+IHtcbiAgICAgIC8vIEFwcGx5IHNhZmUgdHlwZSBjYXN0aW5nIGZvciBtZXRob2QgcHJvcGVydHkgYWNjZXNzXG4gICAgICBjb25zdCBtZXRob2REYXRhID0gbWV0aG9kIGFzIGFueTtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBtZXRob2QgaGFzIG9wdGltYWwgdGVtcGVyYXR1cmVzIGFuZCBhdCBsZWFzdCBvbmUgZmFsbHMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoIW1ldGhvZERhdGE/Lm9wdGltYWxUZW1wZXJhdHVyZXMpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWV0aG9kRGF0YS5vcHRpbWFsVGVtcGVyYXR1cmVzKS5zb21lKFxuICAgICAgICAodGVtcCkgPT4ge1xuICAgICAgICAgIC8vIFBhdHRlcm4gS0stMTA6IEZpbmFsIEFyaXRobWV0aWMgRWxpbWluYXRpb24gZm9yIGRhdGEgbGF5ZXIgb3BlcmF0aW9uc1xuICAgICAgICAgIGNvbnN0IG51bWVyaWNUZW1wID0gTnVtYmVyKHRlbXApIHx8IDA7XG4gICAgICAgICAgY29uc3QgbnVtZXJpY01pblRlbXAgPSBOdW1iZXIobWluVGVtcCkgfHwgMDtcbiAgICAgICAgICBjb25zdCBudW1lcmljTWF4VGVtcCA9IE51bWJlcihtYXhUZW1wKSB8fCA5OTk7XG4gICAgICAgICAgcmV0dXJuIG51bWVyaWNUZW1wID49IG51bWVyaWNNaW5UZW1wICYmIG51bWVyaWNUZW1wIDw9IG51bWVyaWNNYXhUZW1wO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pXG4gICAgLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+ICh7IC4uLmFjYywgW2tleV06IHZhbHVlIH0pLCB7fSk7XG59XG5cbi8qKlxuICogR2V0IGNvb2tpbmcgbWV0aG9kcyBzb3J0ZWQgYnkgc3VzdGFpbmFiaWxpdHkgcmF0aW5nXG4gKiBAcGFyYW0gZGVzY2VuZGluZyBXaGV0aGVyIHRvIHNvcnQgaW4gZGVzY2VuZGluZyBvcmRlciAobW9zdCBzdXN0YWluYWJsZSBmaXJzdClcbiAqIEByZXR1cm5zIEFycmF5IG9mIGNvb2tpbmcgbWV0aG9kcyBzb3J0ZWQgYnkgc3VzdGFpbmFiaWxpdHkgcmF0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29raW5nTWV0aG9kc0J5U3VzdGFpbmFiaWxpdHkoXG4gIGRlc2NlbmRpbmcgPSB0cnVlXG4pOiBDb29raW5nTWV0aG9kRGF0YVtdIHtcbiAgcmV0dXJuIChPYmplY3QudmFsdWVzKGFsbENvb2tpbmdNZXRob2RzKSBhcyBDb29raW5nTWV0aG9kRGF0YVtdKVxuICAgIC5maWx0ZXIoKG1ldGhvZCkgPT4ge1xuICAgICAgLy8gQXBwbHkgc2FmZSB0eXBlIGNhc3RpbmcgZm9yIG1ldGhvZCBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgIGNvbnN0IG1ldGhvZERhdGEgPSBtZXRob2QgYXMgYW55O1xuICAgICAgcmV0dXJuIG1ldGhvZERhdGE/LnN1c3RhaW5hYmlsaXR5UmF0aW5nICE9PSB1bmRlZmluZWQ7XG4gICAgfSlcbiAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gQXBwbHkgc2FmZSB0eXBlIGNhc3RpbmcgZm9yIG1ldGhvZCBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgIGNvbnN0IGFEYXRhID0gYSBhcyBhbnk7XG4gICAgICBjb25zdCBiRGF0YSA9IGIgYXMgYW55O1xuICAgICAgY29uc3QgYVJhdGluZyA9IGFEYXRhPy5zdXN0YWluYWJpbGl0eVJhdGluZyB8fCAwO1xuICAgICAgY29uc3QgYlJhdGluZyA9IGJEYXRhPy5zdXN0YWluYWJpbGl0eVJhdGluZyB8fCAwO1xuICAgICAgcmV0dXJuIGRlc2NlbmRpbmcgPyBiUmF0aW5nIC0gYVJhdGluZyA6IGFSYXRpbmcgLSBiUmF0aW5nO1xuICAgIH0pO1xufVxuIl0sInZlcnNpb24iOjN9