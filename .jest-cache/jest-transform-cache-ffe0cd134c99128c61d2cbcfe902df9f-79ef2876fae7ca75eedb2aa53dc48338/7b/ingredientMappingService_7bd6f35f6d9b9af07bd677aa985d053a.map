{"file":"/Users/GregCastro/Desktop/WhatToEatNext/src/services/ingredientMappingService.ts","mappings":"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","names":[],"sources":["/Users/GregCastro/Desktop/WhatToEatNext/src/services/ingredientMappingService.ts"],"sourcesContent":["/**\n * Ingredient Mapping Service\n * \n * Provides centralized functionality for mapping recipe ingredients\n * to their corresponding ingredient database entries.\n */\n\nimport { connectIngredientsToMappings } from '@/utils/recipeMatching';\nimport { filterRecipesByIngredientMappings } from '@/utils/recipeFilters';\nimport { ingredientsMap } from '@/data/ingredients';\nimport { cuisinesMap } from '@/data/cuisines';\nimport type { Recipe } from '@/types/recipe';\nimport type { ElementalProperties, IngredientMapping } from '@/types/alchemy';\n\n/**\n * Unified service for ingredient mapping operations\n */\nclass IngredientMappingService {\n  /**\n   * Map ingredients from a recipe to their corresponding database entries\n   */\n  mapRecipeIngredients(recipe: Recipe) {\n    // Pattern HH: Safe Recipe type casting for connectIngredientsToMappings with proper import resolution\n    return connectIngredientsToMappings(recipe as unknown);\n  }\n\n  /**\n   * Find recipes that match specific elemental and ingredient requirements\n   */\n  findMatchingRecipes(\n    options: {\n      elementalTarget?: ElementalProperties;\n      requiredIngredients?: string[];\n      excludedIngredients?: string[];\n      dietaryRestrictions?: string[];\n      emphasizedIngredients?: string[];\n      cuisineType?: string;\n      mealType?: string;\n      season?: string;\n    } = {}\n  ) {\n    // Collect recipes based on filters\n    const allRecipes: Recipe[] = [];\n    \n    // Filter by cuisine if specified\n    const cuisines = options.cuisineType \n      ? [cuisinesMap[options.cuisineType as keyof typeof cuisinesMap]].filter(Boolean)\n      : Object.values(cuisinesMap);\n    \n    // Collect recipes from specified cuisines\n    cuisines.forEach(cuisine => {\n      if (!cuisine?.dishes) return;\n      \n      // Define which meal types to include\n      const mealTypes = options.mealType\n        ? [options.mealType as keyof typeof cuisine.dishes].filter(mealType => \n            cuisine.dishes[mealType as keyof typeof cuisine.dishes]\n          )\n        : ['breakfast', 'lunch', 'dinner', 'dessert'];\n      \n      // Define which seasons to include\n      const seasons = options.season\n        ? [options.season as 'spring' | 'summer' | 'autumn' | 'winter']\n        : ['spring', 'summer', 'autumn', 'winter'];\n      \n      // Collect recipes matching criteria\n      mealTypes.forEach(mealType => {\n        const mealDishes = cuisine.dishes[mealType as keyof typeof cuisine.dishes];\n        if (!mealDishes) return;\n        \n        seasons.forEach(season => {\n          const seasonalDishes = mealDishes[season as keyof typeof mealDishes];\n          if (Array.isArray(seasonalDishes)) {\n            // Pattern LL: Safe Recipe type casting for seasonal dishes array\n            allRecipes.push(...(seasonalDishes as any[]));\n          }\n        });\n      });\n    });\n    \n    // Use the filter function with collected recipes\n    return filterRecipesByIngredientMappings(\n      allRecipes as unknown as Recipe[],\n      options.elementalTarget,\n      {\n        required: options.requiredIngredients || [],\n        excluded: options.excludedIngredients || [],\n        dietaryRestrictions: options.dietaryRestrictions || [],\n        emphasized: options.emphasizedIngredients || []\n      }\n    );\n  }\n\n  /**\n   * Suggest alternative ingredients with similar elemental properties\n   */\n  suggestAlternativeIngredients(\n    ingredientName: string,\n    options: {\n      category?: string;\n      similarityThreshold?: number;\n      maxResults?: number;\n    } = {}\n  ) {\n    // Find the original ingredient\n    const originalIngredient = ingredientsMap[ingredientName.toLowerCase()];\n    if (!originalIngredient) {\n      return { \n        success: false, \n        message: `Ingredient '${ingredientName}' not found in database`,\n        suggestions: []\n      };\n    }\n    \n    const {\n      similarityThreshold = 0.7,\n      maxResults = 5,\n      category\n    } = options;\n    \n    // Find alternatives with similar elemental properties\n    const potentialAlternatives = Object.entries(ingredientsMap)\n      .filter(([name, mapping]) => {\n        // Skip the original ingredient\n        if (name.toLowerCase() === ingredientName.toLowerCase()) return false;\n        \n        // Filter by category if specified\n        if (category && mapping.category !== category) return false;\n        \n        // Otherwise match the original ingredient's category\n        if (!category && mapping.category !== originalIngredient.category) return false;\n        \n        // Check elemental similarity\n        const similarity = this.calculateElementalSimilarity(\n          originalIngredient.elementalProperties as unknown as ElementalProperties,\n          mapping.elementalProperties as unknown as ElementalProperties\n        );\n        \n        return similarity >= similarityThreshold;\n      })\n      .map(([name, mapping]) => ({\n        name,\n        similarity: this.calculateElementalSimilarity(\n          originalIngredient.elementalProperties as unknown as ElementalProperties, \n          mapping.elementalProperties as unknown as ElementalProperties\n        ),\n        mapping\n      }))\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, maxResults);\n    \n    return {\n      success: true,\n      original: originalIngredient,\n      suggestions: potentialAlternatives\n    };\n  }\n\n  /**\n   * Calculate elemental compatibility between two ingredients\n   */\n  calculateCompatibility(\n    ingredient1: string | IngredientMapping,\n    ingredient2: string | IngredientMapping\n  ) {\n    // Convert string names to ingredient mappings if needed\n    const mapping1 = typeof ingredient1 === 'string' \n      ? ingredientsMap[ingredient1.toLowerCase()]\n      : ingredient1;\n      \n    const mapping2 = typeof ingredient2 === 'string'\n      ? ingredientsMap[ingredient2.toLowerCase()]\n      : ingredient2;\n    \n    if (!mapping1 || !mapping2) {\n      return {\n        success: false,\n        message: !mapping1 \n          ? `Ingredient '${ingredient1}' not found` \n          : `Ingredient '${ingredient2}' not found`,\n        compatibility: 0\n      };\n    }\n    \n    // Calculate base elemental similarity\n    const similarity = this.calculateElementalSimilarity(\n      mapping1.elementalProperties as unknown as ElementalProperties,\n      mapping2.elementalProperties as unknown as ElementalProperties\n    );\n    \n    // Determine compatibility type based on similarity\n    let compatibilityType = 'neutral';\n    if (similarity > 0.8) compatibilityType = 'excellent';\n    else if (similarity > 0.6) compatibilityType = 'good';\n    else if (similarity > 0.4) compatibilityType = 'fair';\n    else compatibilityType = 'poor';\n    \n    // Apply category compatibility rules\n    let categoryAdjustment = 0;\n    \n    // Some ingredients work well together despite different elements\n    const complementaryCategories: Record<string, string[]> = {\n      'protein': ['spice', 'herb', 'oil'],\n      'grain': ['vegetable', 'protein'],\n      'vegetable': ['oil', 'herb'],\n      'fruit': ['spice', 'sweetener'],\n      'dairy': ['fruit', 'sweetener'],\n      'spice': ['protein', 'vegetable', 'fruit']\n    };\n    \n    const category1 = mapping1.category as string;\n    const category2 = mapping2.category as string;\n    \n    if (category1 && category2) {\n      // Same category usually works well together\n      if (category1 === category2) {\n        categoryAdjustment = 0.1;\n      } \n      // Check for complementary categories\n      else if (\n        (complementaryCategories[category1] && complementaryCategories[category1].includes(category2)) ||\n        (complementaryCategories[category2] && complementaryCategories[category2].includes(category1))\n      ) {\n        categoryAdjustment = 0.15;\n      }\n    }\n    \n    // Adjust final compatibility score\n    const adjustedCompatibility = Math.min(1, Math.max(0, similarity + categoryAdjustment));\n    \n    return {\n      success: true,\n      compatibility: adjustedCompatibility,\n      type: compatibilityType,\n      ingredients: {\n        first: mapping1,\n        second: mapping2\n      }\n    };\n  }\n\n  /**\n   * Analyze ingredient combinations for a recipe\n   */\n  analyzeRecipeIngredientCombinations(recipe: Recipe) {\n    const mappedIngredients = this.mapRecipeIngredients(recipe);\n    const validMappings = mappedIngredients.filter(mapping => mapping.matchedTo);\n    \n    // Not enough ingredients with mappings to analyze\n    if (validMappings.length < 2) {\n      return {\n        success: false,\n        message: 'Not enough mapped ingredients to analyze combinations',\n        mappingQuality: validMappings.length / Math.max(1, recipe.ingredients.length)\n      };\n    }\n    \n    // Analyze all ingredient pairs\n    const combinations: {\n      ingredients: [string, string];\n      compatibility: number;\n      type: string;\n    }[] = [];\n    \n    for (let i = 0; i < validMappings.length; i++) {\n      for (let j = i + 1; j < validMappings.length; j++) {\n        const ing1 = validMappings[i];\n        const ing2 = validMappings[j];\n        \n        if (ing1.matchedTo && ing2.matchedTo) {\n          const result = this.calculateCompatibility(\n            ing1.matchedTo as unknown as IngredientMapping, \n            ing2.matchedTo as unknown as IngredientMapping\n          );\n          \n          if (result.success) {\n            combinations.push({\n              ingredients: [ing1.name, ing2.name],\n              compatibility: result.compatibility,\n              type: result.type\n            });\n          }\n        }\n      }\n    }\n    \n    // Calculate overall recipe harmony\n    const averageCompatibility = combinations.length > 0\n      ? combinations.reduce((sum, combo) => sum + combo.compatibility, 0) / combinations.length\n      : 0;\n    \n    // Find strongest and weakest combinations\n    const sortedCombinations = [...combinations].sort((a, b) => b.compatibility - a.compatibility);\n    \n    return {\n      success: true,\n      averageCompatibility,\n      bestCombinations: sortedCombinations.slice(0, 3),\n      weakestCombinations: sortedCombinations.slice(-3).reverse(),\n      allCombinations: combinations,\n      mappingQuality: validMappings.length / Math.max(1, recipe.ingredients.length)\n    };\n  }\n\n  /**\n   * Helper to calculate similarity between elemental properties\n   */\n  private calculateElementalSimilarity(\n    properties1: ElementalProperties,\n    properties2: ElementalProperties\n  ): number {\n    if (!properties1 || !properties2) return 0;\n    \n    // Calculate difference for each element\n    const fireDiff = Math.abs((properties1.Fire || 0) - (properties2.Fire || 0));\n    const waterDiff = Math.abs((properties1.Water || 0) - (properties2.Water || 0));\n    const earthDiff = Math.abs((properties1.Earth || 0) - (properties2.Earth || 0));\n    const airDiff = Math.abs((properties1.Air || 0) - (properties2.Air || 0));\n    \n    // Total difference (maximum possible is 4)\n    const totalDiff = fireDiff + waterDiff + earthDiff + airDiff;\n    \n    // Convert to similarity (0-1 range)\n    return 1 - (totalDiff / 4);\n  }\n}\n\n// Create singleton instance\nconst ingredientMappingService = new IngredientMappingService();\nexport default ingredientMappingService; "],"version":3}