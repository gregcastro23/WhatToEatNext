b011fc2e1357d833adb5897fc137f95c
"use strict";
/**
 * Safety Protocol System
 * Perfect Codebase Campaign - Comprehensive Safety Implementation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafetyProtocol = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const campaign_1 = require("../../types/campaign");
class SafetyProtocol {
    constructor(settings) {
        this.stashes = new Map();
        this.safetyEvents = [];
        this.stashCounter = 0;
        this.settings = settings;
        this.initializeStashTracking();
    }
    /**
     * Create a git stash with descriptive naming conventions
     */
    async createStash(description, phase) {
        var _a;
        try {
            this.stashCounter++;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const phasePrefix = phase ? `${phase}-` : '';
            const stashName = `campaign-${phasePrefix}${this.stashCounter}-${timestamp}`;
            const fullDescription = `${stashName}: ${description}`;
            // Validate git state before creating stash
            const gitValidation = await this.validateGitState();
            if (!gitValidation.success) {
                throw new Error(`Git validation failed: ${gitValidation.errors.join(', ')}`);
            }
            // Create the git stash with all files including untracked
            (0, child_process_1.execSync)(`git stash push -u -m "${fullDescription}"`, {
                encoding: 'utf8',
                stdio: 'pipe'
            });
            // Get the actual stash reference
            const stashList = (0, child_process_1.execSync)('git stash list --oneline', { encoding: 'utf8' });
            const stashRef = ((_a = stashList.split('\n')[0]) === null || _a === void 0 ? void 0 : _a.split(':')[0]) || 'stash@{0}';
            // Store stash information
            const stash = {
                id: stashName,
                description: fullDescription,
                timestamp: new Date(),
                branch: this.getCurrentBranch(),
                ref: stashRef
            };
            this.stashes.set(stashName, stash);
            this.saveStashTracking();
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.CHECKPOINT_CREATED,
                timestamp: new Date(),
                description: `Git stash created: ${stashName} (${stashRef})`,
                severity: campaign_1.SafetyEventSeverity.INFO,
                action: 'STASH_CREATE'
            });
            console.log(`📦 Created git stash: ${stashName}`);
            console.log(`   Reference: ${stashRef}`);
            console.log(`   Rollback with: git stash apply ${stashRef}`);
            return stashName;
        }
        catch (error) {
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.EMERGENCY_RECOVERY,
                timestamp: new Date(),
                description: `Failed to create git stash: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`,
                severity: campaign_1.SafetyEventSeverity.ERROR,
                action: 'STASH_FAILED'
            });
            throw new Error(`Failed to create git stash: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
        }
    }
    /**
     * Create a named checkpoint stash for specific operations
     */
    async createCheckpointStash(operation, phase) {
        const description = `Checkpoint before ${operation} in ${phase}`;
        return this.createStash(description, phase);
    }
    /**
     * Apply a specific git stash with automatic rollback scenarios
     */
    async applyStash(stashId, validateAfter = true) {
        try {
            const stash = this.stashes.get(stashId);
            if (!stash) {
                throw new Error(`Stash not found: ${stashId}`);
            }
            // Use the stored reference if available, otherwise try to find by message
            let stashRef = stash.ref;
            if (!stashRef) {
                stashRef = await this.findStashByMessage(stash.description);
            }
            // Apply the stash
            (0, child_process_1.execSync)(`git stash apply ${stashRef}`, {
                encoding: 'utf8',
                stdio: 'pipe'
            });
            // Validate after application if requested
            if (validateAfter) {
                const validation = await this.validateGitState();
                if (!validation.success) {
                    console.warn(`⚠️ Git state validation warnings after stash apply: ${validation.warnings.join(', ')}`);
                }
            }
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.ROLLBACK_TRIGGERED,
                timestamp: new Date(),
                description: `Git stash applied: ${stashId} (${stashRef})`,
                severity: campaign_1.SafetyEventSeverity.WARNING,
                action: 'STASH_APPLY'
            });
            console.log(`🔄 Applied git stash: ${stashId}`);
            console.log(`   Reference: ${stashRef}`);
        }
        catch (error) {
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.EMERGENCY_RECOVERY,
                timestamp: new Date(),
                description: `Failed to apply git stash ${stashId}: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`,
                severity: campaign_1.SafetyEventSeverity.ERROR,
                action: 'STASH_APPLY_FAILED'
            });
            throw new Error(`Failed to apply git stash ${stashId}: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
        }
    }
    /**
     * Automatically apply the most recent stash for rollback scenarios
     */
    async autoApplyLatestStash() {
        const stashes = Array.from(this.stashes.values())
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        if (stashes.length === 0) {
            throw new Error('No stashes available for automatic rollback');
        }
        const latestStash = stashes[0];
        await this.applyStash(latestStash.id);
        return latestStash.id;
    }
    /**
     * Apply stash by phase for targeted rollbacks
     */
    async applyStashByPhase(phase) {
        const phaseStashes = Array.from(this.stashes.values())
            .filter(stash => stash.id.includes(`-${phase}-`))
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        if (phaseStashes.length === 0) {
            throw new Error(`No stashes found for phase: ${phase}`);
        }
        const latestPhaseStash = phaseStashes[0];
        await this.applyStash(latestPhaseStash.id);
        return latestPhaseStash.id;
    }
    /**
     * List all campaign stashes
     */
    async listStashes() {
        return Array.from(this.stashes.values());
    }
    /**
     * Detect file corruption using comprehensive syntax validation patterns
     */
    async detectCorruption(files) {
        const detectedFiles = [];
        const corruptionPatterns = [];
        let maxSeverity = campaign_1.CorruptionSeverity.LOW;
        console.log(`🔍 Analyzing ${files.length} files for corruption patterns...`);
        for (const filePath of files) {
            if (!fs.existsSync(filePath)) {
                console.warn(`⚠️ File not found: ${filePath}`);
                continue;
            }
            try {
                const content = fs.readFileSync(filePath, 'utf8');
                const fileCorruption = this.analyzeFileCorruption(filePath, content);
                if (fileCorruption.patterns.length > 0) {
                    detectedFiles.push(filePath);
                    corruptionPatterns.push(...fileCorruption.patterns);
                    console.log(`🚨 Corruption detected in ${filePath}: ${fileCorruption.patterns.length} patterns`);
                    // Update max severity
                    if (fileCorruption.severity === campaign_1.CorruptionSeverity.CRITICAL) {
                        maxSeverity = campaign_1.CorruptionSeverity.CRITICAL;
                    }
                    else if (fileCorruption.severity === campaign_1.CorruptionSeverity.HIGH && maxSeverity !== campaign_1.CorruptionSeverity.CRITICAL) {
                        maxSeverity = campaign_1.CorruptionSeverity.HIGH;
                    }
                    else if (fileCorruption.severity === campaign_1.CorruptionSeverity.MEDIUM && maxSeverity === campaign_1.CorruptionSeverity.LOW) {
                        maxSeverity = campaign_1.CorruptionSeverity.MEDIUM;
                    }
                }
            }
            catch (error) {
                // File read error might indicate corruption
                detectedFiles.push(filePath);
                corruptionPatterns.push({
                    pattern: 'FILE_READ_ERROR',
                    description: `Cannot read file: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`,
                    files: [filePath]
                });
                maxSeverity = campaign_1.CorruptionSeverity.HIGH;
                console.error(`❌ File read error in ${filePath}: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
            }
        }
        const recommendedAction = this.determineRecoveryAction(maxSeverity, detectedFiles.length);
        const report = {
            detectedFiles,
            corruptionPatterns,
            severity: maxSeverity,
            recommendedAction
        };
        if (detectedFiles.length > 0) {
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.CORRUPTION_DETECTED,
                timestamp: new Date(),
                description: `Corruption detected in ${detectedFiles.length} files (${maxSeverity} severity)`,
                severity: this.mapCorruptionToEventSeverity(maxSeverity),
                action: 'CORRUPTION_DETECTED'
            });
            console.log(`📊 Corruption analysis complete: ${detectedFiles.length} files affected, severity: ${maxSeverity}`);
        }
        else {
            console.log(`✅ No corruption detected in ${files.length} files`);
        }
        return report;
    }
    /**
     * Detect import/export corruption based on existing script knowledge
     */
    async detectImportExportCorruption(files) {
        const detectedFiles = [];
        const corruptionPatterns = [];
        let maxSeverity = campaign_1.CorruptionSeverity.LOW;
        console.log(`🔍 Analyzing import/export corruption in ${files.length} files...`);
        for (const filePath of files) {
            if (!fs.existsSync(filePath) || !filePath.match(/\.(ts|tsx|js|jsx)$/)) {
                continue;
            }
            try {
                const content = fs.readFileSync(filePath, 'utf8');
                const importExportCorruption = this.analyzeImportExportCorruption(filePath, content);
                if (importExportCorruption.patterns.length > 0) {
                    detectedFiles.push(filePath);
                    corruptionPatterns.push(...importExportCorruption.patterns);
                    if (importExportCorruption.severity === campaign_1.CorruptionSeverity.CRITICAL) {
                        maxSeverity = campaign_1.CorruptionSeverity.CRITICAL;
                    }
                    else if (importExportCorruption.severity === campaign_1.CorruptionSeverity.HIGH && maxSeverity !== campaign_1.CorruptionSeverity.CRITICAL) {
                        maxSeverity = campaign_1.CorruptionSeverity.HIGH;
                    }
                    else if (importExportCorruption.severity === campaign_1.CorruptionSeverity.MEDIUM && maxSeverity === campaign_1.CorruptionSeverity.LOW) {
                        maxSeverity = campaign_1.CorruptionSeverity.MEDIUM;
                    }
                }
            }
            catch (error) {
                console.error(`❌ Error analyzing import/export corruption in ${filePath}: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
            }
        }
        const recommendedAction = this.determineRecoveryAction(maxSeverity, detectedFiles.length);
        return {
            detectedFiles,
            corruptionPatterns,
            severity: maxSeverity,
            recommendedAction
        };
    }
    /**
     * Real-time monitoring during script execution
     */
    async startRealTimeMonitoring(files, intervalMs = 5000) {
        console.log(`🔄 Starting real-time corruption monitoring for ${files.length} files...`);
        const monitoringInterval = setInterval(async () => {
            try {
                const report = await this.detectCorruption(files);
                if (report.detectedFiles.length > 0) {
                    console.warn(`⚠️ Real-time monitoring detected corruption in ${report.detectedFiles.length} files`);
                    this.addSafetyEvent({
                        type: campaign_1.SafetyEventType.CORRUPTION_DETECTED,
                        timestamp: new Date(),
                        description: `Real-time monitoring detected corruption: ${report.severity}`,
                        severity: this.mapCorruptionToEventSeverity(report.severity),
                        action: 'REALTIME_CORRUPTION_DETECTED'
                    });
                    // If critical corruption is detected, trigger emergency rollback
                    if (report.severity === campaign_1.CorruptionSeverity.CRITICAL && this.settings.automaticRollbackEnabled) {
                        console.error(`🚨 Critical corruption detected! Triggering emergency rollback...`);
                        clearInterval(monitoringInterval);
                        await this.emergencyRollback();
                        return;
                    }
                }
            }
            catch (error) {
                console.error(`❌ Error during real-time monitoring: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
            }
        }, intervalMs);
        // Store the interval ID for cleanup
        this.monitoringInterval = monitoringInterval;
    }
    /**
     * Stop real-time monitoring
     */
    stopRealTimeMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
            console.log(`⏹️ Real-time corruption monitoring stopped`);
        }
    }
    /**
     * Validate syntax using TypeScript compiler
     */
    async validateSyntaxWithTypeScript(files) {
        const detectedFiles = [];
        const corruptionPatterns = [];
        let maxSeverity = campaign_1.CorruptionSeverity.LOW;
        console.log(`🔍 Validating syntax with TypeScript compiler for ${files.length} files...`);
        try {
            // Run TypeScript compiler to check for syntax errors
            const tsFiles = files.filter(f => f.match(/\.(ts|tsx)$/));
            if (tsFiles.length === 0) {
                return { detectedFiles, corruptionPatterns, severity: maxSeverity, recommendedAction: campaign_1.RecoveryAction.CONTINUE };
            }
            const tscOutput = (0, child_process_1.execSync)('yarn tsc --noEmit --skipLibCheck 2>&1', {
                encoding: 'utf8',
                stdio: 'pipe'
            });
            // Parse TypeScript compiler output for syntax errors
            const lines = tscOutput.split('\n');
            for (const line of lines) {
                if (line.includes('error TS') && (line.includes('Unexpected token') || line.includes('Expression expected'))) {
                    const fileMatch = line.match(/^([^(]+)\(/);
                    if (fileMatch) {
                        const filePath = fileMatch[1];
                        if (files.includes(filePath) && !detectedFiles.includes(filePath)) {
                            detectedFiles.push(filePath);
                            corruptionPatterns.push({
                                pattern: 'TYPESCRIPT_SYNTAX_ERROR',
                                description: line.trim(),
                                files: [filePath]
                            });
                            maxSeverity = campaign_1.CorruptionSeverity.HIGH;
                        }
                    }
                }
            }
        }
        catch (error) {
            // TypeScript compiler errors might indicate syntax corruption
            const errorOutput = error.stdout || error.message;
            if (errorOutput.includes('Unexpected token') || errorOutput.includes('Expression expected')) {
                maxSeverity = campaign_1.CorruptionSeverity.HIGH;
                corruptionPatterns.push({
                    pattern: 'TYPESCRIPT_COMPILATION_ERROR',
                    description: `TypeScript compilation failed: ${errorOutput}`,
                    files: files.filter(f => f.match(/\.(ts|tsx)$/))
                });
            }
        }
        const recommendedAction = this.determineRecoveryAction(maxSeverity, detectedFiles.length);
        return {
            detectedFiles,
            corruptionPatterns,
            severity: maxSeverity,
            recommendedAction
        };
    }
    /**
     * Emergency rollback to clean state
     */
    async emergencyRollback() {
        try {
            // Get the most recent stash
            const stashes = Array.from(this.stashes.values())
                .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
            if (stashes.length === 0) {
                throw new Error('No stashes available for emergency rollback');
            }
            const latestStash = stashes[0];
            await this.applyStash(latestStash.id);
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.EMERGENCY_RECOVERY,
                timestamp: new Date(),
                description: `Emergency rollback completed using stash: ${latestStash.id}`,
                severity: campaign_1.SafetyEventSeverity.WARNING,
                action: 'EMERGENCY_ROLLBACK'
            });
            console.log(`🚨 Emergency rollback completed using stash: ${latestStash.id}`);
        }
        catch (error) {
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.EMERGENCY_RECOVERY,
                timestamp: new Date(),
                description: `Emergency rollback failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`,
                severity: campaign_1.SafetyEventSeverity.CRITICAL,
                action: 'EMERGENCY_ROLLBACK_FAILED'
            });
            throw new Error(`Emergency rollback failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
        }
    }
    /**
     * Validate git repository state
     */
    async validateGitState() {
        try {
            // Check if git repo exists
            if (!fs.existsSync('.git')) {
                return {
                    success: false,
                    errors: ['Not a git repository'],
                    warnings: []
                };
            }
            // Check for uncommitted changes
            const status = (0, child_process_1.execSync)('git status --porcelain', { encoding: 'utf8' });
            const hasUncommittedChanges = status.trim().length > 0;
            const warnings = [];
            if (hasUncommittedChanges && !this.settings.automaticRollbackEnabled) {
                warnings.push('Uncommitted changes detected - consider creating a stash');
            }
            return {
                success: true,
                errors: [],
                warnings
            };
        }
        catch (error) {
            return {
                success: false,
                errors: [`Git validation failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`],
                warnings: []
            };
        }
    }
    /**
     * Clean up old stashes based on configurable retention policy
     */
    async cleanupOldStashes() {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - this.settings.stashRetentionDays);
        const stashesToRemove = [];
        let cleanedCount = 0;
        for (const [stashId, stash] of this.stashes.entries()) {
            if (stash.timestamp < cutoffDate) {
                stashesToRemove.push(stashId);
            }
        }
        for (const stashId of stashesToRemove) {
            try {
                const stash = this.stashes.get(stashId);
                if (stash === null || stash === void 0 ? void 0 : stash.ref) {
                    // Try to drop the actual git stash if we have the reference
                    try {
                        (0, child_process_1.execSync)(`git stash drop ${stash.ref}`, {
                            encoding: 'utf8',
                            stdio: 'pipe'
                        });
                    }
                    catch (gitError) {
                        // Stash might already be gone, just log warning
                        console.warn(`⚠️ Could not drop git stash ${stash.ref}: ${(gitError === null || gitError === void 0 ? void 0 : gitError.message) || 'Unknown error'}`);
                    }
                }
                // Remove from our tracking
                this.stashes.delete(stashId);
                cleanedCount++;
                console.log(`🧹 Cleaned up old stash: ${stashId}`);
            }
            catch (error) {
                console.warn(`⚠️ Failed to cleanup stash ${stashId}: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
            }
        }
        if (cleanedCount > 0) {
            this.saveStashTracking();
            this.addSafetyEvent({
                type: campaign_1.SafetyEventType.CHECKPOINT_CREATED,
                timestamp: new Date(),
                description: `Cleaned up ${cleanedCount} old stashes`,
                severity: campaign_1.SafetyEventSeverity.INFO,
                action: 'STASH_CLEANUP'
            });
        }
    }
    /**
     * Get stashes by phase for targeted operations
     */
    async getStashesByPhase(phase) {
        return Array.from(this.stashes.values())
            .filter(stash => stash.id.includes(`-${phase}-`))
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    /**
     * Get stash statistics for reporting
     */
    getStashStatistics() {
        const stashes = Array.from(this.stashes.values());
        const byPhase = {};
        // Count stashes by phase
        for (const stash of stashes) {
            const phaseMatch = stash.id.match(/campaign-([^-]+)-/);
            if (phaseMatch) {
                const phase = phaseMatch[1];
                byPhase[phase] = (byPhase[phase] || 0) + 1;
            }
        }
        const timestamps = stashes.map(s => s.timestamp);
        const oldestStash = timestamps.length > 0 ? new Date(Math.min(...timestamps.map(t => t.getTime()))) : undefined;
        const newestStash = timestamps.length > 0 ? new Date(Math.max(...timestamps.map(t => t.getTime()))) : undefined;
        return {
            total: stashes.length,
            byPhase,
            oldestStash,
            newestStash
        };
    }
    /**
     * Get safety events for reporting
     */
    getSafetyEvents() {
        return [...this.safetyEvents];
    }
    // Private helper methods
    analyzeFileCorruption(filePath, content) {
        const patterns = [];
        let severity = campaign_1.CorruptionSeverity.LOW;
        // Check for import corruption patterns (based on existing scripts)
        const importCorruptionPatterns = [
            {
                regex: /import @\/types\s+from '[^']*'\s*;/g,
                description: 'Corrupted type import statement',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import @\/services\s+from '[^']*'\s*;/g,
                description: 'Corrupted service import statement',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /<<<<<<|>>>>>>|======/g,
                description: 'Git merge conflict markers',
                severity: campaign_1.CorruptionSeverity.CRITICAL
            },
            {
                regex: /\bposit:\s*anyi:\s*anyo:\s*anyn:\s*anys:/g,
                description: 'Corrupted parameter names',
                severity: campaign_1.CorruptionSeverity.MEDIUM
            },
            {
                regex: /\bcate:\s*anyg:\s*anyo:\s*anyr:\s*anyy:/g,
                description: 'Corrupted parameter names',
                severity: campaign_1.CorruptionSeverity.MEDIUM
            }
        ];
        for (const corruptionPattern of importCorruptionPatterns) {
            const matches = content.match(corruptionPattern.regex);
            if (matches) {
                patterns.push({
                    pattern: corruptionPattern.regex.source,
                    description: corruptionPattern.description,
                    files: [filePath]
                });
                // Update severity to the highest found
                if (corruptionPattern.severity === campaign_1.CorruptionSeverity.CRITICAL) {
                    severity = campaign_1.CorruptionSeverity.CRITICAL;
                }
                else if (corruptionPattern.severity === campaign_1.CorruptionSeverity.HIGH && severity !== campaign_1.CorruptionSeverity.CRITICAL) {
                    severity = campaign_1.CorruptionSeverity.HIGH;
                }
                else if (corruptionPattern.severity === campaign_1.CorruptionSeverity.MEDIUM && severity === campaign_1.CorruptionSeverity.LOW) {
                    severity = campaign_1.CorruptionSeverity.MEDIUM;
                }
            }
        }
        // Check for syntax corruption
        if (this.hasSyntaxCorruption(content)) {
            patterns.push({
                pattern: 'SYNTAX_CORRUPTION',
                description: 'Syntax corruption detected',
                files: [filePath]
            });
            severity = campaign_1.CorruptionSeverity.HIGH;
        }
        return { patterns, severity };
    }
    hasSyntaxCorruption(content) {
        // Check for unbalanced brackets (more lenient threshold)
        const openBrackets = (content.match(/\{/g) || []).length;
        const closeBrackets = (content.match(/\}/g) || []).length;
        const openParens = (content.match(/\(/g) || []).length;
        const closeParens = (content.match(/\)/g) || []).length;
        if (Math.abs(openBrackets - closeBrackets) > 1 || Math.abs(openParens - closeParens) > 1) {
            return true;
        }
        // Check for incomplete statements
        const incompletePatterns = [
            /export\s*$/m,
            /import\s*$/m,
            /function\s*$/m,
            /const\s*$/m,
            /let\s*$/m,
            /var\s*$/m
        ];
        return incompletePatterns.some(pattern => pattern.test(content));
    }
    /**
     * Analyze import/export corruption patterns based on existing script knowledge
     */
    analyzeImportExportCorruption(filePath, content) {
        const patterns = [];
        let severity = campaign_1.CorruptionSeverity.LOW;
        // Import/Export corruption patterns based on existing script knowledge
        const importExportCorruptionPatterns = [
            {
                regex: /import\s+\{\s*\}\s+from\s+['"][^'"]*['"];?/g,
                description: 'Empty import statement',
                severity: campaign_1.CorruptionSeverity.MEDIUM
            },
            {
                regex: /import\s+[^{]*\s+from\s+['"]undefined['"];?/g,
                description: 'Import from undefined module',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s+[^{]*\s+from\s+['"]['"]\s*;?/g,
                description: 'Import from empty string',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /export\s+\{\s*\}\s*;?/g,
                description: 'Empty export statement',
                severity: campaign_1.CorruptionSeverity.MEDIUM
            },
            {
                regex: /import\s+[^{]*\s+from\s+['"][^'"]*['"]\s+from\s+['"][^'"]*['"];?/g,
                description: 'Duplicate from clause in import',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s*\{\s*[^}]*,\s*,\s*[^}]*\}\s*from/g,
                description: 'Double comma in import destructuring',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s*\{\s*[^}]*\s+as\s+as\s+[^}]*\}\s*from/g,
                description: 'Duplicate "as" keyword in import',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /export\s*\{\s*[^}]*,\s*,\s*[^}]*\}/g,
                description: 'Double comma in export destructuring',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s+[^{]*\s+from\s+['"]@\/[^'"]*\s+@\/[^'"]*['"];?/g,
                description: 'Corrupted path alias in import',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s+[^{]*\s+from\s+['"][^'"]*\.\.[^'"]*\.\.[^'"]*['"];?/g,
                description: 'Corrupted relative path with multiple ..',
                severity: campaign_1.CorruptionSeverity.MEDIUM
            },
            {
                regex: /import\s*\{\s*[^}]*\s*\}\s*\{\s*[^}]*\s*\}\s*from/g,
                description: 'Duplicate destructuring braces in import',
                severity: campaign_1.CorruptionSeverity.CRITICAL
            },
            {
                regex: /export\s+default\s+default\s+/g,
                description: 'Duplicate default keyword in export',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s+type\s+type\s+/g,
                description: 'Duplicate type keyword in import',
                severity: campaign_1.CorruptionSeverity.HIGH
            },
            {
                regex: /import\s*\*\s+as\s+\*\s+as\s+/g,
                description: 'Corrupted namespace import syntax',
                severity: campaign_1.CorruptionSeverity.CRITICAL
            }
        ];
        for (const corruptionPattern of importExportCorruptionPatterns) {
            const matches = content.match(corruptionPattern.regex);
            if (matches) {
                patterns.push({
                    pattern: corruptionPattern.regex.source,
                    description: `${corruptionPattern.description} (${matches.length} occurrences)`,
                    files: [filePath]
                });
                // Update severity to the highest found
                if (corruptionPattern.severity === campaign_1.CorruptionSeverity.CRITICAL) {
                    severity = campaign_1.CorruptionSeverity.CRITICAL;
                }
                else if (corruptionPattern.severity === campaign_1.CorruptionSeverity.HIGH && severity !== campaign_1.CorruptionSeverity.CRITICAL) {
                    severity = campaign_1.CorruptionSeverity.HIGH;
                }
                else if (corruptionPattern.severity === campaign_1.CorruptionSeverity.MEDIUM && severity === campaign_1.CorruptionSeverity.LOW) {
                    severity = campaign_1.CorruptionSeverity.MEDIUM;
                }
            }
        }
        // Check for malformed import/export statements
        const malformedPatterns = [
            /import\s+[^{]*\s+from(?!\s+['"])/g,
            /export\s+[^{]*\s+from(?!\s+['"])/g,
            /import\s*\{[^}]*\s+from\s+[^'"]/g,
            /export\s*\{[^}]*\s+from\s+[^'"]/g // export with missing quotes
        ];
        for (const pattern of malformedPatterns) {
            const matches = content.match(pattern);
            if (matches) {
                patterns.push({
                    pattern: pattern.source,
                    description: 'Malformed import/export statement syntax',
                    files: [filePath]
                });
                severity = campaign_1.CorruptionSeverity.HIGH;
            }
        }
        return { patterns, severity };
    }
    determineRecoveryAction(severity, fileCount) {
        if (severity === campaign_1.CorruptionSeverity.CRITICAL) {
            return campaign_1.RecoveryAction.EMERGENCY_RESTORE;
        }
        if (severity === campaign_1.CorruptionSeverity.HIGH || fileCount > 10) {
            return campaign_1.RecoveryAction.ROLLBACK;
        }
        if (severity === campaign_1.CorruptionSeverity.MEDIUM || fileCount > 5) {
            return campaign_1.RecoveryAction.RETRY;
        }
        return campaign_1.RecoveryAction.CONTINUE;
    }
    mapCorruptionToEventSeverity(corruption) {
        switch (corruption) {
            case campaign_1.CorruptionSeverity.CRITICAL:
                return campaign_1.SafetyEventSeverity.CRITICAL;
            case campaign_1.CorruptionSeverity.HIGH:
                return campaign_1.SafetyEventSeverity.ERROR;
            case campaign_1.CorruptionSeverity.MEDIUM:
                return campaign_1.SafetyEventSeverity.WARNING;
            case campaign_1.CorruptionSeverity.LOW:
            default:
                return campaign_1.SafetyEventSeverity.INFO;
        }
    }
    getCurrentBranch() {
        try {
            return (0, child_process_1.execSync)('git branch --show-current', { encoding: 'utf8' }).trim();
        }
        catch (_a) {
            return 'unknown';
        }
    }
    addSafetyEvent(event) {
        this.safetyEvents.push(event);
        // Keep only recent events to prevent memory issues
        if (this.safetyEvents.length > 1000) {
            this.safetyEvents = this.safetyEvents.slice(-500);
        }
    }
    /**
     * Initialize stash tracking from persistent storage
     */
    initializeStashTracking() {
        try {
            const stashTrackingPath = path.join('.kiro', 'campaign-stashes.json');
            if (fs.existsSync(stashTrackingPath)) {
                const data = fs.readFileSync(stashTrackingPath, 'utf8');
                const parsed = JSON.parse(data);
                // Restore stashes with proper Date objects
                for (const [id, stashData] of Object.entries(parsed.stashes || {})) {
                    const stash = stashData;
                    this.stashes.set(id, {
                        ...stash,
                        timestamp: new Date(stash.timestamp)
                    });
                }
                this.stashCounter = parsed.counter || 0;
            }
        }
        catch (error) {
            console.warn(`⚠️ Could not load stash tracking: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
            this.stashCounter = 0;
        }
    }
    /**
     * Save stash tracking to persistent storage
     */
    saveStashTracking() {
        try {
            const stashTrackingPath = path.join('.kiro', 'campaign-stashes.json');
            // Ensure .kiro directory exists
            const kiroDir = path.dirname(stashTrackingPath);
            if (!fs.existsSync(kiroDir)) {
                fs.mkdirSync(kiroDir, { recursive: true });
            }
            const data = {
                counter: this.stashCounter,
                stashes: Object.fromEntries(this.stashes.entries()),
                lastUpdated: new Date().toISOString()
            };
            fs.writeFileSync(stashTrackingPath, JSON.stringify(data, null, 2));
        }
        catch (error) {
            console.warn(`⚠️ Could not save stash tracking: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
        }
    }
    /**
     * Find stash by message when reference is not available
     */
    async findStashByMessage(message) {
        try {
            const stashList = (0, child_process_1.execSync)('git stash list', { encoding: 'utf8' });
            const lines = stashList.split('\n');
            for (const line of lines) {
                if (line.includes(message)) {
                    const match = line.match(/^(stash@\{\d+\})/);
                    if (match) {
                        return match[1];
                    }
                }
            }
            throw new Error(`Stash not found with message: ${message}`);
        }
        catch (error) {
            throw new Error(`Failed to find stash by message: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`);
        }
    }
}
exports.SafetyProtocol = SafetyProtocol;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9TYWZldHlQcm90b2NvbC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLG1EQVc4QjtBQUU5QixNQUFhLGNBQWM7SUFNekIsWUFBWSxRQUF3QjtRQUo1QixZQUFPLEdBQTBCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDM0MsaUJBQVksR0FBa0IsRUFBRSxDQUFDO1FBQ2pDLGlCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBRy9CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsV0FBbUIsRUFBRSxLQUFjOztRQUNuRCxJQUFJO1lBQ0YsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3BCLE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNqRSxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUM3QyxNQUFNLFNBQVMsR0FBRyxZQUFZLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBQzdFLE1BQU0sZUFBZSxHQUFHLEdBQUcsU0FBUyxLQUFLLFdBQVcsRUFBRSxDQUFDO1lBRXZELDJDQUEyQztZQUMzQyxNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3BELElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFO2dCQUMxQixNQUFNLElB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QUVwQyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtnQkFDeEIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUMxQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7b0JBQzdDLElBQUksS0FBSyxFQUFFO3dCQUNULE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNqQjtpQkFDRjthQUNGO1lBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUM3RDtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxLQUFpQyxhQUFqQyxLQUFLLHVCQUFMLEtBQUssQ0FBOEIsT0FBTyxLQUFJLGVBQWUsRUFBRSxDQUFDLENBQUM7U0FDdkg7SUFDSCxDQUFDO0NBQ0Y7QUExNkJELHdDQTA2QkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9TYWZldHlQcm90b2NvbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNhZmV0eSBQcm90b2NvbCBTeXN0ZW1cbiAqIFBlcmZlY3QgQ29kZWJhc2UgQ2FtcGFpZ24gLSBDb21wcmVoZW5zaXZlIFNhZmV0eSBJbXBsZW1lbnRhdGlvblxuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtcbiAgU2FmZXR5U2V0dGluZ3MsXG4gIENvcnJ1cHRpb25SZXBvcnQsXG4gIENvcnJ1cHRpb25QYXR0ZXJuLFxuICBDb3JydXB0aW9uU2V2ZXJpdHksXG4gIFJlY292ZXJ5QWN0aW9uLFxuICBHaXRTdGFzaCxcbiAgU2FmZXR5RXZlbnQsXG4gIFNhZmV0eUV2ZW50VHlwZSxcbiAgU2FmZXR5RXZlbnRTZXZlcml0eSxcbiAgVmFsaWRhdGlvblJlc3VsdFxufSBmcm9tICcuLi8uLi90eXBlcy9jYW1wYWlnbic7XG5cbmV4cG9ydCBjbGFzcyBTYWZldHlQcm90b2NvbCB7XG4gIHByaXZhdGUgc2V0dGluZ3M6IFNhZmV0eVNldHRpbmdzO1xuICBwcml2YXRlIHN0YXNoZXM6IE1hcDxzdHJpbmcsIEdpdFN0YXNoPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBzYWZldHlFdmVudHM6IFNhZmV0eUV2ZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBzdGFzaENvdW50ZXI6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IFNhZmV0eVNldHRpbmdzKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXNoVHJhY2tpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBnaXQgc3Rhc2ggd2l0aCBkZXNjcmlwdGl2ZSBuYW1pbmcgY29udmVudGlvbnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVN0YXNoKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHBoYXNlPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdGFzaENvdW50ZXIrKztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOi5dL2csICctJyk7XG4gICAgICBjb25zdCBwaGFzZVByZWZpeCA9IHBoYXNlID8gYCR7cGhhc2V9LWAgOiAnJztcbiAgICAgIGNvbnN0IHN0YXNoTmFtZSA9IGBjYW1wYWlnbi0ke3BoYXNlUHJlZml4fSR7dGhpcy5zdGFzaENvdW50ZXJ9LSR7dGltZXN0YW1wfWA7XG4gICAgICBjb25zdCBmdWxsRGVzY3JpcHRpb24gPSBgJHtzdGFzaE5hbWV9OiAke2Rlc2NyaXB0aW9ufWA7XG5cbiAgICAgIC8vIFZhbGlkYXRlIGdpdCBzdGF0ZSBiZWZvcmUgY3JlYXRpbmcgc3Rhc2hcbiAgICAgIGNvbnN0IGdpdFZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZhbGlkYXRlR2l0U3RhdGUoKTtcbiAgICAgIGlmICghZ2l0VmFsaWRhdGlvbi5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgR2l0IHZhbGlkYXRpb24gZmFpbGVkOiAke2dpdFZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgZ2l0IHN0YXNoIHdpdGggYWxsIGZpbGVzIGluY2x1ZGluZyB1bnRyYWNrZWRcbiAgICAgIGV4ZWNTeW5jKGBnaXQgc3Rhc2ggcHVzaCAtdSAtbSBcIiR7ZnVsbERlc2NyaXB0aW9ufVwiYCwgeyBcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgc3RkaW86ICdwaXBlJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCB0aGUgYWN0dWFsIHN0YXNoIHJlZmVyZW5jZVxuICAgICAgY29uc3Qgc3Rhc2hMaXN0ID0gZXhlY1N5bmMoJ2dpdCBzdGFzaCBsaXN0IC0tb25lbGluZScsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICAgIGNvbnN0IHN0YXNoUmVmID0gc3Rhc2hMaXN0LnNwbGl0KCdcXG4nKVswXT8uc3BsaXQoJzonKVswXSB8fCAnc3Rhc2hAezB9JztcblxuICAgICAgLy8gU3RvcmUgc3Rhc2ggaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IHN0YXNoOiBHaXRTdGFzaCA9IHtcbiAgICAgICAgaWQ6IHN0YXNoTmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGZ1bGxEZXNjcmlwdGlvbixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBicmFuY2g6IHRoaXMuZ2V0Q3VycmVudEJyYW5jaCgpLFxuICAgICAgICByZWY6IHN0YXNoUmVmXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnN0YXNoZXMuc2V0KHN0YXNoTmFtZSwgc3Rhc2gpO1xuICAgICAgdGhpcy5zYXZlU3Rhc2hUcmFja2luZygpO1xuXG4gICAgICB0aGlzLmFkZFNhZmV0eUV2ZW50KHtcbiAgICAgICAgdHlwZTogU2FmZXR5RXZlbnRUeXBlLkNIRUNLUE9JTlRfQ1JFQVRFRCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEdpdCBzdGFzaCBjcmVhdGVkOiAke3N0YXNoTmFtZX0gKCR7c3Rhc2hSZWZ9KWAsXG4gICAgICAgIHNldmVyaXR5OiBTYWZldHlFdmVudFNldmVyaXR5LklORk8sXG4gICAgICAgIGFjdGlvbjogJ1NUQVNIX0NSRUFURSdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TpiBDcmVhdGVkIGdpdCBzdGFzaDogJHtzdGFzaE5hbWV9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgUmVmZXJlbmNlOiAke3N0YXNoUmVmfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFJvbGxiYWNrIHdpdGg6IGdpdCBzdGFzaCBhcHBseSAke3N0YXNoUmVmfWApO1xuXG4gICAgICByZXR1cm4gc3Rhc2hOYW1lO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuYWRkU2FmZXR5RXZlbnQoe1xuICAgICAgICB0eXBlOiBTYWZldHlFdmVudFR5cGUuRU1FUkdFTkNZX1JFQ09WRVJZLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgRmFpbGVkIHRvIGNyZWF0ZSBnaXQgc3Rhc2g6ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCxcbiAgICAgICAgc2V2ZXJpdHk6IFNhZmV0eUV2ZW50U2V2ZXJpdHkuRVJST1IsXG4gICAgICAgIGFjdGlvbjogJ1NUQVNIX0ZBSUxFRCdcbiAgICAgIH0pO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZ2l0IHN0YXNoOiAkeyhlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuYW1lZCBjaGVja3BvaW50IHN0YXNoIGZvciBzcGVjaWZpYyBvcGVyYXRpb25zXG4gICAqL1xuICBhc3luYyBjcmVhdGVDaGVja3BvaW50U3Rhc2gob3BlcmF0aW9uOiBzdHJpbmcsIHBoYXNlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYENoZWNrcG9pbnQgYmVmb3JlICR7b3BlcmF0aW9ufSBpbiAke3BoYXNlfWA7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU3Rhc2goZGVzY3JpcHRpb24sIHBoYXNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHNwZWNpZmljIGdpdCBzdGFzaCB3aXRoIGF1dG9tYXRpYyByb2xsYmFjayBzY2VuYXJpb3NcbiAgICovXG4gIGFzeW5jIGFwcGx5U3Rhc2goc3Rhc2hJZDogc3RyaW5nLCB2YWxpZGF0ZUFmdGVyOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFzaCA9IHRoaXMuc3Rhc2hlcy5nZXQoc3Rhc2hJZCk7XG4gICAgICBpZiAoIXN0YXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3Rhc2ggbm90IGZvdW5kOiAke3N0YXNoSWR9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSB0aGUgc3RvcmVkIHJlZmVyZW5jZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB0cnkgdG8gZmluZCBieSBtZXNzYWdlXG4gICAgICBsZXQgc3Rhc2hSZWYgPSBzdGFzaC5yZWY7XG4gICAgICBpZiAoIXN0YXNoUmVmKSB7XG4gICAgICAgIHN0YXNoUmVmID0gYXdhaXQgdGhpcy5maW5kU3Rhc2hCeU1lc3NhZ2Uoc3Rhc2guZGVzY3JpcHRpb24pO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSB0aGUgc3Rhc2hcbiAgICAgIGV4ZWNTeW5jKGBnaXQgc3Rhc2ggYXBwbHkgJHtzdGFzaFJlZn1gLCB7XG4gICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgIHN0ZGlvOiAncGlwZSdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBWYWxpZGF0ZSBhZnRlciBhcHBsaWNhdGlvbiBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmICh2YWxpZGF0ZUFmdGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZhbGlkYXRlR2l0U3RhdGUoKTtcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBHaXQgc3RhdGUgdmFsaWRhdGlvbiB3YXJuaW5ncyBhZnRlciBzdGFzaCBhcHBseTogJHt2YWxpZGF0aW9uLndhcm5pbmdzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRTYWZldHlFdmVudCh7XG4gICAgICAgIHR5cGU6IFNhZmV0eUV2ZW50VHlwZS5ST0xMQkFDS19UUklHR0VSRUQsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBHaXQgc3Rhc2ggYXBwbGllZDogJHtzdGFzaElkfSAoJHtzdGFzaFJlZn0pYCxcbiAgICAgICAgc2V2ZXJpdHk6IFNhZmV0eUV2ZW50U2V2ZXJpdHkuV0FSTklORyxcbiAgICAgICAgYWN0aW9uOiAnU1RBU0hfQVBQTFknXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCflIQgQXBwbGllZCBnaXQgc3Rhc2g6ICR7c3Rhc2hJZH1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICBSZWZlcmVuY2U6ICR7c3Rhc2hSZWZ9YCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5hZGRTYWZldHlFdmVudCh7XG4gICAgICAgIHR5cGU6IFNhZmV0eUV2ZW50VHlwZS5FTUVSR0VOQ1lfUkVDT1ZFUlksXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBGYWlsZWQgdG8gYXBwbHkgZ2l0IHN0YXNoICR7c3Rhc2hJZH06ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCxcbiAgICAgICAgc2V2ZXJpdHk6IFNhZmV0eUV2ZW50U2V2ZXJpdHkuRVJST1IsXG4gICAgICAgIGFjdGlvbjogJ1NUQVNIX0FQUExZX0ZBSUxFRCdcbiAgICAgIH0pO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhcHBseSBnaXQgc3Rhc2ggJHtzdGFzaElkfTogJHsoZXJyb3IgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXV0b21hdGljYWxseSBhcHBseSB0aGUgbW9zdCByZWNlbnQgc3Rhc2ggZm9yIHJvbGxiYWNrIHNjZW5hcmlvc1xuICAgKi9cbiAgYXN5bmMgYXV0b0FwcGx5TGF0ZXN0U3Rhc2goKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBzdGFzaGVzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXNoZXMudmFsdWVzKCkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKTtcblxuICAgIGlmIChzdGFzaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdGFzaGVzIGF2YWlsYWJsZSBmb3IgYXV0b21hdGljIHJvbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF0ZXN0U3Rhc2ggPSBzdGFzaGVzWzBdO1xuICAgIGF3YWl0IHRoaXMuYXBwbHlTdGFzaChsYXRlc3RTdGFzaC5pZCk7XG4gICAgcmV0dXJuIGxhdGVzdFN0YXNoLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHN0YXNoIGJ5IHBoYXNlIGZvciB0YXJnZXRlZCByb2xsYmFja3NcbiAgICovXG4gIGFzeW5jIGFwcGx5U3Rhc2hCeVBoYXNlKHBoYXNlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHBoYXNlU3Rhc2hlcyA9IEFycmF5LmZyb20odGhpcy5zdGFzaGVzLnZhbHVlcygpKVxuICAgICAgLmZpbHRlcihzdGFzaCA9PiBzdGFzaC5pZC5pbmNsdWRlcyhgLSR7cGhhc2V9LWApKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIudGltZXN0YW1wLmdldFRpbWUoKSAtIGEudGltZXN0YW1wLmdldFRpbWUoKSk7XG5cbiAgICBpZiAocGhhc2VTdGFzaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFzaGVzIGZvdW5kIGZvciBwaGFzZTogJHtwaGFzZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXRlc3RQaGFzZVN0YXNoID0gcGhhc2VTdGFzaGVzWzBdO1xuICAgIGF3YWl0IHRoaXMuYXBwbHlTdGFzaChsYXRlc3RQaGFzZVN0YXNoLmlkKTtcbiAgICByZXR1cm4gbGF0ZXN0UGhhc2VTdGFzaC5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGFsbCBjYW1wYWlnbiBzdGFzaGVzXG4gICAqL1xuICBhc3luYyBsaXN0U3Rhc2hlcygpOiBQcm9taXNlPEdpdFN0YXNoW10+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN0YXNoZXMudmFsdWVzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBmaWxlIGNvcnJ1cHRpb24gdXNpbmcgY29tcHJlaGVuc2l2ZSBzeW50YXggdmFsaWRhdGlvbiBwYXR0ZXJuc1xuICAgKi9cbiAgYXN5bmMgZGV0ZWN0Q29ycnVwdGlvbihmaWxlczogc3RyaW5nW10pOiBQcm9taXNlPENvcnJ1cHRpb25SZXBvcnQ+IHtcbiAgICBjb25zdCBkZXRlY3RlZEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGNvcnJ1cHRpb25QYXR0ZXJuczogQ29ycnVwdGlvblBhdHRlcm5bXSA9IFtdO1xuICAgIGxldCBtYXhTZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5MT1c7XG5cbiAgICBjb25zb2xlLmxvZyhg8J+UjSBBbmFseXppbmcgJHtmaWxlcy5sZW5ndGh9IGZpbGVzIGZvciBjb3JydXB0aW9uIHBhdHRlcm5zLi4uYCk7XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEZpbGUgbm90IGZvdW5kOiAke2ZpbGVQYXRofWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3QgZmlsZUNvcnJ1cHRpb24gPSB0aGlzLmFuYWx5emVGaWxlQ29ycnVwdGlvbihmaWxlUGF0aCwgY29udGVudCk7XG5cbiAgICAgICAgaWYgKGZpbGVDb3JydXB0aW9uLnBhdHRlcm5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZXRlY3RlZEZpbGVzLnB1c2goZmlsZVBhdGgpO1xuICAgICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJucy5wdXNoKC4uLmZpbGVDb3JydXB0aW9uLnBhdHRlcm5zKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+aqCBDb3JydXB0aW9uIGRldGVjdGVkIGluICR7ZmlsZVBhdGh9OiAke2ZpbGVDb3JydXB0aW9uLnBhdHRlcm5zLmxlbmd0aH0gcGF0dGVybnNgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgbWF4IHNldmVyaXR5XG4gICAgICAgICAgaWYgKGZpbGVDb3JydXB0aW9uLnNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpIHtcbiAgICAgICAgICAgIG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZUNvcnJ1cHRpb24uc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5ISUdIICYmIG1heFNldmVyaXR5ICE9PSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpIHtcbiAgICAgICAgICAgIG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWxlQ29ycnVwdGlvbi5zZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5Lk1FRElVTSAmJiBtYXhTZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5LkxPVykge1xuICAgICAgICAgICAgbWF4U2V2ZXJpdHkgPSBDb3JydXB0aW9uU2V2ZXJpdHkuTUVESVVNO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBGaWxlIHJlYWQgZXJyb3IgbWlnaHQgaW5kaWNhdGUgY29ycnVwdGlvblxuICAgICAgICBkZXRlY3RlZEZpbGVzLnB1c2goZmlsZVBhdGgpO1xuICAgICAgICBjb3JydXB0aW9uUGF0dGVybnMucHVzaCh7XG4gICAgICAgICAgcGF0dGVybjogJ0ZJTEVfUkVBRF9FUlJPUicsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDYW5ub3QgcmVhZCBmaWxlOiAkeyhlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgZmlsZXM6IFtmaWxlUGF0aF1cbiAgICAgICAgfSk7XG4gICAgICAgIG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGaWxlIHJlYWQgZXJyb3IgaW4gJHtmaWxlUGF0aH06ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb21tZW5kZWRBY3Rpb24gPSB0aGlzLmRldGVybWluZVJlY292ZXJ5QWN0aW9uKG1heFNldmVyaXR5LCBkZXRlY3RlZEZpbGVzLmxlbmd0aCk7XG5cbiAgICBjb25zdCByZXBvcnQ6IENvcnJ1cHRpb25SZXBvcnQgPSB7XG4gICAgICBkZXRlY3RlZEZpbGVzLFxuICAgICAgY29ycnVwdGlvblBhdHRlcm5zLFxuICAgICAgc2V2ZXJpdHk6IG1heFNldmVyaXR5LFxuICAgICAgcmVjb21tZW5kZWRBY3Rpb25cbiAgICB9O1xuXG4gICAgaWYgKGRldGVjdGVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hZGRTYWZldHlFdmVudCh7XG4gICAgICAgIHR5cGU6IFNhZmV0eUV2ZW50VHlwZS5DT1JSVVBUSU9OX0RFVEVDVEVELFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQ29ycnVwdGlvbiBkZXRlY3RlZCBpbiAke2RldGVjdGVkRmlsZXMubGVuZ3RofSBmaWxlcyAoJHttYXhTZXZlcml0eX0gc2V2ZXJpdHkpYCxcbiAgICAgICAgc2V2ZXJpdHk6IHRoaXMubWFwQ29ycnVwdGlvblRvRXZlbnRTZXZlcml0eShtYXhTZXZlcml0eSksXG4gICAgICAgIGFjdGlvbjogJ0NPUlJVUFRJT05fREVURUNURUQnXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCfk4ogQ29ycnVwdGlvbiBhbmFseXNpcyBjb21wbGV0ZTogJHtkZXRlY3RlZEZpbGVzLmxlbmd0aH0gZmlsZXMgYWZmZWN0ZWQsIHNldmVyaXR5OiAke21heFNldmVyaXR5fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIE5vIGNvcnJ1cHRpb24gZGV0ZWN0ZWQgaW4gJHtmaWxlcy5sZW5ndGh9IGZpbGVzYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaW1wb3J0L2V4cG9ydCBjb3JydXB0aW9uIGJhc2VkIG9uIGV4aXN0aW5nIHNjcmlwdCBrbm93bGVkZ2VcbiAgICovXG4gIGFzeW5jIGRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oZmlsZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxDb3JydXB0aW9uUmVwb3J0PiB7XG4gICAgY29uc3QgZGV0ZWN0ZWRGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBjb3JydXB0aW9uUGF0dGVybnM6IENvcnJ1cHRpb25QYXR0ZXJuW10gPSBbXTtcbiAgICBsZXQgbWF4U2V2ZXJpdHkgPSBDb3JydXB0aW9uU2V2ZXJpdHkuTE9XO1xuXG4gICAgY29uc29sZS5sb2coYPCflI0gQW5hbHl6aW5nIGltcG9ydC9leHBvcnQgY29ycnVwdGlvbiBpbiAke2ZpbGVzLmxlbmd0aH0gZmlsZXMuLi5gKTtcblxuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZXMpIHtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkgfHwgIWZpbGVQYXRoLm1hdGNoKC9cXC4odHN8dHN4fGpzfGpzeCkkLykpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IGltcG9ydEV4cG9ydENvcnJ1cHRpb24gPSB0aGlzLmFuYWx5emVJbXBvcnRFeHBvcnRDb3JydXB0aW9uKGZpbGVQYXRoLCBjb250ZW50KTtcblxuICAgICAgICBpZiAoaW1wb3J0RXhwb3J0Q29ycnVwdGlvbi5wYXR0ZXJucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGV0ZWN0ZWRGaWxlcy5wdXNoKGZpbGVQYXRoKTtcbiAgICAgICAgICBjb3JydXB0aW9uUGF0dGVybnMucHVzaCguLi5pbXBvcnRFeHBvcnRDb3JydXB0aW9uLnBhdHRlcm5zKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaW1wb3J0RXhwb3J0Q29ycnVwdGlvbi5zZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMKSB7XG4gICAgICAgICAgICBtYXhTZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGltcG9ydEV4cG9ydENvcnJ1cHRpb24uc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5ISUdIICYmIG1heFNldmVyaXR5ICE9PSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpIHtcbiAgICAgICAgICAgIG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRFeHBvcnRDb3JydXB0aW9uLnNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuTUVESVVNICYmIG1heFNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuTE9XKSB7XG4gICAgICAgICAgICBtYXhTZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBhbmFseXppbmcgaW1wb3J0L2V4cG9ydCBjb3JydXB0aW9uIGluICR7ZmlsZVBhdGh9OiAkeyhlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlY29tbWVuZGVkQWN0aW9uID0gdGhpcy5kZXRlcm1pbmVSZWNvdmVyeUFjdGlvbihtYXhTZXZlcml0eSwgZGV0ZWN0ZWRGaWxlcy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRldGVjdGVkRmlsZXMsXG4gICAgICBjb3JydXB0aW9uUGF0dGVybnMsXG4gICAgICBzZXZlcml0eTogbWF4U2V2ZXJpdHksXG4gICAgICByZWNvbW1lbmRlZEFjdGlvblxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVhbC10aW1lIG1vbml0b3JpbmcgZHVyaW5nIHNjcmlwdCBleGVjdXRpb25cbiAgICovXG4gIGFzeW5jIHN0YXJ0UmVhbFRpbWVNb25pdG9yaW5nKGZpbGVzOiBzdHJpbmdbXSwgaW50ZXJ2YWxNczogbnVtYmVyID0gNTAwMCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFN0YXJ0aW5nIHJlYWwtdGltZSBjb3JydXB0aW9uIG1vbml0b3JpbmcgZm9yICR7ZmlsZXMubGVuZ3RofSBmaWxlcy4uLmApO1xuICAgIFxuICAgIGNvbnN0IG1vbml0b3JpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHRoaXMuZGV0ZWN0Q29ycnVwdGlvbihmaWxlcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVwb3J0LmRldGVjdGVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFJlYWwtdGltZSBtb25pdG9yaW5nIGRldGVjdGVkIGNvcnJ1cHRpb24gaW4gJHtyZXBvcnQuZGV0ZWN0ZWRGaWxlcy5sZW5ndGh9IGZpbGVzYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5hZGRTYWZldHlFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiBTYWZldHlFdmVudFR5cGUuQ09SUlVQVElPTl9ERVRFQ1RFRCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUmVhbC10aW1lIG1vbml0b3JpbmcgZGV0ZWN0ZWQgY29ycnVwdGlvbjogJHtyZXBvcnQuc2V2ZXJpdHl9YCxcbiAgICAgICAgICAgIHNldmVyaXR5OiB0aGlzLm1hcENvcnJ1cHRpb25Ub0V2ZW50U2V2ZXJpdHkocmVwb3J0LnNldmVyaXR5KSxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFQUxUSU1FX0NPUlJVUFRJT05fREVURUNURUQnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBJZiBjcml0aWNhbCBjb3JydXB0aW9uIGlzIGRldGVjdGVkLCB0cmlnZ2VyIGVtZXJnZW5jeSByb2xsYmFja1xuICAgICAgICAgIGlmIChyZXBvcnQuc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCAmJiB0aGlzLnNldHRpbmdzLmF1dG9tYXRpY1JvbGxiYWNrRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg8J+aqCBDcml0aWNhbCBjb3JydXB0aW9uIGRldGVjdGVkISBUcmlnZ2VyaW5nIGVtZXJnZW5jeSByb2xsYmFjay4uLmApO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtb25pdG9yaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbWVyZ2VuY3lSb2xsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIGR1cmluZyByZWFsLXRpbWUgbW9uaXRvcmluZzogJHsoZXJyb3IgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9LCBpbnRlcnZhbE1zKTtcblxuICAgIC8vIFN0b3JlIHRoZSBpbnRlcnZhbCBJRCBmb3IgY2xlYW51cFxuICAgICh0aGlzIGFzIGFueSkubW9uaXRvcmluZ0ludGVydmFsID0gbW9uaXRvcmluZ0ludGVydmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgcmVhbC10aW1lIG1vbml0b3JpbmdcbiAgICovXG4gIHN0b3BSZWFsVGltZU1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgaWYgKCh0aGlzIGFzIGFueSkubW9uaXRvcmluZ0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKCh0aGlzIGFzIGFueSkubW9uaXRvcmluZ0ludGVydmFsKTtcbiAgICAgICh0aGlzIGFzIGFueSkubW9uaXRvcmluZ0ludGVydmFsID0gbnVsbDtcbiAgICAgIGNvbnNvbGUubG9nKGDij7nvuI8gUmVhbC10aW1lIGNvcnJ1cHRpb24gbW9uaXRvcmluZyBzdG9wcGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHN5bnRheCB1c2luZyBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZVN5bnRheFdpdGhUeXBlU2NyaXB0KGZpbGVzOiBzdHJpbmdbXSk6IFByb21pc2U8Q29ycnVwdGlvblJlcG9ydD4ge1xuICAgIGNvbnN0IGRldGVjdGVkRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgY29ycnVwdGlvblBhdHRlcm5zOiBDb3JydXB0aW9uUGF0dGVybltdID0gW107XG4gICAgbGV0IG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkxPVztcblxuICAgIGNvbnNvbGUubG9nKGDwn5SNIFZhbGlkYXRpbmcgc3ludGF4IHdpdGggVHlwZVNjcmlwdCBjb21waWxlciBmb3IgJHtmaWxlcy5sZW5ndGh9IGZpbGVzLi4uYCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gUnVuIFR5cGVTY3JpcHQgY29tcGlsZXIgdG8gY2hlY2sgZm9yIHN5bnRheCBlcnJvcnNcbiAgICAgIGNvbnN0IHRzRmlsZXMgPSBmaWxlcy5maWx0ZXIoZiA9PiBmLm1hdGNoKC9cXC4odHN8dHN4KSQvKSk7XG4gICAgICBpZiAodHNGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgZGV0ZWN0ZWRGaWxlcywgY29ycnVwdGlvblBhdHRlcm5zLCBzZXZlcml0eTogbWF4U2V2ZXJpdHksIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5DT05USU5VRSB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0c2NPdXRwdXQgPSBleGVjU3luYygneWFybiB0c2MgLS1ub0VtaXQgLS1za2lwTGliQ2hlY2sgMj4mMScsIHsgXG4gICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgIHN0ZGlvOiAncGlwZSdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQYXJzZSBUeXBlU2NyaXB0IGNvbXBpbGVyIG91dHB1dCBmb3Igc3ludGF4IGVycm9yc1xuICAgICAgY29uc3QgbGluZXMgPSB0c2NPdXRwdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdlcnJvciBUUycpICYmIChsaW5lLmluY2x1ZGVzKCdVbmV4cGVjdGVkIHRva2VuJykgfHwgbGluZS5pbmNsdWRlcygnRXhwcmVzc2lvbiBleHBlY3RlZCcpKSkge1xuICAgICAgICAgIGNvbnN0IGZpbGVNYXRjaCA9IGxpbmUubWF0Y2goL14oW14oXSspXFwoLyk7XG4gICAgICAgICAgaWYgKGZpbGVNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlTWF0Y2hbMV07XG4gICAgICAgICAgICBpZiAoZmlsZXMuaW5jbHVkZXMoZmlsZVBhdGgpICYmICFkZXRlY3RlZEZpbGVzLmluY2x1ZGVzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICBkZXRlY3RlZEZpbGVzLnB1c2goZmlsZVBhdGgpO1xuICAgICAgICAgICAgICBjb3JydXB0aW9uUGF0dGVybnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogJ1RZUEVTQ1JJUFRfU1lOVEFYX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbGluZS50cmltKCksXG4gICAgICAgICAgICAgICAgZmlsZXM6IFtmaWxlUGF0aF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVHlwZVNjcmlwdCBjb21waWxlciBlcnJvcnMgbWlnaHQgaW5kaWNhdGUgc3ludGF4IGNvcnJ1cHRpb25cbiAgICAgIGNvbnN0IGVycm9yT3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0IHx8IChlcnJvciBhcyBhbnkpLm1lc3NhZ2U7XG4gICAgICBpZiAoZXJyb3JPdXRwdXQuaW5jbHVkZXMoJ1VuZXhwZWN0ZWQgdG9rZW4nKSB8fCBlcnJvck91dHB1dC5pbmNsdWRlcygnRXhwcmVzc2lvbiBleHBlY3RlZCcpKSB7XG4gICAgICAgIG1heFNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJucy5wdXNoKHtcbiAgICAgICAgICBwYXR0ZXJuOiAnVFlQRVNDUklQVF9DT01QSUxBVElPTl9FUlJPUicsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZDogJHtlcnJvck91dHB1dH1gLFxuICAgICAgICAgIGZpbGVzOiBmaWxlcy5maWx0ZXIoZiA9PiBmLm1hdGNoKC9cXC4odHN8dHN4KSQvKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb21tZW5kZWRBY3Rpb24gPSB0aGlzLmRldGVybWluZVJlY292ZXJ5QWN0aW9uKG1heFNldmVyaXR5LCBkZXRlY3RlZEZpbGVzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGV0ZWN0ZWRGaWxlcyxcbiAgICAgIGNvcnJ1cHRpb25QYXR0ZXJucyxcbiAgICAgIHNldmVyaXR5OiBtYXhTZXZlcml0eSxcbiAgICAgIHJlY29tbWVuZGVkQWN0aW9uXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWVyZ2VuY3kgcm9sbGJhY2sgdG8gY2xlYW4gc3RhdGVcbiAgICovXG4gIGFzeW5jIGVtZXJnZW5jeVJvbGxiYWNrKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdGhlIG1vc3QgcmVjZW50IHN0YXNoXG4gICAgICBjb25zdCBzdGFzaGVzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXNoZXMudmFsdWVzKCkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBhLnRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAoc3Rhc2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdGFzaGVzIGF2YWlsYWJsZSBmb3IgZW1lcmdlbmN5IHJvbGxiYWNrJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhdGVzdFN0YXNoID0gc3Rhc2hlc1swXTtcbiAgICAgIGF3YWl0IHRoaXMuYXBwbHlTdGFzaChsYXRlc3RTdGFzaC5pZCk7XG5cbiAgICAgIHRoaXMuYWRkU2FmZXR5RXZlbnQoe1xuICAgICAgICB0eXBlOiBTYWZldHlFdmVudFR5cGUuRU1FUkdFTkNZX1JFQ09WRVJZLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgRW1lcmdlbmN5IHJvbGxiYWNrIGNvbXBsZXRlZCB1c2luZyBzdGFzaDogJHtsYXRlc3RTdGFzaC5pZH1gLFxuICAgICAgICBzZXZlcml0eTogU2FmZXR5RXZlbnRTZXZlcml0eS5XQVJOSU5HLFxuICAgICAgICBhY3Rpb246ICdFTUVSR0VOQ1lfUk9MTEJBQ0snXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCfmqggRW1lcmdlbmN5IHJvbGxiYWNrIGNvbXBsZXRlZCB1c2luZyBzdGFzaDogJHtsYXRlc3RTdGFzaC5pZH1gKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmFkZFNhZmV0eUV2ZW50KHtcbiAgICAgICAgdHlwZTogU2FmZXR5RXZlbnRUeXBlLkVNRVJHRU5DWV9SRUNPVkVSWSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEVtZXJnZW5jeSByb2xsYmFjayBmYWlsZWQ6ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCxcbiAgICAgICAgc2V2ZXJpdHk6IFNhZmV0eUV2ZW50U2V2ZXJpdHkuQ1JJVElDQUwsXG4gICAgICAgIGFjdGlvbjogJ0VNRVJHRU5DWV9ST0xMQkFDS19GQUlMRUQnXG4gICAgICB9KTtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbWVyZ2VuY3kgcm9sbGJhY2sgZmFpbGVkOiAkeyhlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBnaXQgcmVwb3NpdG9yeSBzdGF0ZVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVHaXRTdGF0ZSgpOiBQcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgZ2l0IHJlcG8gZXhpc3RzXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoJy5naXQnKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogWydOb3QgYSBnaXQgcmVwb3NpdG9yeSddLFxuICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgdW5jb21taXR0ZWQgY2hhbmdlc1xuICAgICAgY29uc3Qgc3RhdHVzID0gZXhlY1N5bmMoJ2dpdCBzdGF0dXMgLS1wb3JjZWxhaW4nLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgICBjb25zdCBoYXNVbmNvbW1pdHRlZENoYW5nZXMgPSBzdGF0dXMudHJpbSgpLmxlbmd0aCA+IDA7XG5cbiAgICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgaWYgKGhhc1VuY29tbWl0dGVkQ2hhbmdlcyAmJiAhdGhpcy5zZXR0aW5ncy5hdXRvbWF0aWNSb2xsYmFja0VuYWJsZWQpIHtcbiAgICAgICAgd2FybmluZ3MucHVzaCgnVW5jb21taXR0ZWQgY2hhbmdlcyBkZXRlY3RlZCAtIGNvbnNpZGVyIGNyZWF0aW5nIGEgc3Rhc2gnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgd2FybmluZ3NcbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yczogW2BHaXQgdmFsaWRhdGlvbiBmYWlsZWQ6ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YF0sXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgb2xkIHN0YXNoZXMgYmFzZWQgb24gY29uZmlndXJhYmxlIHJldGVudGlvbiBwb2xpY3lcbiAgICovXG4gIGFzeW5jIGNsZWFudXBPbGRTdGFzaGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGN1dG9mZkRhdGUuc2V0RGF0ZShjdXRvZmZEYXRlLmdldERhdGUoKSAtIHRoaXMuc2V0dGluZ3Muc3Rhc2hSZXRlbnRpb25EYXlzKTtcblxuICAgIGNvbnN0IHN0YXNoZXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICBsZXQgY2xlYW5lZENvdW50ID0gMDtcblxuICAgIGZvciAoY29uc3QgW3N0YXNoSWQsIHN0YXNoXSBvZiB0aGlzLnN0YXNoZXMuZW50cmllcygpKSB7XG4gICAgICBpZiAoc3Rhc2gudGltZXN0YW1wIDwgY3V0b2ZmRGF0ZSkge1xuICAgICAgICBzdGFzaGVzVG9SZW1vdmUucHVzaChzdGFzaElkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHN0YXNoSWQgb2Ygc3Rhc2hlc1RvUmVtb3ZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGFzaCA9IHRoaXMuc3Rhc2hlcy5nZXQoc3Rhc2hJZCk7XG4gICAgICAgIGlmIChzdGFzaD8ucmVmKSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGRyb3AgdGhlIGFjdHVhbCBnaXQgc3Rhc2ggaWYgd2UgaGF2ZSB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWNTeW5jKGBnaXQgc3Rhc2ggZHJvcCAke3N0YXNoLnJlZn1gLCB7IFxuICAgICAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLCBcbiAgICAgICAgICAgICAgc3RkaW86ICdwaXBlJyBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGdpdEVycm9yKSB7XG4gICAgICAgICAgICAvLyBTdGFzaCBtaWdodCBhbHJlYWR5IGJlIGdvbmUsIGp1c3QgbG9nIHdhcm5pbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIENvdWxkIG5vdCBkcm9wIGdpdCBzdGFzaCAke3N0YXNoLnJlZn06ICR7KGdpdEVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gb3VyIHRyYWNraW5nXG4gICAgICAgIHRoaXMuc3Rhc2hlcy5kZWxldGUoc3Rhc2hJZCk7XG4gICAgICAgIGNsZWFuZWRDb3VudCsrO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCfp7kgQ2xlYW5lZCB1cCBvbGQgc3Rhc2g6ICR7c3Rhc2hJZH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEZhaWxlZCB0byBjbGVhbnVwIHN0YXNoICR7c3Rhc2hJZH06ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsZWFuZWRDb3VudCA+IDApIHtcbiAgICAgIHRoaXMuc2F2ZVN0YXNoVHJhY2tpbmcoKTtcbiAgICAgIHRoaXMuYWRkU2FmZXR5RXZlbnQoe1xuICAgICAgICB0eXBlOiBTYWZldHlFdmVudFR5cGUuQ0hFQ0tQT0lOVF9DUkVBVEVELFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQ2xlYW5lZCB1cCAke2NsZWFuZWRDb3VudH0gb2xkIHN0YXNoZXNgLFxuICAgICAgICBzZXZlcml0eTogU2FmZXR5RXZlbnRTZXZlcml0eS5JTkZPLFxuICAgICAgICBhY3Rpb246ICdTVEFTSF9DTEVBTlVQJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdGFzaGVzIGJ5IHBoYXNlIGZvciB0YXJnZXRlZCBvcGVyYXRpb25zXG4gICAqL1xuICBhc3luYyBnZXRTdGFzaGVzQnlQaGFzZShwaGFzZTogc3RyaW5nKTogUHJvbWlzZTxHaXRTdGFzaFtdPiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdGFzaGVzLnZhbHVlcygpKVxuICAgICAgLmZpbHRlcihzdGFzaCA9PiBzdGFzaC5pZC5pbmNsdWRlcyhgLSR7cGhhc2V9LWApKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIudGltZXN0YW1wLmdldFRpbWUoKSAtIGEudGltZXN0YW1wLmdldFRpbWUoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0YXNoIHN0YXRpc3RpY3MgZm9yIHJlcG9ydGluZ1xuICAgKi9cbiAgZ2V0U3Rhc2hTdGF0aXN0aWNzKCk6IHtcbiAgICB0b3RhbDogbnVtYmVyO1xuICAgIGJ5UGhhc2U6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gICAgb2xkZXN0U3Rhc2g/OiBEYXRlO1xuICAgIG5ld2VzdFN0YXNoPzogRGF0ZTtcbiAgfSB7XG4gICAgY29uc3Qgc3Rhc2hlcyA9IEFycmF5LmZyb20odGhpcy5zdGFzaGVzLnZhbHVlcygpKTtcbiAgICBjb25zdCBieVBoYXNlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgICAvLyBDb3VudCBzdGFzaGVzIGJ5IHBoYXNlXG4gICAgZm9yIChjb25zdCBzdGFzaCBvZiBzdGFzaGVzKSB7XG4gICAgICBjb25zdCBwaGFzZU1hdGNoID0gc3Rhc2guaWQubWF0Y2goL2NhbXBhaWduLShbXi1dKyktLyk7XG4gICAgICBpZiAocGhhc2VNYXRjaCkge1xuICAgICAgICBjb25zdCBwaGFzZSA9IHBoYXNlTWF0Y2hbMV07XG4gICAgICAgIGJ5UGhhc2VbcGhhc2VdID0gKGJ5UGhhc2VbcGhhc2VdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gc3Rhc2hlcy5tYXAocyA9PiBzLnRpbWVzdGFtcCk7XG4gICAgY29uc3Qgb2xkZXN0U3Rhc2ggPSB0aW1lc3RhbXBzLmxlbmd0aCA+IDAgPyBuZXcgRGF0ZShNYXRoLm1pbiguLi50aW1lc3RhbXBzLm1hcCh0ID0+IHQuZ2V0VGltZSgpKSkpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld2VzdFN0YXNoID0gdGltZXN0YW1wcy5sZW5ndGggPiAwID8gbmV3IERhdGUoTWF0aC5tYXgoLi4udGltZXN0YW1wcy5tYXAodCA9PiB0LmdldFRpbWUoKSkpKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbDogc3Rhc2hlcy5sZW5ndGgsXG4gICAgICBieVBoYXNlLFxuICAgICAgb2xkZXN0U3Rhc2gsXG4gICAgICBuZXdlc3RTdGFzaFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNhZmV0eSBldmVudHMgZm9yIHJlcG9ydGluZ1xuICAgKi9cbiAgZ2V0U2FmZXR5RXZlbnRzKCk6IFNhZmV0eUV2ZW50W10ge1xuICAgIHJldHVybiBbLi4udGhpcy5zYWZldHlFdmVudHNdO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuXG4gIHByaXZhdGUgYW5hbHl6ZUZpbGVDb3JydXB0aW9uKGZpbGVQYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHtcbiAgICBwYXR0ZXJuczogQ29ycnVwdGlvblBhdHRlcm5bXTtcbiAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5O1xuICB9IHtcbiAgICBjb25zdCBwYXR0ZXJuczogQ29ycnVwdGlvblBhdHRlcm5bXSA9IFtdO1xuICAgIGxldCBzZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5MT1c7XG5cbiAgICAvLyBDaGVjayBmb3IgaW1wb3J0IGNvcnJ1cHRpb24gcGF0dGVybnMgKGJhc2VkIG9uIGV4aXN0aW5nIHNjcmlwdHMpXG4gICAgY29uc3QgaW1wb3J0Q29ycnVwdGlvblBhdHRlcm5zID0gW1xuICAgICAge1xuICAgICAgICByZWdleDogL2ltcG9ydCBAXFwvdHlwZXNcXHMrZnJvbSAnW14nXSonXFxzKjsvZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb3JydXB0ZWQgdHlwZSBpbXBvcnQgc3RhdGVtZW50JyxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5ISUdIXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL2ltcG9ydCBAXFwvc2VydmljZXNcXHMrZnJvbSAnW14nXSonXFxzKjsvZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb3JydXB0ZWQgc2VydmljZSBpbXBvcnQgc3RhdGVtZW50JyxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5ISUdIXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogLzw8PDw8PHw+Pj4+Pj58PT09PT09L2csXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnR2l0IG1lcmdlIGNvbmZsaWN0IG1hcmtlcnMnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL1xcYnBvc2l0OlxccyphbnlpOlxccyphbnlvOlxccyphbnluOlxccyphbnlzOi9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NvcnJ1cHRlZCBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5Lk1FRElVTVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9cXGJjYXRlOlxccyphbnlnOlxccyphbnlvOlxccyphbnlyOlxccyphbnl5Oi9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NvcnJ1cHRlZCBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5Lk1FRElVTVxuICAgICAgfVxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IGNvcnJ1cHRpb25QYXR0ZXJuIG9mIGltcG9ydENvcnJ1cHRpb25QYXR0ZXJucykge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goY29ycnVwdGlvblBhdHRlcm4ucmVnZXgpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcGF0dGVybnMucHVzaCh7XG4gICAgICAgICAgcGF0dGVybjogY29ycnVwdGlvblBhdHRlcm4ucmVnZXguc291cmNlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBjb3JydXB0aW9uUGF0dGVybi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBmaWxlczogW2ZpbGVQYXRoXVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgc2V2ZXJpdHkgdG8gdGhlIGhpZ2hlc3QgZm91bmRcbiAgICAgICAgaWYgKGNvcnJ1cHRpb25QYXR0ZXJuLnNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpIHtcbiAgICAgICAgICBzZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTDtcbiAgICAgICAgfSBlbHNlIGlmIChjb3JydXB0aW9uUGF0dGVybi5zZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0ggJiYgc2V2ZXJpdHkgIT09IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCkge1xuICAgICAgICAgIHNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgIH0gZWxzZSBpZiAoY29ycnVwdGlvblBhdHRlcm4uc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU0gJiYgc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5MT1cpIHtcbiAgICAgICAgICBzZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igc3ludGF4IGNvcnJ1cHRpb25cbiAgICBpZiAodGhpcy5oYXNTeW50YXhDb3JydXB0aW9uKGNvbnRlbnQpKSB7XG4gICAgICBwYXR0ZXJucy5wdXNoKHtcbiAgICAgICAgcGF0dGVybjogJ1NZTlRBWF9DT1JSVVBUSU9OJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTeW50YXggY29ycnVwdGlvbiBkZXRlY3RlZCcsXG4gICAgICAgIGZpbGVzOiBbZmlsZVBhdGhdXG4gICAgICB9KTtcbiAgICAgIHNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGF0dGVybnMsIHNldmVyaXR5IH07XG4gIH1cblxuICBwcml2YXRlIGhhc1N5bnRheENvcnJ1cHRpb24oY29udGVudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgZm9yIHVuYmFsYW5jZWQgYnJhY2tldHMgKG1vcmUgbGVuaWVudCB0aHJlc2hvbGQpXG4gICAgY29uc3Qgb3BlbkJyYWNrZXRzID0gKGNvbnRlbnQubWF0Y2goL1xcey9nKSB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IGNsb3NlQnJhY2tldHMgPSAoY29udGVudC5tYXRjaCgvXFx9L2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgb3BlblBhcmVucyA9IChjb250ZW50Lm1hdGNoKC9cXCgvZykgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZVBhcmVucyA9IChjb250ZW50Lm1hdGNoKC9cXCkvZykgfHwgW10pLmxlbmd0aDtcblxuICAgIGlmIChNYXRoLmFicyhvcGVuQnJhY2tldHMgLSBjbG9zZUJyYWNrZXRzKSA+IDEgfHwgTWF0aC5hYnMob3BlblBhcmVucyAtIGNsb3NlUGFyZW5zKSA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBpbmNvbXBsZXRlIHN0YXRlbWVudHNcbiAgICBjb25zdCBpbmNvbXBsZXRlUGF0dGVybnMgPSBbXG4gICAgICAvZXhwb3J0XFxzKiQvbSxcbiAgICAgIC9pbXBvcnRcXHMqJC9tLFxuICAgICAgL2Z1bmN0aW9uXFxzKiQvbSxcbiAgICAgIC9jb25zdFxccyokL20sXG4gICAgICAvbGV0XFxzKiQvbSxcbiAgICAgIC92YXJcXHMqJC9tXG4gICAgXTtcblxuICAgIHJldHVybiBpbmNvbXBsZXRlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChjb250ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQW5hbHl6ZSBpbXBvcnQvZXhwb3J0IGNvcnJ1cHRpb24gcGF0dGVybnMgYmFzZWQgb24gZXhpc3Rpbmcgc2NyaXB0IGtub3dsZWRnZVxuICAgKi9cbiAgcHJpdmF0ZSBhbmFseXplSW1wb3J0RXhwb3J0Q29ycnVwdGlvbihmaWxlUGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB7XG4gICAgcGF0dGVybnM6IENvcnJ1cHRpb25QYXR0ZXJuW107XG4gICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eTtcbiAgfSB7XG4gICAgY29uc3QgcGF0dGVybnM6IENvcnJ1cHRpb25QYXR0ZXJuW10gPSBbXTtcbiAgICBsZXQgc2V2ZXJpdHkgPSBDb3JydXB0aW9uU2V2ZXJpdHkuTE9XO1xuXG4gICAgLy8gSW1wb3J0L0V4cG9ydCBjb3JydXB0aW9uIHBhdHRlcm5zIGJhc2VkIG9uIGV4aXN0aW5nIHNjcmlwdCBrbm93bGVkZ2VcbiAgICBjb25zdCBpbXBvcnRFeHBvcnRDb3JydXB0aW9uUGF0dGVybnMgPSBbXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvaW1wb3J0XFxzK1xce1xccypcXH1cXHMrZnJvbVxccytbJ1wiXVteJ1wiXSpbJ1wiXTs/L2csXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRW1wdHkgaW1wb3J0IHN0YXRlbWVudCcsXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuTUVESVVNXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL2ltcG9ydFxccytbXntdKlxccytmcm9tXFxzK1snXCJddW5kZWZpbmVkWydcIl07Py9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0ltcG9ydCBmcm9tIHVuZGVmaW5lZCBtb2R1bGUnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkhJR0hcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvaW1wb3J0XFxzK1tee10qXFxzK2Zyb21cXHMrWydcIl1bJ1wiXVxccyo7Py9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0ltcG9ydCBmcm9tIGVtcHR5IHN0cmluZycsXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuSElHSFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9leHBvcnRcXHMrXFx7XFxzKlxcfVxccyo7Py9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0VtcHR5IGV4cG9ydCBzdGF0ZW1lbnQnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5Lk1FRElVTVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9pbXBvcnRcXHMrW157XSpcXHMrZnJvbVxccytbJ1wiXVteJ1wiXSpbJ1wiXVxccytmcm9tXFxzK1snXCJdW14nXCJdKlsnXCJdOz8vZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEdXBsaWNhdGUgZnJvbSBjbGF1c2UgaW4gaW1wb3J0JyxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5ISUdIXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL2ltcG9ydFxccypcXHtcXHMqW159XSosXFxzKixcXHMqW159XSpcXH1cXHMqZnJvbS9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0RvdWJsZSBjb21tYSBpbiBpbXBvcnQgZGVzdHJ1Y3R1cmluZycsXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuSElHSFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9pbXBvcnRcXHMqXFx7XFxzKltefV0qXFxzK2FzXFxzK2FzXFxzK1tefV0qXFx9XFxzKmZyb20vZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEdXBsaWNhdGUgXCJhc1wiIGtleXdvcmQgaW4gaW1wb3J0JyxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5ISUdIXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL2V4cG9ydFxccypcXHtcXHMqW159XSosXFxzKixcXHMqW159XSpcXH0vZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEb3VibGUgY29tbWEgaW4gZXhwb3J0IGRlc3RydWN0dXJpbmcnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkhJR0hcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvaW1wb3J0XFxzK1tee10qXFxzK2Zyb21cXHMrWydcIl1AXFwvW14nXCJdKlxccytAXFwvW14nXCJdKlsnXCJdOz8vZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb3JydXB0ZWQgcGF0aCBhbGlhcyBpbiBpbXBvcnQnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkhJR0hcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvaW1wb3J0XFxzK1tee10qXFxzK2Zyb21cXHMrWydcIl1bXidcIl0qXFwuXFwuW14nXCJdKlxcLlxcLlteJ1wiXSpbJ1wiXTs/L2csXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQ29ycnVwdGVkIHJlbGF0aXZlIHBhdGggd2l0aCBtdWx0aXBsZSAuLicsXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuTUVESVVNXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL2ltcG9ydFxccypcXHtcXHMqW159XSpcXHMqXFx9XFxzKlxce1xccypbXn1dKlxccypcXH1cXHMqZnJvbS9nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0R1cGxpY2F0ZSBkZXN0cnVjdHVyaW5nIGJyYWNlcyBpbiBpbXBvcnQnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL2V4cG9ydFxccytkZWZhdWx0XFxzK2RlZmF1bHRcXHMrL2csXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRHVwbGljYXRlIGRlZmF1bHQga2V5d29yZCBpbiBleHBvcnQnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkhJR0hcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvaW1wb3J0XFxzK3R5cGVcXHMrdHlwZVxccysvZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEdXBsaWNhdGUgdHlwZSBrZXl3b3JkIGluIGltcG9ydCcsXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuSElHSFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9pbXBvcnRcXHMqXFwqXFxzK2FzXFxzK1xcKlxccythc1xccysvZyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb3JydXB0ZWQgbmFtZXNwYWNlIGltcG9ydCBzeW50YXgnLFxuICAgICAgICBzZXZlcml0eTogQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMXG4gICAgICB9XG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgY29ycnVwdGlvblBhdHRlcm4gb2YgaW1wb3J0RXhwb3J0Q29ycnVwdGlvblBhdHRlcm5zKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaChjb3JydXB0aW9uUGF0dGVybi5yZWdleCk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBwYXR0ZXJucy5wdXNoKHtcbiAgICAgICAgICBwYXR0ZXJuOiBjb3JydXB0aW9uUGF0dGVybi5yZWdleC5zb3VyY2UsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGAke2NvcnJ1cHRpb25QYXR0ZXJuLmRlc2NyaXB0aW9ufSAoJHttYXRjaGVzLmxlbmd0aH0gb2NjdXJyZW5jZXMpYCxcbiAgICAgICAgICBmaWxlczogW2ZpbGVQYXRoXVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgc2V2ZXJpdHkgdG8gdGhlIGhpZ2hlc3QgZm91bmRcbiAgICAgICAgaWYgKGNvcnJ1cHRpb25QYXR0ZXJuLnNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwpIHtcbiAgICAgICAgICBzZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTDtcbiAgICAgICAgfSBlbHNlIGlmIChjb3JydXB0aW9uUGF0dGVybi5zZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0ggJiYgc2V2ZXJpdHkgIT09IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCkge1xuICAgICAgICAgIHNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICAgIH0gZWxzZSBpZiAoY29ycnVwdGlvblBhdHRlcm4uc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU0gJiYgc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5MT1cpIHtcbiAgICAgICAgICBzZXZlcml0eSA9IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbWFsZm9ybWVkIGltcG9ydC9leHBvcnQgc3RhdGVtZW50c1xuICAgIGNvbnN0IG1hbGZvcm1lZFBhdHRlcm5zID0gW1xuICAgICAgL2ltcG9ydFxccytbXntdKlxccytmcm9tKD8hXFxzK1snXCJdKS9nLCAvLyBpbXBvcnQgd2l0aG91dCBwcm9wZXIgZnJvbSBjbGF1c2VcbiAgICAgIC9leHBvcnRcXHMrW157XSpcXHMrZnJvbSg/IVxccytbJ1wiXSkvZywgLy8gZXhwb3J0IHdpdGhvdXQgcHJvcGVyIGZyb20gY2xhdXNlXG4gICAgICAvaW1wb3J0XFxzKlxce1tefV0qXFxzK2Zyb21cXHMrW14nXCJdL2csICAvLyBpbXBvcnQgd2l0aCBtaXNzaW5nIHF1b3Rlc1xuICAgICAgL2V4cG9ydFxccypcXHtbXn1dKlxccytmcm9tXFxzK1teJ1wiXS9nICAgLy8gZXhwb3J0IHdpdGggbWlzc2luZyBxdW90ZXNcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIG1hbGZvcm1lZFBhdHRlcm5zKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHBhdHRlcm5zLnB1c2goe1xuICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4uc291cmNlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWFsZm9ybWVkIGltcG9ydC9leHBvcnQgc3RhdGVtZW50IHN5bnRheCcsXG4gICAgICAgICAgZmlsZXM6IFtmaWxlUGF0aF1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldmVyaXR5ID0gQ29ycnVwdGlvblNldmVyaXR5LkhJR0g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGF0dGVybnMsIHNldmVyaXR5IH07XG4gIH1cblxuICBwcml2YXRlIGRldGVybWluZVJlY292ZXJ5QWN0aW9uKHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHksIGZpbGVDb3VudDogbnVtYmVyKTogUmVjb3ZlcnlBY3Rpb24ge1xuICAgIGlmIChzZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMKSB7XG4gICAgICByZXR1cm4gUmVjb3ZlcnlBY3Rpb24uRU1FUkdFTkNZX1JFU1RPUkU7XG4gICAgfVxuXG4gICAgaWYgKHNldmVyaXR5ID09PSBDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCB8fCBmaWxlQ291bnQgPiAxMCkge1xuICAgICAgcmV0dXJuIFJlY292ZXJ5QWN0aW9uLlJPTExCQUNLO1xuICAgIH1cblxuICAgIGlmIChzZXZlcml0eSA9PT0gQ29ycnVwdGlvblNldmVyaXR5Lk1FRElVTSB8fCBmaWxlQ291bnQgPiA1KSB7XG4gICAgICByZXR1cm4gUmVjb3ZlcnlBY3Rpb24uUkVUUlk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlY292ZXJ5QWN0aW9uLkNPTlRJTlVFO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXBDb3JydXB0aW9uVG9FdmVudFNldmVyaXR5KGNvcnJ1cHRpb246IENvcnJ1cHRpb25TZXZlcml0eSk6IFNhZmV0eUV2ZW50U2V2ZXJpdHkge1xuICAgIHN3aXRjaCAoY29ycnVwdGlvbikge1xuICAgICAgY2FzZSBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUw6XG4gICAgICAgIHJldHVybiBTYWZldHlFdmVudFNldmVyaXR5LkNSSVRJQ0FMO1xuICAgICAgY2FzZSBDb3JydXB0aW9uU2V2ZXJpdHkuSElHSDpcbiAgICAgICAgcmV0dXJuIFNhZmV0eUV2ZW50U2V2ZXJpdHkuRVJST1I7XG4gICAgICBjYXNlIENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU06XG4gICAgICAgIHJldHVybiBTYWZldHlFdmVudFNldmVyaXR5LldBUk5JTkc7XG4gICAgICBjYXNlIENvcnJ1cHRpb25TZXZlcml0eS5MT1c6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU2FmZXR5RXZlbnRTZXZlcml0eS5JTkZPO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q3VycmVudEJyYW5jaCgpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZXhlY1N5bmMoJ2dpdCBicmFuY2ggLS1zaG93LWN1cnJlbnQnLCB7IGVuY29kaW5nOiAndXRmOCcgfSkudHJpbSgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZFNhZmV0eUV2ZW50KGV2ZW50OiBTYWZldHlFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuc2FmZXR5RXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIFxuICAgIC8vIEtlZXAgb25seSByZWNlbnQgZXZlbnRzIHRvIHByZXZlbnQgbWVtb3J5IGlzc3Vlc1xuICAgIGlmICh0aGlzLnNhZmV0eUV2ZW50cy5sZW5ndGggPiAxMDAwKSB7XG4gICAgICB0aGlzLnNhZmV0eUV2ZW50cyA9IHRoaXMuc2FmZXR5RXZlbnRzLnNsaWNlKC01MDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHN0YXNoIHRyYWNraW5nIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVTdGFzaFRyYWNraW5nKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFzaFRyYWNraW5nUGF0aCA9IHBhdGguam9pbignLmtpcm8nLCAnY2FtcGFpZ24tc3Rhc2hlcy5qc29uJyk7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhzdGFzaFRyYWNraW5nUGF0aCkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhzdGFzaFRyYWNraW5nUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc3RvcmUgc3Rhc2hlcyB3aXRoIHByb3BlciBEYXRlIG9iamVjdHNcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHN0YXNoRGF0YV0gb2YgT2JqZWN0LmVudHJpZXMocGFyc2VkLnN0YXNoZXMgfHwge30pKSB7XG4gICAgICAgICAgY29uc3Qgc3Rhc2ggPSBzdGFzaERhdGEgYXMgYW55O1xuICAgICAgICAgIHRoaXMuc3Rhc2hlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgIC4uLnN0YXNoLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShzdGFzaC50aW1lc3RhbXApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuc3Rhc2hDb3VudGVyID0gcGFyc2VkLmNvdW50ZXIgfHwgMDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gQ291bGQgbm90IGxvYWQgc3Rhc2ggdHJhY2tpbmc6ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB0aGlzLnN0YXNoQ291bnRlciA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgc3Rhc2ggdHJhY2tpbmcgdG8gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAqL1xuICBwcml2YXRlIHNhdmVTdGFzaFRyYWNraW5nKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFzaFRyYWNraW5nUGF0aCA9IHBhdGguam9pbignLmtpcm8nLCAnY2FtcGFpZ24tc3Rhc2hlcy5qc29uJyk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSAua2lybyBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICBjb25zdCBraXJvRGlyID0gcGF0aC5kaXJuYW1lKHN0YXNoVHJhY2tpbmdQYXRoKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhraXJvRGlyKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoa2lyb0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGNvdW50ZXI6IHRoaXMuc3Rhc2hDb3VudGVyLFxuICAgICAgICBzdGFzaGVzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zdGFzaGVzLmVudHJpZXMoKSksXG4gICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoc3Rhc2hUcmFja2luZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gQ291bGQgbm90IHNhdmUgc3Rhc2ggdHJhY2tpbmc6ICR7KGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgc3Rhc2ggYnkgbWVzc2FnZSB3aGVuIHJlZmVyZW5jZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGZpbmRTdGFzaEJ5TWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFzaExpc3QgPSBleGVjU3luYygnZ2l0IHN0YXNoIGxpc3QnLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgICBjb25zdCBsaW5lcyA9IHN0YXNoTGlzdC5zcGxpdCgnXFxuJyk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBpZiAobGluZS5pbmNsdWRlcyhtZXNzYWdlKSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvXihzdGFzaEBcXHtcXGQrXFx9KS8pO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXNoIG5vdCBmb3VuZCB3aXRoIG1lc3NhZ2U6ICR7bWVzc2FnZX1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBzdGFzaCBieSBtZXNzYWdlOiAkeyhlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxufSJdLCJ2ZXJzaW9uIjozfQ==