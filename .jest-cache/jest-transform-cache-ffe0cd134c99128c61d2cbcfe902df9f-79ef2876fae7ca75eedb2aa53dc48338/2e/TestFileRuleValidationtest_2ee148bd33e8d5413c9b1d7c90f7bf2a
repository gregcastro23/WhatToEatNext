72ffcbf33474de8e0f2fe4322985127e
"use strict";
/**
 * Test File Rule Validation Test Suite
 *
 * Tests the domain-specific ESLint rules for test files
 * to ensure appropriate relaxations for mock variables and testing patterns.
 *
 * Requirements: 4.4
 */
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
describe('Test File Rule Validation', () => {
    const projectRoot = process.cwd();
    const tempFiles = [];
    afterEach(() => {
        // Clean up temporary test files
        tempFiles.forEach(file => {
            try {
                (0, child_process_1.execSync)(`rm -f "${file}"`);
            }
            catch { }
        });
        tempFiles.length = 0;
    });
    describe('Mock Variable Relaxations', () => {
        test('should ignore unused mock variables', async () => {
            const testContent = `
        describe('Mock Variable Tests', () => {
          test('should handle mock variables', () => {
            const mockFunction = jest.fn();
            const _stubValue = 'test-stub';
            const testData = { id: 1, name: 'test' };
            const _mockObject = { method: jest.fn() };
            const _stubArray = [1, 2, 3];
            const _testConfig = { enabled: true };
            const UNUSED_mock = 'unused-mock';
            const UNUSED_stub = 'unused-stub';
            const UNUSED_test = 'unused-test';
            
            // Only use one variable to test unused variable handling
            expect(mockFunction).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-mock-variables.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('mock') || msg.message.includes('stub') || msg.message.includes('test')));
                    // Mock variable patterns should be ignored in test files
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('mock') || msg.message.includes('stub') || msg.message.includes('test')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow Jest mock functions', async () => {
            const testContent = `
        describe('Jest Mock Functions', () => {
          const mockCallback = jest.fn();
          const mockImplementation = jest.fn(() => 'mocked');
          const mockReturnValue = jest.fn().mockReturnValue('value');
          const mockResolvedValue = jest.fn().mockResolvedValue('resolved');
          const mockRejectedValue = jest.fn().mockRejectedValue(new Error('rejected'));
          
          beforeEach(() => {
            jest.clearAllMocks();
            mockCallback.mockClear();
            mockImplementation.mockReset();
            mockReturnValue.mockRestore();
          });
          
          test('should work with mocks', () => {
            expect(mockCallback).toHaveBeenCalledTimes(0);
            expect(mockImplementation()).toBe('mocked');
            expect(mockReturnValue()).toBe('value');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-mocks.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('mock'));
                    // Jest mock functions should be allowed
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('mock'));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow test data structures', async () => {
            const testContent = `
        describe('Test Data Structures', () => {
          const testUser = { id: 1, name: 'Test User', email: 'test@example.com' };
          const _testIngredient = { name: 'tomato', elementalProperties: { Fire: 0.3, Water: 0.7, Earth: 0.2, Air: 0.1 } };
          const _testRecipe = { id: 1, name: 'Test Recipe', ingredients: [] };
          const _testPlanetaryPosition = { sign: 'aries', degree: 8.5, exactLongitude: 8.5, isRetrograde: false };
          const _testConfig = { apiUrl: 'http://test.api', timeout: 5000 };
          const _testMetrics = { errors: 0, warnings: 5, processed: 100 };
          
          test('should use test data', () => {
            expect(testUser.id).toBe(1);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-data.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('test'));
                    // Test data structures should be allowed
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('test'));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test-Specific Rule Relaxations', () => {
        test('should allow explicit any types in tests', async () => {
            const testContent = `
        describe('Any Type Tests', () => {
          test('should allow any types for flexible testing', () => {
            const anyValue: any = 'test-value';
            const anyObject: any = { prop: 'value' };
            const anyArray: any[] = [1, 'two', { three: 3 }];
            const anyFunction: any = () => 'result';
            
            // Test dynamic behavior
            anyObject.dynamicProperty = 'dynamic';
            anyArray.push({ dynamic: true });
            
            expect(anyValue).toBeDefined();
            expect(anyObject.prop).toBe('value');
            expect(anyArray.length).toBeGreaterThan(0);
            expect(anyFunction()).toBe('result');
          });
          
          test('should handle API responses with any', () => {
            const apiResponse: any = {
              data: { id: 1, name: 'test' },
              status: 200,
              headers: { 'content-type': 'application/json' }
            };
            
            expect(apiResponse.data.id).toBe(1);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-any-types.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const anyTypeErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2);
                    // Test files should allow explicit any types
                    expect(anyTypeErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const anyTypeErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2);
                        expect(anyTypeErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow console statements in tests', async () => {
            const testContent = `
        describe('Console Statement Tests', () => {
          test('should allow console output for debugging', () => {
            console.log('Test starting...');
            console.info('Processing test data');
            console.warn('This is a test warning');
            console.error('This is a test error (not real)');
            console.debug('Debug information for test');
            console.table([{ test: 'data', value: 123 }]);
            console.group('Test Group');
            console.log('Grouped test output');
            console.groupEnd();
            console.time('test-timer');
            console.timeEnd('test-timer');
            console.count('test-counter');
            
            expect(true).toBe(true);
          });
          
          beforeEach(() => {
            console.log('Setting up test...');
          });
          
          afterEach(() => {
            console.log('Cleaning up test...');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-console-statements.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2);
                    // Test files should allow console statements
                    expect(consoleErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2);
                        expect(consoleErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow non-null assertions in tests', async () => {
            const testContent = `
        describe('Non-null Assertion Tests', () => {
          test('should allow non-null assertions for test certainty', () => {
            const maybeValue: string | null = 'test-value';
            const maybeObject: { prop?: string } = { prop: 'value' };
            const maybeArray: number[] | undefined = [1, 2, 3];
            
            // Non-null assertions should be allowed in tests
            const definiteValue = maybeValue!;
            const definiteProperty = maybeObject.prop!;
            const definiteArray = maybeArray!;
            
            expect(definiteValue).toBe('test-value');
            expect(definiteProperty).toBe('value');
            expect(definiteArray.length).toBe(3);
            
            // Test DOM elements (common in React tests)
            const element = document.querySelector('.test-element')!;
            const button = document.getElementById('test-button')!;
            
            // These would normally be checked, but in tests we know they exist
            expect(element).toBeDefined();
            expect(button).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-non-null-assertions.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const nonNullErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2);
                    // Test files should allow non-null assertions
                    expect(nonNullErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const nonNullErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2);
                        expect(nonNullErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow magic numbers in tests', async () => {
            const testContent = `
        describe('Magic Numbers Tests', () => {
          test('should allow magic numbers for test values', () => {
            const testId = 12345;
            const testScore = 98.7;
            const testCount = 42;
            const testPercentage = 75.5;
            const _testTimeout = 5000;
            const _testPort = 3000;
            const testStatusCode = 200;
            const testErrorCode = 404;
            
            expect(testId).toBe(12345);
            expect(testScore).toBeCloseTo(98.7);
            expect(testCount).toBe(42);
            expect(testPercentage).toBe(75.5);
            
            // Common test patterns with magic numbers
            setTimeout(() => {}, 1000);
            expect(Array(10).fill(0)).toHaveLength(10);
            expect(Math.random() * 100).toBeLessThan(100);
            
            // HTTP status codes
            expect(testStatusCode).toBe(200);
            expect(testErrorCode).toBe(404);
          });
          
          test('should handle test data with magic numbers', () => {
            const testData = {
              users: Array(50).fill(null).map((_, i) => ({ id: i + 1 })),
              pageSize: 25,
              totalPages: 4,
              currentPage: 1
            };
            
            expect(testData.users).toHaveLength(50);
            expect(testData.pageSize).toBe(25);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-magic-numbers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const magicNumberErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-magic-numbers' && msg.severity === 2);
                    // Test files should allow magic numbers
                    expect(magicNumberErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const magicNumberErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-magic-numbers' && msg.severity === 2);
                        expect(magicNumberErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow relaxed complexity in tests', async () => {
            const testContent = `
        describe('Complex Test Logic', () => {
          test('should allow complex test scenarios', () => {
            // Complex test logic should be allowed
            const testScenarios = [
              { input: 'a', expected: 1 },
              { input: 'b', expected: 2 },
              { input: 'c', expected: 3 }
            ];
            
            testScenarios.forEach(scenario => {
              for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 3; j++) {
                  if (scenario.input === 'a') {
                    if (i > 2) {
                      if (j === 1) {
                        expect(scenario.expected).toBe(1);
                      } else if (j === 2) {
                        expect(scenario.expected).toBeGreaterThan(0);
                      } else {
                        expect(scenario.expected).toBeDefined();
                      }
                    } else {
                      expect(scenario.expected).toBeTruthy();
                    }
                  } else if (scenario.input === 'b') {
                    if (i < 3) {
                      expect(scenario.expected).toBe(2);
                    } else {
                      expect(scenario.expected).toBeGreaterThan(1);
                    }
                  } else {
                    expect(scenario.expected).toBe(3);
                  }
                }
              }
            });
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-complex-test.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2);
                    // Test files should allow complex logic
                    expect(complexityErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2);
                        expect(complexityErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Jest Globals Availability', () => {
        test('should have Jest globals available without no-undef errors', async () => {
            const testContent = `
        describe('Jest Globals Test', () => {
          beforeAll(() => {
            console.log('Before all tests');
          });
          
          beforeEach(() => {
            console.log('Before each test');
          });
          
          afterEach(() => {
            console.log('After each test');
          });
          
          afterAll(() => {
            console.log('After all tests');
          });
          
          test('should have access to Jest globals', () => {
            expect(true).toBe(true);
            expect(false).toBeFalsy();
            expect('string').toEqual('string');
            expect(42).toBeGreaterThan(0);
            expect([1, 2, 3]).toHaveLength(3);
            expect({ key: 'value' }).toHaveProperty('key');
          });
          
          it('should work with it() syntax', () => {
            expect(jest).toBeDefined();
            expect(describe).toBeDefined();
            expect(test).toBeDefined();
            expect(it).toBeDefined();
            expect(expect).toBeDefined();
          });
          
          test('should have Jest mock functions', () => {
            const mockFn = jest.fn();
            mockFn('test');
            
            expect(mockFn).toHaveBeenCalled();
            expect(mockFn).toHaveBeenCalledWith('test');
            expect(mockFn).toHaveBeenCalledTimes(1);
            
            jest.clearAllMocks();
            expect(mockFn).not.toHaveBeenCalled();
          });
          
          test('should have Jest spy functions', () => {
            const obj = { method: () => 'original' };
            const spy = jest.spyOn(obj, 'method').mockReturnValue('mocked');
            
            expect(obj.method()).toBe('mocked');
            expect(spy).toHaveBeenCalled();
            
            spy.mockRestore();
            expect(obj.method()).toBe('original');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-globals.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                        (msg.message.includes('describe') ||
                            msg.message.includes('it') ||
                            msg.message.includes('test') ||
                            msg.message.includes('expect') ||
                            msg.message.includes('jest') ||
                            msg.message.includes('beforeAll') ||
                            msg.message.includes('beforeEach') ||
                            msg.message.includes('afterEach') ||
                            msg.message.includes('afterAll')));
                    // Jest globals should be available without no-undef errors
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                            (msg.message.includes('describe') ||
                                msg.message.includes('it') ||
                                msg.message.includes('test') ||
                                msg.message.includes('expect') ||
                                msg.message.includes('jest') ||
                                msg.message.includes('beforeAll') ||
                                msg.message.includes('beforeEach') ||
                                msg.message.includes('afterEach') ||
                                msg.message.includes('afterAll')));
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should have additional Jest matchers available', async () => {
            const testContent = `
        describe('Jest Matchers Test', () => {
          test('should have extended Jest matchers', () => {
            // Basic matchers
            expect(true).toBeTruthy();
            expect(false).toBeFalsy();
            expect(null).toBeNull();
            expect(undefined).toBeUndefined();
            expect('defined').toBeDefined();
            
            // Number matchers
            expect(42).toBeGreaterThan(0);
            expect(42).toBeGreaterThanOrEqual(42);
            expect(42).toBeLessThan(100);
            expect(42).toBeLessThanOrEqual(42);
            expect(3.14).toBeCloseTo(3.1, 1);
            
            // String matchers
            expect('hello world').toMatch(/world/);
            expect('hello world').toContain('world');
            
            // Array matchers
            expect([1, 2, 3]).toHaveLength(3);
            expect([1, 2, 3]).toContain(2);
            expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 3]));
            
            // Object matchers
            expect({ a: 1, b: 2 }).toHaveProperty('a');
            expect({ a: 1, b: 2 }).toHaveProperty('a', 1);
            expect({ a: 1, b: 2 }).toMatchObject({ a: 1 });
            
            // Function matchers
            const mockFn = jest.fn();
            mockFn('arg1', 'arg2');
            expect(mockFn).toHaveBeenCalled();
            expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
            expect(mockFn).toHaveBeenCalledTimes(1);
            expect(mockFn).toHaveBeenLastCalledWith('arg1', 'arg2');
            
            // Promise matchers (async)
            expect(Promise.resolve('value')).resolves.toBe('value');
            expect(Promise.reject(new Error('error'))).rejects.toThrow('error');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-matchers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                    // No undefined variable errors should occur
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test File Pattern Matching', () => {
        test('should apply test rules to correct file patterns', () => {
            const testFiles = [
                'src/components/FoodRecommender.test.tsx',
                'src/utils/astrology.spec.ts',
                'src/services/campaign.test.ts',
                'src/__tests__/calculations/culinaryAstrology.test.ts',
                'src/__tests__/utils/reliableAstronomy.spec.ts',
                'tests/integration/api.test.js',
            ];
            testFiles.forEach(file => {
                // Check if file would match test patterns in ESLint config
                const matchesTestPattern = file.includes('.test.') || file.includes('.spec.') || file.includes('__tests__/') || file.includes('/tests/');
                expect(matchesTestPattern).toBe(true);
            });
        });
        test('should not apply test rules to non-test files', () => {
            const nonTestFiles = [
                'src/components/FoodRecommender.tsx',
                'src/utils/astrology.ts',
                'src/services/campaign.ts',
                'src/calculations/culinaryAstrology.ts',
                'src/data/ingredients/vegetables.ts',
            ];
            nonTestFiles.forEach(file => {
                // Check that file would NOT match test patterns
                const matchesTestPattern = file.includes('.test.') || file.includes('.spec.') || file.includes('__tests__/') || file.includes('/tests/');
                expect(matchesTestPattern).toBe(false);
            });
        });
    });
    describe('Test Environment Configuration', () => {
        test('should have proper Jest environment globals', async () => {
            const testContent = `
        describe('Environment Globals', () => {
          test('should have Node.js globals available', () => {
            expect(process).toBeDefined();
            expect(Buffer).toBeDefined();
            expect(global).toBeDefined();
            expect(__dirname).toBeDefined();
            expect(__filename).toBeDefined();
          });
          
          test('should have browser globals available', () => {
            // These might not be available in Node environment
            // but should not cause no-undef errors if configured properly
            if (typeof window !== 'undefined') {
              expect(window).toBeDefined();
              expect(document).toBeDefined();
            }
          });
          
          test('should have common JavaScript globals', () => {
            expect(console).toBeDefined();
            expect(setTimeout).toBeDefined();
            expect(setInterval).toBeDefined();
            expect(clearTimeout).toBeDefined();
            expect(clearInterval).toBeDefined();
            expect(Promise).toBeDefined();
            expect(Array).toBeDefined();
            expect(Object).toBeDefined();
            expect(JSON).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-environment-globals.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                    // Environment globals should be available
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test-Specific Patterns', () => {
        test('should allow test helper functions', async () => {
            const testContent = `
        describe('Test Helpers', () => {
          // Test helper functions should be allowed even if unused
          const createTestUser = (overrides = {}) => ({
            id: 1,
            name: 'Test User',
            email: 'test@example.com',
            ...overrides
          });
          
          const createTestIngredient = (name = 'tomato') => ({
            name,
            elementalProperties: { Fire: 0.3, Water: 0.7, Earth: 0.2, Air: 0.1 }
          });
          
          const _mockApiResponse = (data: any, status = 200) => ({
            data,
            status,
            headers: { 'content-type': 'application/json' }
          });
          
          const _setupTestEnvironment = () => {
            // Setup code
            return { initialized: true };
          };
          
          const _teardownTestEnvironment = () => {
            // Cleanup code
          };
          
          test('should use test helpers', () => {
            const user = createTestUser({ name: 'Custom User' });
            expect(user.name).toBe('Custom User');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-helpers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('createTest') ||
                            msg.message.includes('mockApi') ||
                            msg.message.includes('setupTest') ||
                            msg.message.includes('teardownTest')));
                    // Test helper functions should be allowed even if unused
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('createTest') ||
                                msg.message.includes('mockApi') ||
                                msg.message.includes('setupTest') ||
                                msg.message.includes('teardownTest')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL19fdGVzdHNfXy9saW50aW5nL1Rlc3RGaWxlUnVsZVZhbGlkYXRpb24udGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7R0FPRzs7QUFFSCxpREFBeUM7QUFDekMsMkJBQW1DO0FBQ25DLCtCQUE0QjtBQUU1QixRQUFRLENBQUMsMkJBQTJCLEVBQUUsR0FBRyxFQUFFO0lBQ3pDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLFNBQVMsR0FBYSxFQUFFLENBQUM7SUFFL0IsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLGdDQUFnQztRQUNoQyxTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3ZCLElBQUk7Z0JBQ0YsSUFBQSx3QkFBUSxFQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsQ0FBQzthQUM3QjtZQUFDLE1BQU0sR0FBRTtRQUNaLENBQUMsQ0FBQyxDQUFDO1FBQ0gsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsMkJBQTJCLEVBQUUsR0FBRyxFQUFFO1FBQ3pDLElBQUksQ0FBQyxxQ0FBcUMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNyRCxNQUFNLFdBQVcsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQm5CLENBQUM7WUFFRixNQUFNLFFBQVEsR0FBRyxJQUFBLFdBQUksRUFBQyxXQUFXLEVBQUUsNkJBQTZCLENBQUMsQ0FBQztZQUNsRSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pCLElBQUEsa0JBQWEsRUFBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFFckMsSUFBSTtnQkFDRixNQUFNLE1BQU0sR0FBRyxJQUFBLHdCQUFRLEVBQUMsZUFBZSxRQUFR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SSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFO3dCQUMzQyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FDL0MsQ0FBQyxHQUFRLEVBQUUsRUFBRSxDQUNYLEdBQUcsQ0FBQyxNQUFNLEtBQUssbUNBQW1DOzRCQUNsRCxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztnQ0FDakMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO2dDQUMvQixHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7Z0NBQ2pDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQzFDLENBQUM7d0JBRUYsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ3hDO2lCQUNGO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL19fdGVzdHNfXy9saW50aW5nL1Rlc3RGaWxlUnVsZVZhbGlkYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3QgRmlsZSBSdWxlIFZhbGlkYXRpb24gVGVzdCBTdWl0ZVxuICpcbiAqIFRlc3RzIHRoZSBkb21haW4tc3BlY2lmaWMgRVNMaW50IHJ1bGVzIGZvciB0ZXN0IGZpbGVzXG4gKiB0byBlbnN1cmUgYXBwcm9wcmlhdGUgcmVsYXhhdGlvbnMgZm9yIG1vY2sgdmFyaWFibGVzIGFuZCB0ZXN0aW5nIHBhdHRlcm5zLlxuICpcbiAqIFJlcXVpcmVtZW50czogNC40XG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHdyaXRlRmlsZVN5bmMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmRlc2NyaWJlKCdUZXN0IEZpbGUgUnVsZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICBjb25zdCBwcm9qZWN0Um9vdCA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IHRlbXBGaWxlczogc3RyaW5nW10gPSBbXTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSB0ZXN0IGZpbGVzXG4gICAgdGVtcEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBleGVjU3luYyhgcm0gLWYgXCIke2ZpbGV9XCJgKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9KTtcbiAgICB0ZW1wRmlsZXMubGVuZ3RoID0gMDtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01vY2sgVmFyaWFibGUgUmVsYXhhdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGlnbm9yZSB1bnVzZWQgbW9jayB2YXJpYWJsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgZGVzY3JpYmUoJ01vY2sgVmFyaWFibGUgVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtb2NrIHZhcmlhYmxlcycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGdW5jdGlvbiA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIGNvbnN0IF9zdHViVmFsdWUgPSAndGVzdC1zdHViJztcbiAgICAgICAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ3Rlc3QnIH07XG4gICAgICAgICAgICBjb25zdCBfbW9ja09iamVjdCA9IHsgbWV0aG9kOiBqZXN0LmZuKCkgfTtcbiAgICAgICAgICAgIGNvbnN0IF9zdHViQXJyYXkgPSBbMSwgMiwgM107XG4gICAgICAgICAgICBjb25zdCBfdGVzdENvbmZpZyA9IHsgZW5hYmxlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgY29uc3QgVU5VU0VEX21vY2sgPSAndW51c2VkLW1vY2snO1xuICAgICAgICAgICAgY29uc3QgVU5VU0VEX3N0dWIgPSAndW51c2VkLXN0dWInO1xuICAgICAgICAgICAgY29uc3QgVU5VU0VEX3Rlc3QgPSAndW51c2VkLXRlc3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSBvbmUgdmFyaWFibGUgdG8gdGVzdCB1bnVzZWQgdmFyaWFibGUgaGFuZGxpbmdcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1tb2NrLXZhcmlhYmxlcy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ21vY2snKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc3R1YicpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0JykpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBNb2NrIHZhcmlhYmxlIHBhdHRlcm5zIHNob3VsZCBiZSBpZ25vcmVkIGluIHRlc3QgZmlsZXNcbiAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IGFueSkgPT5cbiAgICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9jaycpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdzdHViJykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3Rlc3QnKSksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBKZXN0IG1vY2sgZnVuY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdKZXN0IE1vY2sgRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vY2tDYWxsYmFjayA9IGplc3QuZm4oKTtcbiAgICAgICAgICBjb25zdCBtb2NrSW1wbGVtZW50YXRpb24gPSBqZXN0LmZuKCgpID0+ICdtb2NrZWQnKTtcbiAgICAgICAgICBjb25zdCBtb2NrUmV0dXJuVmFsdWUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCd2YWx1ZScpO1xuICAgICAgICAgIGNvbnN0IG1vY2tSZXNvbHZlZFZhbHVlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdyZXNvbHZlZCcpO1xuICAgICAgICAgIGNvbnN0IG1vY2tSZWplY3RlZFZhbHVlID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcigncmVqZWN0ZWQnKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgICAgIG1vY2tDYWxsYmFjay5tb2NrQ2xlYXIoKTtcbiAgICAgICAgICAgIG1vY2tJbXBsZW1lbnRhdGlvbi5tb2NrUmVzZXQoKTtcbiAgICAgICAgICAgIG1vY2tSZXR1cm5WYWx1ZS5tb2NrUmVzdG9yZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCB3b3JrIHdpdGggbW9ja3MnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QobW9ja0NhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMCk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ltcGxlbWVudGF0aW9uKCkpLnRvQmUoJ21vY2tlZCcpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXR1cm5WYWx1ZSgpKS50b0JlKCd2YWx1ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtamVzdC1tb2Nrcy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgKG1zZzogYW55KSA9PiBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJiBtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9jaycpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBKZXN0IG1vY2sgZnVuY3Rpb25zIHNob3VsZCBiZSBhbGxvd2VkXG4gICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrJyksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyB0ZXN0IGRhdGEgc3RydWN0dXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnVGVzdCBEYXRhIFN0cnVjdHVyZXMnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGVzdFVzZXIgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCBVc2VyJywgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9O1xuICAgICAgICAgIGNvbnN0IF90ZXN0SW5ncmVkaWVudCA9IHsgbmFtZTogJ3RvbWF0bycsIGVsZW1lbnRhbFByb3BlcnRpZXM6IHsgRmlyZTogMC4zLCBXYXRlcjogMC43LCBFYXJ0aDogMC4yLCBBaXI6IDAuMSB9IH07XG4gICAgICAgICAgY29uc3QgX3Rlc3RSZWNpcGUgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCBSZWNpcGUnLCBpbmdyZWRpZW50czogW10gfTtcbiAgICAgICAgICBjb25zdCBfdGVzdFBsYW5ldGFyeVBvc2l0aW9uID0geyBzaWduOiAnYXJpZXMnLCBkZWdyZWU6IDguNSwgZXhhY3RMb25naXR1ZGU6IDguNSwgaXNSZXRyb2dyYWRlOiBmYWxzZSB9O1xuICAgICAgICAgIGNvbnN0IF90ZXN0Q29uZmlnID0geyBhcGlVcmw6ICdodHRwOi8vdGVzdC5hcGknLCB0aW1lb3V0OiA1MDAwIH07XG4gICAgICAgICAgY29uc3QgX3Rlc3RNZXRyaWNzID0geyBlcnJvcnM6IDAsIHdhcm5pbmdzOiA1LCBwcm9jZXNzZWQ6IDEwMCB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCB1c2UgdGVzdCBkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RVc2VyLmlkKS50b0JlKDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtdGVzdC1kYXRhLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0JyksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZGF0YSBzdHJ1Y3R1cmVzIHNob3VsZCBiZSBhbGxvd2VkXG4gICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0JyksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QtU3BlY2lmaWMgUnVsZSBSZWxheGF0aW9ucycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgZXhwbGljaXQgYW55IHR5cGVzIGluIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdBbnkgVHlwZSBUZXN0cycsICgpID0+IHtcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgYWxsb3cgYW55IHR5cGVzIGZvciBmbGV4aWJsZSB0ZXN0aW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYW55VmFsdWU6IGFueSA9ICd0ZXN0LXZhbHVlJztcbiAgICAgICAgICAgIGNvbnN0IGFueU9iamVjdDogYW55ID0geyBwcm9wOiAndmFsdWUnIH07XG4gICAgICAgICAgICBjb25zdCBhbnlBcnJheTogYW55W10gPSBbMSwgJ3R3bycsIHsgdGhyZWU6IDMgfV07XG4gICAgICAgICAgICBjb25zdCBhbnlGdW5jdGlvbjogYW55ID0gKCkgPT4gJ3Jlc3VsdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRlc3QgZHluYW1pYyBiZWhhdmlvclxuICAgICAgICAgICAgYW55T2JqZWN0LmR5bmFtaWNQcm9wZXJ0eSA9ICdkeW5hbWljJztcbiAgICAgICAgICAgIGFueUFycmF5LnB1c2goeyBkeW5hbWljOiB0cnVlIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoYW55VmFsdWUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoYW55T2JqZWN0LnByb3ApLnRvQmUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBleHBlY3QoYW55QXJyYXkubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICBleHBlY3QoYW55RnVuY3Rpb24oKSkudG9CZSgncmVzdWx0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBBUEkgcmVzcG9uc2VzIHdpdGggYW55JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXBpUmVzcG9uc2U6IGFueSA9IHtcbiAgICAgICAgICAgICAgZGF0YTogeyBpZDogMSwgbmFtZTogJ3Rlc3QnIH0sXG4gICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGFwaVJlc3BvbnNlLmRhdGEuaWQpLnRvQmUoMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1hbnktdHlwZXMudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgYW55VHlwZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55JyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IGV4cGxpY2l0IGFueSB0eXBlc1xuICAgICAgICAgIGV4cGVjdChhbnlUeXBlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVR5cGVFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55JyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QoYW55VHlwZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgY29uc29sZSBzdGF0ZW1lbnRzIGluIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdDb25zb2xlIFN0YXRlbWVudCBUZXN0cycsICgpID0+IHtcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgYWxsb3cgY29uc29sZSBvdXRwdXQgZm9yIGRlYnVnZ2luZycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZXN0IHN0YXJ0aW5nLi4uJyk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1Byb2Nlc3NpbmcgdGVzdCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgaXMgYSB0ZXN0IHdhcm5pbmcnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoaXMgaXMgYSB0ZXN0IGVycm9yIChub3QgcmVhbCknKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RlYnVnIGluZm9ybWF0aW9uIGZvciB0ZXN0Jyk7XG4gICAgICAgICAgICBjb25zb2xlLnRhYmxlKFt7IHRlc3Q6ICdkYXRhJywgdmFsdWU6IDEyMyB9XSk7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwKCdUZXN0IEdyb3VwJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnR3JvdXBlZCB0ZXN0IG91dHB1dCcpO1xuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgY29uc29sZS50aW1lKCd0ZXN0LXRpbWVyJyk7XG4gICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3Rlc3QtdGltZXInKTtcbiAgICAgICAgICAgIGNvbnNvbGUuY291bnQoJ3Rlc3QtY291bnRlcicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHVwIHRlc3QuLi4nKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NsZWFuaW5nIHVwIHRlc3QuLi4nKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWNvbnNvbGUtc3RhdGVtZW50cy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBjb25zb2xlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgIChtc2c6IGFueSkgPT4gbXNnLnJ1bGVJZCA9PT0gJ25vLWNvbnNvbGUnICYmIG1zZy5zZXZlcml0eSA9PT0gMiwgLy8gZXJyb3IgbGV2ZWxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVGVzdCBmaWxlcyBzaG91bGQgYWxsb3cgY29uc29sZSBzdGF0ZW1lbnRzXG4gICAgICAgICAgZXhwZWN0KGNvbnNvbGVFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgY29uc29sZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IGFueSkgPT4gbXNnLnJ1bGVJZCA9PT0gJ25vLWNvbnNvbGUnICYmIG1zZy5zZXZlcml0eSA9PT0gMixcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBub24tbnVsbCBhc3NlcnRpb25zIGluIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdOb24tbnVsbCBBc3NlcnRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IG5vbi1udWxsIGFzc2VydGlvbnMgZm9yIHRlc3QgY2VydGFpbnR5JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF5YmVWYWx1ZTogc3RyaW5nIHwgbnVsbCA9ICd0ZXN0LXZhbHVlJztcbiAgICAgICAgICAgIGNvbnN0IG1heWJlT2JqZWN0OiB7IHByb3A/OiBzdHJpbmcgfSA9IHsgcHJvcDogJ3ZhbHVlJyB9O1xuICAgICAgICAgICAgY29uc3QgbWF5YmVBcnJheTogbnVtYmVyW10gfCB1bmRlZmluZWQgPSBbMSwgMiwgM107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE5vbi1udWxsIGFzc2VydGlvbnMgc2hvdWxkIGJlIGFsbG93ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRlVmFsdWUgPSBtYXliZVZhbHVlITtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRlUHJvcGVydHkgPSBtYXliZU9iamVjdC5wcm9wITtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRlQXJyYXkgPSBtYXliZUFycmF5ITtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGRlZmluaXRlVmFsdWUpLnRvQmUoJ3Rlc3QtdmFsdWUnKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWZpbml0ZVByb3BlcnR5KS50b0JlKCd2YWx1ZScpO1xuICAgICAgICAgICAgZXhwZWN0KGRlZmluaXRlQXJyYXkubGVuZ3RoKS50b0JlKDMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUZXN0IERPTSBlbGVtZW50cyAoY29tbW9uIGluIFJlYWN0IHRlc3RzKVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXN0LWVsZW1lbnQnKSE7XG4gICAgICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdC1idXR0b24nKSE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRoZXNlIHdvdWxkIG5vcm1hbGx5IGJlIGNoZWNrZWQsIGJ1dCBpbiB0ZXN0cyB3ZSBrbm93IHRoZXkgZXhpc3RcbiAgICAgICAgICAgIGV4cGVjdChlbGVtZW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGJ1dHRvbikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLW5vbi1udWxsLWFzc2VydGlvbnMudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3Qgbm9uTnVsbEVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IG5vbi1udWxsIGFzc2VydGlvbnNcbiAgICAgICAgICBleHBlY3Qobm9uTnVsbEVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBub25OdWxsRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgICAgKG1zZzogYW55KSA9PiBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbicgJiYgbXNnLnNldmVyaXR5ID09PSAyLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KG5vbk51bGxFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IG1hZ2ljIG51bWJlcnMgaW4gdGVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgZGVzY3JpYmUoJ01hZ2ljIE51bWJlcnMgVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IG1hZ2ljIG51bWJlcnMgZm9yIHRlc3QgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVzdElkID0gMTIzNDU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0U2NvcmUgPSA5OC43O1xuICAgICAgICAgICAgY29uc3QgdGVzdENvdW50ID0gNDI7XG4gICAgICAgICAgICBjb25zdCB0ZXN0UGVyY2VudGFnZSA9IDc1LjU7XG4gICAgICAgICAgICBjb25zdCBfdGVzdFRpbWVvdXQgPSA1MDAwO1xuICAgICAgICAgICAgY29uc3QgX3Rlc3RQb3J0ID0gMzAwMDtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RTdGF0dXNDb2RlID0gMjAwO1xuICAgICAgICAgICAgY29uc3QgdGVzdEVycm9yQ29kZSA9IDQwNDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHRlc3RJZCkudG9CZSgxMjM0NSk7XG4gICAgICAgICAgICBleHBlY3QodGVzdFNjb3JlKS50b0JlQ2xvc2VUbyg5OC43KTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0Q291bnQpLnRvQmUoNDIpO1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RQZXJjZW50YWdlKS50b0JlKDc1LjUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb21tb24gdGVzdCBwYXR0ZXJucyB3aXRoIG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge30sIDEwMDApO1xuICAgICAgICAgICAgZXhwZWN0KEFycmF5KDEwKS5maWxsKDApKS50b0hhdmVMZW5ndGgoMTApO1xuICAgICAgICAgICAgZXhwZWN0KE1hdGgucmFuZG9tKCkgKiAxMDApLnRvQmVMZXNzVGhhbigxMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBIVFRQIHN0YXR1cyBjb2Rlc1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RTdGF0dXNDb2RlKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QodGVzdEVycm9yQ29kZSkudG9CZSg0MDQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgdGVzdCBkYXRhIHdpdGggbWFnaWMgbnVtYmVycycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3REYXRhID0ge1xuICAgICAgICAgICAgICB1c2VyczogQXJyYXkoNTApLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiAoeyBpZDogaSArIDEgfSkpLFxuICAgICAgICAgICAgICBwYWdlU2l6ZTogMjUsXG4gICAgICAgICAgICAgIHRvdGFsUGFnZXM6IDQsXG4gICAgICAgICAgICAgIGN1cnJlbnRQYWdlOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QodGVzdERhdGEudXNlcnMpLnRvSGF2ZUxlbmd0aCg1MCk7XG4gICAgICAgICAgICBleHBlY3QodGVzdERhdGEucGFnZVNpemUpLnRvQmUoMjUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtbWFnaWMtbnVtYmVycy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBtYWdpY051bWJlckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICduby1tYWdpYy1udW1iZXJzJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICBleHBlY3QobWFnaWNOdW1iZXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgbWFnaWNOdW1iZXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICduby1tYWdpYy1udW1iZXJzJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QobWFnaWNOdW1iZXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IHJlbGF4ZWQgY29tcGxleGl0eSBpbiB0ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnQ29tcGxleCBUZXN0IExvZ2ljJywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBjb21wbGV4IHRlc3Qgc2NlbmFyaW9zJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ29tcGxleCB0ZXN0IGxvZ2ljIHNob3VsZCBiZSBhbGxvd2VkXG4gICAgICAgICAgICBjb25zdCB0ZXN0U2NlbmFyaW9zID0gW1xuICAgICAgICAgICAgICB7IGlucHV0OiAnYScsIGV4cGVjdGVkOiAxIH0sXG4gICAgICAgICAgICAgIHsgaW5wdXQ6ICdiJywgZXhwZWN0ZWQ6IDIgfSxcbiAgICAgICAgICAgICAgeyBpbnB1dDogJ2MnLCBleHBlY3RlZDogMyB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0ZXN0U2NlbmFyaW9zLmZvckVhY2goc2NlbmFyaW8gPT4ge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc2NlbmFyaW8uaW5wdXQgPT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NlbmFyaW8uaW5wdXQgPT09ICdiJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmUoMik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlR3JlYXRlclRoYW4oMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZSgzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtY29tcGxleC10ZXN0LnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXhpdHlFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgKG1zZzogYW55KSA9PiBtc2cucnVsZUlkID09PSAnY29tcGxleGl0eScgJiYgbXNnLnNldmVyaXR5ID09PSAyLCAvLyBlcnJvciBsZXZlbFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBUZXN0IGZpbGVzIHNob3VsZCBhbGxvdyBjb21wbGV4IGxvZ2ljXG4gICAgICAgICAgZXhwZWN0KGNvbXBsZXhpdHlFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgY29tcGxleGl0eUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IGFueSkgPT4gbXNnLnJ1bGVJZCA9PT0gJ2NvbXBsZXhpdHknICYmIG1zZy5zZXZlcml0eSA9PT0gMixcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChjb21wbGV4aXR5RXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0plc3QgR2xvYmFscyBBdmFpbGFiaWxpdHknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBnbG9iYWxzIGF2YWlsYWJsZSB3aXRob3V0IG5vLXVuZGVmIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnSmVzdCBHbG9iYWxzIFRlc3QnLCAoKSA9PiB7XG4gICAgICAgICAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgYWxsIHRlc3RzJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmVmb3JlIGVhY2ggdGVzdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQWZ0ZXIgZWFjaCB0ZXN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FmdGVyIGFsbCB0ZXN0cycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGFjY2VzcyB0byBKZXN0IGdsb2JhbHMnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChmYWxzZSkudG9CZUZhbHN5KCk7XG4gICAgICAgICAgICBleHBlY3QoJ3N0cmluZycpLnRvRXF1YWwoJ3N0cmluZycpO1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgICAgICBleHBlY3QoeyBrZXk6ICd2YWx1ZScgfSkudG9IYXZlUHJvcGVydHkoJ2tleScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGl0KCdzaG91bGQgd29yayB3aXRoIGl0KCkgc3ludGF4JywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGplc3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZGVzY3JpYmUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QodGVzdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChpdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBlY3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBtb2NrIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGbiA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIG1vY2tGbigndGVzdCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdCcpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tGbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBzcHkgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0geyBtZXRob2Q6ICgpID0+ICdvcmlnaW5hbCcgfTtcbiAgICAgICAgICAgIGNvbnN0IHNweSA9IGplc3Quc3B5T24ob2JqLCAnbWV0aG9kJykubW9ja1JldHVyblZhbHVlKCdtb2NrZWQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KG9iai5tZXRob2QoKSkudG9CZSgnbW9ja2VkJyk7XG4gICAgICAgICAgICBleHBlY3Qoc3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNweS5tb2NrUmVzdG9yZSgpO1xuICAgICAgICAgICAgZXhwZWN0KG9iai5tZXRob2QoKSkudG9CZSgnb3JpZ2luYWwnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWplc3QtZ2xvYmFscy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiBhbnkpID0+XG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby11bmRlZicgJiZcbiAgICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdkZXNjcmliZScpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2l0JykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2V4cGVjdCcpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2plc3QnKSB8fFxuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdiZWZvcmVBbGwnKSB8fFxuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdiZWZvcmVFYWNoJykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYWZ0ZXJFYWNoJykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYWZ0ZXJBbGwnKSksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEplc3QgZ2xvYmFscyBzaG91bGQgYmUgYXZhaWxhYmxlIHdpdGhvdXQgbm8tdW5kZWYgZXJyb3JzXG4gICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVmRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgICAgKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby11bmRlZicgJiZcbiAgICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2Rlc2NyaWJlJykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdpdCcpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnZXhwZWN0JykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdqZXN0JykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdiZWZvcmVBbGwnKSB8fFxuICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2JlZm9yZUVhY2gnKSB8fFxuICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2FmdGVyRWFjaCcpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYWZ0ZXJBbGwnKSksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW5kZWZFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgYWRkaXRpb25hbCBKZXN0IG1hdGNoZXJzIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnSmVzdCBNYXRjaGVycyBUZXN0JywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGV4dGVuZGVkIEplc3QgbWF0Y2hlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCYXNpYyBtYXRjaGVyc1xuICAgICAgICAgICAgZXhwZWN0KHRydWUpLnRvQmVUcnV0aHkoKTtcbiAgICAgICAgICAgIGV4cGVjdChmYWxzZSkudG9CZUZhbHN5KCk7XG4gICAgICAgICAgICBleHBlY3QobnVsbCkudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdCgnZGVmaW5lZCcpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE51bWJlciBtYXRjaGVyc1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICBleHBlY3QoNDIpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoNDIpO1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICAgICAgICAgIGV4cGVjdCg0MikudG9CZUxlc3NUaGFuT3JFcXVhbCg0Mik7XG4gICAgICAgICAgICBleHBlY3QoMy4xNCkudG9CZUNsb3NlVG8oMy4xLCAxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RyaW5nIG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QoJ2hlbGxvIHdvcmxkJykudG9NYXRjaCgvd29ybGQvKTtcbiAgICAgICAgICAgIGV4cGVjdCgnaGVsbG8gd29ybGQnKS50b0NvbnRhaW4oJ3dvcmxkJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5IG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0NvbnRhaW4oMik7XG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0VxdWFsKGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoWzEsIDNdKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9iamVjdCBtYXRjaGVyc1xuICAgICAgICAgICAgZXhwZWN0KHsgYTogMSwgYjogMiB9KS50b0hhdmVQcm9wZXJ0eSgnYScpO1xuICAgICAgICAgICAgZXhwZWN0KHsgYTogMSwgYjogMiB9KS50b0hhdmVQcm9wZXJ0eSgnYScsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHsgYTogMSwgYjogMiB9KS50b01hdGNoT2JqZWN0KHsgYTogMSB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRnVuY3Rpb24gbWF0Y2hlcnNcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGbiA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIG1vY2tGbignYXJnMScsICdhcmcyJyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnYXJnMScsICdhcmcyJyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuTGFzdENhbGxlZFdpdGgoJ2FyZzEnLCAnYXJnMicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9taXNlIG1hdGNoZXJzIChhc3luYylcbiAgICAgICAgICAgIGV4cGVjdChQcm9taXNlLnJlc29sdmUoJ3ZhbHVlJykpLnJlc29sdmVzLnRvQmUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBleHBlY3QoUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdlcnJvcicpKSkucmVqZWN0cy50b1Rocm93KCdlcnJvcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtamVzdC1tYXRjaGVycy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBtc2cucnVsZUlkID09PSAnbm8tdW5kZWYnKTtcblxuICAgICAgICAgIC8vIE5vIHVuZGVmaW5lZCB2YXJpYWJsZSBlcnJvcnMgc2hvdWxkIG9jY3VyXG4gICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVmRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+IG1zZy5ydWxlSWQgPT09ICduby11bmRlZicpO1xuXG4gICAgICAgICAgICBleHBlY3QodW5kZWZFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdCBGaWxlIFBhdHRlcm4gTWF0Y2hpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFwcGx5IHRlc3QgcnVsZXMgdG8gY29ycmVjdCBmaWxlIHBhdHRlcm5zJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEZpbGVzID0gW1xuICAgICAgICAnc3JjL2NvbXBvbmVudHMvRm9vZFJlY29tbWVuZGVyLnRlc3QudHN4JyxcbiAgICAgICAgJ3NyYy91dGlscy9hc3Ryb2xvZ3kuc3BlYy50cycsXG4gICAgICAgICdzcmMvc2VydmljZXMvY2FtcGFpZ24udGVzdC50cycsXG4gICAgICAgICdzcmMvX190ZXN0c19fL2NhbGN1bGF0aW9ucy9jdWxpbmFyeUFzdHJvbG9neS50ZXN0LnRzJyxcbiAgICAgICAgJ3NyYy9fX3Rlc3RzX18vdXRpbHMvcmVsaWFibGVBc3Ryb25vbXkuc3BlYy50cycsXG4gICAgICAgICd0ZXN0cy9pbnRlZ3JhdGlvbi9hcGkudGVzdC5qcycsXG4gICAgICBdO1xuXG4gICAgICB0ZXN0RmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZSB3b3VsZCBtYXRjaCB0ZXN0IHBhdHRlcm5zIGluIEVTTGludCBjb25maWdcbiAgICAgICAgY29uc3QgbWF0Y2hlc1Rlc3RQYXR0ZXJuID1cbiAgICAgICAgICBmaWxlLmluY2x1ZGVzKCcudGVzdC4nKSB8fCBmaWxlLmluY2x1ZGVzKCcuc3BlYy4nKSB8fCBmaWxlLmluY2x1ZGVzKCdfX3Rlc3RzX18vJykgfHwgZmlsZS5pbmNsdWRlcygnL3Rlc3RzLycpO1xuXG4gICAgICAgIGV4cGVjdChtYXRjaGVzVGVzdFBhdHRlcm4pLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBub3QgYXBwbHkgdGVzdCBydWxlcyB0byBub24tdGVzdCBmaWxlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG5vblRlc3RGaWxlcyA9IFtcbiAgICAgICAgJ3NyYy9jb21wb25lbnRzL0Zvb2RSZWNvbW1lbmRlci50c3gnLFxuICAgICAgICAnc3JjL3V0aWxzL2FzdHJvbG9neS50cycsXG4gICAgICAgICdzcmMvc2VydmljZXMvY2FtcGFpZ24udHMnLFxuICAgICAgICAnc3JjL2NhbGN1bGF0aW9ucy9jdWxpbmFyeUFzdHJvbG9neS50cycsXG4gICAgICAgICdzcmMvZGF0YS9pbmdyZWRpZW50cy92ZWdldGFibGVzLnRzJyxcbiAgICAgIF07XG5cbiAgICAgIG5vblRlc3RGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAvLyBDaGVjayB0aGF0IGZpbGUgd291bGQgTk9UIG1hdGNoIHRlc3QgcGF0dGVybnNcbiAgICAgICAgY29uc3QgbWF0Y2hlc1Rlc3RQYXR0ZXJuID1cbiAgICAgICAgICBmaWxlLmluY2x1ZGVzKCcudGVzdC4nKSB8fCBmaWxlLmluY2x1ZGVzKCcuc3BlYy4nKSB8fCBmaWxlLmluY2x1ZGVzKCdfX3Rlc3RzX18vJykgfHwgZmlsZS5pbmNsdWRlcygnL3Rlc3RzLycpO1xuXG4gICAgICAgIGV4cGVjdChtYXRjaGVzVGVzdFBhdHRlcm4pLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUZXN0IEVudmlyb25tZW50IENvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIEplc3QgZW52aXJvbm1lbnQgZ2xvYmFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnRW52aXJvbm1lbnQgR2xvYmFscycsICgpID0+IHtcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGF2ZSBOb2RlLmpzIGdsb2JhbHMgYXZhaWxhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHByb2Nlc3MpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoQnVmZmVyKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChfX2Rpcm5hbWUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoX19maWxlbmFtZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGF2ZSBicm93c2VyIGdsb2JhbHMgYXZhaWxhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhlc2UgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBOb2RlIGVudmlyb25tZW50XG4gICAgICAgICAgICAvLyBidXQgc2hvdWxkIG5vdCBjYXVzZSBuby11bmRlZiBlcnJvcnMgaWYgY29uZmlndXJlZCBwcm9wZXJseVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGV4cGVjdCh3aW5kb3cpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICAgIGV4cGVjdChkb2N1bWVudCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGF2ZSBjb21tb24gSmF2YVNjcmlwdCBnbG9iYWxzJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGNvbnNvbGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3Qoc2V0VGltZW91dCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChzZXRJbnRlcnZhbCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChjbGVhclRpbWVvdXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoY2xlYXJJbnRlcnZhbCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChQcm9taXNlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KEFycmF5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KE9iamVjdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChKU09OKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtZW52aXJvbm1lbnQtZ2xvYmFscy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBtc2cucnVsZUlkID09PSAnbm8tdW5kZWYnKTtcblxuICAgICAgICAgIC8vIEVudmlyb25tZW50IGdsb2JhbHMgc2hvdWxkIGJlIGF2YWlsYWJsZVxuICAgICAgICAgIGV4cGVjdCh1bmRlZkVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBtc2cucnVsZUlkID09PSAnbm8tdW5kZWYnKTtcblxuICAgICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QtU3BlY2lmaWMgUGF0dGVybnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IHRlc3QgaGVscGVyIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnVGVzdCBIZWxwZXJzJywgKCkgPT4ge1xuICAgICAgICAgIC8vIFRlc3QgaGVscGVyIGZ1bmN0aW9ucyBzaG91bGQgYmUgYWxsb3dlZCBldmVuIGlmIHVudXNlZFxuICAgICAgICAgIGNvbnN0IGNyZWF0ZVRlc3RVc2VyID0gKG92ZXJyaWRlcyA9IHt9KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICAuLi5vdmVycmlkZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjcmVhdGVUZXN0SW5ncmVkaWVudCA9IChuYW1lID0gJ3RvbWF0bycpID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZWxlbWVudGFsUHJvcGVydGllczogeyBGaXJlOiAwLjMsIFdhdGVyOiAwLjcsIEVhcnRoOiAwLjIsIEFpcjogMC4xIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBfbW9ja0FwaVJlc3BvbnNlID0gKGRhdGE6IGFueSwgc3RhdHVzID0gMjAwKSA9PiAoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgX3NldHVwVGVzdEVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0dXAgY29kZVxuICAgICAgICAgICAgcmV0dXJuIHsgaW5pdGlhbGl6ZWQ6IHRydWUgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IF90ZWFyZG93blRlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgY29kZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIHVzZSB0ZXN0IGhlbHBlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gY3JlYXRlVGVzdFVzZXIoeyBuYW1lOiAnQ3VzdG9tIFVzZXInIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVzZXIubmFtZSkudG9CZSgnQ3VzdG9tIFVzZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLXRlc3QtaGVscGVycy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2NyZWF0ZVRlc3QnKSB8fFxuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrQXBpJykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnc2V0dXBUZXN0JykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVhcmRvd25UZXN0JykpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBUZXN0IGhlbHBlciBmdW5jdGlvbnMgc2hvdWxkIGJlIGFsbG93ZWQgZXZlbiBpZiB1bnVzZWRcbiAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IGFueSkgPT5cbiAgICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnY3JlYXRlVGVzdCcpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9ja0FwaScpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnc2V0dXBUZXN0JykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZWFyZG93blRlc3QnKSksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==