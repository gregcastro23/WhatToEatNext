{"file":"/Users/GregCastro/Desktop/WhatToEatNext/src/utils/calculationCache.ts","mappings":"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","names":[],"sources":["/Users/GregCastro/Desktop/WhatToEatNext/src/utils/calculationCache.ts"],"sourcesContent":["/**\n * Calculation Cache Utility\n * \n * A utility for caching expensive calculations with precise TypeScript typing\n * and performance monitoring.\n */\n\ninterface CacheItem<T> {\n  value: T;\n  timestamp: number;\n  input: string; // JSON string of inputs for comparison\n}\n\n// Global cache store\nconst calculationCache: Record<string, CacheItem<any>> = {};\n\n// Default TTL is 60 seconds - adjust based on how quickly data changes\nconst DEFAULT_CACHE_TTL = 60 * 1000; \n\n/**\n * Get a cached calculation result or compute and cache it if not found\n * \n * @param cacheKey - Unique identifier for this calculation\n * @param inputObj - Object representing the calculation inputs (for comparison)\n * @param calculationFn - Function that performs the actual calculation\n * @param ttl - Optional TTL in milliseconds (defaults to 60s)\n * @returns The calculation result (either from cache or freshly computed)\n */\nexport function getCachedCalculation<T>(\n  cacheKey: string,\n  inputObj: Record<string, unknown>,\n  calculationFn: () => T | Promise<T>,\n  ttl: number = DEFAULT_CACHE_TTL\n): T | Promise<T> {\n  // Create a hash of the input for comparison\n  const inputHash = JSON.stringify(inputObj);\n  const now = Date.now();\n  const cached = calculationCache[cacheKey];\n  \n  // Check if we have a valid cached result\n  if (cached && \n      cached.input === inputHash && \n      (now - cached.timestamp) < ttl) {\n    console.log(`ðŸ”„ Cache hit for ${cacheKey} (age: ${Math.round((now - cached.timestamp)/1000)}s)`);\n    return cached.value;\n  }\n  \n  // Log cache miss\n  console.log(`âš¡ Cache miss for ${cacheKey}, calculating...`);\n  \n  try {\n    // Perform the calculation\n    const resultOrPromise = calculationFn();\n    \n    // Handle both synchronous and asynchronous calculations\n    if (resultOrPromise instanceof Promise) {\n      // For async functions, return a promise that caches when resolved\n      return resultOrPromise.then(asyncResult => {\n        calculationCache[cacheKey] = {\n          value: asyncResult,\n          timestamp: Date.now(), // Use current time (not 'now') for actual caching\n          input: inputHash\n        };\n        return asyncResult;\n      });\n    } else {\n      // For synchronous functions, cache immediately\n      calculationCache[cacheKey] = {\n        value: resultOrPromise,\n        timestamp: now,\n        input: inputHash\n      };\n      return resultOrPromise;\n    }\n  } catch (error) {\n    console.error(`Error in cached calculation ${cacheKey}:`, error);\n    throw error; // Re-throw to let caller handle errors\n  }\n}\n\n/**\n * Clear all cached calculations or a specific cache entry\n * @param cacheKey - Optional specific cache key to clear\n */\nexport function clearCalculationCache(cacheKey?: string): void {\n  if (cacheKey) {\n    delete calculationCache[cacheKey];\n    console.log(`Cache cleared for: ${cacheKey}`);\n  } else {\n    // Clear all cache entries\n    Object.keys(calculationCache).forEach(key => {\n      delete calculationCache[key];\n    });\n    console.log('All calculation cache entries cleared');\n  }\n}\n\n/**\n * Get cache statistics for debugging\n */\nexport function getCacheStats(): {\n  totalEntries: number;\n  keys: string[];\n  oldestEntry: number;\n  newestEntry: number;\n} {\n  const keys = Object.keys(calculationCache);\n  const timestamps = keys.map(key => calculationCache[key].timestamp);\n  \n  return {\n    totalEntries: keys.length,\n    keys,\n    oldestEntry: timestamps.length ? Math.min(...timestamps) : 0,\n    newestEntry: timestamps.length ? Math.max(...timestamps) : 0\n  };\n} "],"version":3}