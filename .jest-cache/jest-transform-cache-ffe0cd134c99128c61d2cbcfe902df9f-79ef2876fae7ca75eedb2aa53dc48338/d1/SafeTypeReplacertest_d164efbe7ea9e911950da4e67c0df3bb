b3e6f158a62aca8afcde19aed3b040d8
"use strict";
/**
 * SafeTypeReplacer Tests
 * Comprehensive test suite for the Safe Type Replacer system
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock execSync for TypeScript compilation tests
jest.mock('child_process');
// Mock fs for file operations
jest.mock('fs');
// Mock SafetyValidator
jest.mock('../SafetyValidator');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const SafeTypeReplacer_1 = require("../SafeTypeReplacer");
const types_1 = require("../types");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
const MockSafetyValidator = jest.fn().mockImplementation(() => ({
    calculateSafetyScore: jest.fn().mockReturnValue({
        isValid: true,
        safetyScore: 0.9,
        validationErrors: [],
        warnings: [],
        recommendations: []
    }),
    validateTypeScriptCompilation: jest.fn().mockResolvedValue({
        buildSuccessful: true,
        compilationErrors: [],
        lintingWarnings: [],
        performanceMetrics: { buildTime: 100, memoryUsage: 1000000 }
    }),
    validateBuildAfterBatch: jest.fn().mockResolvedValue({
        buildSuccessful: true,
        compilationErrors: [],
        lintingWarnings: [],
        performanceMetrics: { buildTime: 100, memoryUsage: 1000000 }
    }),
    validateRollbackCapability: jest.fn().mockResolvedValue({
        canRollback: true,
        backupIntegrity: true,
        rollbackErrors: [],
        restorationVerified: true
    }),
    updateSafetyThresholds: jest.fn()
}));
describe('SafeTypeReplacer', () => {
    let replacer;
    let testBackupDir;
    beforeEach(() => {
        jest.clearAllMocks();
        testBackupDir = './.test-backups';
        replacer = new SafeTypeReplacer_1.SafeTypeReplacer(testBackupDir, 0.7, 30000, 3);
        // Mock fs.existsSync to return false for backup directory initially
        mockFs.existsSync.mockImplementation((path) => {
            if (path === testBackupDir)
                return false;
            return true; // Assume other files exist
        });
        // Mock fs.mkdirSync
        mockFs.mkdirSync.mockImplementation(() => undefined);
        // Mock fs.readFileSync and writeFileSync
        mockFs.readFileSync.mockImplementation(() => 'const items: any[] = [];');
        mockFs.writeFileSync.mockImplementation(() => undefined);
        // Mock successful TypeScript compilation by default
        mockExecSync.mockImplementation(() => '');
    });
    describe('Constructor and Initialization', () => {
        test('creates backup directory if it does not exist', () => {
            expect(mockFs.mkdirSync).toHaveBeenCalledWith(testBackupDir, { recursive: true });
        });
        test('initializes with default strategies', () => {
            const strategies = replacer.getStrategies();
            expect(strategies).toHaveLength(10);
            expect(strategies[0].priority).toBe(1); // Array type strategy should be first
        });
        test('allows custom configuration', () => {
            const customReplacer = new SafeTypeReplacer_1.SafeTypeReplacer('.custom-backup', 0.8, 60000, 5);
            expect(customReplacer.getBackupDirectory()).toBe('.custom-backup');
        });
    });
    describe('Single Replacement Operations', () => {
        test('successfully replaces array types', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(1);
            expect(result.failedReplacements).toHaveLength(0);
            expect(result.rollbackPerformed).toBe(false);
        });
        test('handles low safety score rejection', async () => {
            const replacement = {
                original: 'any',
                replacement: 'string',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.3,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.failedReplacements).toHaveLength(1);
            expect(result.compilationErrors[0]).toContain('Safety score');
        });
        test('rolls back on TypeScript compilation failure', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock compilation failure
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type mismatch';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Type mismatch');
        });
        test('handles invalid line numbers', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 999,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];'); // Only 1 line
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Invalid line number');
        });
        test('handles pattern not found in line', async () => {
            const replacement = {
                original: 'string[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];'); // Pattern doesn't match
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Pattern "string[]" not found');
        });
    });
    describe('Batch Processing', () => {
        test('processes multiple replacements successfully', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'Record<string, any>',
                    replacement: 'Record<string, unknown>',
                    filePath: 'test2.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockImplementation((filePath) => {
                if (filePath.includes('test1.ts'))
                    return 'const items: any[] = [];';
                if (filePath.includes('test2.ts'))
                    return 'const data: Record<string, any> = {};';
                return 'backup content';
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(2);
            expect(result.failedReplacements).toHaveLength(0);
        });
        test('rolls back all changes on overall compilation failure', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                }
            ];
            // Mock overall compilation to fail
            mockExecSync.mockImplementation(() => {
                const error = new Error('Overall compilation failed');
                error.stdout = 'error TS2322: Overall type error';
                throw error;
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Overall type error');
        });
        test('groups replacements by file correctly', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'test.ts',
                    lineNumber: 2,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'any',
                    replacement: 'unknown',
                    filePath: 'test.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockReturnValue('const x: any = 1;\nconst items: any[] = [];');
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(2);
        });
    });
    describe('Safety Score Calculation', () => {
        test('calculates higher scores for array replacements', () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.7,
                validationRequired: true
            };
            // Access private method through any cast for testing
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeGreaterThan(0.7); // Should be boosted for array replacement
        });
        test('calculates lower scores for error handling contexts', () => {
            const replacement = {
                original: 'catch (error: any)',
                replacement: 'catch (error: unknown)',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeLessThan(0.8); // Should be reduced for error context
        });
        test('boosts scores for test files', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'test.test.ts',
                lineNumber: 1,
                confidence: 0.7,
                validationRequired: true
            };
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeGreaterThan(0.7); // Should be boosted for test files
        });
    });
    describe('Rollback Verification', () => {
        test('verifies rollback capability successfully', async () => {
            const filePath = 'test.ts';
            const backupPath = 'backup.ts';
            mockFs.readFileSync.mockImplementation((path) => {
                if (path === filePath)
                    return 'modified content';
                if (path === backupPath)
                    return 'original content';
                return '';
            });
            const result = await replacer.verifyRollbackCapability(filePath, backupPath);
            expect(result.success).toBe(true);
        });
        test('detects missing backup file', async () => {
            const filePath = 'test.ts';
            const backupPath = 'missing-backup.ts';
            mockFs.existsSync.mockImplementation((path) => {
                return path !== backupPath; // Backup doesn't exist
            });
            const result = await replacer.verifyRollbackCapability(filePath, backupPath);
            expect(result.success).toBe(false);
            expect(result.error).toContain('Backup file does not exist');
        });
    });
    describe('Strategy Management', () => {
        test('allows adding custom strategies', () => {
            const customStrategy = {
                pattern: /custom_pattern/g,
                replacement: () => 'custom_replacement',
                validator: () => true,
                priority: 0
            };
            replacer.addStrategy(customStrategy);
            const strategies = replacer.getStrategies();
            expect(strategies[0]).toBe(customStrategy); // Should be first due to priority 0
        });
        test('maintains strategy priority order', () => {
            const strategies = replacer.getStrategies();
            for (let i = 1; i < strategies.length; i++) {
                expect(strategies[i].priority).toBeGreaterThanOrEqual(strategies[i - 1].priority);
            }
        });
    });
    describe('Backup Management', () => {
        test('creates backups with timestamp', async () => {
            const filePath = 'test.ts';
            mockFs.readFileSync.mockReturnValue('original content');
            const backupPath = await replacer.createBackup(filePath);
            expect(backupPath).toContain('.test-backups');
            expect(backupPath).toContain('test.ts');
            expect(backupPath).toContain('.backup');
            expect(mockFs.writeFileSync).toHaveBeenCalledWith(backupPath, 'original content', 'utf8');
        });
        test('cleans up old backup files', () => {
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            mockFs.readdirSync.mockReturnValue(['old.backup', 'recent.backup', 'other.txt']);
            mockFs.statSync.mockImplementation((filePath) => {
                if (filePath.includes('old.backup')) {
                    return { mtime: oldDate };
                }
                return { mtime: new Date() }; // Recent file
            });
            replacer.cleanupOldBackups(7); // Keep 7 days
            expect(mockFs.unlinkSync).toHaveBeenCalledWith(path.join(testBackupDir, 'old.backup'));
            expect(mockFs.unlinkSync).not.toHaveBeenCalledWith(path.join(testBackupDir, 'recent.backup'));
        });
    });
    describe('Error Handling and Retries', () => {
        test('handles file system errors gracefully', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock backup creation to fail
            mockFs.writeFileSync.mockImplementation((filePath) => {
                if (filePath.includes('.backup')) {
                    throw new Error('Backup creation failed');
                }
            });
            // Expect the error to be thrown since backup creation is critical
            await expect(replacer.applyReplacement(replacement)).rejects.toThrow('Backup creation failed');
        });
        test('handles compilation errors with rollback', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock compilation to fail
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type error';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Type error');
        });
    });
    describe('TypeScript Compilation Validation', () => {
        test('handles successful compilation', async () => {
            mockExecSync.mockReturnValue('');
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
        test('extracts TypeScript errors from output', async () => {
            const errorOutput = `
        src/test.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/test.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        Found 2 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = errorOutput;
                throw error;
            });
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(false);
            expect(result.errors).toHaveLength(2);
            expect(result.errors[0]).toContain('error TS2322');
            expect(result.errors[1]).toContain('error TS2304');
        });
        test('handles compilation timeout', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('Timeout');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(false);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]).toContain('Timeout');
        });
    });
    describe('Advanced Replacement Strategy Patterns', () => {
        test('infers array element types from context', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = ["hello", "world"];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferArrayElementType(context);
            expect(inferredType).toBe('string');
        });
        test('infers Record value types from object literals', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const config: Record<string, any> = { name: "test", count: 42 };',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferRecordValueType(context);
            expect(['string', 'number', 'unknown']).toContain(inferredType);
        });
        test('infers function parameter types from parameter names', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function handleClick(event: any) { }',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.COMPONENT,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferFunctionParameterType(context, 'event');
            expect(inferredType).toBe('Event');
        });
        test('infers return types from function context', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function isValid(): any {',
                surroundingLines: ['  return true;'],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferReturnType(context);
            expect(inferredType).toBe('boolean');
        });
        test('detects error handling contexts correctly', () => {
            const errorContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'catch (error: any) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const isErrorContext = replacer.isInErrorHandlingContext(errorContext);
            expect(isErrorContext).toBe(true);
        });
        test('detects external API contexts correctly', () => {
            const apiContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const response: any = await fetch("/api/data");',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.SERVICE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const isApiContext = replacer.isExternalApiContext(apiContext);
            expect(isApiContext).toBe(true);
        });
        test('applies domain-specific type inference for astrological context', () => {
            const astroContext = {
                filePath: 'astrology.ts',
                lineNumber: 1,
                codeSnippet: 'const planetaryPositions: any[] = [];',
                surroundingLines: ['positions.push("mars");'],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.ASTROLOGICAL,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferArrayElementType(astroContext);
            expect(inferredType).toBe('string');
        });
        test('applies domain-specific type inference for recipe context', () => {
            const recipeContext = {
                filePath: 'recipe.ts',
                lineNumber: 1,
                codeSnippet: 'function processIngredient(ingredient: any) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.RECIPE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferFunctionParameterType(recipeContext, 'ingredient');
            expect(inferredType).toBe('Ingredient');
        });
        test('handles complex replacement patterns with validation', async () => {
            const mockContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function process(data: any): any { return data; }',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const strategies = replacer.getStrategies();
            // Test function parameter strategy
            const paramStrategy = strategies.find(s => s.priority === 4);
            expect(paramStrategy).toBeDefined();
            expect(paramStrategy.validator(mockContext)).toBe(true);
            // Test return type strategy
            const returnStrategy = strategies.find(s => s.priority === 5);
            expect(returnStrategy).toBeDefined();
            expect(returnStrategy.validator(mockContext)).toBe(true);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZVR5cGVSZXBsYWNlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRSCxpREFBaUQ7QUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUczQiw4QkFBOEI7QUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUdoQix1QkFBdUI7QUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBZmhDLGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDBEQUF1RDtBQUN2RCxvQ0FBOEU7QUFJOUUsTUFBTSxZQUFZLEdBQUcsd0JBQWdELENBQUM7QUFJdEUsTUFBTSxNQUFNLEdBQUcsRUFBNEIsQ0FBQztBQUk1QyxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzlELG9CQUFvQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUM7UUFDOUMsT0FBTyxFQUFFLElBQUk7UUFDYixXQUFXLEVBQUUsR0FBRztRQUNoQixnQkFBZ0IsRUFBRSxFQUFFO1FBQ3BCLFFBQVEsRUFBRSxFQUFFO1FBQ1osZUFBZSxFQUFFLEVBQUU7S0FDcEIsQ0FBQztJQUNGLDZCQUE2QixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztRQUN6RCxlQUFlLEVBQUUsSUFBSTtRQUNyQixpQkFBaUIsRUFBRSxFQUFFO1FBQ3JCLGVBQWUsRUFBRSxFQUFFO1FBQ25CLGtCQUFrQixFQUFFLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUs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QkFDeEI7YUFDRixDQUFDO1lBRUYsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBRTVDLG1DQUFtQztZQUNuQyxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM3RCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDcEMsTUFBTSxDQUFDLGFBQWMsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFekQsNEJBQTRCO1lBQzVCLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzlELE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNyQyxNQUFNLENBQUMsY0FBZSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZVR5cGVSZXBsYWNlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2FmZVR5cGVSZXBsYWNlciBUZXN0c1xuICogQ29tcHJlaGVuc2l2ZSB0ZXN0IHN1aXRlIGZvciB0aGUgU2FmZSBUeXBlIFJlcGxhY2VyIHN5c3RlbVxuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgU2FmZVR5cGVSZXBsYWNlciB9IGZyb20gJy4uL1NhZmVUeXBlUmVwbGFjZXInO1xuaW1wb3J0IHsgQ2xhc3NpZmljYXRpb25Db250ZXh0LCBDb2RlRG9tYWluLCBUeXBlUmVwbGFjZW1lbnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vIE1vY2sgZXhlY1N5bmMgZm9yIFR5cGVTY3JpcHQgY29tcGlsYXRpb24gdGVzdHNcbmplc3QubW9jaygnY2hpbGRfcHJvY2VzcycpO1xuY29uc3QgbW9ja0V4ZWNTeW5jID0gZXhlY1N5bmMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZXhlY1N5bmM+O1xuXG4vLyBNb2NrIGZzIGZvciBmaWxlIG9wZXJhdGlvbnNcbmplc3QubW9jaygnZnMnKTtcbmNvbnN0IG1vY2tGcyA9IGZzIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBmcz47XG5cbi8vIE1vY2sgU2FmZXR5VmFsaWRhdG9yXG5qZXN0Lm1vY2soJy4uL1NhZmV0eVZhbGlkYXRvcicpO1xuY29uc3QgTW9ja1NhZmV0eVZhbGlkYXRvciA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgY2FsY3VsYXRlU2FmZXR5U2NvcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgc2FmZXR5U2NvcmU6IDAuOSxcbiAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXSxcbiAgICB3YXJuaW5nczogW10sXG4gICAgcmVjb21tZW5kYXRpb25zOiBbXVxuICB9KSxcbiAgdmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgYnVpbGRTdWNjZXNzZnVsOiB0cnVlLFxuICAgIGNvbXBpbGF0aW9uRXJyb3JzOiBbXSxcbiAgICBsaW50aW5nV2FybmluZ3M6IFtdLFxuICAgIHBlcmZvcm1hbmNlTWV0cmljczogeyBidWlsZFRpbWU6IDEwMCwgbWVtb3J5VXNhZ2U6IDEwMDAwMDAgfVxuICB9KSxcbiAgdmFsaWRhdGVCdWlsZEFmdGVyQmF0Y2g6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgYnVpbGRTdWNjZXNzZnVsOiB0cnVlLFxuICAgIGNvbXBpbGF0aW9uRXJyb3JzOiBbXSxcbiAgICBsaW50aW5nV2FybmluZ3M6IFtdLFxuICAgIHBlcmZvcm1hbmNlTWV0cmljczogeyBidWlsZFRpbWU6IDEwMCwgbWVtb3J5VXNhZ2U6IDEwMDAwMDAgfVxuICB9KSxcbiAgdmFsaWRhdGVSb2xsYmFja0NhcGFiaWxpdHk6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgY2FuUm9sbGJhY2s6IHRydWUsXG4gICAgYmFja3VwSW50ZWdyaXR5OiB0cnVlLFxuICAgIHJvbGxiYWNrRXJyb3JzOiBbXSxcbiAgICByZXN0b3JhdGlvblZlcmlmaWVkOiB0cnVlXG4gIH0pLFxuICB1cGRhdGVTYWZldHlUaHJlc2hvbGRzOiBqZXN0LmZuKClcbn0pKTtcblxuZGVzY3JpYmUoJ1NhZmVUeXBlUmVwbGFjZXInLCAoKSA9PiB7XG4gIGxldCByZXBsYWNlcjogU2FmZVR5cGVSZXBsYWNlcjtcbiAgbGV0IHRlc3RCYWNrdXBEaXI6IHN0cmluZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICB0ZXN0QmFja3VwRGlyID0gJy4vLnRlc3QtYmFja3Vwcyc7XG4gICAgcmVwbGFjZXIgPSBuZXcgU2FmZVR5cGVSZXBsYWNlcih0ZXN0QmFja3VwRGlyLCAwLjcsIDMwMDAwLCAzKTtcblxuICAgIC8vIE1vY2sgZnMuZXhpc3RzU3luYyB0byByZXR1cm4gZmFsc2UgZm9yIGJhY2t1cCBkaXJlY3RvcnkgaW5pdGlhbGx5XG4gICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiBhbnkpID0+IHtcbiAgICAgIGlmIChwYXRoID09PSB0ZXN0QmFja3VwRGlyKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gQXNzdW1lIG90aGVyIGZpbGVzIGV4aXN0XG4gICAgfSk7XG5cbiAgICAvLyBNb2NrIGZzLm1rZGlyU3luY1xuICAgIG1vY2tGcy5ta2RpclN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHVuZGVmaW5lZCBhcyBhbnkpO1xuXG4gICAgLy8gTW9jayBmcy5yZWFkRmlsZVN5bmMgYW5kIHdyaXRlRmlsZVN5bmNcbiAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107Jyk7XG4gICAgbW9ja0ZzLndyaXRlRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgVHlwZVNjcmlwdCBjb21waWxhdGlvbiBieSBkZWZhdWx0XG4gICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAnJyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25zdHJ1Y3RvciBhbmQgSW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnY3JlYXRlcyBiYWNrdXAgZGlyZWN0b3J5IGlmIGl0IGRvZXMgbm90IGV4aXN0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KG1vY2tGcy5ta2RpclN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RCYWNrdXBEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5pdGlhbGl6ZXMgd2l0aCBkZWZhdWx0IHN0cmF0ZWdpZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gcmVwbGFjZXIuZ2V0U3RyYXRlZ2llcygpO1xuICAgICAgZXhwZWN0KHN0cmF0ZWdpZXMpLnRvSGF2ZUxlbmd0aCgxMCk7XG4gICAgICBleHBlY3Qoc3RyYXRlZ2llc1swXS5wcmlvcml0eSkudG9CZSgxKTsgLy8gQXJyYXkgdHlwZSBzdHJhdGVneSBzaG91bGQgYmUgZmlyc3RcbiAgICB9KTtcblxuICAgIHRlc3QoJ2FsbG93cyBjdXN0b20gY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbVJlcGxhY2VyID0gbmV3IFNhZmVUeXBlUmVwbGFjZXIoJy5jdXN0b20tYmFja3VwJywgMC44LCA2MDAwMCwgNSk7XG4gICAgICBleHBlY3QoY3VzdG9tUmVwbGFjZXIuZ2V0QmFja3VwRGlyZWN0b3J5KCkpLnRvQmUoJy5jdXN0b20tYmFja3VwJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTaW5nbGUgUmVwbGFjZW1lbnQgT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICB0ZXN0KCdzdWNjZXNzZnVsbHkgcmVwbGFjZXMgYXJyYXkgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkUmVwbGFjZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmZhaWxlZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yb2xsYmFja1BlcmZvcm1lZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGxvdyBzYWZldHkgc2NvcmUgcmVqZWN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICByZXBsYWNlbWVudDogJ3N0cmluZycsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuMywgLy8gTG93IGNvbmZpZGVuY2VcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZmFpbGVkUmVwbGFjZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzWzBdKS50b0NvbnRhaW4oJ1NhZmV0eSBzY29yZScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncm9sbHMgYmFjayBvbiBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb21waWxhdGlvbiBmYWlsdXJlXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gJ2Vycm9yIFRTMjMyMjogVHlwZSBtaXNtYXRjaCc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yb2xsYmFja1BlcmZvcm1lZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvQ29udGFpbignZXJyb3IgVFMyMzIyOiBUeXBlIG1pc21hdGNoJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGludmFsaWQgbGluZSBudW1iZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogOTk5LCAvLyBJbnZhbGlkIGxpbmUgbnVtYmVyXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IGFueVtdID0gW107Jyk7IC8vIE9ubHkgMSBsaW5lXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdJbnZhbGlkIGxpbmUgbnVtYmVyJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIHBhdHRlcm4gbm90IGZvdW5kIGluIGxpbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ3N0cmluZ1tdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpOyAvLyBQYXR0ZXJuIGRvZXNuJ3QgbWF0Y2hcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzWzBdKS50b0NvbnRhaW4oJ1BhdHRlcm4gXCJzdHJpbmdbXVwiIG5vdCBmb3VuZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmF0Y2ggUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICB0ZXN0KCdwcm9jZXNzZXMgbXVsdGlwbGUgcmVwbGFjZW1lbnRzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50czogVHlwZVJlcGxhY2VtZW50W10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgICAgZmlsZVBhdGg6ICd0ZXN0MS50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ1JlY29yZDxzdHJpbmcsIGFueT4nLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAnUmVjb3JkPHN0cmluZywgdW5rbm93bj4nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdDIudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZVBhdGg6IGFueSkgPT4ge1xuICAgICAgICBpZiAoZmlsZVBhdGguaW5jbHVkZXMoJ3Rlc3QxLnRzJykpIHJldHVybiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107JztcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCd0ZXN0Mi50cycpKSByZXR1cm4gJ2NvbnN0IGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTsnO1xuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5wcm9jZXNzQmF0Y2gocmVwbGFjZW1lbnRzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkUmVwbGFjZW1lbnRzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmZhaWxlZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncm9sbHMgYmFjayBhbGwgY2hhbmdlcyBvbiBvdmVyYWxsIGNvbXBpbGF0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudHM6IFR5cGVSZXBsYWNlbWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdDEudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICAvLyBNb2NrIG92ZXJhbGwgY29tcGlsYXRpb24gdG8gZmFpbFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdPdmVyYWxsIGNvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gJ2Vycm9yIFRTMjMyMjogT3ZlcmFsbCB0eXBlIGVycm9yJztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKHJlcGxhY2VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9ycykudG9Db250YWluKCdlcnJvciBUUzIzMjI6IE92ZXJhbGwgdHlwZSBlcnJvcicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZ3JvdXBzIHJlcGxhY2VtZW50cyBieSBmaWxlIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50czogVHlwZVJlcGxhY2VtZW50W10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAyLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd24nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCB4OiBhbnkgPSAxO1xcbmNvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5wcm9jZXNzQmF0Y2gocmVwbGFjZW1lbnRzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkUmVwbGFjZW1lbnRzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTYWZldHkgU2NvcmUgQ2FsY3VsYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnY2FsY3VsYXRlcyBoaWdoZXIgc2NvcmVzIGZvciBhcnJheSByZXBsYWNlbWVudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjcsXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gQWNjZXNzIHByaXZhdGUgbWV0aG9kIHRocm91Z2ggYW55IGNhc3QgZm9yIHRlc3RpbmdcbiAgICAgIGNvbnN0IHNjb3JlID0gKHJlcGxhY2VyIGFzIGFueSkuY2FsY3VsYXRlU2FmZXR5U2NvcmUocmVwbGFjZW1lbnQpO1xuICAgICAgZXhwZWN0KHNjb3JlKS50b0JlR3JlYXRlclRoYW4oMC43KTsgLy8gU2hvdWxkIGJlIGJvb3N0ZWQgZm9yIGFycmF5IHJlcGxhY2VtZW50XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjYWxjdWxhdGVzIGxvd2VyIHNjb3JlcyBmb3IgZXJyb3IgaGFuZGxpbmcgY29udGV4dHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2NhdGNoIChlcnJvcjogYW55KScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAnY2F0Y2ggKGVycm9yOiB1bmtub3duKScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY29yZSA9IChyZXBsYWNlciBhcyBhbnkpLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChzY29yZSkudG9CZUxlc3NUaGFuKDAuOCk7IC8vIFNob3VsZCBiZSByZWR1Y2VkIGZvciBlcnJvciBjb250ZXh0XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdib29zdHMgc2NvcmVzIGZvciB0ZXN0IGZpbGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd24nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuNyxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY29yZSA9IChyZXBsYWNlciBhcyBhbnkpLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChzY29yZSkudG9CZUdyZWF0ZXJUaGFuKDAuNyk7IC8vIFNob3VsZCBiZSBib29zdGVkIGZvciB0ZXN0IGZpbGVzXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSb2xsYmFjayBWZXJpZmljYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgndmVyaWZpZXMgcm9sbGJhY2sgY2FwYWJpbGl0eSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9ICd0ZXN0LnRzJztcbiAgICAgIGNvbnN0IGJhY2t1cFBhdGggPSAnYmFja3VwLnRzJztcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gZmlsZVBhdGgpIHJldHVybiAnbW9kaWZpZWQgY29udGVudCc7XG4gICAgICAgIGlmIChwYXRoID09PSBiYWNrdXBQYXRoKSByZXR1cm4gJ29yaWdpbmFsIGNvbnRlbnQnO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKHJlcGxhY2VyIGFzIGFueSkudmVyaWZ5Um9sbGJhY2tDYXBhYmlsaXR5KGZpbGVQYXRoLCBiYWNrdXBQYXRoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgbWlzc2luZyBiYWNrdXAgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gJ3Rlc3QudHMnO1xuICAgICAgY29uc3QgYmFja3VwUGF0aCA9ICdtaXNzaW5nLWJhY2t1cC50cyc7XG5cbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogYW55KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXRoICE9PSBiYWNrdXBQYXRoOyAvLyBCYWNrdXAgZG9lc24ndCBleGlzdFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChyZXBsYWNlciBhcyBhbnkpLnZlcmlmeVJvbGxiYWNrQ2FwYWJpbGl0eShmaWxlUGF0aCwgYmFja3VwUGF0aCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdCYWNrdXAgZmlsZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RyYXRlZ3kgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdhbGxvd3MgYWRkaW5nIGN1c3RvbSBzdHJhdGVnaWVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY3VzdG9tU3RyYXRlZ3kgPSB7XG4gICAgICAgIHBhdHRlcm46IC9jdXN0b21fcGF0dGVybi9nLFxuICAgICAgICByZXBsYWNlbWVudDogKCkgPT4gJ2N1c3RvbV9yZXBsYWNlbWVudCcsXG4gICAgICAgIHZhbGlkYXRvcjogKCkgPT4gdHJ1ZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH07XG5cbiAgICAgIHJlcGxhY2VyLmFkZFN0cmF0ZWd5KGN1c3RvbVN0cmF0ZWd5KTtcbiAgICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSByZXBsYWNlci5nZXRTdHJhdGVnaWVzKCk7XG5cbiAgICAgIGV4cGVjdChzdHJhdGVnaWVzWzBdKS50b0JlKGN1c3RvbVN0cmF0ZWd5KTsgLy8gU2hvdWxkIGJlIGZpcnN0IGR1ZSB0byBwcmlvcml0eSAwXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdtYWludGFpbnMgc3RyYXRlZ3kgcHJpb3JpdHkgb3JkZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gcmVwbGFjZXIuZ2V0U3RyYXRlZ2llcygpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmF0ZWdpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0KHN0cmF0ZWdpZXNbaV0ucHJpb3JpdHkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoc3RyYXRlZ2llc1tpIC0gMV0ucHJpb3JpdHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFja3VwIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnY3JlYXRlcyBiYWNrdXBzIHdpdGggdGltZXN0YW1wJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSAndGVzdC50cyc7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnb3JpZ2luYWwgY29udGVudCcpO1xuXG4gICAgICBjb25zdCBiYWNrdXBQYXRoID0gYXdhaXQgKHJlcGxhY2VyIGFzIGFueSkuY3JlYXRlQmFja3VwKGZpbGVQYXRoKTtcblxuICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbignLnRlc3QtYmFja3VwcycpO1xuICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbigndGVzdC50cycpO1xuICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbignLmJhY2t1cCcpO1xuICAgICAgZXhwZWN0KG1vY2tGcy53cml0ZUZpbGVTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYmFja3VwUGF0aCxcbiAgICAgICAgJ29yaWdpbmFsIGNvbnRlbnQnLFxuICAgICAgICAndXRmOCdcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjbGVhbnMgdXAgb2xkIGJhY2t1cCBmaWxlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG9sZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgb2xkRGF0ZS5zZXREYXRlKG9sZERhdGUuZ2V0RGF0ZSgpIC0gMTApOyAvLyAxMCBkYXlzIG9sZFxuXG4gICAgICBtb2NrRnMucmVhZGRpclN5bmMubW9ja1JldHVyblZhbHVlKFsnb2xkLmJhY2t1cCcsICdyZWNlbnQuYmFja3VwJywgJ290aGVyLnR4dCddIGFzIGFueSk7XG4gICAgICBtb2NrRnMuc3RhdFN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChmaWxlUGF0aDogYW55KSA9PiB7XG4gICAgICAgIGlmIChmaWxlUGF0aC5pbmNsdWRlcygnb2xkLmJhY2t1cCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbXRpbWU6IG9sZERhdGUgfSBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbXRpbWU6IG5ldyBEYXRlKCkgfSBhcyBhbnk7IC8vIFJlY2VudCBmaWxlXG4gICAgICB9KTtcblxuICAgICAgcmVwbGFjZXIuY2xlYW51cE9sZEJhY2t1cHMoNyk7IC8vIEtlZXAgNyBkYXlzXG5cbiAgICAgIGV4cGVjdChtb2NrRnMudW5saW5rU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHBhdGguam9pbih0ZXN0QmFja3VwRGlyLCAnb2xkLmJhY2t1cCcpXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tGcy51bmxpbmtTeW5jKS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHBhdGguam9pbih0ZXN0QmFja3VwRGlyLCAncmVjZW50LmJhY2t1cCcpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcgYW5kIFJldHJpZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnaGFuZGxlcyBmaWxlIHN5c3RlbSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIGJhY2t1cCBjcmVhdGlvbiB0byBmYWlsXG4gICAgICBtb2NrRnMud3JpdGVGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGZpbGVQYXRoOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2t1cCBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4cGVjdCB0aGUgZXJyb3IgdG8gYmUgdGhyb3duIHNpbmNlIGJhY2t1cCBjcmVhdGlvbiBpcyBjcml0aWNhbFxuICAgICAgYXdhaXQgZXhwZWN0KHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpKS5yZWplY3RzLnRvVGhyb3coJ0JhY2t1cCBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY29tcGlsYXRpb24gZXJyb3JzIHdpdGggcm9sbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb21waWxhdGlvbiB0byBmYWlsXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gJ2Vycm9yIFRTMjMyMjogVHlwZSBlcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yb2xsYmFja1BlcmZvcm1lZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvQ29udGFpbignZXJyb3IgVFMyMzIyOiBUeXBlIGVycm9yJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUeXBlU2NyaXB0IENvbXBpbGF0aW9uIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnaGFuZGxlcyBzdWNjZXNzZnVsIGNvbXBpbGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChyZXBsYWNlciBhcyBhbnkpLnZhbGlkYXRlVHlwZVNjcmlwdENvbXBpbGF0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdleHRyYWN0cyBUeXBlU2NyaXB0IGVycm9ycyBmcm9tIG91dHB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yT3V0cHV0ID0gYFxuICAgICAgICBzcmMvdGVzdC50cygxMCw1KTogZXJyb3IgVFMyMzIyOiBUeXBlICdzdHJpbmcnIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHR5cGUgJ251bWJlcicuXG4gICAgICAgIHNyYy90ZXN0LnRzKDE1LDEwKTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd1bmtub3duVmFyaWFibGUnLlxuICAgICAgICBGb3VuZCAyIGVycm9ycy5cbiAgICAgIGA7XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICBlcnJvci5zdGRvdXQgPSBlcnJvck91dHB1dDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKHJlcGxhY2VyIGFzIGFueSkudmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yc1swXSkudG9Db250YWluKCdlcnJvciBUUzIzMjInKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzFdKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMwNCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb21waWxhdGlvbiB0aW1lb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUaW1lb3V0JykgYXMgYW55O1xuICAgICAgICBlcnJvci5jb2RlID0gJ1RJTUVPVVQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAocmVwbGFjZXIgYXMgYW55KS52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzBdKS50b0NvbnRhaW4oJ1RpbWVvdXQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FkdmFuY2VkIFJlcGxhY2VtZW50IFN0cmF0ZWd5IFBhdHRlcm5zJywgKCkgPT4ge1xuICAgIHRlc3QoJ2luZmVycyBhcnJheSBlbGVtZW50IHR5cGVzIGZyb20gY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBpdGVtczogYW55W10gPSBbXCJoZWxsb1wiLCBcIndvcmxkXCJdOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyQXJyYXlFbGVtZW50VHlwZShjb250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ3N0cmluZycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5mZXJzIFJlY29yZCB2YWx1ZSB0eXBlcyBmcm9tIG9iamVjdCBsaXRlcmFscycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBjb25maWc6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7IG5hbWU6IFwidGVzdFwiLCBjb3VudDogNDIgfTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgYW55KS5pbmZlclJlY29yZFZhbHVlVHlwZShjb250ZXh0KTtcbiAgICAgIGV4cGVjdChbJ3N0cmluZycsICdudW1iZXInLCAndW5rbm93biddKS50b0NvbnRhaW4oaW5mZXJyZWRUeXBlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2luZmVycyBmdW5jdGlvbiBwYXJhbWV0ZXIgdHlwZXMgZnJvbSBwYXJhbWV0ZXIgbmFtZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQ6IGFueSkgeyB9JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uQ09NUE9ORU5ULFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgYW55KS5pbmZlckZ1bmN0aW9uUGFyYW1ldGVyVHlwZShjb250ZXh0LCAnZXZlbnQnKTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ0V2ZW50Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdpbmZlcnMgcmV0dXJuIHR5cGVzIGZyb20gZnVuY3Rpb24gY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBpc1ZhbGlkKCk6IGFueSB7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogWycgIHJldHVybiB0cnVlOyddLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyUmV0dXJuVHlwZShjb250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ2Jvb2xlYW4nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgZXJyb3IgaGFuZGxpbmcgY29udGV4dHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY2F0Y2ggKGVycm9yOiBhbnkpIHsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpc0Vycm9yQ29udGV4dCA9IChyZXBsYWNlciBhcyBhbnkpLmlzSW5FcnJvckhhbmRsaW5nQ29udGV4dChlcnJvckNvbnRleHQpO1xuICAgICAgZXhwZWN0KGlzRXJyb3JDb250ZXh0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGV0ZWN0cyBleHRlcm5hbCBBUEkgY29udGV4dHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgYXBpQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IHJlc3BvbnNlOiBhbnkgPSBhd2FpdCBmZXRjaChcIi9hcGkvZGF0YVwiKTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5TRVJWSUNFLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpc0FwaUNvbnRleHQgPSAocmVwbGFjZXIgYXMgYW55KS5pc0V4dGVybmFsQXBpQ29udGV4dChhcGlDb250ZXh0KTtcbiAgICAgIGV4cGVjdChpc0FwaUNvbnRleHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdhcHBsaWVzIGRvbWFpbi1zcGVjaWZpYyB0eXBlIGluZmVyZW5jZSBmb3IgYXN0cm9sb2dpY2FsIGNvbnRleHQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBhc3Ryb0NvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICdhc3Ryb2xvZ3kudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IHBsYW5ldGFyeVBvc2l0aW9uczogYW55W10gPSBbXTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbJ3Bvc2l0aW9ucy5wdXNoKFwibWFyc1wiKTsnXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5BU1RST0xPR0lDQUwsXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyQXJyYXlFbGVtZW50VHlwZShhc3Ryb0NvbnRleHQpO1xuICAgICAgZXhwZWN0KGluZmVycmVkVHlwZSkudG9CZSgnc3RyaW5nJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdhcHBsaWVzIGRvbWFpbi1zcGVjaWZpYyB0eXBlIGluZmVyZW5jZSBmb3IgcmVjaXBlIGNvbnRleHQnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZWNpcGVDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAncmVjaXBlLnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBwcm9jZXNzSW5ncmVkaWVudChpbmdyZWRpZW50OiBhbnkpIHsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5SRUNJUEUsXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyRnVuY3Rpb25QYXJhbWV0ZXJUeXBlKHJlY2lwZUNvbnRleHQsICdpbmdyZWRpZW50Jyk7XG4gICAgICBleHBlY3QoaW5mZXJyZWRUeXBlKS50b0JlKCdJbmdyZWRpZW50Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGNvbXBsZXggcmVwbGFjZW1lbnQgcGF0dGVybnMgd2l0aCB2YWxpZGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0NvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBwcm9jZXNzKGRhdGE6IGFueSk6IGFueSB7IHJldHVybiBkYXRhOyB9JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IHJlcGxhY2VyLmdldFN0cmF0ZWdpZXMoKTtcblxuICAgICAgLy8gVGVzdCBmdW5jdGlvbiBwYXJhbWV0ZXIgc3RyYXRlZ3lcbiAgICAgIGNvbnN0IHBhcmFtU3RyYXRlZ3kgPSBzdHJhdGVnaWVzLmZpbmQocyA9PiBzLnByaW9yaXR5ID09PSA0KTtcbiAgICAgIGV4cGVjdChwYXJhbVN0cmF0ZWd5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHBhcmFtU3RyYXRlZ3khLnZhbGlkYXRvcihtb2NrQ29udGV4dCkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFRlc3QgcmV0dXJuIHR5cGUgc3RyYXRlZ3lcbiAgICAgIGNvbnN0IHJldHVyblN0cmF0ZWd5ID0gc3RyYXRlZ2llcy5maW5kKHMgPT4gcy5wcmlvcml0eSA9PT0gNSk7XG4gICAgICBleHBlY3QocmV0dXJuU3RyYXRlZ3kpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmV0dXJuU3RyYXRlZ3khLnZhbGlkYXRvcihtb2NrQ29udGV4dCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=