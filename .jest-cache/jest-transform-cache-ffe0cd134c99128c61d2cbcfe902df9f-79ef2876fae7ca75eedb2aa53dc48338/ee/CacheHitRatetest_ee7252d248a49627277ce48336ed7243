4e279dc3492926ef338f25a793a48a59
"use strict";
/**
 * Performance Tests for Cache Hit Rate Validation
 * Perfect Codebase Campaign - Cache Performance Testing
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ProgressTracker_1 = require("../../ProgressTracker");
const CampaignController_1 = require("../../CampaignController");
const campaign_1 = require("../../../../types/campaign");
describe('Cache Hit Rate Performance Tests', () => {
    let progressTracker;
    let campaignController;
    let mockConfig;
    beforeEach(() => {
        const safetySettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7,
        };
        mockConfig = {
            phases: [
                {
                    id: 'cache-test-phase',
                    name: 'Cache Test Phase',
                    description: 'Phase for cache testing',
                    tools: [
                        {
                            scriptPath: 'scripts/cache/test-script.js',
                            parameters: { enableCache: true },
                            batchSize: 50,
                            safetyLevel: campaign_1.SafetyLevel.MEDIUM,
                        },
                    ],
                    successCriteria: { buildTime: 10 },
                    safetyCheckpoints: [],
                },
            ],
            safetySettings,
            progressTargets: {
                typeScriptErrors: 0,
                lintingWarnings: 0,
                buildTime: 10,
                enterpriseSystems: 200,
            },
            toolConfiguration: {
                enhancedErrorFixer: 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js',
                explicitAnyFixer: 'scripts/typescript-fixes/fix-explicit-any-systematic.js',
                unusedVariablesFixer: 'scripts/typescript-fixes/fix-unused-variables-enhanced.js',
                consoleStatementFixer: 'scripts/lint-fixes/fix-console-statements-only.js',
            },
        };
        progressTracker = new ProgressTracker_1.ProgressTracker();
        campaignController = new CampaignController_1.CampaignController(mockConfig);
        // Reset mocks
        jest.clearAllMocks();
    });
    describe('Cache Hit Rate Monitoring', () => {
        it('should validate cache hit rate above 80% target', async () => {
            // Mock excellent cache performance
            jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(0.85);
            const cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.85);
            expect(cacheHitRate).toBeGreaterThanOrEqual(0.8); // Above 80% target
            expect(cacheHitRate).toBeLessThanOrEqual(1.0); // Cannot exceed 100%
        });
        it('should detect poor cache performance', async () => {
            // Mock poor cache performance
            jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(0.65);
            const cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.65);
            expect(cacheHitRate).toBeLessThan(0.8); // Below 80% target
        });
        it('should handle cache measurement errors gracefully', async () => {
            // Mock cache measurement error
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockRejectedValue(new Error('Cache measurement failed'));
            const cacheHitRate = await progressTracker
                .getCacheHitRate()
                .catch(() => 0);
            expect(cacheHitRate).toBe(0); // Error handling returns 0
        });
        it('should track cache performance trends over time', async () => {
            const cacheReadings = [];
            let callCount = 0;
            // Mock improving cache performance over time
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                callCount++;
                // Simulate cache warming up - performance improves over time
                const baseRate = 0.6;
                const improvement = Math.min(0.3, callCount * 0.05); // Max 30% improvement
                return Math.min(0.95, baseRate + improvement); // Cap at 95%
            });
            // Collect multiple cache hit rate readings
            for (let i = 0; i < 10; i++) {
                const cacheHitRate = await progressTracker.getCacheHitRate();
                cacheReadings.push(cacheHitRate);
            }
            expect(cacheReadings.length).toBe(10);
            expect(cacheReadings.every(rate => rate >= 0 && rate <= 1)).toBe(true);
            // Cache performance should improve over time
            const firstReading = cacheReadings[0];
            const lastReading = cacheReadings[cacheReadings.length - 1];
            expect(lastReading).toBeGreaterThanOrEqual(firstReading);
            expect(lastReading).toBeGreaterThanOrEqual(0.8); // Should reach target
        });
    });
    describe('Cache Performance Optimization', () => {
        it('should validate 3-tier caching system performance', async () => {
            // Mock 3-tier cache system with different hit rates
            const cacheHitRates = {
                l1Cache: 0.9,
                l2Cache: 0.7,
                l3Cache: 0.5, // 50% L3 cache hit rate (disk/network)
            };
            // Calculate overall cache hit rate
            const overallHitRate = cacheHitRates.l1Cache * 0.6 + // L1 handles 60% of requests
                cacheHitRates.l2Cache * 0.3 + // L2 handles 30% of requests
                cacheHitRates.l3Cache * 0.1; // L3 handles 10% of requests
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockResolvedValue(overallHitRate);
            const cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBeCloseTo(0.81, 2); // Should be ~81%
            expect(cacheHitRate).toBeGreaterThan(0.8); // Above target
        });
        it('should detect cache invalidation impact', async () => {
            let cacheInvalidated = false;
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                // Simulate cache invalidation impact
                return cacheInvalidated ? 0.3 : 0.85; // Dramatic drop after invalidation
            });
            // Before cache invalidation
            let cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.85);
            // Simulate cache invalidation
            cacheInvalidated = true;
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.3);
            expect(cacheHitRate).toBeLessThan(0.8); // Below target after invalidation
        });
        it('should validate cache warming strategies', async () => {
            const warmupReadings = [];
            let warmupStep = 0;
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                warmupStep++;
                // Simulate cache warming - exponential improvement
                const maxRate = 0.9;
                const warmupRate = maxRate * (1 - Math.exp(-warmupStep * 0.3));
                return Math.min(maxRate, warmupRate);
            });
            // Simulate cache warming process
            for (let i = 0; i < 8; i++) {
                const cacheHitRate = await progressTracker.getCacheHitRate();
                warmupReadings.push(cacheHitRate);
            }
            expect(warmupReadings.length).toBe(8);
            // Cache should warm up progressively
            expect(warmupReadings[0]).toBeLessThan(0.3); // Cold start
            expect(warmupReadings[warmupReadings.length - 1]).toBeGreaterThan(0.8); // Warmed up
            // Each reading should be better than or equal to the previous
            for (let i = 1; i < warmupReadings.length; i++) {
                expect(warmupReadings[i]).toBeGreaterThanOrEqual(warmupReadings[i - 1]);
            }
        });
        it('should handle cache size optimization', async () => {
            // Mock different cache sizes and their hit rates
            const cacheSizeTests = [
                { size: '10MB', hitRate: 0.6 },
                { size: '50MB', hitRate: 0.8 },
                { size: '100MB', hitRate: 0.9 },
                { size: '200MB', hitRate: 0.92 }, // Very large cache (diminishing returns)
            ];
            for (const test of cacheSizeTests) {
                jest
                    .spyOn(progressTracker, 'getCacheHitRate')
                    .mockResolvedValue(test.hitRate);
                const cacheHitRate = await progressTracker.getCacheHitRate();
                expect(cacheHitRate).toBe(test.hitRate);
                // Larger caches should generally have better hit rates
                if (test.size === '100MB') {
                    expect(cacheHitRate).toBeGreaterThan(0.8); // Should exceed target
                }
            }
        });
    });
    describe('Cache Performance Under Load', () => {
        it('should maintain cache performance under concurrent access', async () => {
            let concurrentRequests = 0;
            const maxConcurrentRequests = 10;
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                concurrentRequests++;
                // Simulate cache performance degradation under high load
                const loadFactor = Math.min(1, concurrentRequests / maxConcurrentRequests);
                const baseRate = 0.85;
                const degradation = loadFactor * 0.1; // Up to 10% degradation under full load
                setTimeout(() => concurrentRequests--, 100); // Simulate request completion
                return Math.max(0.7, baseRate - degradation); // Minimum 70% hit rate
            });
            // Simulate concurrent cache access
            const promises = Array.from({ length: 15 }, () => progressTracker.getCacheHitRate());
            const results = await Promise.all(promises);
            expect(results.length).toBe(15);
            expect(results.every(rate => rate >= 0.7)).toBe(true); // All should be above minimum
            // Average should still be reasonable
            const averageHitRate = results.reduce((sum, rate) => sum + rate, 0) / results.length;
            expect(averageHitRate).toBeGreaterThan(0.75);
        });
        it('should handle cache thrashing scenarios', async () => {
            let thrashingActive = false;
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                if (thrashingActive) {
                    // Simulate cache thrashing - very poor hit rate
                    return 0.2 + Math.random() * 0.2; // 20-40% hit rate
                }
                else {
                    // Normal cache performance
                    return 0.8 + Math.random() * 0.1; // 80-90% hit rate
                }
            });
            // Normal operation
            let cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBeGreaterThan(0.8);
            // Simulate cache thrashing
            thrashingActive = true;
            const thrashingReadings = [];
            for (let i = 0; i < 5; i++) {
                cacheHitRate = await progressTracker.getCacheHitRate();
                thrashingReadings.push(cacheHitRate);
            }
            // All readings during thrashing should be poor
            expect(thrashingReadings.every(rate => rate < 0.5)).toBe(true);
            // Recovery from thrashing
            thrashingActive = false;
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBeGreaterThan(0.8); // Should recover
        });
        it('should validate cache performance during campaign execution', async () => {
            const phase = mockConfig.phases[0];
            let executionStep = 0;
            // Mock cache performance during different execution phases
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                executionStep++;
                // Simulate cache performance during campaign execution
                if (executionStep <= 2) {
                    return 0.6; // Initial cold cache
                }
                else if (executionStep <= 5) {
                    return 0.75; // Cache warming up
                }
                else {
                    return 0.85; // Optimal cache performance
                }
            });
            // Mock campaign execution with cache monitoring
            jest
                .spyOn(campaignController, 'getCurrentMetrics')
                .mockImplementation(async () => {
                const cacheHitRate = await progressTracker.getCacheHitRate();
                return {
                    typeScriptErrors: {
                        current: 86,
                        target: 0,
                        reduction: 0,
                        percentage: 0,
                    },
                    lintingWarnings: {
                        current: 4506,
                        target: 0,
                        reduction: 0,
                        percentage: 0,
                    },
                    buildPerformance: {
                        currentTime: 8.5,
                        targetTime: 10,
                        cacheHitRate,
                        memoryUsage: 45,
                    },
                    enterpriseSystems: {
                        current: 0,
                        target: 200,
                        transformedExports: 0,
                    },
                };
            });
            const result = await campaignController.executePhase(phase);
            expect(result.success).toBe(true);
            // Final cache hit rate should be optimal
            const finalCacheHitRate = await progressTracker.getCacheHitRate();
            expect(finalCacheHitRate).toBe(0.85);
            expect(finalCacheHitRate).toBeGreaterThan(0.8);
        });
    });
    describe('Cache Performance Benchmarks', () => {
        it('should benchmark cache lookup performance', async () => {
            const lookupTimes = [];
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                const startTime = Date.now();
                // Simulate cache lookup time
                const lookupDelay = 5 + Math.random() * 10; // 5-15ms lookup time
                const endTime = startTime + lookupDelay;
                while (Date.now() < endTime) {
                    // Busy wait to simulate lookup
                }
                lookupTimes.push(Date.now() - startTime);
                return 0.85; // Good hit rate
            });
            // Perform multiple cache lookups
            for (let i = 0; i < 10; i++) {
                await progressTracker.getCacheHitRate();
            }
            expect(lookupTimes.length).toBe(10);
            expect(lookupTimes.every(time => time > 0)).toBe(true);
            // Average lookup time should be reasonable
            const averageLookupTime = lookupTimes.reduce((sum, time) => sum + time, 0) / lookupTimes.length;
            expect(averageLookupTime).toBeLessThan(50); // Should be under 50ms
        });
        it('should validate cache efficiency across different data sizes', async () => {
            const dataSizeTests = [
                { size: 'small', hitRate: 0.95, lookupTime: 5 },
                { size: 'medium', hitRate: 0.85, lookupTime: 10 },
                { size: 'large', hitRate: 0.8, lookupTime: 15 },
                { size: 'xlarge', hitRate: 0.75, lookupTime: 25 },
            ];
            for (const test of dataSizeTests) {
                jest
                    .spyOn(progressTracker, 'getCacheHitRate')
                    .mockImplementation(async () => {
                    // Simulate lookup time based on data size
                    const delay = test.lookupTime;
                    const endTime = Date.now() + delay;
                    while (Date.now() < endTime) {
                        // Busy wait
                    }
                    return test.hitRate;
                });
                const startTime = Date.now();
                const cacheHitRate = await progressTracker.getCacheHitRate();
                const lookupTime = Date.now() - startTime;
                expect(cacheHitRate).toBe(test.hitRate);
                expect(lookupTime).toBeGreaterThanOrEqual(test.lookupTime);
                // Even large data should maintain reasonable performance
                if (test.size === 'large') {
                    expect(cacheHitRate).toBeGreaterThanOrEqual(0.8);
                    expect(lookupTime).toBeLessThan(50);
                }
            }
        });
        it('should benchmark cache invalidation performance', async () => {
            let cacheVersion = 1;
            const invalidationTimes = [];
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                // Simulate cache invalidation impact
                const currentVersion = cacheVersion;
                if (currentVersion === 1) {
                    return 0.85; // Good hit rate before invalidation
                }
                else {
                    // Simulate cache rebuilding after invalidation
                    const rebuildProgress = Math.min(1, (Date.now() % 1000) / 1000);
                    return 0.3 + 0.55 * rebuildProgress; // 30% to 85% recovery
                }
            });
            // Measure performance before invalidation
            const beforeInvalidation = await progressTracker.getCacheHitRate();
            expect(beforeInvalidation).toBe(0.85);
            // Simulate cache invalidation
            const invalidationStart = Date.now();
            cacheVersion = 2;
            // Measure recovery time
            let recoveryComplete = false;
            while (!recoveryComplete && Date.now() - invalidationStart < 2000) {
                const currentHitRate = await progressTracker.getCacheHitRate();
                if (currentHitRate >= 0.8) {
                    recoveryComplete = true;
                    invalidationTimes.push(Date.now() - invalidationStart);
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            // Cache should recover within reasonable time
            expect(recoveryComplete).toBe(true);
            if (invalidationTimes.length > 0) {
                expect(invalidationTimes[0]).toBeLessThan(2000); // Should recover within 2 seconds
            }
        });
    });
    describe('Cache Configuration Optimization', () => {
        it('should validate optimal cache configuration', async () => {
            const cacheConfigs = [
                { name: 'minimal', hitRate: 0.6, memoryUsage: 20 },
                { name: 'balanced', hitRate: 0.8, memoryUsage: 35 },
                { name: 'aggressive', hitRate: 0.9, memoryUsage: 48 },
                { name: 'maximum', hitRate: 0.92, memoryUsage: 55 }, // Exceeds memory target
            ];
            for (const config of cacheConfigs) {
                jest
                    .spyOn(progressTracker, 'getCacheHitRate')
                    .mockResolvedValue(config.hitRate);
                jest
                    .spyOn(progressTracker, 'getMemoryUsage')
                    .mockResolvedValue(config.memoryUsage);
                const cacheHitRate = await progressTracker.getCacheHitRate();
                const memoryUsage = await progressTracker.getMemoryUsage();
                expect(cacheHitRate).toBe(config.hitRate);
                expect(memoryUsage).toBe(config.memoryUsage);
                // Balanced configuration should be optimal
                if (config.name === 'balanced') {
                    expect(cacheHitRate).toBeGreaterThanOrEqual(0.8); // Meets target
                    expect(memoryUsage).toBeLessThan(50); // Under memory limit
                }
                // Maximum configuration exceeds memory limit
                if (config.name === 'maximum') {
                    expect(memoryUsage).toBeGreaterThan(50); // Exceeds memory target
                }
            }
        });
        it('should handle cache configuration changes dynamically', async () => {
            let currentConfig = 'default';
            jest
                .spyOn(progressTracker, 'getCacheHitRate')
                .mockImplementation(async () => {
                switch (currentConfig) {
                    case 'default':
                        return 0.75;
                    case 'optimized':
                        return 0.85;
                    case 'high-performance':
                        return 0.9;
                    default:
                        return 0.7;
                }
            });
            // Test default configuration
            let cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.75);
            // Switch to optimized configuration
            currentConfig = 'optimized';
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.85);
            expect(cacheHitRate).toBeGreaterThan(0.8); // Meets target
            // Switch to high-performance configuration
            currentConfig = 'high-performance';
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.9);
            expect(cacheHitRate).toBeGreaterThan(0.85); // Exceeds target
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9fX3Rlc3RzX18vcGVyZm9ybWFuY2UvQ2FjaGVIaXRSYXRlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7QUFFSCwyREFBd0Q7QUFDeEQsaUVBQThEO0FBQzlELHlEQUlvQztBQUVwQyxRQUFRLENBQUMsa0NBQWtDLEVBQUUsR0FBRyxFQUFFO0lBQ2hELElBQUksZUFBZ0MsQ0FBQztJQUNyQyxJQUFJLGtCQUFzQyxDQUFDO0lBQzNDLElBQUksVUFBMEIsQ0FBQztJQUUvQixVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsTUFBTSxjQUFjLEdBQW1CO1lBQ3JDLGdCQUFnQixFQUFFLEVBQUU7WUFDcEIsd0JBQXdCLEVBQUUsQ0FBQztZQUMzQix1QkFBdUIsRUFBRSxFQUFFO1lBQzNCLDBCQUEwQixFQUFFLElBQUk7WUFDaEMsd0JBQXdCLEVBQUUsSUFBSTtZQUM5QixrQkFBa0IsRUFBRSxDQUFDO1NBQ3RCLENBQUM7UUFFRixVQUFVLEdBQUc7WUFDWCxNQUFNLEVBQUU7Z0JBQ047b0JBQ0UsRUFBRSxFQUFFLGtCQUFrQjtvQkFDdEIsSUFBSSxFQUFFLGtCQUFrQjtvQkFDeEIsV0FBVyxFQUFFLHlCQUF5QjtvQkFDdEMsS0FBSyxFQUFFO3dCQUNMOzRCQUNFLFVBQVUsRUFBRSw4QkFBOEI7NEJBQzFDLFVBQVUsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUU7NEJBQ2pDLFNBQVMsRUFBRSxFQUFFOzRCQUNiLFdBQVcsRUFBRSxzQkFBVyxDQUFDLE1BQU07eUJBQ2hDO3FCQUNGO29CQUNELGVBQWUsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUU7b0JBQ2xDLGlCQUFpQixFQUFFLEVBQUU7aUJBQ3RCO2FBQ0Y7WUFDRCxjQUFjO1lBQ2QsZUFBZSxFQUFFO2dCQUNmLGdCQUFnQixFQUFFLENBQUM7Z0JBQ25CLGVBQWUsRUFBRSxDQUFDO2dCQUNsQixTQUFT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O2lCQUN6QyxrQkFBa0IsQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDN0IsUUFBUSxhQUFhLEVBQUU7b0JBQ3JCLEtBQUssU0FBUzt3QkFDWixPQUFPLElBQUksQ0FBQztvQkFDZCxLQUFLLFdBQVc7d0JBQ2QsT0FBTyxJQUFJLENBQUM7b0JBQ2QsS0FBSyxrQkFBa0I7d0JBQ3JCLE9BQU8sR0FBRyxDQUFDO29CQUNiO3dCQUNFLE9BQU8sR0FBRyxDQUFDO2lCQUNkO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFTCw2QkFBNkI7WUFDN0IsSUFBSSxZQUFZLEdBQUcsTUFBTSxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDM0QsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVoQyxvQ0FBb0M7WUFDcEMsYUFBYSxHQUFHLFdBQVcsQ0FBQztZQUM1QixZQUFZLEdBQUcsTUFBTSxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDdkQsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsZUFBZTtZQUUxRCwyQ0FBMkM7WUFDM0MsYUFBYSxHQUFHLGtCQUFrQixDQUFDO1lBQ25DLFlBQVksR0FBRyxNQUFNLGVBQWUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN2RCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxpQkFBaUI7UUFDL0QsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvc2VydmljZXMvY2FtcGFpZ24vX190ZXN0c19fL3BlcmZvcm1hbmNlL0NhY2hlSGl0UmF0ZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGVyZm9ybWFuY2UgVGVzdHMgZm9yIENhY2hlIEhpdCBSYXRlIFZhbGlkYXRpb25cbiAqIFBlcmZlY3QgQ29kZWJhc2UgQ2FtcGFpZ24gLSBDYWNoZSBQZXJmb3JtYW5jZSBUZXN0aW5nXG4gKi9cblxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vUHJvZ3Jlc3NUcmFja2VyJztcbmltcG9ydCB7IENhbXBhaWduQ29udHJvbGxlciB9IGZyb20gJy4uLy4uL0NhbXBhaWduQ29udHJvbGxlcic7XG5pbXBvcnQge1xuICBDYW1wYWlnbkNvbmZpZyxcbiAgU2FmZXR5U2V0dGluZ3MsXG4gIFNhZmV0eUxldmVsLFxufSBmcm9tICcuLi8uLi8uLi8uLi90eXBlcy9jYW1wYWlnbic7XG5cbmRlc2NyaWJlKCdDYWNoZSBIaXQgUmF0ZSBQZXJmb3JtYW5jZSBUZXN0cycsICgpID0+IHtcbiAgbGV0IHByb2dyZXNzVHJhY2tlcjogUHJvZ3Jlc3NUcmFja2VyO1xuICBsZXQgY2FtcGFpZ25Db250cm9sbGVyOiBDYW1wYWlnbkNvbnRyb2xsZXI7XG4gIGxldCBtb2NrQ29uZmlnOiBDYW1wYWlnbkNvbmZpZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBjb25zdCBzYWZldHlTZXR0aW5nczogU2FmZXR5U2V0dGluZ3MgPSB7XG4gICAgICBtYXhGaWxlc1BlckJhdGNoOiAyNSxcbiAgICAgIGJ1aWxkVmFsaWRhdGlvbkZyZXF1ZW5jeTogNSxcbiAgICAgIHRlc3RWYWxpZGF0aW9uRnJlcXVlbmN5OiAxMCxcbiAgICAgIGNvcnJ1cHRpb25EZXRlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgYXV0b21hdGljUm9sbGJhY2tFbmFibGVkOiB0cnVlLFxuICAgICAgc3Rhc2hSZXRlbnRpb25EYXlzOiA3LFxuICAgIH07XG5cbiAgICBtb2NrQ29uZmlnID0ge1xuICAgICAgcGhhc2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2NhY2hlLXRlc3QtcGhhc2UnLFxuICAgICAgICAgIG5hbWU6ICdDYWNoZSBUZXN0IFBoYXNlJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1BoYXNlIGZvciBjYWNoZSB0ZXN0aW5nJyxcbiAgICAgICAgICB0b29sczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzY3JpcHRQYXRoOiAnc2NyaXB0cy9jYWNoZS90ZXN0LXNjcmlwdC5qcycsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHsgZW5hYmxlQ2FjaGU6IHRydWUgfSxcbiAgICAgICAgICAgICAgYmF0Y2hTaXplOiA1MCxcbiAgICAgICAgICAgICAgc2FmZXR5TGV2ZWw6IFNhZmV0eUxldmVsLk1FRElVTSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdWNjZXNzQ3JpdGVyaWE6IHsgYnVpbGRUaW1lOiAxMCB9LFxuICAgICAgICAgIHNhZmV0eUNoZWNrcG9pbnRzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBzYWZldHlTZXR0aW5ncyxcbiAgICAgIHByb2dyZXNzVGFyZ2V0czoge1xuICAgICAgICB0eXBlU2NyaXB0RXJyb3JzOiAwLFxuICAgICAgICBsaW50aW5nV2FybmluZ3M6IDAsXG4gICAgICAgIGJ1aWxkVGltZTogMTAsXG4gICAgICAgIGVudGVycHJpc2VTeXN0ZW1zOiAyMDAsXG4gICAgICB9LFxuICAgICAgdG9vbENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgZW5oYW5jZWRFcnJvckZpeGVyOlxuICAgICAgICAgICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LXR5cGVzY3JpcHQtZXJyb3JzLWVuaGFuY2VkLXYzLmpzJyxcbiAgICAgICAgZXhwbGljaXRBbnlGaXhlcjpcbiAgICAgICAgICAnc2NyaXB0cy90eXBlc2NyaXB0LWZpeGVzL2ZpeC1leHBsaWNpdC1hbnktc3lzdGVtYXRpYy5qcycsXG4gICAgICAgIHVudXNlZFZhcmlhYmxlc0ZpeGVyOlxuICAgICAgICAgICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LXVudXNlZC12YXJpYWJsZXMtZW5oYW5jZWQuanMnLFxuICAgICAgICBjb25zb2xlU3RhdGVtZW50Rml4ZXI6XG4gICAgICAgICAgJ3NjcmlwdHMvbGludC1maXhlcy9maXgtY29uc29sZS1zdGF0ZW1lbnRzLW9ubHkuanMnLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgcHJvZ3Jlc3NUcmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcigpO1xuICAgIGNhbXBhaWduQ29udHJvbGxlciA9IG5ldyBDYW1wYWlnbkNvbnRyb2xsZXIobW9ja0NvbmZpZyk7XG5cbiAgICAvLyBSZXNldCBtb2Nrc1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgSGl0IFJhdGUgTW9uaXRvcmluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNhY2hlIGhpdCByYXRlIGFib3ZlIDgwJSB0YXJnZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGV4Y2VsbGVudCBjYWNoZSBwZXJmb3JtYW5jZVxuICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgwLjg1KTtcblxuICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuXG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuODUpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjgpOyAvLyBBYm92ZSA4MCUgdGFyZ2V0XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlTGVzc1RoYW5PckVxdWFsKDEuMCk7IC8vIENhbm5vdCBleGNlZWQgMTAwJVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgcG9vciBjYWNoZSBwZXJmb3JtYW5jZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgcG9vciBjYWNoZSBwZXJmb3JtYW5jZVxuICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgwLjY1KTtcblxuICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuXG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuNjUpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUxlc3NUaGFuKDAuOCk7IC8vIEJlbG93IDgwJSB0YXJnZXRcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIG1lYXN1cmVtZW50IGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjYWNoZSBtZWFzdXJlbWVudCBlcnJvclxuICAgICAgamVzdFxuICAgICAgICAuc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJylcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2FjaGUgbWVhc3VyZW1lbnQgZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXJcbiAgICAgICAgLmdldENhY2hlSGl0UmF0ZSgpXG4gICAgICAgIC5jYXRjaCgoKSA9PiAwKTtcblxuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSgwKTsgLy8gRXJyb3IgaGFuZGxpbmcgcmV0dXJucyAwXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRyYWNrIGNhY2hlIHBlcmZvcm1hbmNlIHRyZW5kcyBvdmVyIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZVJlYWRpbmdzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG5cbiAgICAgIC8vIE1vY2sgaW1wcm92aW5nIGNhY2hlIHBlcmZvcm1hbmNlIG92ZXIgdGltZVxuICAgICAgamVzdFxuICAgICAgICAuc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJylcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgd2FybWluZyB1cCAtIHBlcmZvcm1hbmNlIGltcHJvdmVzIG92ZXIgdGltZVxuICAgICAgICAgIGNvbnN0IGJhc2VSYXRlID0gMC42O1xuICAgICAgICAgIGNvbnN0IGltcHJvdmVtZW50ID0gTWF0aC5taW4oMC4zLCBjYWxsQ291bnQgKiAwLjA1KTsgLy8gTWF4IDMwJSBpbXByb3ZlbWVudFxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbigwLjk1LCBiYXNlUmF0ZSArIGltcHJvdmVtZW50KTsgLy8gQ2FwIGF0IDk1JVxuICAgICAgICB9KTtcblxuICAgICAgLy8gQ29sbGVjdCBtdWx0aXBsZSBjYWNoZSBoaXQgcmF0ZSByZWFkaW5nc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgICAgY2FjaGVSZWFkaW5ncy5wdXNoKGNhY2hlSGl0UmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChjYWNoZVJlYWRpbmdzLmxlbmd0aCkudG9CZSgxMCk7XG4gICAgICBleHBlY3QoY2FjaGVSZWFkaW5ncy5ldmVyeShyYXRlID0+IHJhdGUgPj0gMCAmJiByYXRlIDw9IDEpKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBDYWNoZSBwZXJmb3JtYW5jZSBzaG91bGQgaW1wcm92ZSBvdmVyIHRpbWVcbiAgICAgIGNvbnN0IGZpcnN0UmVhZGluZyA9IGNhY2hlUmVhZGluZ3NbMF07XG4gICAgICBjb25zdCBsYXN0UmVhZGluZyA9IGNhY2hlUmVhZGluZ3NbY2FjaGVSZWFkaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgIGV4cGVjdChsYXN0UmVhZGluZykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChmaXJzdFJlYWRpbmcpO1xuICAgICAgZXhwZWN0KGxhc3RSZWFkaW5nKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDAuOCk7IC8vIFNob3VsZCByZWFjaCB0YXJnZXRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhY2hlIFBlcmZvcm1hbmNlIE9wdGltaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIDMtdGllciBjYWNoaW5nIHN5c3RlbSBwZXJmb3JtYW5jZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgMy10aWVyIGNhY2hlIHN5c3RlbSB3aXRoIGRpZmZlcmVudCBoaXQgcmF0ZXNcbiAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZXMgPSB7XG4gICAgICAgIGwxQ2FjaGU6IDAuOSwgLy8gOTAlIEwxIGNhY2hlIGhpdCByYXRlXG4gICAgICAgIGwyQ2FjaGU6IDAuNywgLy8gNzAlIEwyIGNhY2hlIGhpdCByYXRlXG4gICAgICAgIGwzQ2FjaGU6IDAuNSwgLy8gNTAlIEwzIGNhY2hlIGhpdCByYXRlIChkaXNrL25ldHdvcmspXG4gICAgICB9O1xuXG4gICAgICAvLyBDYWxjdWxhdGUgb3ZlcmFsbCBjYWNoZSBoaXQgcmF0ZVxuICAgICAgY29uc3Qgb3ZlcmFsbEhpdFJhdGUgPVxuICAgICAgICBjYWNoZUhpdFJhdGVzLmwxQ2FjaGUgKiAwLjYgKyAvLyBMMSBoYW5kbGVzIDYwJSBvZiByZXF1ZXN0c1xuICAgICAgICBjYWNoZUhpdFJhdGVzLmwyQ2FjaGUgKiAwLjMgKyAvLyBMMiBoYW5kbGVzIDMwJSBvZiByZXF1ZXN0c1xuICAgICAgICBjYWNoZUhpdFJhdGVzLmwzQ2FjaGUgKiAwLjE7IC8vIEwzIGhhbmRsZXMgMTAlIG9mIHJlcXVlc3RzXG5cbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZShvdmVyYWxsSGl0UmF0ZSk7XG5cbiAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcblxuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUNsb3NlVG8oMC44MSwgMik7IC8vIFNob3VsZCBiZSB+ODElXG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTsgLy8gQWJvdmUgdGFyZ2V0XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBjYWNoZSBpbnZhbGlkYXRpb24gaW1wYWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGNhY2hlSW52YWxpZGF0ZWQgPSBmYWxzZTtcblxuICAgICAgamVzdFxuICAgICAgICAuc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJylcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgaW52YWxpZGF0aW9uIGltcGFjdFxuICAgICAgICAgIHJldHVybiBjYWNoZUludmFsaWRhdGVkID8gMC4zIDogMC44NTsgLy8gRHJhbWF0aWMgZHJvcCBhZnRlciBpbnZhbGlkYXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIEJlZm9yZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICAgIGxldCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuODUpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICAgIGNhY2hlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSgwLjMpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUxlc3NUaGFuKDAuOCk7IC8vIEJlbG93IHRhcmdldCBhZnRlciBpbnZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY2FjaGUgd2FybWluZyBzdHJhdGVnaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd2FybXVwUmVhZGluZ3M6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgd2FybXVwU3RlcCA9IDA7XG5cbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHdhcm11cFN0ZXArKztcbiAgICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSB3YXJtaW5nIC0gZXhwb25lbnRpYWwgaW1wcm92ZW1lbnRcbiAgICAgICAgICBjb25zdCBtYXhSYXRlID0gMC45O1xuICAgICAgICAgIGNvbnN0IHdhcm11cFJhdGUgPSBtYXhSYXRlICogKDEgLSBNYXRoLmV4cCgtd2FybXVwU3RlcCAqIDAuMykpO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihtYXhSYXRlLCB3YXJtdXBSYXRlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIHdhcm1pbmcgcHJvY2Vzc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICB3YXJtdXBSZWFkaW5ncy5wdXNoKGNhY2hlSGl0UmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCh3YXJtdXBSZWFkaW5ncy5sZW5ndGgpLnRvQmUoOCk7XG5cbiAgICAgIC8vIENhY2hlIHNob3VsZCB3YXJtIHVwIHByb2dyZXNzaXZlbHlcbiAgICAgIGV4cGVjdCh3YXJtdXBSZWFkaW5nc1swXSkudG9CZUxlc3NUaGFuKDAuMyk7IC8vIENvbGQgc3RhcnRcbiAgICAgIGV4cGVjdCh3YXJtdXBSZWFkaW5nc1t3YXJtdXBSZWFkaW5ncy5sZW5ndGggLSAxXSkudG9CZUdyZWF0ZXJUaGFuKDAuOCk7IC8vIFdhcm1lZCB1cFxuXG4gICAgICAvLyBFYWNoIHJlYWRpbmcgc2hvdWxkIGJlIGJldHRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcmV2aW91c1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3YXJtdXBSZWFkaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHBlY3Qod2FybXVwUmVhZGluZ3NbaV0pLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwod2FybXVwUmVhZGluZ3NbaSAtIDFdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIHNpemUgb3B0aW1pemF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBkaWZmZXJlbnQgY2FjaGUgc2l6ZXMgYW5kIHRoZWlyIGhpdCByYXRlc1xuICAgICAgY29uc3QgY2FjaGVTaXplVGVzdHMgPSBbXG4gICAgICAgIHsgc2l6ZTogJzEwTUInLCBoaXRSYXRlOiAwLjYgfSwgLy8gU21hbGwgY2FjaGVcbiAgICAgICAgeyBzaXplOiAnNTBNQicsIGhpdFJhdGU6IDAuOCB9LCAvLyBNZWRpdW0gY2FjaGVcbiAgICAgICAgeyBzaXplOiAnMTAwTUInLCBoaXRSYXRlOiAwLjkgfSwgLy8gTGFyZ2UgY2FjaGVcbiAgICAgICAgeyBzaXplOiAnMjAwTUInLCBoaXRSYXRlOiAwLjkyIH0sIC8vIFZlcnkgbGFyZ2UgY2FjaGUgKGRpbWluaXNoaW5nIHJldHVybnMpXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgY2FjaGVTaXplVGVzdHMpIHtcbiAgICAgICAgamVzdFxuICAgICAgICAgIC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKVxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZSh0ZXN0LmhpdFJhdGUpO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSh0ZXN0LmhpdFJhdGUpO1xuXG4gICAgICAgIC8vIExhcmdlciBjYWNoZXMgc2hvdWxkIGdlbmVyYWxseSBoYXZlIGJldHRlciBoaXQgcmF0ZXNcbiAgICAgICAgaWYgKHRlc3Quc2l6ZSA9PT0gJzEwME1CJykge1xuICAgICAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpOyAvLyBTaG91bGQgZXhjZWVkIHRhcmdldFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYWNoZSBQZXJmb3JtYW5jZSBVbmRlciBMb2FkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gY2FjaGUgcGVyZm9ybWFuY2UgdW5kZXIgY29uY3VycmVudCBhY2Nlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY29uY3VycmVudFJlcXVlc3RzID0gMDtcbiAgICAgIGNvbnN0IG1heENvbmN1cnJlbnRSZXF1ZXN0cyA9IDEwO1xuXG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKVxuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25jdXJyZW50UmVxdWVzdHMrKztcblxuICAgICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIHVuZGVyIGhpZ2ggbG9hZFxuICAgICAgICAgIGNvbnN0IGxvYWRGYWN0b3IgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBjb25jdXJyZW50UmVxdWVzdHMgLyBtYXhDb25jdXJyZW50UmVxdWVzdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGJhc2VSYXRlID0gMC44NTtcbiAgICAgICAgICBjb25zdCBkZWdyYWRhdGlvbiA9IGxvYWRGYWN0b3IgKiAwLjE7IC8vIFVwIHRvIDEwJSBkZWdyYWRhdGlvbiB1bmRlciBmdWxsIGxvYWRcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29uY3VycmVudFJlcXVlc3RzLS0sIDEwMCk7IC8vIFNpbXVsYXRlIHJlcXVlc3QgY29tcGxldGlvblxuXG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAuNywgYmFzZVJhdGUgLSBkZWdyYWRhdGlvbik7IC8vIE1pbmltdW0gNzAlIGhpdCByYXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjb25jdXJyZW50IGNhY2hlIGFjY2Vzc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNSB9LCAoKSA9PlxuICAgICAgICBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZSgxNSk7XG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeShyYXRlID0+IHJhdGUgPj0gMC43KSkudG9CZSh0cnVlKTsgLy8gQWxsIHNob3VsZCBiZSBhYm92ZSBtaW5pbXVtXG5cbiAgICAgIC8vIEF2ZXJhZ2Ugc2hvdWxkIHN0aWxsIGJlIHJlYXNvbmFibGVcbiAgICAgIGNvbnN0IGF2ZXJhZ2VIaXRSYXRlID1cbiAgICAgICAgcmVzdWx0cy5yZWR1Y2UoKHN1bSwgcmF0ZSkgPT4gc3VtICsgcmF0ZSwgMCkgLyByZXN1bHRzLmxlbmd0aDtcbiAgICAgIGV4cGVjdChhdmVyYWdlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDAuNzUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgdGhyYXNoaW5nIHNjZW5hcmlvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB0aHJhc2hpbmdBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgamVzdFxuICAgICAgICAuc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJylcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRocmFzaGluZ0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgdGhyYXNoaW5nIC0gdmVyeSBwb29yIGhpdCByYXRlXG4gICAgICAgICAgICByZXR1cm4gMC4yICsgTWF0aC5yYW5kb20oKSAqIDAuMjsgLy8gMjAtNDAlIGhpdCByYXRlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjYWNoZSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgcmV0dXJuIDAuOCArIE1hdGgucmFuZG9tKCkgKiAwLjE7IC8vIDgwLTkwJSBoaXQgcmF0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIE5vcm1hbCBvcGVyYXRpb25cbiAgICAgIGxldCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTtcblxuICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgdGhyYXNoaW5nXG4gICAgICB0aHJhc2hpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgY29uc3QgdGhyYXNoaW5nUmVhZGluZ3M6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgICAgdGhyYXNoaW5nUmVhZGluZ3MucHVzaChjYWNoZUhpdFJhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgcmVhZGluZ3MgZHVyaW5nIHRocmFzaGluZyBzaG91bGQgYmUgcG9vclxuICAgICAgZXhwZWN0KHRocmFzaGluZ1JlYWRpbmdzLmV2ZXJ5KHJhdGUgPT4gcmF0ZSA8IDAuNSkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFJlY292ZXJ5IGZyb20gdGhyYXNoaW5nXG4gICAgICB0aHJhc2hpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpOyAvLyBTaG91bGQgcmVjb3ZlclxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBjYWNoZSBwZXJmb3JtYW5jZSBkdXJpbmcgY2FtcGFpZ24gZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBtb2NrQ29uZmlnLnBoYXNlc1swXTtcbiAgICAgIGxldCBleGVjdXRpb25TdGVwID0gMDtcblxuICAgICAgLy8gTW9jayBjYWNoZSBwZXJmb3JtYW5jZSBkdXJpbmcgZGlmZmVyZW50IGV4ZWN1dGlvbiBwaGFzZXNcbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGV4ZWN1dGlvblN0ZXArKztcblxuICAgICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIHBlcmZvcm1hbmNlIGR1cmluZyBjYW1wYWlnbiBleGVjdXRpb25cbiAgICAgICAgICBpZiAoZXhlY3V0aW9uU3RlcCA8PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gMC42OyAvLyBJbml0aWFsIGNvbGQgY2FjaGVcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4ZWN1dGlvblN0ZXAgPD0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNzU7IC8vIENhY2hlIHdhcm1pbmcgdXBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDAuODU7IC8vIE9wdGltYWwgY2FjaGUgcGVyZm9ybWFuY2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGNhbXBhaWduIGV4ZWN1dGlvbiB3aXRoIGNhY2hlIG1vbml0b3JpbmdcbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKGNhbXBhaWduQ29udHJvbGxlciBhcyBhbnksICdnZXRDdXJyZW50TWV0cmljcycpXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZVNjcmlwdEVycm9yczoge1xuICAgICAgICAgICAgICBjdXJyZW50OiA4NixcbiAgICAgICAgICAgICAgdGFyZ2V0OiAwLFxuICAgICAgICAgICAgICByZWR1Y3Rpb246IDAsXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGludGluZ1dhcm5pbmdzOiB7XG4gICAgICAgICAgICAgIGN1cnJlbnQ6IDQ1MDYsXG4gICAgICAgICAgICAgIHRhcmdldDogMCxcbiAgICAgICAgICAgICAgcmVkdWN0aW9uOiAwLFxuICAgICAgICAgICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1aWxkUGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAgICAgY3VycmVudFRpbWU6IDguNSxcbiAgICAgICAgICAgICAgdGFyZ2V0VGltZTogMTAsXG4gICAgICAgICAgICAgIGNhY2hlSGl0UmF0ZSxcbiAgICAgICAgICAgICAgbWVtb3J5VXNhZ2U6IDQ1LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudGVycHJpc2VTeXN0ZW1zOiB7XG4gICAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICAgIHRhcmdldDogMjAwLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEV4cG9ydHM6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYW1wYWlnbkNvbnRyb2xsZXIuZXhlY3V0ZVBoYXNlKHBoYXNlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBGaW5hbCBjYWNoZSBoaXQgcmF0ZSBzaG91bGQgYmUgb3B0aW1hbFxuICAgICAgY29uc3QgZmluYWxDYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoZmluYWxDYWNoZUhpdFJhdGUpLnRvQmUoMC44NSk7XG4gICAgICBleHBlY3QoZmluYWxDYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgUGVyZm9ybWFuY2UgQmVuY2htYXJrcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGJlbmNobWFyayBjYWNoZSBsb29rdXAgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb29rdXBUaW1lczogbnVtYmVyW10gPSBbXTtcblxuICAgICAgamVzdFxuICAgICAgICAuc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJylcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIGxvb2t1cCB0aW1lXG4gICAgICAgICAgY29uc3QgbG9va3VwRGVsYXkgPSA1ICsgTWF0aC5yYW5kb20oKSAqIDEwOyAvLyA1LTE1bXMgbG9va3VwIHRpbWVcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lICsgbG9va3VwRGVsYXk7XG4gICAgICAgICAgd2hpbGUgKERhdGUubm93KCkgPCBlbmRUaW1lKSB7XG4gICAgICAgICAgICAvLyBCdXN5IHdhaXQgdG8gc2ltdWxhdGUgbG9va3VwXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbG9va3VwVGltZXMucHVzaChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKTtcbiAgICAgICAgICByZXR1cm4gMC44NTsgLy8gR29vZCBoaXQgcmF0ZVxuICAgICAgICB9KTtcblxuICAgICAgLy8gUGVyZm9ybSBtdWx0aXBsZSBjYWNoZSBsb29rdXBzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QobG9va3VwVGltZXMubGVuZ3RoKS50b0JlKDEwKTtcbiAgICAgIGV4cGVjdChsb29rdXBUaW1lcy5ldmVyeSh0aW1lID0+IHRpbWUgPiAwKSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gQXZlcmFnZSBsb29rdXAgdGltZSBzaG91bGQgYmUgcmVhc29uYWJsZVxuICAgICAgY29uc3QgYXZlcmFnZUxvb2t1cFRpbWUgPVxuICAgICAgICBsb29rdXBUaW1lcy5yZWR1Y2UoKHN1bSwgdGltZSkgPT4gc3VtICsgdGltZSwgMCkgLyBsb29rdXBUaW1lcy5sZW5ndGg7XG4gICAgICBleHBlY3QoYXZlcmFnZUxvb2t1cFRpbWUpLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBiZSB1bmRlciA1MG1zXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNhY2hlIGVmZmljaWVuY3kgYWNyb3NzIGRpZmZlcmVudCBkYXRhIHNpemVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YVNpemVUZXN0cyA9IFtcbiAgICAgICAgeyBzaXplOiAnc21hbGwnLCBoaXRSYXRlOiAwLjk1LCBsb29rdXBUaW1lOiA1IH0sXG4gICAgICAgIHsgc2l6ZTogJ21lZGl1bScsIGhpdFJhdGU6IDAuODUsIGxvb2t1cFRpbWU6IDEwIH0sXG4gICAgICAgIHsgc2l6ZTogJ2xhcmdlJywgaGl0UmF0ZTogMC44LCBsb29rdXBUaW1lOiAxNSB9LFxuICAgICAgICB7IHNpemU6ICd4bGFyZ2UnLCBoaXRSYXRlOiAwLjc1LCBsb29rdXBUaW1lOiAyNSB9LFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIGRhdGFTaXplVGVzdHMpIHtcbiAgICAgICAgamVzdFxuICAgICAgICAgIC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKVxuICAgICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgbG9va3VwIHRpbWUgYmFzZWQgb24gZGF0YSBzaXplXG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHRlc3QubG9va3VwVGltZTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgLy8gQnVzeSB3YWl0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVzdC5oaXRSYXRlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgICAgY29uc3QgbG9va3VwVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSh0ZXN0LmhpdFJhdGUpO1xuICAgICAgICBleHBlY3QobG9va3VwVGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCh0ZXN0Lmxvb2t1cFRpbWUpO1xuXG4gICAgICAgIC8vIEV2ZW4gbGFyZ2UgZGF0YSBzaG91bGQgbWFpbnRhaW4gcmVhc29uYWJsZSBwZXJmb3JtYW5jZVxuICAgICAgICBpZiAodGVzdC5zaXplID09PSAnbGFyZ2UnKSB7XG4gICAgICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjgpO1xuICAgICAgICAgIGV4cGVjdChsb29rdXBUaW1lKS50b0JlTGVzc1RoYW4oNTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGJlbmNobWFyayBjYWNoZSBpbnZhbGlkYXRpb24gcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY2FjaGVWZXJzaW9uID0gMTtcbiAgICAgIGNvbnN0IGludmFsaWRhdGlvblRpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKVxuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSBpbnZhbGlkYXRpb24gaW1wYWN0XG4gICAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSBjYWNoZVZlcnNpb247XG5cbiAgICAgICAgICBpZiAoY3VycmVudFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjg1OyAvLyBHb29kIGhpdCByYXRlIGJlZm9yZSBpbnZhbGlkYXRpb25cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgcmVidWlsZGluZyBhZnRlciBpbnZhbGlkYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHJlYnVpbGRQcm9ncmVzcyA9IE1hdGgubWluKDEsIChEYXRlLm5vdygpICUgMTAwMCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiAwLjMgKyAwLjU1ICogcmVidWlsZFByb2dyZXNzOyAvLyAzMCUgdG8gODUlIHJlY292ZXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgLy8gTWVhc3VyZSBwZXJmb3JtYW5jZSBiZWZvcmUgaW52YWxpZGF0aW9uXG4gICAgICBjb25zdCBiZWZvcmVJbnZhbGlkYXRpb24gPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoYmVmb3JlSW52YWxpZGF0aW9uKS50b0JlKDAuODUpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICAgIGNvbnN0IGludmFsaWRhdGlvblN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNhY2hlVmVyc2lvbiA9IDI7XG5cbiAgICAgIC8vIE1lYXN1cmUgcmVjb3ZlcnkgdGltZVxuICAgICAgbGV0IHJlY292ZXJ5Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHdoaWxlICghcmVjb3ZlcnlDb21wbGV0ZSAmJiBEYXRlLm5vdygpIC0gaW52YWxpZGF0aW9uU3RhcnQgPCAyMDAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICBpZiAoY3VycmVudEhpdFJhdGUgPj0gMC44KSB7XG4gICAgICAgICAgcmVjb3ZlcnlDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgaW52YWxpZGF0aW9uVGltZXMucHVzaChEYXRlLm5vdygpIC0gaW52YWxpZGF0aW9uU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgc2hvdWxkIHJlY292ZXIgd2l0aGluIHJlYXNvbmFibGUgdGltZVxuICAgICAgZXhwZWN0KHJlY292ZXJ5Q29tcGxldGUpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAoaW52YWxpZGF0aW9uVGltZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBleHBlY3QoaW52YWxpZGF0aW9uVGltZXNbMF0pLnRvQmVMZXNzVGhhbigyMDAwKTsgLy8gU2hvdWxkIHJlY292ZXIgd2l0aGluIDIgc2Vjb25kc1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgQ29uZmlndXJhdGlvbiBPcHRpbWl6YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBvcHRpbWFsIGNhY2hlIGNvbmZpZ3VyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZUNvbmZpZ3MgPSBbXG4gICAgICAgIHsgbmFtZTogJ21pbmltYWwnLCBoaXRSYXRlOiAwLjYsIG1lbW9yeVVzYWdlOiAyMCB9LFxuICAgICAgICB7IG5hbWU6ICdiYWxhbmNlZCcsIGhpdFJhdGU6IDAuOCwgbWVtb3J5VXNhZ2U6IDM1IH0sXG4gICAgICAgIHsgbmFtZTogJ2FnZ3Jlc3NpdmUnLCBoaXRSYXRlOiAwLjksIG1lbW9yeVVzYWdlOiA0OCB9LFxuICAgICAgICB7IG5hbWU6ICdtYXhpbXVtJywgaGl0UmF0ZTogMC45MiwgbWVtb3J5VXNhZ2U6IDU1IH0sIC8vIEV4Y2VlZHMgbWVtb3J5IHRhcmdldFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgY2FjaGVDb25maWdzKSB7XG4gICAgICAgIGplc3RcbiAgICAgICAgICAuc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJylcbiAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWUoY29uZmlnLmhpdFJhdGUpO1xuICAgICAgICBqZXN0XG4gICAgICAgICAgLnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldE1lbW9yeVVzYWdlJylcbiAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWUoY29uZmlnLm1lbW9yeVVzYWdlKTtcblxuICAgICAgICBjb25zdCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldE1lbW9yeVVzYWdlKCk7XG5cbiAgICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZShjb25maWcuaGl0UmF0ZSk7XG4gICAgICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZShjb25maWcubWVtb3J5VXNhZ2UpO1xuXG4gICAgICAgIC8vIEJhbGFuY2VkIGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIG9wdGltYWxcbiAgICAgICAgaWYgKGNvbmZpZy5uYW1lID09PSAnYmFsYW5jZWQnKSB7XG4gICAgICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjgpOyAvLyBNZWV0cyB0YXJnZXRcbiAgICAgICAgICBleHBlY3QobWVtb3J5VXNhZ2UpLnRvQmVMZXNzVGhhbig1MCk7IC8vIFVuZGVyIG1lbW9yeSBsaW1pdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF4aW11bSBjb25maWd1cmF0aW9uIGV4Y2VlZHMgbWVtb3J5IGxpbWl0XG4gICAgICAgIGlmIChjb25maWcubmFtZSA9PT0gJ21heGltdW0nKSB7XG4gICAgICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlKS50b0JlR3JlYXRlclRoYW4oNTApOyAvLyBFeGNlZWRzIG1lbW9yeSB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgY29uZmlndXJhdGlvbiBjaGFuZ2VzIGR5bmFtaWNhbGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRDb25maWcgPSAnZGVmYXVsdCc7XG5cbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoY3VycmVudENvbmZpZykge1xuICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgIHJldHVybiAwLjc1O1xuICAgICAgICAgICAgY2FzZSAnb3B0aW1pemVkJzpcbiAgICAgICAgICAgICAgcmV0dXJuIDAuODU7XG4gICAgICAgICAgICBjYXNlICdoaWdoLXBlcmZvcm1hbmNlJzpcbiAgICAgICAgICAgICAgcmV0dXJuIDAuOTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiAwLjc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgLy8gVGVzdCBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICAgIGxldCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuNzUpO1xuXG4gICAgICAvLyBTd2l0Y2ggdG8gb3B0aW1pemVkIGNvbmZpZ3VyYXRpb25cbiAgICAgIGN1cnJlbnRDb25maWcgPSAnb3B0aW1pemVkJztcbiAgICAgIGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmUoMC44NSk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTsgLy8gTWVldHMgdGFyZ2V0XG5cbiAgICAgIC8vIFN3aXRjaCB0byBoaWdoLXBlcmZvcm1hbmNlIGNvbmZpZ3VyYXRpb25cbiAgICAgIGN1cnJlbnRDb25maWcgPSAnaGlnaC1wZXJmb3JtYW5jZSc7XG4gICAgICBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuOSk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44NSk7IC8vIEV4Y2VlZHMgdGFyZ2V0XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=