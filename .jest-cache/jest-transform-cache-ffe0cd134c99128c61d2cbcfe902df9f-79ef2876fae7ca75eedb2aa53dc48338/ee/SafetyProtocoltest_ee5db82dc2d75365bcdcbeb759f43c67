661346e319879910d22f728aa724418a
"use strict";
/**
 * Unit Tests for SafetyProtocol
 * Perfect Codebase Campaign - Safety Protocol Testing
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('child_process');
jest.mock('fs');
const SafetyProtocol_1 = require("../SafetyProtocol");
const campaign_1 = require("../../../types/campaign");
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('SafetyProtocol', () => {
    let safetyProtocol;
    let mockSettings;
    beforeEach(() => {
        mockSettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7
        };
        safetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
        // Reset mocks
        jest.clearAllMocks();
        // Default mock implementations
        mockExecSync.mockReturnValue('');
        mockFs.existsSync.mockReturnValue(true);
        mockFs.readFileSync.mockReturnValue('valid content');
    });
    describe('Constructor', () => {
        it('should initialize with provided settings', () => {
            expect(safetyProtocol).toBeInstanceOf(SafetyProtocol_1.SafetyProtocol);
        });
        it('should initialize empty stashes map', () => {
            const stashes = safetyProtocol.stashes;
            expect(stashes.size).toBe(0);
        });
        it('should initialize empty safety events array', () => {
            const events = safetyProtocol.safetyEvents;
            expect(events).toEqual([]);
        });
    });
    describe('createStash', () => {
        beforeEach(() => {
            // Mock git commands
            mockExecSync
                .mockReturnValueOnce('') // git status validation
                .mockReturnValueOnce('') // git stash push
                .mockReturnValueOnce('stash@{0}: campaign-1-2023-01-01T00-00-00-000Z: Test stash') // git stash list
                .mockReturnValueOnce('main'); // git branch --show-current
        });
        it('should create git stash with descriptive name', async () => {
            const stashId = await safetyProtocol.createStash('Test stash', 'phase1');
            expect(stashId).toMatch(/^campaign-phase1-\d+-/);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash push -u -m'), expect.any(Object));
        });
        it('should store stash information', async () => {
            const stashId = await safetyProtocol.createStash('Test stash');
            const stashes = safetyProtocol.stashes;
            expect(stashes.has(stashId)).toBe(true);
            const stash = stashes.get(stashId);
            expect(stash.description).toContain('Test stash');
            expect(stash.ref).toBe('stash@{0}');
        });
        it('should record safety event for stash creation', async () => {
            await safetyProtocol.createStash('Test stash');
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.CHECKPOINT_CREATED);
            expect(events[0].description).toContain('Git stash created');
        });
        it('should handle git validation failure', async () => {
            // Mock git validation failure
            jest.spyOn(safetyProtocol, 'validateGitState').mockResolvedValue({
                success: false,
                errors: ['Not a git repository'],
                warnings: []
            });
            await expect(safetyProtocol.createStash('Test stash')).rejects.toThrow('Git validation failed: Not a git repository');
        });
        it('should handle git stash creation failure', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.toString().includes('git stash push')) {
                    throw new Error('Git stash failed');
                }
                return '';
            });
            await expect(safetyProtocol.createStash('Test stash')).rejects.toThrow('Failed to create git stash: Git stash failed');
        });
    });
    describe('applyStash', () => {
        let mockStash;
        beforeEach(() => {
            mockStash = {
                id: 'test-stash-1',
                description: 'Test stash description',
                timestamp: new Date(),
                branch: 'main',
                ref: 'stash@{0}'
            };
            // Add stash to internal map
            safetyProtocol.stashes.set('test-stash-1', mockStash);
            // Mock git validation
            jest.spyOn(safetyProtocol, 'validateGitState').mockResolvedValue({
                success: true,
                errors: [],
                warnings: []
            });
        });
        it('should apply stash successfully', async () => {
            await safetyProtocol.applyStash('test-stash-1');
            expect(mockExecSync).toHaveBeenCalledWith('git stash apply stash@{0}', expect.any(Object));
        });
        it('should record safety event for stash application', async () => {
            await safetyProtocol.applyStash('test-stash-1');
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.ROLLBACK_TRIGGERED);
            expect(events[0].description).toContain('Git stash applied: test-stash-1');
        });
        it('should validate git state after application when requested', async () => {
            await safetyProtocol.applyStash('test-stash-1', true);
            expect(safetyProtocol['validateGitState']).toHaveBeenCalled();
        });
        it('should handle non-existent stash', async () => {
            await expect(safetyProtocol.applyStash('non-existent')).rejects.toThrow('Stash not found: non-existent');
        });
        it('should handle git stash apply failure', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.toString().includes('git stash apply')) {
                    throw new Error('Git stash apply failed');
                }
                return '';
            });
            await expect(safetyProtocol.applyStash('test-stash-1')).rejects.toThrow('Failed to apply git stash test-stash-1: Git stash apply failed');
        });
    });
    describe('autoApplyLatestStash', () => {
        beforeEach(() => {
            // Add multiple stashes with different timestamps
            const stash1 = {
                id: 'stash-1',
                description: 'First stash',
                timestamp: new Date('2023-01-01'),
                branch: 'main',
                ref: 'stash@{1}'
            };
            const stash2 = {
                id: 'stash-2',
                description: 'Latest stash',
                timestamp: new Date('2023-01-02'),
                branch: 'main',
                ref: 'stash@{0}'
            };
            safetyProtocol.stashes.set('stash-1', stash1);
            safetyProtocol.stashes.set('stash-2', stash2);
            jest.spyOn(safetyProtocol, 'applyStash').mockResolvedValue();
        });
        it('should apply the most recent stash', async () => {
            const appliedStashId = await safetyProtocol.autoApplyLatestStash();
            expect(appliedStashId).toBe('stash-2');
            expect(safetyProtocol.applyStash).toHaveBeenCalledWith('stash-2');
        });
        it('should handle no available stashes', async () => {
            safetyProtocol.stashes.clear();
            await expect(safetyProtocol.autoApplyLatestStash()).rejects.toThrow('No stashes available for automatic rollback');
        });
    });
    describe('detectCorruption', () => {
        const mockFiles = ['file1.ts', 'file2.ts', 'file3.ts'];
        beforeEach(() => {
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue('valid content');
        });
        it('should detect no corruption in valid files', async () => {
            const report = await safetyProtocol.detectCorruption(mockFiles);
            expect(report.detectedFiles).toEqual([]);
            expect(report.corruptionPatterns).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
            expect(report.recommendedAction).toBe(campaign_1.RecoveryAction.CONTINUE);
        });
        it('should detect git merge conflict markers', async () => {
            mockFs.readFileSync.mockReturnValue(`
        function test() {
        <<<<<<< HEAD
          return 'version 1';
        =======
          return 'version 2';
        >>>>>>> branch
        }
      `);
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.CRITICAL);
            expect(report.recommendedAction).toBe(campaign_1.RecoveryAction.EMERGENCY_RESTORE);
        });
        it('should detect corrupted import statements', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import @/types from './types';
        import @/services from './services';
      `);
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.description.includes('Corrupted type import'))).toBe(true);
        });
        it('should detect syntax corruption', async () => {
            mockFs.readFileSync.mockReturnValue(`
        function test() {
          return 'missing closing brace';
      `);
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should handle file read errors', async () => {
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('Permission denied');
            });
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.pattern === 'FILE_READ_ERROR')).toBe(true);
        });
        it('should skip non-existent files', async () => {
            mockFs.existsSync.mockReturnValue(false);
            const report = await safetyProtocol.detectCorruption(['non-existent.ts']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
        it('should record safety event when corruption is detected', async () => {
            mockFs.readFileSync.mockReturnValue('<<<<<<< HEAD\nconflict\n>>>>>>> branch');
            await safetyProtocol.detectCorruption(['file1.ts']);
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.CORRUPTION_DETECTED);
        });
    });
    describe('detectImportExportCorruption', () => {
        beforeEach(() => {
            mockFs.existsSync.mockReturnValue(true);
        });
        it('should detect empty import statements', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import { } from './module';
        export { };
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.corruptionPatterns.some(p => p.description.includes('Empty import'))).toBe(true);
            expect(report.corruptionPatterns.some(p => p.description.includes('Empty export'))).toBe(true);
        });
        it('should detect import from undefined module', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import something from "undefined";
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.description.includes('Import from undefined'))).toBe(true);
        });
        it('should detect duplicate from clauses', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import something from './module' from './other';
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should detect double commas in destructuring', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import { a,, b } from './module';
        export { x,, y };
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should skip non-JavaScript/TypeScript files', async () => {
            const report = await safetyProtocol.detectImportExportCorruption(['file1.txt', 'file2.md']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
    });
    describe('validateSyntaxWithTypeScript', () => {
        it('should validate syntax using TypeScript compiler', async () => {
            mockExecSync.mockReturnValue('No errors found');
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.ts', 'file2.ts']);
            expect(mockExecSync).toHaveBeenCalledWith('yarn tsc --noEmit --skipLibCheck 2>&1', expect.any(Object));
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
        it('should detect TypeScript syntax errors', async () => {
            mockExecSync.mockReturnValue(`
        file1.ts(10,5): error TS1005: Unexpected token 'function'
        file2.ts(15,10): error TS1109: Expression expected
      `);
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.ts', 'file2.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.detectedFiles).toContain('file2.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should handle TypeScript compilation errors', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('TypeScript compilation failed');
                error.stdout = 'Unexpected token at line 5';
                throw error;
            });
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.ts']);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.pattern === 'TYPESCRIPT_COMPILATION_ERROR')).toBe(true);
        });
        it('should skip non-TypeScript files', async () => {
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.js', 'file2.txt']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
    });
    describe('emergencyRollback', () => {
        beforeEach(() => {
            const stash = {
                id: 'emergency-stash',
                description: 'Emergency stash',
                timestamp: new Date(),
                branch: 'main',
                ref: 'stash@{0}'
            };
            safetyProtocol.stashes.set('emergency-stash', stash);
            jest.spyOn(safetyProtocol, 'applyStash').mockResolvedValue();
        });
        it('should apply the most recent stash for emergency rollback', async () => {
            await safetyProtocol.emergencyRollback();
            expect(safetyProtocol.applyStash).toHaveBeenCalledWith('emergency-stash');
        });
        it('should record safety event for emergency rollback', async () => {
            await safetyProtocol.emergencyRollback();
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.EMERGENCY_RECOVERY);
            expect(events[0].description).toContain('Emergency rollback completed');
        });
        it('should handle no available stashes', async () => {
            safetyProtocol.stashes.clear();
            await expect(safetyProtocol.emergencyRollback()).rejects.toThrow('No stashes available for emergency rollback');
        });
        it('should handle rollback failure', async () => {
            jest.spyOn(safetyProtocol, 'applyStash').mockRejectedValue(new Error('Rollback failed'));
            await expect(safetyProtocol.emergencyRollback()).rejects.toThrow('Emergency rollback failed: Rollback failed');
            const events = safetyProtocol.safetyEvents;
            expect(events.some(e => e.type === campaign_1.SafetyEventType.EMERGENCY_RECOVERY && e.severity === campaign_1.SafetyEventSeverity.CRITICAL)).toBe(true);
        });
    });
    describe('validateGitState', () => {
        it('should validate successful git state', async () => {
            mockFs.existsSync.mockReturnValue(true);
            mockExecSync.mockReturnValue(''); // No uncommitted changes
            const result = await safetyProtocol.validateGitState();
            expect(result.success).toBe(true);
            expect(result.errors).toEqual([]);
        });
        it('should detect non-git repository', async () => {
            mockFs.existsSync.mockReturnValue(false);
            const result = await safetyProtocol.validateGitState();
            expect(result.success).toBe(false);
            expect(result.errors).toContain('Not a git repository');
        });
        it('should warn about uncommitted changes when automatic rollback is disabled', async () => {
            mockFs.existsSync.mockReturnValue(true);
            mockExecSync.mockReturnValue('M file1.ts\nA file2.ts'); // Uncommitted changes
            const settingsWithoutAutoRollback = { ...mockSettings, automaticRollbackEnabled: false };
            const protocol = new SafetyProtocol_1.SafetyProtocol(settingsWithoutAutoRollback);
            const result = await protocol.validateGitState();
            expect(result.success).toBe(true);
            expect(result.warnings).toContain('Uncommitted changes detected - consider creating a stash');
        });
        it('should handle git command failure', async () => {
            mockFs.existsSync.mockReturnValue(true);
            mockExecSync.mockImplementation(() => {
                throw new Error('Git command failed');
            });
            const result = await safetyProtocol.validateGitState();
            expect(result.success).toBe(false);
            expect(result.errors).toContain('Git validation failed: Git command failed');
        });
    });
    describe('cleanupOldStashes', () => {
        beforeEach(() => {
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            const recentDate = new Date();
            recentDate.setDate(recentDate.getDate() - 3); // 3 days old
            const oldStash = {
                id: 'old-stash',
                description: 'Old stash',
                timestamp: oldDate,
                branch: 'main',
                ref: 'stash@{1}'
            };
            const recentStash = {
                id: 'recent-stash',
                description: 'Recent stash',
                timestamp: recentDate,
                branch: 'main',
                ref: 'stash@{0}'
            };
            safetyProtocol.stashes.set('old-stash', oldStash);
            safetyProtocol.stashes.set('recent-stash', recentStash);
        });
        it('should cleanup stashes older than retention period', async () => {
            await safetyProtocol.cleanupOldStashes();
            const stashes = safetyProtocol.stashes;
            expect(stashes.has('old-stash')).toBe(false);
            expect(stashes.has('recent-stash')).toBe(true);
        });
        it('should attempt to drop git stashes', async () => {
            await safetyProtocol.cleanupOldStashes();
            expect(mockExecSync).toHaveBeenCalledWith('git stash drop stash@{1}', expect.any(Object));
        });
        it('should handle git stash drop failures gracefully', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.toString().includes('git stash drop')) {
                    throw new Error('Stash not found');
                }
                return '';
            });
            // Should not throw error
            await expect(safetyProtocol.cleanupOldStashes()).resolves.not.toThrow();
            // Should still remove from tracking
            const stashes = safetyProtocol.stashes;
            expect(stashes.has('old-stash')).toBe(false);
        });
        it('should record safety event for cleanup', async () => {
            await safetyProtocol.cleanupOldStashes();
            const events = safetyProtocol.safetyEvents;
            expect(events.some(e => e.description.includes('Cleaned up 1 old stashes'))).toBe(true);
        });
    });
    describe('getStashStatistics', () => {
        beforeEach(() => {
            const stash1 = {
                id: 'campaign-phase1-1-timestamp',
                description: 'Phase 1 stash',
                timestamp: new Date('2023-01-01'),
                branch: 'main'
            };
            const stash2 = {
                id: 'campaign-phase2-2-timestamp',
                description: 'Phase 2 stash',
                timestamp: new Date('2023-01-02'),
                branch: 'main'
            };
            const stash3 = {
                id: 'campaign-phase1-3-timestamp',
                description: 'Another Phase 1 stash',
                timestamp: new Date('2023-01-03'),
                branch: 'main'
            };
            safetyProtocol.stashes.set('stash1', stash1);
            safetyProtocol.stashes.set('stash2', stash2);
            safetyProtocol.stashes.set('stash3', stash3);
        });
        it('should return comprehensive stash statistics', () => {
            const stats = safetyProtocol.getStashStatistics();
            expect(stats.total).toBe(3);
            expect(stats.byPhase.phase1).toBe(2);
            expect(stats.byPhase.phase2).toBe(1);
            expect(stats.oldestStash).toEqual(new Date('2023-01-01'));
            expect(stats.newestStash).toEqual(new Date('2023-01-03'));
        });
        it('should handle empty stashes', () => {
            safetyProtocol.stashes.clear();
            const stats = safetyProtocol.getStashStatistics();
            expect(stats.total).toBe(0);
            expect(stats.byPhase).toEqual({});
            expect(stats.oldestStash).toBeUndefined();
            expect(stats.newestStash).toBeUndefined();
        });
    });
    describe('Real-time Monitoring', () => {
        beforeEach(() => {
            jest.useFakeTimers();
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: [],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.LOW,
                recommendedAction: campaign_1.RecoveryAction.CONTINUE
            });
        });
        afterEach(() => {
            jest.useRealTimers();
        });
        it('should start real-time monitoring', async () => {
            const files = ['file1.ts', 'file2.ts'];
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            expect(safetyProtocol.detectCorruption).toHaveBeenCalledWith(files);
        });
        it('should trigger emergency rollback on critical corruption', async () => {
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: ['file1.ts'],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.CRITICAL,
                recommendedAction: campaign_1.RecoveryAction.EMERGENCY_RESTORE
            });
            jest.spyOn(safetyProtocol, 'emergencyRollback').mockResolvedValue();
            const files = ['file1.ts'];
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // Wait for async operations
            await new Promise(resolve => setTimeout(resolve, 0));
            expect(safetyProtocol.emergencyRollback).toHaveBeenCalled();
        });
        it('should stop real-time monitoring', () => {
            const files = ['file1.ts'];
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            safetyProtocol.stopRealTimeMonitoring();
            // Fast-forward time - monitoring should not trigger
            jest.advanceTimersByTime(1000);
            expect(safetyProtocol.detectCorruption).not.toHaveBeenCalled();
        });
    });
    describe('Safety Event Management', () => {
        it('should limit safety events to prevent memory issues', () => {
            // Add many safety events
            for (let i = 0; i < 1100; i++) {
                safetyProtocol.addSafetyEvent({
                    type: campaign_1.SafetyEventType.CHECKPOINT_CREATED,
                    timestamp: new Date(),
                    description: `Event ${i}`,
                    severity: campaign_1.SafetyEventSeverity.INFO,
                    action: 'TEST'
                });
            }
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(500); // Should be trimmed to 500
        });
        it('should preserve most recent events when trimming', () => {
            // Add many safety events
            for (let i = 0; i < 1100; i++) {
                safetyProtocol.addSafetyEvent({
                    type: campaign_1.SafetyEventType.CHECKPOINT_CREATED,
                    timestamp: new Date(),
                    description: `Event ${i}`,
                    severity: campaign_1.SafetyEventSeverity.INFO,
                    action: 'TEST'
                });
            }
            const events = safetyProtocol.safetyEvents;
            expect(events[events.length - 1].description).toBe('Event 1099');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9fX3Rlc3RzX18vU2FmZXR5UHJvdG9jb2wudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JILG9CQUFvQjtBQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFoQmhCLHNEQUFtRDtBQUNuRCxzREFTaUM7QUFDakMsaURBQXlDO0FBQ3pDLHVDQUF5QjtBQU16QixNQUFNLFlBQVksR0FBRyx3QkFBZ0QsQ0FBQztBQUN0RSxNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBRTVDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUU7SUFDOUIsSUFBSSxjQUE4QixDQUFDO0lBQ25DLElBQUksWUFBNEIsQ0FBQztJQUVqQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsWUFBWSxHQUFHO1lBQ2IsZ0JBQWdCLEVBQUUsRUFBRTtZQUNwQix3QkFBd0IsRUFBRSxDQUFDO1lBQzNCLHVCQUF1QixFQUFFLEVBQUU7WUFDM0IsMEJBQTBCLEVBQUUsSUFBSTtZQUNoQyx3QkFBd0IsRUFBRSxJQUFJO1lBQzlCLGtCQUFrQixFQUFFLENBQUM7U0FDdEIsQ0FBQztRQUVGLGNBQWMsR0FBRyxJQUFJLCtCQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFbEQsY0FBYztRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVyQiwrQkFBK0I7UUFDL0IsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN2RCxDQUFDLENBQUMsQ0FB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QUFFLEVBQUU7Z0JBQzVCLGNBQXNCLENBQUMsY0FBYyxDQUFDO29CQUNyQyxJQUFJLEVBQUUsMEJBQWUsQ0FBQyxrQkFBa0I7b0JBQ3hDLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtvQkFDckIsV0FBVyxFQUFFLFNBQVMsQ0FBQyxFQUFFO29CQUN6QixRQUFRLEVBQUUsOEJBQW1CLENBQUMsSUFBSTtvQkFDbEMsTUFBTSxFQUFFLE1BQU07aUJBQ2YsQ0FBQyxDQUFDO2FBQ0o7WUFFRCxNQUFNLE1BQU0sR0FBSSxjQUFzQixDQUFDLFlBQVksQ0FBQztZQUNwRCxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ25FLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvR3JlZ0Nhc3Ryby9EZXNrdG9wL1doYXRUb0VhdE5leHQvc3JjL3NlcnZpY2VzL2NhbXBhaWduL19fdGVzdHNfXy9TYWZldHlQcm90b2NvbC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW5pdCBUZXN0cyBmb3IgU2FmZXR5UHJvdG9jb2xcbiAqIFBlcmZlY3QgQ29kZWJhc2UgQ2FtcGFpZ24gLSBTYWZldHkgUHJvdG9jb2wgVGVzdGluZ1xuICovXG5cbmltcG9ydCB7IFNhZmV0eVByb3RvY29sIH0gZnJvbSAnLi4vU2FmZXR5UHJvdG9jb2wnO1xuaW1wb3J0IHtcbiAgU2FmZXR5U2V0dGluZ3MsXG4gIENvcnJ1cHRpb25SZXBvcnQsXG4gIENvcnJ1cHRpb25TZXZlcml0eSxcbiAgUmVjb3ZlcnlBY3Rpb24sXG4gIEdpdFN0YXNoLFxuICBTYWZldHlFdmVudCxcbiAgU2FmZXR5RXZlbnRUeXBlLFxuICBTYWZldHlFdmVudFNldmVyaXR5XG59IGZyb20gJy4uLy4uLy4uL3R5cGVzL2NhbXBhaWduJztcbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ2NoaWxkX3Byb2Nlc3MnKTtcbmplc3QubW9jaygnZnMnKTtcblxuY29uc3QgbW9ja0V4ZWNTeW5jID0gZXhlY1N5bmMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZXhlY1N5bmM+O1xuY29uc3QgbW9ja0ZzID0gZnMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzPjtcblxuZGVzY3JpYmUoJ1NhZmV0eVByb3RvY29sJywgKCkgPT4ge1xuICBsZXQgc2FmZXR5UHJvdG9jb2w6IFNhZmV0eVByb3RvY29sO1xuICBsZXQgbW9ja1NldHRpbmdzOiBTYWZldHlTZXR0aW5ncztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrU2V0dGluZ3MgPSB7XG4gICAgICBtYXhGaWxlc1BlckJhdGNoOiAyNSxcbiAgICAgIGJ1aWxkVmFsaWRhdGlvbkZyZXF1ZW5jeTogNSxcbiAgICAgIHRlc3RWYWxpZGF0aW9uRnJlcXVlbmN5OiAxMCxcbiAgICAgIGNvcnJ1cHRpb25EZXRlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgYXV0b21hdGljUm9sbGJhY2tFbmFibGVkOiB0cnVlLFxuICAgICAgc3Rhc2hSZXRlbnRpb25EYXlzOiA3XG4gICAgfTtcblxuICAgIHNhZmV0eVByb3RvY29sID0gbmV3IFNhZmV0eVByb3RvY29sKG1vY2tTZXR0aW5ncyk7XG5cbiAgICAvLyBSZXNldCBtb2Nrc1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIERlZmF1bHQgbW9jayBpbXBsZW1lbnRhdGlvbnNcbiAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcbiAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3ZhbGlkIGNvbnRlbnQnKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbnN0cnVjdG9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIHByb3ZpZGVkIHNldHRpbmdzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHNhZmV0eVByb3RvY29sKS50b0JlSW5zdGFuY2VPZihTYWZldHlQcm90b2NvbCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgZW1wdHkgc3Rhc2hlcyBtYXAnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFzaGVzID0gKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcztcbiAgICAgIGV4cGVjdChzdGFzaGVzLnNpemUpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgZW1wdHkgc2FmZXR5IGV2ZW50cyBhcnJheScsICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnNhZmV0eUV2ZW50cztcbiAgICAgIGV4cGVjdChldmVudHMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY3JlYXRlU3Rhc2gnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAvLyBNb2NrIGdpdCBjb21tYW5kc1xuICAgICAgbW9ja0V4ZWNTeW5jXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBnaXQgc3RhdHVzIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGdpdCBzdGFzaCBwdXNoXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCdzdGFzaEB7MH06IGNhbXBhaWduLTEtMjAyMy0wMS0wMVQwMC0wMC0wMC0wMDBaOiBUZXN0IHN0YXNoJykgLy8gZ2l0IHN0YXNoIGxpc3RcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJ21haW4nKTsgLy8gZ2l0IGJyYW5jaCAtLXNob3ctY3VycmVudFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgZ2l0IHN0YXNoIHdpdGggZGVzY3JpcHRpdmUgbmFtZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoSWQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnVGVzdCBzdGFzaCcsICdwaGFzZTEnKTtcblxuICAgICAgZXhwZWN0KHN0YXNoSWQpLnRvTWF0Y2goL15jYW1wYWlnbi1waGFzZTEtXFxkKy0vKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnZ2l0IHN0YXNoIHB1c2ggLXUgLW0nKSxcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdG9yZSBzdGFzaCBpbmZvcm1hdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoSWQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnVGVzdCBzdGFzaCcpO1xuXG4gICAgICBjb25zdCBzdGFzaGVzID0gKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcztcbiAgICAgIGV4cGVjdChzdGFzaGVzLmhhcyhzdGFzaElkKSkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3Rhc2ggPSBzdGFzaGVzLmdldChzdGFzaElkKTtcbiAgICAgIGV4cGVjdChzdGFzaC5kZXNjcmlwdGlvbikudG9Db250YWluKCdUZXN0IHN0YXNoJyk7XG4gICAgICBleHBlY3Qoc3Rhc2gucmVmKS50b0JlKCdzdGFzaEB7MH0nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIHNhZmV0eSBldmVudCBmb3Igc3Rhc2ggY3JlYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnVGVzdCBzdGFzaCcpO1xuXG4gICAgICBjb25zdCBldmVudHMgPSAoc2FmZXR5UHJvdG9jb2wgYXMgYW55KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChldmVudHNbMF0udHlwZSkudG9CZShTYWZldHlFdmVudFR5cGUuQ0hFQ0tQT0lOVF9DUkVBVEVEKTtcbiAgICAgIGV4cGVjdChldmVudHNbMF0uZGVzY3JpcHRpb24pLnRvQ29udGFpbignR2l0IHN0YXNoIGNyZWF0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGdpdCB2YWxpZGF0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGdpdCB2YWxpZGF0aW9uIGZhaWx1cmVcbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wgYXMgYW55LCAndmFsaWRhdGVHaXRTdGF0ZScpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yczogWydOb3QgYSBnaXQgcmVwb3NpdG9yeSddLFxuICAgICAgICB3YXJuaW5nczogW11cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnR2l0IHZhbGlkYXRpb24gZmFpbGVkOiBOb3QgYSBnaXQgcmVwb3NpdG9yeSdcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnaXQgc3Rhc2ggY3JlYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQudG9TdHJpbmcoKS5pbmNsdWRlcygnZ2l0IHN0YXNoIHB1c2gnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2l0IHN0YXNoIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBnaXQgc3Rhc2g6IEdpdCBzdGFzaCBmYWlsZWQnXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYXBwbHlTdGFzaCcsICgpID0+IHtcbiAgICBsZXQgbW9ja1N0YXNoOiBHaXRTdGFzaDtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1N0YXNoID0ge1xuICAgICAgICBpZDogJ3Rlc3Qtc3Rhc2gtMScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBzdGFzaCBkZXNjcmlwdGlvbicsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICAgIHJlZjogJ3N0YXNoQHswfSdcbiAgICAgIH07XG5cbiAgICAgIC8vIEFkZCBzdGFzaCB0byBpbnRlcm5hbCBtYXBcbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnN0YXNoZXMuc2V0KCd0ZXN0LXN0YXNoLTEnLCBtb2NrU3Rhc2gpO1xuXG4gICAgICAvLyBNb2NrIGdpdCB2YWxpZGF0aW9uXG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sIGFzIGFueSwgJ3ZhbGlkYXRlR2l0U3RhdGUnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFwcGx5IHN0YXNoIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2goJ3Rlc3Qtc3Rhc2gtMScpO1xuXG4gICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ2dpdCBzdGFzaCBhcHBseSBzdGFzaEB7MH0nLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlY29yZCBzYWZldHkgZXZlbnQgZm9yIHN0YXNoIGFwcGxpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCgndGVzdC1zdGFzaC0xJyk7XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnNhZmV0eUV2ZW50cztcbiAgICAgIGV4cGVjdChldmVudHMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGV2ZW50c1swXS50eXBlKS50b0JlKFNhZmV0eUV2ZW50VHlwZS5ST0xMQkFDS19UUklHR0VSRUQpO1xuICAgICAgZXhwZWN0KGV2ZW50c1swXS5kZXNjcmlwdGlvbikudG9Db250YWluKCdHaXQgc3Rhc2ggYXBwbGllZDogdGVzdC1zdGFzaC0xJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGdpdCBzdGF0ZSBhZnRlciBhcHBsaWNhdGlvbiB3aGVuIHJlcXVlc3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2goJ3Rlc3Qtc3Rhc2gtMScsIHRydWUpO1xuXG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2xbJ3ZhbGlkYXRlR2l0U3RhdGUnXSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9uLWV4aXN0ZW50IHN0YXNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2goJ25vbi1leGlzdGVudCcpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICdTdGFzaCBub3QgZm91bmQ6IG5vbi1leGlzdGVudCdcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnaXQgc3Rhc2ggYXBwbHkgZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQudG9TdHJpbmcoKS5pbmNsdWRlcygnZ2l0IHN0YXNoIGFwcGx5JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdCBzdGFzaCBhcHBseSBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2goJ3Rlc3Qtc3Rhc2gtMScpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICdGYWlsZWQgdG8gYXBwbHkgZ2l0IHN0YXNoIHRlc3Qtc3Rhc2gtMTogR2l0IHN0YXNoIGFwcGx5IGZhaWxlZCdcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhdXRvQXBwbHlMYXRlc3RTdGFzaCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIC8vIEFkZCBtdWx0aXBsZSBzdGFzaGVzIHdpdGggZGlmZmVyZW50IHRpbWVzdGFtcHNcbiAgICAgIGNvbnN0IHN0YXNoMSA9IHtcbiAgICAgICAgaWQ6ICdzdGFzaC0xJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdGaXJzdCBzdGFzaCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjMtMDEtMDEnKSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICAgIHJlZjogJ3N0YXNoQHsxfSdcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGFzaDIgPSB7XG4gICAgICAgIGlkOiAnc3Rhc2gtMicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnTGF0ZXN0IHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyMy0wMS0wMicpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezB9J1xuICAgICAgfTtcblxuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ3N0YXNoLTEnLCBzdGFzaDEpO1xuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ3N0YXNoLTInLCBzdGFzaDIpO1xuXG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnYXBwbHlTdGFzaCcpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFwcGx5IHRoZSBtb3N0IHJlY2VudCBzdGFzaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFwcGxpZWRTdGFzaElkID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXV0b0FwcGx5TGF0ZXN0U3Rhc2goKTtcblxuICAgICAgZXhwZWN0KGFwcGxpZWRTdGFzaElkKS50b0JlKCdzdGFzaC0yJyk7XG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N0YXNoLTInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5vIGF2YWlsYWJsZSBzdGFzaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5jbGVhcigpO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuYXV0b0FwcGx5TGF0ZXN0U3Rhc2goKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnTm8gc3Rhc2hlcyBhdmFpbGFibGUgZm9yIGF1dG9tYXRpYyByb2xsYmFjaydcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdkZXRlY3RDb3JydXB0aW9uJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tGaWxlcyA9IFsnZmlsZTEudHMnLCAnZmlsZTIudHMnLCAnZmlsZTMudHMnXTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3ZhbGlkIGNvbnRlbnQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IG5vIGNvcnJ1cHRpb24gaW4gdmFsaWQgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKG1vY2tGaWxlcyk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5yZWNvbW1lbmRlZEFjdGlvbikudG9CZShSZWNvdmVyeUFjdGlvbi5DT05USU5VRSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBnaXQgbWVyZ2UgY29uZmxpY3QgbWFya2VycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgICAgPDw8PDw8PCBIRUFEXG4gICAgICAgICAgcmV0dXJuICd2ZXJzaW9uIDEnO1xuICAgICAgICA9PT09PT09XG4gICAgICAgICAgcmV0dXJuICd2ZXJzaW9uIDInO1xuICAgICAgICA+Pj4+Pj4+IGJyYW5jaFxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ2ZpbGUxLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbignZmlsZTEudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMKTtcbiAgICAgIGV4cGVjdChyZXBvcnQucmVjb21tZW5kZWRBY3Rpb24pLnRvQmUoUmVjb3ZlcnlBY3Rpb24uRU1FUkdFTkNZX1JFU1RPUkUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgY29ycnVwdGVkIGltcG9ydCBzdGF0ZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuICAgICAgICBpbXBvcnQgQC90eXBlcyBmcm9tICcuL3R5cGVzJztcbiAgICAgICAgaW1wb3J0IEAvc2VydmljZXMgZnJvbSAnLi9zZXJ2aWNlcyc7XG4gICAgICBgKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ2ZpbGUxLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbignZmlsZTEudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkhJR0gpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0NvcnJ1cHRlZCB0eXBlIGltcG9ydCcpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IHN5bnRheCBjb3JydXB0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuICAgICAgICBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgICAgIHJldHVybiAnbWlzc2luZyBjbG9zaW5nIGJyYWNlJztcbiAgICAgIGApO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsnZmlsZTEudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBmaWxlIHJlYWQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Blcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ2ZpbGUxLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbignZmlsZTEudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkhJR0gpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAucGF0dGVybiA9PT0gJ0ZJTEVfUkVBRF9FUlJPUicpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBza2lwIG5vbi1leGlzdGVudCBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWydub24tZXhpc3RlbnQudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWNvcmQgc2FmZXR5IGV2ZW50IHdoZW4gY29ycnVwdGlvbiBpcyBkZXRlY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCc8PDw8PDw8IEhFQURcXG5jb25mbGljdFxcbj4+Pj4+Pj4gYnJhbmNoJyk7XG5cbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc2FmZXR5RXZlbnRzO1xuICAgICAgZXhwZWN0KGV2ZW50cy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoZXZlbnRzWzBdLnR5cGUpLnRvQmUoU2FmZXR5RXZlbnRUeXBlLkNPUlJVUFRJT05fREVURUNURUQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGV0ZWN0SW1wb3J0RXhwb3J0Q29ycnVwdGlvbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGVtcHR5IGltcG9ydCBzdGF0ZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuICAgICAgICBpbXBvcnQgeyB9IGZyb20gJy4vbW9kdWxlJztcbiAgICAgICAgZXhwb3J0IHsgfTtcbiAgICAgIGApO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RJbXBvcnRFeHBvcnRDb3JydXB0aW9uKFsnZmlsZTEudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0VtcHR5IGltcG9ydCcpKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdFbXB0eSBleHBvcnQnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBpbXBvcnQgZnJvbSB1bmRlZmluZWQgbW9kdWxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuICAgICAgICBpbXBvcnQgc29tZXRoaW5nIGZyb20gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGApO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RJbXBvcnRFeHBvcnRDb3JydXB0aW9uKFsnZmlsZTEudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucy5zb21lKHAgPT4gcC5kZXNjcmlwdGlvbi5pbmNsdWRlcygnSW1wb3J0IGZyb20gdW5kZWZpbmVkJykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgZHVwbGljYXRlIGZyb20gY2xhdXNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgaW1wb3J0IHNvbWV0aGluZyBmcm9tICcuL21vZHVsZScgZnJvbSAnLi9vdGhlcic7XG4gICAgICBgKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0SW1wb3J0RXhwb3J0Q29ycnVwdGlvbihbJ2ZpbGUxLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbignZmlsZTEudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkhJR0gpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgZG91YmxlIGNvbW1hcyBpbiBkZXN0cnVjdHVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuICAgICAgICBpbXBvcnQgeyBhLCwgYiB9IGZyb20gJy4vbW9kdWxlJztcbiAgICAgICAgZXhwb3J0IHsgeCwsIHkgfTtcbiAgICAgIGApO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RJbXBvcnRFeHBvcnRDb3JydXB0aW9uKFsnZmlsZTEudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgbm9uLUphdmFTY3JpcHQvVHlwZVNjcmlwdCBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWydmaWxlMS50eHQnLCAnZmlsZTIubWQnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN5bnRheCB1c2luZyBUeXBlU2NyaXB0IGNvbXBpbGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnTm8gZXJyb3JzIGZvdW5kJyk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWydmaWxlMS50cycsICdmaWxlMi50cyddKTtcblxuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICd5YXJuIHRzYyAtLW5vRW1pdCAtLXNraXBMaWJDaGVjayAyPiYxJyxcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBUeXBlU2NyaXB0IHN5bnRheCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgZmlsZTEudHMoMTAsNSk6IGVycm9yIFRTMTAwNTogVW5leHBlY3RlZCB0b2tlbiAnZnVuY3Rpb24nXG4gICAgICAgIGZpbGUyLnRzKDE1LDEwKTogZXJyb3IgVFMxMTA5OiBFeHByZXNzaW9uIGV4cGVjdGVkXG4gICAgICBgKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdChbJ2ZpbGUxLnRzJywgJ2ZpbGUyLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbignZmlsZTEudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMi50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHlwZVNjcmlwdCBjb21waWxhdGlvbiBmYWlsZWQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0ZG91dCA9ICdVbmV4cGVjdGVkIHRva2VuIGF0IGxpbmUgNSc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucy5zb21lKHAgPT4gcC5wYXR0ZXJuID09PSAnVFlQRVNDUklQVF9DT01QSUxBVElPTl9FUlJPUicpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBza2lwIG5vbi1UeXBlU2NyaXB0IGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdChbJ2ZpbGUxLmpzJywgJ2ZpbGUyLnR4dCddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlbWVyZ2VuY3lSb2xsYmFjaycsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoID0ge1xuICAgICAgICBpZDogJ2VtZXJnZW5jeS1zdGFzaCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRW1lcmdlbmN5IHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezB9J1xuICAgICAgfTtcblxuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ2VtZXJnZW5jeS1zdGFzaCcsIHN0YXNoKTtcbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdhcHBseVN0YXNoJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgdGhlIG1vc3QgcmVjZW50IHN0YXNoIGZvciBlbWVyZ2VuY3kgcm9sbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5lbWVyZ2VuY3lSb2xsYmFjaygpO1xuXG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2VtZXJnZW5jeS1zdGFzaCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWNvcmQgc2FmZXR5IGV2ZW50IGZvciBlbWVyZ2VuY3kgcm9sbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5lbWVyZ2VuY3lSb2xsYmFjaygpO1xuXG4gICAgICBjb25zdCBldmVudHMgPSAoc2FmZXR5UHJvdG9jb2wgYXMgYW55KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChldmVudHNbMF0udHlwZSkudG9CZShTYWZldHlFdmVudFR5cGUuRU1FUkdFTkNZX1JFQ09WRVJZKTtcbiAgICAgIGV4cGVjdChldmVudHNbMF0uZGVzY3JpcHRpb24pLnRvQ29udGFpbignRW1lcmdlbmN5IHJvbGxiYWNrIGNvbXBsZXRlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm8gYXZhaWxhYmxlIHN0YXNoZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoc2FmZXR5UHJvdG9jb2wgYXMgYW55KS5zdGFzaGVzLmNsZWFyKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzYWZldHlQcm90b2NvbC5lbWVyZ2VuY3lSb2xsYmFjaygpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICdObyBzdGFzaGVzIGF2YWlsYWJsZSBmb3IgZW1lcmdlbmN5IHJvbGxiYWNrJ1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJvbGxiYWNrIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnYXBwbHlTdGFzaCcpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUm9sbGJhY2sgZmFpbGVkJykpO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuZW1lcmdlbmN5Um9sbGJhY2soKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnRW1lcmdlbmN5IHJvbGxiYWNrIGZhaWxlZDogUm9sbGJhY2sgZmFpbGVkJ1xuICAgICAgKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc2FmZXR5RXZlbnRzO1xuICAgICAgZXhwZWN0KGV2ZW50cy5zb21lKGUgPT4gZS50eXBlID09PSBTYWZldHlFdmVudFR5cGUuRU1FUkdFTkNZX1JFQ09WRVJZICYmIGUuc2V2ZXJpdHkgPT09IFNhZmV0eUV2ZW50U2V2ZXJpdHkuQ1JJVElDQUwpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVHaXRTdGF0ZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN1Y2Nlc3NmdWwgZ2l0IHN0YXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7IC8vIE5vIHVuY29tbWl0dGVkIGNoYW5nZXNcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBub24tZ2l0IHJlcG9zaXRvcnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC52YWxpZGF0ZUdpdFN0YXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9Db250YWluKCdOb3QgYSBnaXQgcmVwb3NpdG9yeScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB3YXJuIGFib3V0IHVuY29tbWl0dGVkIGNoYW5nZXMgd2hlbiBhdXRvbWF0aWMgcm9sbGJhY2sgaXMgZGlzYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCdNIGZpbGUxLnRzXFxuQSBmaWxlMi50cycpOyAvLyBVbmNvbW1pdHRlZCBjaGFuZ2VzXG4gICAgICBcbiAgICAgIGNvbnN0IHNldHRpbmdzV2l0aG91dEF1dG9Sb2xsYmFjayA9IHsgLi4ubW9ja1NldHRpbmdzLCBhdXRvbWF0aWNSb2xsYmFja0VuYWJsZWQ6IGZhbHNlIH07XG4gICAgICBjb25zdCBwcm90b2NvbCA9IG5ldyBTYWZldHlQcm90b2NvbChzZXR0aW5nc1dpdGhvdXRBdXRvUm9sbGJhY2spO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm90b2NvbC52YWxpZGF0ZUdpdFN0YXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQud2FybmluZ3MpLnRvQ29udGFpbignVW5jb21taXR0ZWQgY2hhbmdlcyBkZXRlY3RlZCAtIGNvbnNpZGVyIGNyZWF0aW5nIGEgc3Rhc2gnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGdpdCBjb21tYW5kIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXQgY29tbWFuZCBmYWlsZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC52YWxpZGF0ZUdpdFN0YXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9Db250YWluKCdHaXQgdmFsaWRhdGlvbiBmYWlsZWQ6IEdpdCBjb21tYW5kIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2xlYW51cE9sZFN0YXNoZXMnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBjb25zdCBvbGREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIG9sZERhdGUuc2V0RGF0ZShvbGREYXRlLmdldERhdGUoKSAtIDEwKTsgLy8gMTAgZGF5cyBvbGRcblxuICAgICAgY29uc3QgcmVjZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICByZWNlbnREYXRlLnNldERhdGUocmVjZW50RGF0ZS5nZXREYXRlKCkgLSAzKTsgLy8gMyBkYXlzIG9sZFxuXG4gICAgICBjb25zdCBvbGRTdGFzaCA9IHtcbiAgICAgICAgaWQ6ICdvbGQtc3Rhc2gnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09sZCBzdGFzaCcsXG4gICAgICAgIHRpbWVzdGFtcDogb2xkRGF0ZSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICAgIHJlZjogJ3N0YXNoQHsxfSdcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlY2VudFN0YXNoID0ge1xuICAgICAgICBpZDogJ3JlY2VudC1zdGFzaCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmVjZW50IHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiByZWNlbnREYXRlLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezB9J1xuICAgICAgfTtcblxuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ29sZC1zdGFzaCcsIG9sZFN0YXNoKTtcbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnN0YXNoZXMuc2V0KCdyZWNlbnQtc3Rhc2gnLCByZWNlbnRTdGFzaCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFudXAgc3Rhc2hlcyBvbGRlciB0aGFuIHJldGVudGlvbiBwZXJpb2QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jbGVhbnVwT2xkU3Rhc2hlcygpO1xuXG4gICAgICBjb25zdCBzdGFzaGVzID0gKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcztcbiAgICAgIGV4cGVjdChzdGFzaGVzLmhhcygnb2xkLXN0YXNoJykpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHN0YXNoZXMuaGFzKCdyZWNlbnQtc3Rhc2gnKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXR0ZW1wdCB0byBkcm9wIGdpdCBzdGFzaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY2xlYW51cE9sZFN0YXNoZXMoKTtcblxuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdnaXQgc3Rhc2ggZHJvcCBzdGFzaEB7MX0nLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnaXQgc3Rhc2ggZHJvcCBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC50b1N0cmluZygpLmluY2x1ZGVzKCdnaXQgc3Rhc2ggZHJvcCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFzaCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBlcnJvclxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCkpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XG5cbiAgICAgIC8vIFNob3VsZCBzdGlsbCByZW1vdmUgZnJvbSB0cmFja2luZ1xuICAgICAgY29uc3Qgc3Rhc2hlcyA9IChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnN0YXNoZXM7XG4gICAgICBleHBlY3Qoc3Rhc2hlcy5oYXMoJ29sZC1zdGFzaCcpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIHNhZmV0eSBldmVudCBmb3IgY2xlYW51cCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCk7XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnNhZmV0eUV2ZW50cztcbiAgICAgIGV4cGVjdChldmVudHMuc29tZShlID0+IGUuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0NsZWFuZWQgdXAgMSBvbGQgc3Rhc2hlcycpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFN0YXNoU3RhdGlzdGljcycsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoMSA9IHtcbiAgICAgICAgaWQ6ICdjYW1wYWlnbi1waGFzZTEtMS10aW1lc3RhbXAnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1BoYXNlIDEgc3Rhc2gnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDIzLTAxLTAxJyksXG4gICAgICAgIGJyYW5jaDogJ21haW4nXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGFzaDIgPSB7XG4gICAgICAgIGlkOiAnY2FtcGFpZ24tcGhhc2UyLTItdGltZXN0YW1wJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdQaGFzZSAyIHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyMy0wMS0wMicpLFxuICAgICAgICBicmFuY2g6ICdtYWluJ1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3Rhc2gzID0ge1xuICAgICAgICBpZDogJ2NhbXBhaWduLXBoYXNlMS0zLXRpbWVzdGFtcCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQW5vdGhlciBQaGFzZSAxIHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyMy0wMS0wMycpLFxuICAgICAgICBicmFuY2g6ICdtYWluJ1xuICAgICAgfTtcblxuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ3N0YXNoMScsIHN0YXNoMSk7XG4gICAgICAoc2FmZXR5UHJvdG9jb2wgYXMgYW55KS5zdGFzaGVzLnNldCgnc3Rhc2gyJywgc3Rhc2gyKTtcbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnN0YXNoZXMuc2V0KCdzdGFzaDMnLCBzdGFzaDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY29tcHJlaGVuc2l2ZSBzdGFzaCBzdGF0aXN0aWNzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSBzYWZldHlQcm90b2NvbC5nZXRTdGFzaFN0YXRpc3RpY3MoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UucGhhc2UxKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UucGhhc2UyKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdFN0YXNoKS50b0VxdWFsKG5ldyBEYXRlKCcyMDIzLTAxLTAxJykpO1xuICAgICAgZXhwZWN0KHN0YXRzLm5ld2VzdFN0YXNoKS50b0VxdWFsKG5ldyBEYXRlKCcyMDIzLTAxLTAzJykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgc3Rhc2hlcycsICgpID0+IHtcbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnN0YXNoZXMuY2xlYXIoKTtcblxuICAgICAgY29uc3Qgc3RhdHMgPSBzYWZldHlQcm90b2NvbC5nZXRTdGFzaFN0YXRpc3RpY3MoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UpLnRvRXF1YWwoe30pO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdFN0YXNoKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3RhdHMubmV3ZXN0U3Rhc2gpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlYWwtdGltZSBNb25pdG9yaW5nJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnZGV0ZWN0Q29ycnVwdGlvbicpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGV0ZWN0ZWRGaWxlczogW10sXG4gICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJuczogW10sXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuTE9XLFxuICAgICAgICByZWNvbW1lbmRlZEFjdGlvbjogUmVjb3ZlcnlBY3Rpb24uQ09OVElOVUVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdGFydCByZWFsLXRpbWUgbW9uaXRvcmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVzID0gWydmaWxlMS50cycsICdmaWxlMi50cyddO1xuICAgICAgXG4gICAgICBzYWZldHlQcm90b2NvbC5zdGFydFJlYWxUaW1lTW9uaXRvcmluZyhmaWxlcywgMTAwMCk7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCB0aW1lIHRvIHRyaWdnZXIgbW9uaXRvcmluZ1xuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuXG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmlsZXMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmlnZ2VyIGVtZXJnZW5jeSByb2xsYmFjayBvbiBjcml0aWNhbCBjb3JydXB0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2RldGVjdENvcnJ1cHRpb24nKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRldGVjdGVkRmlsZXM6IFsnZmlsZTEudHMnXSxcbiAgICAgICAgY29ycnVwdGlvblBhdHRlcm5zOiBbXSxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCxcbiAgICAgICAgcmVjb21tZW5kZWRBY3Rpb246IFJlY292ZXJ5QWN0aW9uLkVNRVJHRU5DWV9SRVNUT1JFXG4gICAgICB9KTtcbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdlbWVyZ2VuY3lSb2xsYmFjaycpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG5cbiAgICAgIGNvbnN0IGZpbGVzID0gWydmaWxlMS50cyddO1xuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RhcnRSZWFsVGltZU1vbml0b3JpbmcoZmlsZXMsIDEwMDApO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgdGltZSB0byB0cmlnZ2VyIG1vbml0b3JpbmdcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcblxuICAgICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcblxuICAgICAgZXhwZWN0KHNhZmV0eVByb3RvY29sLmVtZXJnZW5jeVJvbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN0b3AgcmVhbC10aW1lIG1vbml0b3JpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlcyA9IFsnZmlsZTEudHMnXTtcbiAgICAgIHNhZmV0eVByb3RvY29sLnN0YXJ0UmVhbFRpbWVNb25pdG9yaW5nKGZpbGVzLCAxMDAwKTtcbiAgICAgIFxuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RvcFJlYWxUaW1lTW9uaXRvcmluZygpO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgdGltZSAtIG1vbml0b3Jpbmcgc2hvdWxkIG5vdCB0cmlnZ2VyXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG5cbiAgICAgIGV4cGVjdChzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FmZXR5IEV2ZW50IE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBsaW1pdCBzYWZldHkgZXZlbnRzIHRvIHByZXZlbnQgbWVtb3J5IGlzc3VlcycsICgpID0+IHtcbiAgICAgIC8vIEFkZCBtYW55IHNhZmV0eSBldmVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTEwMDsgaSsrKSB7XG4gICAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLmFkZFNhZmV0eUV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBTYWZldHlFdmVudFR5cGUuQ0hFQ0tQT0lOVF9DUkVBVEVELFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEV2ZW50ICR7aX1gLFxuICAgICAgICAgIHNldmVyaXR5OiBTYWZldHlFdmVudFNldmVyaXR5LklORk8sXG4gICAgICAgICAgYWN0aW9uOiAnVEVTVCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnNhZmV0eUV2ZW50cztcbiAgICAgIGV4cGVjdChldmVudHMubGVuZ3RoKS50b0JlKDUwMCk7IC8vIFNob3VsZCBiZSB0cmltbWVkIHRvIDUwMFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBtb3N0IHJlY2VudCBldmVudHMgd2hlbiB0cmltbWluZycsICgpID0+IHtcbiAgICAgIC8vIEFkZCBtYW55IHNhZmV0eSBldmVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTEwMDsgaSsrKSB7XG4gICAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLmFkZFNhZmV0eUV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBTYWZldHlFdmVudFR5cGUuQ0hFQ0tQT0lOVF9DUkVBVEVELFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEV2ZW50ICR7aX1gLFxuICAgICAgICAgIHNldmVyaXR5OiBTYWZldHlFdmVudFNldmVyaXR5LklORk8sXG4gICAgICAgICAgYWN0aW9uOiAnVEVTVCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyBhbnkpLnNhZmV0eUV2ZW50cztcbiAgICAgIGV4cGVjdChldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdLmRlc2NyaXB0aW9uKS50b0JlKCdFdmVudCAxMDk5Jyk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9