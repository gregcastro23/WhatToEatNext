9bf2718838a5347efef043e50793417a
"use strict";
/**
 * Import Cleanup System
 * Automated import detection, removal, and organization system
 * Part of the Kiro Optimization Campaign System
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_IMPORT_CLEANUP_CONFIG = exports.ImportCleanupSystem = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const logger_1 = require("../../utils/logger");
class ImportCleanupSystem {
    config;
    processedFiles = new Set();
    constructor(config) {
        this.config = config;
    }
    /**
     * Execute comprehensive import cleanup
     */
    async executeCleanup(targetFiles) {
        const startTime = Date.now();
        logger_1.logger.info('Starting import cleanup system execution');
        try {
            // Get files to process
            const filesToProcess = targetFiles || await this.getTypeScriptFiles();
            const batchedFiles = this.batchFiles(filesToProcess);
            let totalResult = {
                filesProcessed: [],
                unusedImportsRemoved: 0,
                importsOrganized: 0,
                styleViolationsFixed: 0,
                buildValidationPassed: true,
                errors: [],
                warnings: []
            };
            // Process files in batches
            for (let i = 0; i < batchedFiles.length; i++) {
                const batch = batchedFiles[i];
                logger_1.logger.info(`Processing batch ${i + 1}/${batchedFiles.length} (${batch.length} files)`);
                const batchResult = await this.processBatch(batch);
                totalResult = this.mergeBatchResults(totalResult, batchResult);
                // Validate build after each batch if enabled
                if (this.config.safetyValidationEnabled &&
                    (i + 1) % this.config.buildValidationFrequency === 0) {
                    const buildValid = await this.validateBuild();
                    if (!buildValid) {
                        totalResult.buildValidationPassed = false;
                        totalResult.errors.push(`Build validation failed after batch ${i + 1}`);
                        break;
                    }
                }
            }
            const executionTime = Date.now() - startTime;
            logger_1.logger.info(`Import cleanup completed in ${executionTime}ms`, {
                filesProcessed: totalResult.filesProcessed.length,
                unusedImportsRemoved: totalResult.unusedImportsRemoved,
                importsOrganized: totalResult.importsOrganized
            });
            return totalResult;
        }
        catch (error) {
            logger_1.logger.error('Import cleanup system failed', error);
            return {
                filesProcessed: [],
                unusedImportsRemoved: 0,
                importsOrganized: 0,
                styleViolationsFixed: 0,
                buildValidationPassed: false,
                errors: [error.message],
                warnings: []
            };
        }
    }
    /**
     * Detect unused imports across the codebase
     */
    async detectUnusedImports(filePaths) {
        const files = filePaths || await this.getTypeScriptFiles();
        const unusedImports = [];
        for (const filePath of files) {
            try {
                const fileUnusedImports = await this.detectUnusedImportsInFile(filePath);
                unusedImports.push(...fileUnusedImports);
            }
            catch (error) {
                logger_1.logger.warn(`Failed to analyze imports in ${filePath}`, error);
            }
        }
        return unusedImports;
    }
    /**
     * Remove unused imports from files
     */
    async removeUnusedImports(filePaths) {
        let removedCount = 0;
        for (const filePath of filePaths) {
            try {
                const removed = await this.removeUnusedImportsFromFile(filePath);
                removedCount += removed;
                this.processedFiles.add(filePath);
            }
            catch (error) {
                logger_1.logger.error(`Failed to remove unused imports from ${filePath}`, error);
            }
        }
        return removedCount;
    }
    /**
     * Organize imports according to style rules
     */
    async organizeImports(filePaths) {
        let organizedCount = 0;
        for (const filePath of filePaths) {
            try {
                const organized = await this.organizeImportsInFile(filePath);
                if (organized) {
                    organizedCount++;
                    this.processedFiles.add(filePath);
                }
            }
            catch (error) {
                logger_1.logger.error(`Failed to organize imports in ${filePath}`, error);
            }
        }
        return organizedCount;
    }
    /**
     * Enforce import style consistency
     */
    async enforceImportStyle(filePaths) {
        let fixedCount = 0;
        for (const filePath of filePaths) {
            try {
                const fixed = await this.enforceImportStyleInFile(filePath);
                if (fixed) {
                    fixedCount++;
                    this.processedFiles.add(filePath);
                }
            }
            catch (error) {
                logger_1.logger.error(`Failed to enforce import style in ${filePath}`, error);
            }
        }
        return fixedCount;
    }
    // Private implementation methods
    async processBatch(filePaths) {
        const result = {
            filesProcessed: [],
            unusedImportsRemoved: 0,
            importsOrganized: 0,
            styleViolationsFixed: 0,
            buildValidationPassed: true,
            errors: [],
            warnings: []
        };
        // Step 1: Remove unused imports
        try {
            result.unusedImportsRemoved = await this.removeUnusedImports(filePaths);
        }
        catch (error) {
            result.errors.push(`Unused import removal failed: ${error.message}`);
        }
        // Step 2: Organize imports
        if (this.config.organizationRules.groupExternalImports ||
            this.config.organizationRules.groupInternalImports) {
            try {
                result.importsOrganized = await this.organizeImports(filePaths);
            }
            catch (error) {
                result.errors.push(`Import organization failed: ${error.message}`);
            }
        }
        // Step 3: Enforce style consistency
        if (this.config.importStyleEnforcement) {
            try {
                result.styleViolationsFixed = await this.enforceImportStyle(filePaths);
            }
            catch (error) {
                result.errors.push(`Import style enforcement failed: ${error.message}`);
            }
        }
        result.filesProcessed = Array.from(this.processedFiles);
        return result;
    }
    async detectUnusedImportsInFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        const unusedImports = [];
        // Parse import statements
        const importRegex = /^import\s+(?:type\s+)?(?:\{([^}]+)\}|\*\s+as\s+(\w+)|(\w+))\s+from\s+['"]([^'"]+)['"];?/;
        const typeImportRegex = /^import\s+type\s+/;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            const match = line.match(importRegex);
            if (match) {
                const isTypeImport = typeImportRegex.test(line);
                const importStatement = line;
                // Extract imported names
                let importedNames = [];
                if (match[1]) {
                    // Named imports: { name1, name2 }
                    importedNames = match[1].split(',').map(name => name.trim());
                }
                else if (match[2]) {
                    // Namespace import: * as name
                    importedNames = [match[2]];
                }
                else if (match[3]) {
                    // Default import: name
                    importedNames = [match[3]];
                }
                // Check if each imported name is used
                for (const importName of importedNames) {
                    if (!this.isImportUsed(content, importName, i)) {
                        unusedImports.push({
                            filePath,
                            importName,
                            importLine: i + 1,
                            importStatement,
                            isTypeImport
                        });
                    }
                }
            }
        }
        return unusedImports;
    }
    isImportUsed(content, importName, importLineIndex) {
        const lines = content.split('\n');
        // Remove the import line from consideration
        const contentWithoutImport = lines
            .filter((_, index) => index !== importLineIndex)
            .join('\n');
        // Check for usage patterns
        const usagePatterns = [
            new RegExp(`\\b${importName}\\b`, 'g'),
            new RegExp(`\\b${importName}\\.`, 'g'),
            new RegExp(`\\b${importName}\\(`, 'g'),
            new RegExp(`<${importName}\\b`, 'g'),
            new RegExp(`extends\\s+${importName}\\b`, 'g'),
            new RegExp(`implements\\s+${importName}\\b`, 'g'),
            new RegExp(`:\\s*${importName}\\b`, 'g'), // Type annotation
        ];
        return usagePatterns.some(pattern => pattern.test(contentWithoutImport));
    }
    async removeUnusedImportsFromFile(filePath) {
        const unusedImports = await this.detectUnusedImportsInFile(filePath);
        if (unusedImports.length === 0) {
            return 0;
        }
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        let removedCount = 0;
        // Group unused imports by line
        const unusedByLine = new Map();
        for (const unused of unusedImports) {
            const lineIndex = unused.importLine - 1;
            if (!unusedByLine.has(lineIndex)) {
                unusedByLine.set(lineIndex, []);
            }
            unusedByLine.get(lineIndex)?.push(unused);
        }
        // Process lines in reverse order to maintain line numbers
        const sortedLines = Array.from(unusedByLine.keys()).sort((a, b) => b - a);
        for (const lineIndex of sortedLines) {
            const lineUnused = unusedByLine.get(lineIndex);
            if (!lineUnused)
                continue;
            const originalLine = lines[lineIndex];
            // If all imports on this line are unused, remove the entire line
            const allImportsOnLine = this.extractAllImportsFromLine(originalLine);
            const allUnused = allImportsOnLine.every(imp => lineUnused.some(unused => unused.importName === imp));
            if (allUnused) {
                lines.splice(lineIndex, 1);
                removedCount += lineUnused.length;
            }
            else {
                // Remove only specific unused imports from the line
                let modifiedLine = originalLine;
                for (const unused of lineUnused) {
                    modifiedLine = this.removeImportFromLine(modifiedLine, unused.importName);
                    removedCount++;
                }
                lines[lineIndex] = modifiedLine;
            }
        }
        // Write the modified content back
        fs.writeFileSync(filePath, lines.join('\n'), 'utf8');
        return removedCount;
    }
    extractAllImportsFromLine(line) {
        const importRegex = /^import\s+(?:type\s+)?(?:\{([^}]+)\}|\*\s+as\s+(\w+)|(\w+))\s+from/;
        const match = line.match(importRegex);
        if (!match)
            return [];
        if (match[1]) {
            // Named imports
            return match[1].split(',').map(name => name.trim());
        }
        else if (match[2]) {
            // Namespace import
            return [match[2]];
        }
        else if (match[3]) {
            // Default import
            return [match[3]];
        }
        return [];
    }
    removeImportFromLine(line, importName) {
        // Handle different import patterns
        const patterns = [
            // Remove from named imports: { name1, name2, name3 } -> { name1, name3 }
            {
                regex: new RegExp(`\\{([^}]*?)\\b${importName}\\b,?([^}]*?)\\}`, 'g'),
                replacement: (match, before, after) => {
                    const cleanBefore = before.replace(/,\s*$/, '').trim();
                    const cleanAfter = after.replace(/^\s*,/, '').trim();
                    const combined = [cleanBefore, cleanAfter].filter(Boolean).join(', ');
                    return `{${combined}}`;
                }
            }
        ];
        let modifiedLine = line;
        for (const pattern of patterns) {
            modifiedLine = modifiedLine.replace(pattern.regex, pattern.replacement);
        }
        return modifiedLine;
    }
    async organizeImportsInFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        // Find import section
        const importLines = [];
        const importRegex = /^import\s+/;
        const typeImportRegex = /^import\s+type\s+/;
        const externalImportRegex = /from\s+['"](?![@./])/;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (importRegex.test(line)) {
                importLines.push({
                    line: lines[i],
                    index: i,
                    isExternal: externalImportRegex.test(line),
                    isType: typeImportRegex.test(line)
                });
            }
            else if (line && !line.startsWith('//') && !line.startsWith('/*')) {
                // Stop at first non-import, non-comment line
                break;
            }
        }
        if (importLines.length === 0) {
            return false;
        }
        // Organize imports according to rules
        const organizedImports = this.organizeImportLines(importLines);
        // Check if organization changed anything
        const originalImportSection = importLines.map(imp => imp.line).join('\n');
        const organizedImportSection = organizedImports.join('\n');
        if (originalImportSection === organizedImportSection) {
            return false;
        }
        // Replace import section
        const firstImportIndex = importLines[0].index;
        const lastImportIndex = importLines[importLines.length - 1].index;
        const newLines = [
            ...lines.slice(0, firstImportIndex),
            ...organizedImports,
            ...lines.slice(lastImportIndex + 1)
        ];
        fs.writeFileSync(filePath, newLines.join('\n'), 'utf8');
        return true;
    }
    organizeImportLines(importLines) {
        const { organizationRules } = this.config;
        const organized = [];
        // Separate imports by type
        const externalImports = importLines.filter(imp => imp.isExternal);
        const internalImports = importLines.filter(imp => !imp.isExternal);
        // Sort function
        const sortImports = (imports) => {
            if (organizationRules.sortAlphabetically) {
                return imports.sort((a, b) => a.line.localeCompare(b.line));
            }
            return imports;
        };
        // Separate type imports if configured
        if (organizationRules.separateTypeImports) {
            const externalTypeImports = sortImports(externalImports.filter(imp => imp.isType));
            const externalValueImports = sortImports(externalImports.filter(imp => !imp.isType));
            const internalTypeImports = sortImports(internalImports.filter(imp => imp.isType));
            const internalValueImports = sortImports(internalImports.filter(imp => !imp.isType));
            // Add external imports
            if (organizationRules.groupExternalImports) {
                organized.push(...externalTypeImports.map(imp => imp.line));
                if (externalTypeImports.length > 0 && externalValueImports.length > 0) {
                    organized.push(''); // Empty line between type and value imports
                }
                organized.push(...externalValueImports.map(imp => imp.line));
                if ((externalTypeImports.length > 0 || externalValueImports.length > 0) &&
                    (internalTypeImports.length > 0 || internalValueImports.length > 0)) {
                    organized.push(''); // Empty line between external and internal
                }
            }
            // Add internal imports
            if (organizationRules.groupInternalImports) {
                organized.push(...internalTypeImports.map(imp => imp.line));
                if (internalTypeImports.length > 0 && internalValueImports.length > 0) {
                    organized.push(''); // Empty line between type and value imports
                }
                organized.push(...internalValueImports.map(imp => imp.line));
            }
        }
        else {
            // Don't separate type imports
            if (organizationRules.groupExternalImports) {
                organized.push(...sortImports(externalImports).map(imp => imp.line));
                if (externalImports.length > 0 && internalImports.length > 0) {
                    organized.push(''); // Empty line between external and internal
                }
            }
            if (organizationRules.groupInternalImports) {
                organized.push(...sortImports(internalImports).map(imp => imp.line));
            }
        }
        return organized;
    }
    async enforceImportStyleInFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        let modified = false;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (/^import\s+/.test(line.trim())) {
                const styledLine = this.applyImportStyle(line);
                if (styledLine !== line) {
                    lines[i] = styledLine;
                    modified = true;
                }
            }
        }
        if (modified) {
            fs.writeFileSync(filePath, lines.join('\n'), 'utf8');
        }
        return modified;
    }
    applyImportStyle(line) {
        const { organizationRules } = this.config;
        let styledLine = line;
        // Enforce trailing commas in multi-line imports
        if (organizationRules.enforceTrailingCommas) {
            styledLine = styledLine.replace(/\{\s*([^}]+[^,])\s*\}/g, (match, imports) => {
                if (imports.includes(',')) {
                    return `{ ${imports.trim()}, }`;
                }
                return match;
            });
        }
        // Enforce line length limits
        if (organizationRules.maxLineLength && styledLine.length > organizationRules.maxLineLength) {
            // Break long import lines
            const importMatch = styledLine.match(/^(\s*import\s+(?:type\s+)?\{)([^}]+)(\}\s+from\s+.+)$/);
            if (importMatch) {
                const [, prefix, imports, suffix] = importMatch;
                const importList = imports.split(',').map(imp => imp.trim());
                if (importList.length > 1) {
                    const formattedImports = importList.map(imp => `  ${imp}`).join(',\n');
                    styledLine = `${prefix}\n${formattedImports}\n${suffix}`;
                }
            }
        }
        return styledLine;
    }
    async getTypeScriptFiles() {
        try {
            const output = (0, child_process_1.execSync)('find src -name "*.ts" -o -name "*.tsx" | grep -v __tests__ | grep -v .test. | grep -v .spec.', { encoding: 'utf8', stdio: 'pipe' });
            return output.trim().split('\n').filter(Boolean);
        }
        catch (error) {
            logger_1.logger.error('Failed to get TypeScript files', error);
            return [];
        }
    }
    batchFiles(files) {
        const batches = [];
        for (let i = 0; i < files.length; i += this.config.maxFilesPerBatch) {
            batches.push(files.slice(i, i + this.config.maxFilesPerBatch));
        }
        return batches;
    }
    async validateBuild() {
        try {
            (0, child_process_1.execSync)('yarn tsc --noEmit --skipLibCheck', {
                encoding: 'utf8',
                stdio: 'pipe',
                timeout: 30000
            });
            return true;
        }
        catch (error) {
            logger_1.logger.warn('Build validation failed during import cleanup', error);
            return false;
        }
    }
    mergeBatchResults(total, batch) {
        return {
            filesProcessed: [...total.filesProcessed, ...batch.filesProcessed],
            unusedImportsRemoved: total.unusedImportsRemoved + batch.unusedImportsRemoved,
            importsOrganized: total.importsOrganized + batch.importsOrganized,
            styleViolationsFixed: total.styleViolationsFixed + batch.styleViolationsFixed,
            buildValidationPassed: total.buildValidationPassed && batch.buildValidationPassed,
            errors: [...total.errors, ...batch.errors],
            warnings: [...total.warnings, ...batch.warnings]
        };
    }
}
exports.ImportCleanupSystem = ImportCleanupSystem;
/**
 * Default configuration for import cleanup
 */
exports.DEFAULT_IMPORT_CLEANUP_CONFIG = {
    maxFilesPerBatch: 20,
    safetyValidationEnabled: true,
    buildValidationFrequency: 5,
    importStyleEnforcement: true,
    organizationRules: {
        groupExternalImports: true,
        groupInternalImports: true,
        sortAlphabetically: true,
        separateTypeImports: true,
        enforceTrailingCommas: true,
        maxLineLength: 100
    }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9JbXBvcnRDbGVhbnVwU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFHekIsK0NBQTRDO0FBcUM1QyxNQUFhLG1CQUFtQjtJQUN0QixNQUFNLENBQXNCO0lBQzVCLGNBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUVoRCxZQUFZLE1BQTJCO1FBQ3JDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxjQUFjLENBQUMsV0FBc0I7UUFDekMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzdCLGVBQU0sQ0FBQyxJQUFJLENBQUMsMENBQTBDLENBQUMsQ0FBQztRQUV4RCxJQUFJO1lBQ0YsdUJBQXVCO1lBQ3ZCLE1BQU0sY0FBYyxHQUFHLFdBQVcsSUFBSSxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQ3RFLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7WUFFckQsSUFBSSxXQUFXLEdBQXdCO2dCQUNyQyxjQUFjLEVBQUUsRUFBRTtnQkFDbEIsb0JBQW9CLEVBQUUsQ0FBQztnQkFDdkIsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDbkIsb0JBQW9CLEVBQUUsQ0FBQztnQkFDdkIscUJBQXFCLEVBQUUsSUFBSTtnQkFDM0IsTUFBTSxFQUFFLEVBQUU7Z0JBQ1YsUUFBUSxFQUFFLEVBQUU7YUFDYixDQUFDO1lBRUYsMkJBQTJCO1lBQzNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM1QyxNQUFNLEtBQUssR0FB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RjtBQXBrQkQsa0RBb2tCQztBQUVEOztHQUVHO0FBQ1UsUUFBQSw2QkFBNkIsR0FBd0I7SUFDaEUsZ0JBQWdCLEVBQUUsRUFBRTtJQUNwQix1QkFBdUIsRUFBRSxJQUFJO0lBQzdCLHdCQUF3QixFQUFFLENBQUM7SUFDM0Isc0JBQXNCLEVBQUUsSUFBSTtJQUM1QixpQkFBaUIsRUFBRTtRQUNqQixvQkFBb0IsRUFBRSxJQUFJO1FBQzFCLG9CQUFvQixFQUFFLElBQUk7UUFDMUIsa0JBQWtCLEVBQUUsSUFBSTtRQUN4QixtQkFBbUIsRUFBRSxJQUFJO1FBQ3pCLHFCQUFxQixFQUFFLElBQUk7UUFDM0IsYUFBYSxFQUFFLEdBQUc7S0FDbkI7Q0FDRixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvc2VydmljZXMvY2FtcGFpZ24vSW1wb3J0Q2xlYW51cFN5c3RlbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEltcG9ydCBDbGVhbnVwIFN5c3RlbVxuICogQXV0b21hdGVkIGltcG9ydCBkZXRlY3Rpb24sIHJlbW92YWwsIGFuZCBvcmdhbml6YXRpb24gc3lzdGVtXG4gKiBQYXJ0IG9mIHRoZSBLaXJvIE9wdGltaXphdGlvbiBDYW1wYWlnbiBTeXN0ZW1cbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRDbGVhbnVwQ29uZmlnIHtcbiAgbWF4RmlsZXNQZXJCYXRjaDogbnVtYmVyO1xuICBzYWZldHlWYWxpZGF0aW9uRW5hYmxlZDogYm9vbGVhbjtcbiAgYnVpbGRWYWxpZGF0aW9uRnJlcXVlbmN5OiBudW1iZXI7XG4gIGltcG9ydFN0eWxlRW5mb3JjZW1lbnQ6IGJvb2xlYW47XG4gIG9yZ2FuaXphdGlvblJ1bGVzOiBJbXBvcnRPcmdhbml6YXRpb25SdWxlcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRPcmdhbml6YXRpb25SdWxlcyB7XG4gIGdyb3VwRXh0ZXJuYWxJbXBvcnRzOiBib29sZWFuO1xuICBncm91cEludGVybmFsSW1wb3J0czogYm9vbGVhbjtcbiAgc29ydEFscGhhYmV0aWNhbGx5OiBib29sZWFuO1xuICBzZXBhcmF0ZVR5cGVJbXBvcnRzOiBib29sZWFuO1xuICBlbmZvcmNlVHJhaWxpbmdDb21tYXM6IGJvb2xlYW47XG4gIG1heExpbmVMZW5ndGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRDbGVhbnVwUmVzdWx0IHtcbiAgZmlsZXNQcm9jZXNzZWQ6IHN0cmluZ1tdO1xuICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogbnVtYmVyO1xuICBpbXBvcnRzT3JnYW5pemVkOiBudW1iZXI7XG4gIHN0eWxlVmlvbGF0aW9uc0ZpeGVkOiBudW1iZXI7XG4gIGJ1aWxkVmFsaWRhdGlvblBhc3NlZDogYm9vbGVhbjtcbiAgZXJyb3JzOiBzdHJpbmdbXTtcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVudXNlZEltcG9ydCB7XG4gIGZpbGVQYXRoOiBzdHJpbmc7XG4gIGltcG9ydE5hbWU6IHN0cmluZztcbiAgaW1wb3J0TGluZTogbnVtYmVyO1xuICBpbXBvcnRTdGF0ZW1lbnQ6IHN0cmluZztcbiAgaXNUeXBlSW1wb3J0OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgSW1wb3J0Q2xlYW51cFN5c3RlbSB7XG4gIHByaXZhdGUgY29uZmlnOiBJbXBvcnRDbGVhbnVwQ29uZmlnO1xuICBwcml2YXRlIHByb2Nlc3NlZEZpbGVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEltcG9ydENsZWFudXBDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGNvbXByZWhlbnNpdmUgaW1wb3J0IGNsZWFudXBcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVDbGVhbnVwKHRhcmdldEZpbGVzPzogc3RyaW5nW10pOiBQcm9taXNlPEltcG9ydENsZWFudXBSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxvZ2dlci5pbmZvKCdTdGFydGluZyBpbXBvcnQgY2xlYW51cCBzeXN0ZW0gZXhlY3V0aW9uJyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGZpbGVzIHRvIHByb2Nlc3NcbiAgICAgIGNvbnN0IGZpbGVzVG9Qcm9jZXNzID0gdGFyZ2V0RmlsZXMgfHwgYXdhaXQgdGhpcy5nZXRUeXBlU2NyaXB0RmlsZXMoKTtcbiAgICAgIGNvbnN0IGJhdGNoZWRGaWxlcyA9IHRoaXMuYmF0Y2hGaWxlcyhmaWxlc1RvUHJvY2Vzcyk7XG5cbiAgICAgIGxldCB0b3RhbFJlc3VsdDogSW1wb3J0Q2xlYW51cFJlc3VsdCA9IHtcbiAgICAgICAgZmlsZXNQcm9jZXNzZWQ6IFtdLFxuICAgICAgICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogMCxcbiAgICAgICAgaW1wb3J0c09yZ2FuaXplZDogMCxcbiAgICAgICAgc3R5bGVWaW9sYXRpb25zRml4ZWQ6IDAsXG4gICAgICAgIGJ1aWxkVmFsaWRhdGlvblBhc3NlZDogdHJ1ZSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBQcm9jZXNzIGZpbGVzIGluIGJhdGNoZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlZEZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlZEZpbGVzW2ldO1xuICAgICAgICBsb2dnZXIuaW5mbyhgUHJvY2Vzc2luZyBiYXRjaCAke2kgKyAxfS8ke2JhdGNoZWRGaWxlcy5sZW5ndGh9ICgke2JhdGNoLmxlbmd0aH0gZmlsZXMpYCk7XG5cbiAgICAgICAgY29uc3QgYmF0Y2hSZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NCYXRjaChiYXRjaCk7XG4gICAgICAgIHRvdGFsUmVzdWx0ID0gdGhpcy5tZXJnZUJhdGNoUmVzdWx0cyh0b3RhbFJlc3VsdCwgYmF0Y2hSZXN1bHQpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGJ1aWxkIGFmdGVyIGVhY2ggYmF0Y2ggaWYgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5jb25maWcuc2FmZXR5VmFsaWRhdGlvbkVuYWJsZWQgJiYgXG4gICAgICAgICAgICAoaSArIDEpICUgdGhpcy5jb25maWcuYnVpbGRWYWxpZGF0aW9uRnJlcXVlbmN5ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgYnVpbGRWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVCdWlsZCgpO1xuICAgICAgICAgIGlmICghYnVpbGRWYWxpZCkge1xuICAgICAgICAgICAgdG90YWxSZXN1bHQuYnVpbGRWYWxpZGF0aW9uUGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0b3RhbFJlc3VsdC5lcnJvcnMucHVzaChgQnVpbGQgdmFsaWRhdGlvbiBmYWlsZWQgYWZ0ZXIgYmF0Y2ggJHtpICsgMX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGxvZ2dlci5pbmZvKGBJbXBvcnQgY2xlYW51cCBjb21wbGV0ZWQgaW4gJHtleGVjdXRpb25UaW1lfW1zYCwge1xuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogdG90YWxSZXN1bHQuZmlsZXNQcm9jZXNzZWQubGVuZ3RoLFxuICAgICAgICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogdG90YWxSZXN1bHQudW51c2VkSW1wb3J0c1JlbW92ZWQsXG4gICAgICAgIGltcG9ydHNPcmdhbml6ZWQ6IHRvdGFsUmVzdWx0LmltcG9ydHNPcmdhbml6ZWRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdG90YWxSZXN1bHQ7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdJbXBvcnQgY2xlYW51cCBzeXN0ZW0gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZXNQcm9jZXNzZWQ6IFtdLFxuICAgICAgICB1bnVzZWRJbXBvcnRzUmVtb3ZlZDogMCxcbiAgICAgICAgaW1wb3J0c09yZ2FuaXplZDogMCxcbiAgICAgICAgc3R5bGVWaW9sYXRpb25zRml4ZWQ6IDAsXG4gICAgICAgIGJ1aWxkVmFsaWRhdGlvblBhc3NlZDogZmFsc2UsXG4gICAgICAgIGVycm9yczogWyhlcnJvciBhcyBFcnJvcikubWVzc2FnZV0sXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHVudXNlZCBpbXBvcnRzIGFjcm9zcyB0aGUgY29kZWJhc2VcbiAgICovXG4gIGFzeW5jIGRldGVjdFVudXNlZEltcG9ydHMoZmlsZVBhdGhzPzogc3RyaW5nW10pOiBQcm9taXNlPFVudXNlZEltcG9ydFtdPiB7XG4gICAgY29uc3QgZmlsZXMgPSBmaWxlUGF0aHMgfHwgYXdhaXQgdGhpcy5nZXRUeXBlU2NyaXB0RmlsZXMoKTtcbiAgICBjb25zdCB1bnVzZWRJbXBvcnRzOiBVbnVzZWRJbXBvcnRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmlsZVVudXNlZEltcG9ydHMgPSBhd2FpdCB0aGlzLmRldGVjdFVudXNlZEltcG9ydHNJbkZpbGUoZmlsZVBhdGgpO1xuICAgICAgICB1bnVzZWRJbXBvcnRzLnB1c2goLi4uZmlsZVVudXNlZEltcG9ydHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byBhbmFseXplIGltcG9ydHMgaW4gJHtmaWxlUGF0aH1gLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVudXNlZEltcG9ydHM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVudXNlZCBpbXBvcnRzIGZyb20gZmlsZXNcbiAgICovXG4gIGFzeW5jIHJlbW92ZVVudXNlZEltcG9ydHMoZmlsZVBhdGhzOiBzdHJpbmdbXSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgbGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGZpbGVQYXRocykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGF3YWl0IHRoaXMucmVtb3ZlVW51c2VkSW1wb3J0c0Zyb21GaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgcmVtb3ZlZENvdW50ICs9IHJlbW92ZWQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkRmlsZXMuYWRkKGZpbGVQYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHJlbW92ZSB1bnVzZWQgaW1wb3J0cyBmcm9tICR7ZmlsZVBhdGh9YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVkQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogT3JnYW5pemUgaW1wb3J0cyBhY2NvcmRpbmcgdG8gc3R5bGUgcnVsZXNcbiAgICovXG4gIGFzeW5jIG9yZ2FuaXplSW1wb3J0cyhmaWxlUGF0aHM6IHN0cmluZ1tdKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBsZXQgb3JnYW5pemVkQ291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9yZ2FuaXplZCA9IGF3YWl0IHRoaXMub3JnYW5pemVJbXBvcnRzSW5GaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKG9yZ2FuaXplZCkge1xuICAgICAgICAgIG9yZ2FuaXplZENvdW50Kys7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzZWRGaWxlcy5hZGQoZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBvcmdhbml6ZSBpbXBvcnRzIGluICR7ZmlsZVBhdGh9YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmdhbml6ZWRDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmZvcmNlIGltcG9ydCBzdHlsZSBjb25zaXN0ZW5jeVxuICAgKi9cbiAgYXN5bmMgZW5mb3JjZUltcG9ydFN0eWxlKGZpbGVQYXRoczogc3RyaW5nW10pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGxldCBmaXhlZENvdW50ID0gMDtcblxuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmaXhlZCA9IGF3YWl0IHRoaXMuZW5mb3JjZUltcG9ydFN0eWxlSW5GaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKGZpeGVkKSB7XG4gICAgICAgICAgZml4ZWRDb3VudCsrO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc2VkRmlsZXMuYWRkKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZW5mb3JjZSBpbXBvcnQgc3R5bGUgaW4gJHtmaWxlUGF0aH1gLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpeGVkQ291bnQ7XG4gIH1cblxuICAvLyBQcml2YXRlIGltcGxlbWVudGF0aW9uIG1ldGhvZHNcblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NCYXRjaChmaWxlUGF0aHM6IHN0cmluZ1tdKTogUHJvbWlzZTxJbXBvcnRDbGVhbnVwUmVzdWx0PiB7XG4gICAgY29uc3QgcmVzdWx0OiBJbXBvcnRDbGVhbnVwUmVzdWx0ID0ge1xuICAgICAgZmlsZXNQcm9jZXNzZWQ6IFtdLFxuICAgICAgdW51c2VkSW1wb3J0c1JlbW92ZWQ6IDAsXG4gICAgICBpbXBvcnRzT3JnYW5pemVkOiAwLFxuICAgICAgc3R5bGVWaW9sYXRpb25zRml4ZWQ6IDAsXG4gICAgICBidWlsZFZhbGlkYXRpb25QYXNzZWQ6IHRydWUsXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgd2FybmluZ3M6IFtdXG4gICAgfTtcblxuICAgIC8vIFN0ZXAgMTogUmVtb3ZlIHVudXNlZCBpbXBvcnRzXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdC51bnVzZWRJbXBvcnRzUmVtb3ZlZCA9IGF3YWl0IHRoaXMucmVtb3ZlVW51c2VkSW1wb3J0cyhmaWxlUGF0aHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXN1bHQuZXJyb3JzLnB1c2goYFVudXNlZCBpbXBvcnQgcmVtb3ZhbCBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgMjogT3JnYW5pemUgaW1wb3J0c1xuICAgIGlmICh0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25SdWxlcy5ncm91cEV4dGVybmFsSW1wb3J0cyB8fCBcbiAgICAgICAgdGhpcy5jb25maWcub3JnYW5pemF0aW9uUnVsZXMuZ3JvdXBJbnRlcm5hbEltcG9ydHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdC5pbXBvcnRzT3JnYW5pemVkID0gYXdhaXQgdGhpcy5vcmdhbml6ZUltcG9ydHMoZmlsZVBhdGhzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChgSW1wb3J0IG9yZ2FuaXphdGlvbiBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgMzogRW5mb3JjZSBzdHlsZSBjb25zaXN0ZW5jeVxuICAgIGlmICh0aGlzLmNvbmZpZy5pbXBvcnRTdHlsZUVuZm9yY2VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQuc3R5bGVWaW9sYXRpb25zRml4ZWQgPSBhd2FpdCB0aGlzLmVuZm9yY2VJbXBvcnRTdHlsZShmaWxlUGF0aHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKGBJbXBvcnQgc3R5bGUgZW5mb3JjZW1lbnQgZmFpbGVkOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQuZmlsZXNQcm9jZXNzZWQgPSBBcnJheS5mcm9tKHRoaXMucHJvY2Vzc2VkRmlsZXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGRldGVjdFVudXNlZEltcG9ydHNJbkZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8VW51c2VkSW1wb3J0W10+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgdW51c2VkSW1wb3J0czogVW51c2VkSW1wb3J0W10gPSBbXTtcblxuICAgIC8vIFBhcnNlIGltcG9ydCBzdGF0ZW1lbnRzXG4gICAgY29uc3QgaW1wb3J0UmVnZXggPSAvXmltcG9ydFxccysoPzp0eXBlXFxzKyk/KD86XFx7KFtefV0rKVxcfXxcXCpcXHMrYXNcXHMrKFxcdyspfChcXHcrKSlcXHMrZnJvbVxccytbJ1wiXShbXidcIl0rKVsnXCJdOz8vO1xuICAgIGNvbnN0IHR5cGVJbXBvcnRSZWdleCA9IC9eaW1wb3J0XFxzK3R5cGVcXHMrLztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goaW1wb3J0UmVnZXgpO1xuICAgICAgXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgaXNUeXBlSW1wb3J0ID0gdHlwZUltcG9ydFJlZ2V4LnRlc3QobGluZSk7XG4gICAgICAgIGNvbnN0IGltcG9ydFN0YXRlbWVudCA9IGxpbmU7XG4gICAgICAgIFxuICAgICAgICAvLyBFeHRyYWN0IGltcG9ydGVkIG5hbWVzXG4gICAgICAgIGxldCBpbXBvcnRlZE5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAvLyBOYW1lZCBpbXBvcnRzOiB7IG5hbWUxLCBuYW1lMiB9XG4gICAgICAgICAgaW1wb3J0ZWROYW1lcyA9IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKG5hbWUgPT4gbmFtZS50cmltKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgLy8gTmFtZXNwYWNlIGltcG9ydDogKiBhcyBuYW1lXG4gICAgICAgICAgaW1wb3J0ZWROYW1lcyA9IFttYXRjaFsyXV07XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IGltcG9ydDogbmFtZVxuICAgICAgICAgIGltcG9ydGVkTmFtZXMgPSBbbWF0Y2hbM11dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZWFjaCBpbXBvcnRlZCBuYW1lIGlzIHVzZWRcbiAgICAgICAgZm9yIChjb25zdCBpbXBvcnROYW1lIG9mIGltcG9ydGVkTmFtZXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNJbXBvcnRVc2VkKGNvbnRlbnQsIGltcG9ydE5hbWUsIGkpKSB7XG4gICAgICAgICAgICB1bnVzZWRJbXBvcnRzLnB1c2goe1xuICAgICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgaW1wb3J0TmFtZSxcbiAgICAgICAgICAgICAgaW1wb3J0TGluZTogaSArIDEsXG4gICAgICAgICAgICAgIGltcG9ydFN0YXRlbWVudCxcbiAgICAgICAgICAgICAgaXNUeXBlSW1wb3J0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW51c2VkSW1wb3J0cztcbiAgfVxuXG4gIHByaXZhdGUgaXNJbXBvcnRVc2VkKGNvbnRlbnQ6IHN0cmluZywgaW1wb3J0TmFtZTogc3RyaW5nLCBpbXBvcnRMaW5lSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIHRoZSBpbXBvcnQgbGluZSBmcm9tIGNvbnNpZGVyYXRpb25cbiAgICBjb25zdCBjb250ZW50V2l0aG91dEltcG9ydCA9IGxpbmVzXG4gICAgICAuZmlsdGVyKChfLCBpbmRleCkgPT4gaW5kZXggIT09IGltcG9ydExpbmVJbmRleClcbiAgICAgIC5qb2luKCdcXG4nKTtcblxuICAgIC8vIENoZWNrIGZvciB1c2FnZSBwYXR0ZXJuc1xuICAgIGNvbnN0IHVzYWdlUGF0dGVybnMgPSBbXG4gICAgICBuZXcgUmVnRXhwKGBcXFxcYiR7aW1wb3J0TmFtZX1cXFxcYmAsICdnJyksIC8vIERpcmVjdCB1c2FnZVxuICAgICAgbmV3IFJlZ0V4cChgXFxcXGIke2ltcG9ydE5hbWV9XFxcXC5gLCAnZycpLCAvLyBQcm9wZXJ0eSBhY2Nlc3NcbiAgICAgIG5ldyBSZWdFeHAoYFxcXFxiJHtpbXBvcnROYW1lfVxcXFwoYCwgJ2cnKSwgLy8gRnVuY3Rpb24gY2FsbFxuICAgICAgbmV3IFJlZ0V4cChgPCR7aW1wb3J0TmFtZX1cXFxcYmAsICdnJyksIC8vIEpTWCBjb21wb25lbnRcbiAgICAgIG5ldyBSZWdFeHAoYGV4dGVuZHNcXFxccyske2ltcG9ydE5hbWV9XFxcXGJgLCAnZycpLCAvLyBDbGFzcyBleHRlbnNpb25cbiAgICAgIG5ldyBSZWdFeHAoYGltcGxlbWVudHNcXFxccyske2ltcG9ydE5hbWV9XFxcXGJgLCAnZycpLCAvLyBJbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAgICAgIG5ldyBSZWdFeHAoYDpcXFxccyoke2ltcG9ydE5hbWV9XFxcXGJgLCAnZycpLCAvLyBUeXBlIGFubm90YXRpb25cbiAgICBdO1xuXG4gICAgcmV0dXJuIHVzYWdlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChjb250ZW50V2l0aG91dEltcG9ydCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZW1vdmVVbnVzZWRJbXBvcnRzRnJvbUZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgdW51c2VkSW1wb3J0cyA9IGF3YWl0IHRoaXMuZGV0ZWN0VW51c2VkSW1wb3J0c0luRmlsZShmaWxlUGF0aCk7XG4gICAgaWYgKHVudXNlZEltcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cbiAgICAvLyBHcm91cCB1bnVzZWQgaW1wb3J0cyBieSBsaW5lXG4gICAgY29uc3QgdW51c2VkQnlMaW5lID0gbmV3IE1hcDxudW1iZXIsIFVudXNlZEltcG9ydFtdPigpO1xuICAgIGZvciAoY29uc3QgdW51c2VkIG9mIHVudXNlZEltcG9ydHMpIHtcbiAgICAgIGNvbnN0IGxpbmVJbmRleCA9IHVudXNlZC5pbXBvcnRMaW5lIC0gMTtcbiAgICAgIGlmICghdW51c2VkQnlMaW5lLmhhcyhsaW5lSW5kZXgpKSB7XG4gICAgICAgIHVudXNlZEJ5TGluZS5zZXQobGluZUluZGV4LCBbXSk7XG4gICAgICB9XG4gICAgICB1bnVzZWRCeUxpbmUuZ2V0KGxpbmVJbmRleCk/LnB1c2godW51c2VkKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGxpbmVzIGluIHJldmVyc2Ugb3JkZXIgdG8gbWFpbnRhaW4gbGluZSBudW1iZXJzXG4gICAgY29uc3Qgc29ydGVkTGluZXMgPSBBcnJheS5mcm9tKHVudXNlZEJ5TGluZS5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGxpbmVJbmRleCBvZiBzb3J0ZWRMaW5lcykge1xuICAgICAgY29uc3QgbGluZVVudXNlZCA9IHVudXNlZEJ5TGluZS5nZXQobGluZUluZGV4KTtcbiAgICAgIGlmICghbGluZVVudXNlZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IG9yaWdpbmFsTGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBcbiAgICAgIC8vIElmIGFsbCBpbXBvcnRzIG9uIHRoaXMgbGluZSBhcmUgdW51c2VkLCByZW1vdmUgdGhlIGVudGlyZSBsaW5lXG4gICAgICBjb25zdCBhbGxJbXBvcnRzT25MaW5lID0gdGhpcy5leHRyYWN0QWxsSW1wb3J0c0Zyb21MaW5lKG9yaWdpbmFsTGluZSk7XG4gICAgICBjb25zdCBhbGxVbnVzZWQgPSBhbGxJbXBvcnRzT25MaW5lLmV2ZXJ5KGltcCA9PiBcbiAgICAgICAgbGluZVVudXNlZC5zb21lKHVudXNlZCA9PiB1bnVzZWQuaW1wb3J0TmFtZSA9PT0gaW1wKVxuICAgICAgKTtcblxuICAgICAgaWYgKGFsbFVudXNlZCkge1xuICAgICAgICBsaW5lcy5zcGxpY2UobGluZUluZGV4LCAxKTtcbiAgICAgICAgcmVtb3ZlZENvdW50ICs9IGxpbmVVbnVzZWQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9ubHkgc3BlY2lmaWMgdW51c2VkIGltcG9ydHMgZnJvbSB0aGUgbGluZVxuICAgICAgICBsZXQgbW9kaWZpZWRMaW5lID0gb3JpZ2luYWxMaW5lO1xuICAgICAgICBmb3IgKGNvbnN0IHVudXNlZCBvZiBsaW5lVW51c2VkKSB7XG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gdGhpcy5yZW1vdmVJbXBvcnRGcm9tTGluZShtb2RpZmllZExpbmUsIHVudXNlZC5pbXBvcnROYW1lKTtcbiAgICAgICAgICByZW1vdmVkQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBsaW5lc1tsaW5lSW5kZXhdID0gbW9kaWZpZWRMaW5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdyaXRlIHRoZSBtb2RpZmllZCBjb250ZW50IGJhY2tcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBsaW5lcy5qb2luKCdcXG4nKSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gcmVtb3ZlZENvdW50O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0QWxsSW1wb3J0c0Zyb21MaW5lKGxpbmU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBpbXBvcnRSZWdleCA9IC9eaW1wb3J0XFxzKyg/OnR5cGVcXHMrKT8oPzpcXHsoW159XSspXFx9fFxcKlxccythc1xccysoXFx3Kyl8KFxcdyspKVxccytmcm9tLztcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goaW1wb3J0UmVnZXgpO1xuICAgIFxuICAgIGlmICghbWF0Y2gpIHJldHVybiBbXTtcbiAgICBcbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgIC8vIE5hbWVkIGltcG9ydHNcbiAgICAgIHJldHVybiBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAvLyBOYW1lc3BhY2UgaW1wb3J0XG4gICAgICByZXR1cm4gW21hdGNoWzJdXTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAvLyBEZWZhdWx0IGltcG9ydFxuICAgICAgcmV0dXJuIFttYXRjaFszXV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlSW1wb3J0RnJvbUxpbmUobGluZTogc3RyaW5nLCBpbXBvcnROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgaW1wb3J0IHBhdHRlcm5zXG4gICAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgICAvLyBSZW1vdmUgZnJvbSBuYW1lZCBpbXBvcnRzOiB7IG5hbWUxLCBuYW1lMiwgbmFtZTMgfSAtPiB7IG5hbWUxLCBuYW1lMyB9XG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKGBcXFxceyhbXn1dKj8pXFxcXGIke2ltcG9ydE5hbWV9XFxcXGIsPyhbXn1dKj8pXFxcXH1gLCAnZycpLFxuICAgICAgICByZXBsYWNlbWVudDogKG1hdGNoOiBzdHJpbmcsIGJlZm9yZTogc3RyaW5nLCBhZnRlcjogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xlYW5CZWZvcmUgPSBiZWZvcmUucmVwbGFjZSgvLFxccyokLywgJycpLnRyaW0oKTtcbiAgICAgICAgICBjb25zdCBjbGVhbkFmdGVyID0gYWZ0ZXIucmVwbGFjZSgvXlxccyosLywgJycpLnRyaW0oKTtcbiAgICAgICAgICBjb25zdCBjb21iaW5lZCA9IFtjbGVhbkJlZm9yZSwgY2xlYW5BZnRlcl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgcmV0dXJuIGB7JHtjb21iaW5lZH19YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG5cbiAgICBsZXQgbW9kaWZpZWRMaW5lID0gbGluZTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKHBhdHRlcm4ucmVnZXgsIHBhdHRlcm4ucmVwbGFjZW1lbnQgYXMgYW55KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZWRMaW5lO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBvcmdhbml6ZUltcG9ydHNJbkZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBcbiAgICAvLyBGaW5kIGltcG9ydCBzZWN0aW9uXG4gICAgY29uc3QgaW1wb3J0TGluZXM6IHsgbGluZTogc3RyaW5nOyBpbmRleDogbnVtYmVyOyBpc0V4dGVybmFsOiBib29sZWFuOyBpc1R5cGU6IGJvb2xlYW4gfVtdID0gW107XG4gICAgY29uc3QgaW1wb3J0UmVnZXggPSAvXmltcG9ydFxccysvO1xuICAgIGNvbnN0IHR5cGVJbXBvcnRSZWdleCA9IC9eaW1wb3J0XFxzK3R5cGVcXHMrLztcbiAgICBjb25zdCBleHRlcm5hbEltcG9ydFJlZ2V4ID0gL2Zyb21cXHMrWydcIl0oPyFbQC4vXSkvO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgIGlmIChpbXBvcnRSZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGltcG9ydExpbmVzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGxpbmVzW2ldLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGlzRXh0ZXJuYWw6IGV4dGVybmFsSW1wb3J0UmVnZXgudGVzdChsaW5lKSxcbiAgICAgICAgICBpc1R5cGU6IHR5cGVJbXBvcnRSZWdleC50ZXN0KGxpbmUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChsaW5lICYmICFsaW5lLnN0YXJ0c1dpdGgoJy8vJykgJiYgIWxpbmUuc3RhcnRzV2l0aCgnLyonKSkge1xuICAgICAgICAvLyBTdG9wIGF0IGZpcnN0IG5vbi1pbXBvcnQsIG5vbi1jb21tZW50IGxpbmVcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGltcG9ydExpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9yZ2FuaXplIGltcG9ydHMgYWNjb3JkaW5nIHRvIHJ1bGVzXG4gICAgY29uc3Qgb3JnYW5pemVkSW1wb3J0cyA9IHRoaXMub3JnYW5pemVJbXBvcnRMaW5lcyhpbXBvcnRMaW5lcyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgb3JnYW5pemF0aW9uIGNoYW5nZWQgYW55dGhpbmdcbiAgICBjb25zdCBvcmlnaW5hbEltcG9ydFNlY3Rpb24gPSBpbXBvcnRMaW5lcy5tYXAoaW1wID0+IGltcC5saW5lKS5qb2luKCdcXG4nKTtcbiAgICBjb25zdCBvcmdhbml6ZWRJbXBvcnRTZWN0aW9uID0gb3JnYW5pemVkSW1wb3J0cy5qb2luKCdcXG4nKTtcbiAgICBcbiAgICBpZiAob3JpZ2luYWxJbXBvcnRTZWN0aW9uID09PSBvcmdhbml6ZWRJbXBvcnRTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSBpbXBvcnQgc2VjdGlvblxuICAgIGNvbnN0IGZpcnN0SW1wb3J0SW5kZXggPSBpbXBvcnRMaW5lc1swXS5pbmRleDtcbiAgICBjb25zdCBsYXN0SW1wb3J0SW5kZXggPSBpbXBvcnRMaW5lc1tpbXBvcnRMaW5lcy5sZW5ndGggLSAxXS5pbmRleDtcbiAgICBcbiAgICBjb25zdCBuZXdMaW5lcyA9IFtcbiAgICAgIC4uLmxpbmVzLnNsaWNlKDAsIGZpcnN0SW1wb3J0SW5kZXgpLFxuICAgICAgLi4ub3JnYW5pemVkSW1wb3J0cyxcbiAgICAgIC4uLmxpbmVzLnNsaWNlKGxhc3RJbXBvcnRJbmRleCArIDEpXG4gICAgXTtcblxuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIG5ld0xpbmVzLmpvaW4oJ1xcbicpLCAndXRmOCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBvcmdhbml6ZUltcG9ydExpbmVzKGltcG9ydExpbmVzOiB7IGxpbmU6IHN0cmluZzsgaXNFeHRlcm5hbDogYm9vbGVhbjsgaXNUeXBlOiBib29sZWFuIH1bXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCB7IG9yZ2FuaXphdGlvblJ1bGVzIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBvcmdhbml6ZWQ6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBTZXBhcmF0ZSBpbXBvcnRzIGJ5IHR5cGVcbiAgICBjb25zdCBleHRlcm5hbEltcG9ydHMgPSBpbXBvcnRMaW5lcy5maWx0ZXIoaW1wID0+IGltcC5pc0V4dGVybmFsKTtcbiAgICBjb25zdCBpbnRlcm5hbEltcG9ydHMgPSBpbXBvcnRMaW5lcy5maWx0ZXIoaW1wID0+ICFpbXAuaXNFeHRlcm5hbCk7XG5cbiAgICAvLyBTb3J0IGZ1bmN0aW9uXG4gICAgY29uc3Qgc29ydEltcG9ydHMgPSAoaW1wb3J0czogdHlwZW9mIGltcG9ydExpbmVzKSA9PiB7XG4gICAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMuc29ydEFscGhhYmV0aWNhbGx5KSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRzLnNvcnQoKGEsIGIpID0+IGEubGluZS5sb2NhbGVDb21wYXJlKGIubGluZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGltcG9ydHM7XG4gICAgfTtcblxuICAgIC8vIFNlcGFyYXRlIHR5cGUgaW1wb3J0cyBpZiBjb25maWd1cmVkXG4gICAgaWYgKG9yZ2FuaXphdGlvblJ1bGVzLnNlcGFyYXRlVHlwZUltcG9ydHMpIHtcbiAgICAgIGNvbnN0IGV4dGVybmFsVHlwZUltcG9ydHMgPSBzb3J0SW1wb3J0cyhleHRlcm5hbEltcG9ydHMuZmlsdGVyKGltcCA9PiBpbXAuaXNUeXBlKSk7XG4gICAgICBjb25zdCBleHRlcm5hbFZhbHVlSW1wb3J0cyA9IHNvcnRJbXBvcnRzKGV4dGVybmFsSW1wb3J0cy5maWx0ZXIoaW1wID0+ICFpbXAuaXNUeXBlKSk7XG4gICAgICBjb25zdCBpbnRlcm5hbFR5cGVJbXBvcnRzID0gc29ydEltcG9ydHMoaW50ZXJuYWxJbXBvcnRzLmZpbHRlcihpbXAgPT4gaW1wLmlzVHlwZSkpO1xuICAgICAgY29uc3QgaW50ZXJuYWxWYWx1ZUltcG9ydHMgPSBzb3J0SW1wb3J0cyhpbnRlcm5hbEltcG9ydHMuZmlsdGVyKGltcCA9PiAhaW1wLmlzVHlwZSkpO1xuXG4gICAgICAvLyBBZGQgZXh0ZXJuYWwgaW1wb3J0c1xuICAgICAgaWYgKG9yZ2FuaXphdGlvblJ1bGVzLmdyb3VwRXh0ZXJuYWxJbXBvcnRzKSB7XG4gICAgICAgIG9yZ2FuaXplZC5wdXNoKC4uLmV4dGVybmFsVHlwZUltcG9ydHMubWFwKGltcCA9PiBpbXAubGluZSkpO1xuICAgICAgICBpZiAoZXh0ZXJuYWxUeXBlSW1wb3J0cy5sZW5ndGggPiAwICYmIGV4dGVybmFsVmFsdWVJbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcmdhbml6ZWQucHVzaCgnJyk7IC8vIEVtcHR5IGxpbmUgYmV0d2VlbiB0eXBlIGFuZCB2YWx1ZSBpbXBvcnRzXG4gICAgICAgIH1cbiAgICAgICAgb3JnYW5pemVkLnB1c2goLi4uZXh0ZXJuYWxWYWx1ZUltcG9ydHMubWFwKGltcCA9PiBpbXAubGluZSkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKChleHRlcm5hbFR5cGVJbXBvcnRzLmxlbmd0aCA+IDAgfHwgZXh0ZXJuYWxWYWx1ZUltcG9ydHMubGVuZ3RoID4gMCkgJiYgXG4gICAgICAgICAgICAoaW50ZXJuYWxUeXBlSW1wb3J0cy5sZW5ndGggPiAwIHx8IGludGVybmFsVmFsdWVJbXBvcnRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgb3JnYW5pemVkLnB1c2goJycpOyAvLyBFbXB0eSBsaW5lIGJldHdlZW4gZXh0ZXJuYWwgYW5kIGludGVybmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGludGVybmFsIGltcG9ydHNcbiAgICAgIGlmIChvcmdhbml6YXRpb25SdWxlcy5ncm91cEludGVybmFsSW1wb3J0cykge1xuICAgICAgICBvcmdhbml6ZWQucHVzaCguLi5pbnRlcm5hbFR5cGVJbXBvcnRzLm1hcChpbXAgPT4gaW1wLmxpbmUpKTtcbiAgICAgICAgaWYgKGludGVybmFsVHlwZUltcG9ydHMubGVuZ3RoID4gMCAmJiBpbnRlcm5hbFZhbHVlSW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3JnYW5pemVkLnB1c2goJycpOyAvLyBFbXB0eSBsaW5lIGJldHdlZW4gdHlwZSBhbmQgdmFsdWUgaW1wb3J0c1xuICAgICAgICB9XG4gICAgICAgIG9yZ2FuaXplZC5wdXNoKC4uLmludGVybmFsVmFsdWVJbXBvcnRzLm1hcChpbXAgPT4gaW1wLmxpbmUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3Qgc2VwYXJhdGUgdHlwZSBpbXBvcnRzXG4gICAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMuZ3JvdXBFeHRlcm5hbEltcG9ydHMpIHtcbiAgICAgICAgb3JnYW5pemVkLnB1c2goLi4uc29ydEltcG9ydHMoZXh0ZXJuYWxJbXBvcnRzKS5tYXAoaW1wID0+IGltcC5saW5lKSk7XG4gICAgICAgIGlmIChleHRlcm5hbEltcG9ydHMubGVuZ3RoID4gMCAmJiBpbnRlcm5hbEltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9yZ2FuaXplZC5wdXNoKCcnKTsgLy8gRW1wdHkgbGluZSBiZXR3ZWVuIGV4dGVybmFsIGFuZCBpbnRlcm5hbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmdhbml6YXRpb25SdWxlcy5ncm91cEludGVybmFsSW1wb3J0cykge1xuICAgICAgICBvcmdhbml6ZWQucHVzaCguLi5zb3J0SW1wb3J0cyhpbnRlcm5hbEltcG9ydHMpLm1hcChpbXAgPT4gaW1wLmxpbmUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JnYW5pemVkO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBlbmZvcmNlSW1wb3J0U3R5bGVJbkZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIGlmICgvXmltcG9ydFxccysvLnRlc3QobGluZS50cmltKCkpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlZExpbmUgPSB0aGlzLmFwcGx5SW1wb3J0U3R5bGUobGluZSk7XG4gICAgICAgIGlmIChzdHlsZWRMaW5lICE9PSBsaW5lKSB7XG4gICAgICAgICAgbGluZXNbaV0gPSBzdHlsZWRMaW5lO1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgbGluZXMuam9pbignXFxuJyksICd1dGY4Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGlmaWVkO1xuICB9XG5cbiAgcHJpdmF0ZSBhcHBseUltcG9ydFN0eWxlKGxpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBvcmdhbml6YXRpb25SdWxlcyB9ID0gdGhpcy5jb25maWc7XG4gICAgbGV0IHN0eWxlZExpbmUgPSBsaW5lO1xuXG4gICAgLy8gRW5mb3JjZSB0cmFpbGluZyBjb21tYXMgaW4gbXVsdGktbGluZSBpbXBvcnRzXG4gICAgaWYgKG9yZ2FuaXphdGlvblJ1bGVzLmVuZm9yY2VUcmFpbGluZ0NvbW1hcykge1xuICAgICAgc3R5bGVkTGluZSA9IHN0eWxlZExpbmUucmVwbGFjZSgvXFx7XFxzKihbXn1dK1teLF0pXFxzKlxcfS9nLCAobWF0Y2gsIGltcG9ydHMpID0+IHtcbiAgICAgICAgaWYgKGltcG9ydHMuaW5jbHVkZXMoJywnKSkge1xuICAgICAgICAgIHJldHVybiBgeyAke2ltcG9ydHMudHJpbSgpfSwgfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRW5mb3JjZSBsaW5lIGxlbmd0aCBsaW1pdHNcbiAgICBpZiAob3JnYW5pemF0aW9uUnVsZXMubWF4TGluZUxlbmd0aCAmJiBzdHlsZWRMaW5lLmxlbmd0aCA+IG9yZ2FuaXphdGlvblJ1bGVzLm1heExpbmVMZW5ndGgpIHtcbiAgICAgIC8vIEJyZWFrIGxvbmcgaW1wb3J0IGxpbmVzXG4gICAgICBjb25zdCBpbXBvcnRNYXRjaCA9IHN0eWxlZExpbmUubWF0Y2goL14oXFxzKmltcG9ydFxccysoPzp0eXBlXFxzKyk/XFx7KShbXn1dKykoXFx9XFxzK2Zyb21cXHMrLispJC8pO1xuICAgICAgaWYgKGltcG9ydE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IFssIHByZWZpeCwgaW1wb3J0cywgc3VmZml4XSA9IGltcG9ydE1hdGNoO1xuICAgICAgICBjb25zdCBpbXBvcnRMaXN0ID0gaW1wb3J0cy5zcGxpdCgnLCcpLm1hcChpbXAgPT4gaW1wLnRyaW0oKSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaW1wb3J0TGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW1wb3J0cyA9IGltcG9ydExpc3QubWFwKGltcCA9PiBgICAke2ltcH1gKS5qb2luKCcsXFxuJyk7XG4gICAgICAgICAgc3R5bGVkTGluZSA9IGAke3ByZWZpeH1cXG4ke2Zvcm1hdHRlZEltcG9ydHN9XFxuJHtzdWZmaXh9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZWRMaW5lO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRUeXBlU2NyaXB0RmlsZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhcbiAgICAgICAgJ2ZpbmQgc3JjIC1uYW1lIFwiKi50c1wiIC1vIC1uYW1lIFwiKi50c3hcIiB8IGdyZXAgLXYgX190ZXN0c19fIHwgZ3JlcCAtdiAudGVzdC4gfCBncmVwIC12IC5zcGVjLicsXG4gICAgICAgIHsgZW5jb2Rpbmc6ICd1dGY4Jywgc3RkaW86ICdwaXBlJyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIG91dHB1dC50cmltKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IFR5cGVTY3JpcHQgZmlsZXMnLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBiYXRjaEZpbGVzKGZpbGVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdW10ge1xuICAgIGNvbnN0IGJhdGNoZXM6IHN0cmluZ1tdW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSArPSB0aGlzLmNvbmZpZy5tYXhGaWxlc1BlckJhdGNoKSB7XG4gICAgICBiYXRjaGVzLnB1c2goZmlsZXMuc2xpY2UoaSwgaSArIHRoaXMuY29uZmlnLm1heEZpbGVzUGVyQmF0Y2gpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhdGNoZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlQnVpbGQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKCd5YXJuIHRzYyAtLW5vRW1pdCAtLXNraXBMaWJDaGVjaycsIHsgXG4gICAgICAgIGVuY29kaW5nOiAndXRmOCcsIFxuICAgICAgICBzdGRpbzogJ3BpcGUnLFxuICAgICAgICB0aW1lb3V0OiAzMDAwMCBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdCdWlsZCB2YWxpZGF0aW9uIGZhaWxlZCBkdXJpbmcgaW1wb3J0IGNsZWFudXAnLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBtZXJnZUJhdGNoUmVzdWx0cyh0b3RhbDogSW1wb3J0Q2xlYW51cFJlc3VsdCwgYmF0Y2g6IEltcG9ydENsZWFudXBSZXN1bHQpOiBJbXBvcnRDbGVhbnVwUmVzdWx0IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZXNQcm9jZXNzZWQ6IFsuLi50b3RhbC5maWxlc1Byb2Nlc3NlZCwgLi4uYmF0Y2guZmlsZXNQcm9jZXNzZWRdLFxuICAgICAgdW51c2VkSW1wb3J0c1JlbW92ZWQ6IHRvdGFsLnVudXNlZEltcG9ydHNSZW1vdmVkICsgYmF0Y2gudW51c2VkSW1wb3J0c1JlbW92ZWQsXG4gICAgICBpbXBvcnRzT3JnYW5pemVkOiB0b3RhbC5pbXBvcnRzT3JnYW5pemVkICsgYmF0Y2guaW1wb3J0c09yZ2FuaXplZCxcbiAgICAgIHN0eWxlVmlvbGF0aW9uc0ZpeGVkOiB0b3RhbC5zdHlsZVZpb2xhdGlvbnNGaXhlZCArIGJhdGNoLnN0eWxlVmlvbGF0aW9uc0ZpeGVkLFxuICAgICAgYnVpbGRWYWxpZGF0aW9uUGFzc2VkOiB0b3RhbC5idWlsZFZhbGlkYXRpb25QYXNzZWQgJiYgYmF0Y2guYnVpbGRWYWxpZGF0aW9uUGFzc2VkLFxuICAgICAgZXJyb3JzOiBbLi4udG90YWwuZXJyb3JzLCAuLi5iYXRjaC5lcnJvcnNdLFxuICAgICAgd2FybmluZ3M6IFsuLi50b3RhbC53YXJuaW5ncywgLi4uYmF0Y2gud2FybmluZ3NdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgaW1wb3J0IGNsZWFudXBcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU1QT1JUX0NMRUFOVVBfQ09ORklHOiBJbXBvcnRDbGVhbnVwQ29uZmlnID0ge1xuICBtYXhGaWxlc1BlckJhdGNoOiAyMCxcbiAgc2FmZXR5VmFsaWRhdGlvbkVuYWJsZWQ6IHRydWUsXG4gIGJ1aWxkVmFsaWRhdGlvbkZyZXF1ZW5jeTogNSxcbiAgaW1wb3J0U3R5bGVFbmZvcmNlbWVudDogdHJ1ZSxcbiAgb3JnYW5pemF0aW9uUnVsZXM6IHtcbiAgICBncm91cEV4dGVybmFsSW1wb3J0czogdHJ1ZSxcbiAgICBncm91cEludGVybmFsSW1wb3J0czogdHJ1ZSxcbiAgICBzb3J0QWxwaGFiZXRpY2FsbHk6IHRydWUsXG4gICAgc2VwYXJhdGVUeXBlSW1wb3J0czogdHJ1ZSxcbiAgICBlbmZvcmNlVHJhaWxpbmdDb21tYXM6IHRydWUsXG4gICAgbWF4TGluZUxlbmd0aDogMTAwXG4gIH1cbn07Il0sInZlcnNpb24iOjN9