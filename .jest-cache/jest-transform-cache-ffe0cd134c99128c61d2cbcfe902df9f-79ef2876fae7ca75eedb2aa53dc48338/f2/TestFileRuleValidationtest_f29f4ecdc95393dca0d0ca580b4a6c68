8baa37c5ef8ae71de99b550371dca2e0
"use strict";
/**
 * Test File Rule Validation Test Suite
 *
 * Tests the domain-specific ESLint rules for test files
 * to ensure appropriate relaxations for mock variables and testing patterns.
 *
 * Requirements: 4.4
 */
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
describe('Test File Rule Validation', () => {
    const projectRoot = process.cwd();
    const tempFiles = [];
    afterEach(() => {
        // Clean up temporary test files
        tempFiles.forEach(file => {
            try {
                (0, child_process_1.execSync)(`rm -f "${file}"`);
            }
            catch { }
        });
        tempFiles.length = 0;
    });
    describe('Mock Variable Relaxations', () => {
        test('should ignore unused mock variables', async () => {
            const testContent = `
        describe('Mock Variable Tests', () => {
          test('should handle mock variables', () => {
            const mockFunction = jest.fn();
            const _stubValue = 'test-stub';
            const testData = { id: 1, name: 'test' };
            const _mockObject = { method: jest.fn() };
            const _stubArray = [1, 2, 3];
            const _testConfig = { enabled: true };
            const UNUSED_mock = 'unused-mock';
            const UNUSED_stub = 'unused-stub';
            const UNUSED_test = 'unused-test';
            
            // Only use one variable to test unused variable handling
            expect(mockFunction).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-mock-variables.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('mock') || msg.message.includes('stub') || msg.message.includes('test')));
                    // Mock variable patterns should be ignored in test files
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('mock') || msg.message.includes('stub') || msg.message.includes('test')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow Jest mock functions', async () => {
            const testContent = `
        describe('Jest Mock Functions', () => {
          const mockCallback = jest.fn();
          const mockImplementation = jest.fn(() => 'mocked');
          const mockReturnValue = jest.fn().mockReturnValue('value');
          const mockResolvedValue = jest.fn().mockResolvedValue('resolved');
          const mockRejectedValue = jest.fn().mockRejectedValue(new Error('rejected'));
          
          beforeEach(() => {
            jest.clearAllMocks();
            mockCallback.mockClear();
            mockImplementation.mockReset();
            mockReturnValue.mockRestore();
          });
          
          test('should work with mocks', () => {
            expect(mockCallback).toHaveBeenCalledTimes(0);
            expect(mockImplementation()).toBe('mocked');
            expect(mockReturnValue()).toBe('value');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-mocks.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('mock'));
                    // Jest mock functions should be allowed
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('mock'));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow test data structures', async () => {
            const testContent = `
        describe('Test Data Structures', () => {
          const testUser = { id: 1, name: 'Test User', email: 'test@example.com' };
          const _testIngredient = { name: 'tomato', elementalProperties: { Fire: 0.3, Water: 0.7, Earth: 0.2, Air: 0.1 } };
          const _testRecipe = { id: 1, name: 'Test Recipe', ingredients: [] };
          const _testPlanetaryPosition = { sign: 'aries', degree: 8.5, exactLongitude: 8.5, isRetrograde: false };
          const _testConfig = { apiUrl: 'http://test.api', timeout: 5000 };
          const _testMetrics = { errors: 0, warnings: 5, processed: 100 };
          
          test('should use test data', () => {
            expect(testUser.id).toBe(1);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-data.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('test'));
                    // Test data structures should be allowed
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' && msg.message.includes('test'));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test-Specific Rule Relaxations', () => {
        test('should allow explicit any types in tests', async () => {
            const testContent = `
        describe('Any Type Tests', () => {
          test('should allow any types for flexible testing', () => {
            const anyValue: any = 'test-value';
            const anyObject: any = { prop: 'value' };
            const anyArray: any[] = [1, 'two', { three: 3 }];
            const anyFunction: any = () => 'result';
            
            // Test dynamic behavior
            anyObject.dynamicProperty = 'dynamic';
            anyArray.push({ dynamic: true });
            
            expect(anyValue).toBeDefined();
            expect(anyObject.prop).toBe('value');
            expect(anyArray.length).toBeGreaterThan(0);
            expect(anyFunction()).toBe('result');
          });
          
          test('should handle API responses with any', () => {
            const apiResponse: any = {
              data: { id: 1, name: 'test' },
              status: 200,
              headers: { 'content-type': 'application/json' }
            };
            
            expect(apiResponse.data.id).toBe(1);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-any-types.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const anyTypeErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2);
                    // Test files should allow explicit any types
                    expect(anyTypeErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const anyTypeErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2);
                        expect(anyTypeErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow console statements in tests', async () => {
            const testContent = `
        describe('Console Statement Tests', () => {
          test('should allow console output for debugging', () => {
            console.log('Test starting...');
            console.info('Processing test data');
            console.warn('This is a test warning');
            console.error('This is a test error (not real)');
            console.debug('Debug information for test');
            console.table([{ test: 'data', value: 123 }]);
            console.group('Test Group');
            console.log('Grouped test output');
            console.groupEnd();
            console.time('test-timer');
            console.timeEnd('test-timer');
            console.count('test-counter');
            
            expect(true).toBe(true);
          });
          
          beforeEach(() => {
            console.log('Setting up test...');
          });
          
          afterEach(() => {
            console.log('Cleaning up test...');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-console-statements.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2);
                    // Test files should allow console statements
                    expect(consoleErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2);
                        expect(consoleErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow non-null assertions in tests', async () => {
            const testContent = `
        describe('Non-null Assertion Tests', () => {
          test('should allow non-null assertions for test certainty', () => {
            const maybeValue: string | null = 'test-value';
            const maybeObject: { prop?: string } = { prop: 'value' };
            const maybeArray: number[] | undefined = [1, 2, 3];
            
            // Non-null assertions should be allowed in tests
            const definiteValue = maybeValue!;
            const definiteProperty = maybeObject.prop!;
            const definiteArray = maybeArray!;
            
            expect(definiteValue).toBe('test-value');
            expect(definiteProperty).toBe('value');
            expect(definiteArray.length).toBe(3);
            
            // Test DOM elements (common in React tests)
            const element = document.querySelector('.test-element')!;
            const button = document.getElementById('test-button')!;
            
            // These would normally be checked, but in tests we know they exist
            expect(element).toBeDefined();
            expect(button).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-non-null-assertions.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const nonNullErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2);
                    // Test files should allow non-null assertions
                    expect(nonNullErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const nonNullErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2);
                        expect(nonNullErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow magic numbers in tests', async () => {
            const testContent = `
        describe('Magic Numbers Tests', () => {
          test('should allow magic numbers for test values', () => {
            const testId = 12345;
            const testScore = 98.7;
            const testCount = 42;
            const testPercentage = 75.5;
            const _testTimeout = 5000;
            const _testPort = 3000;
            const testStatusCode = 200;
            const testErrorCode = 404;
            
            expect(testId).toBe(12345);
            expect(testScore).toBeCloseTo(98.7);
            expect(testCount).toBe(42);
            expect(testPercentage).toBe(75.5);
            
            // Common test patterns with magic numbers
            setTimeout(() => {}, 1000);
            expect(Array(10).fill(0)).toHaveLength(10);
            expect(Math.random() * 100).toBeLessThan(100);
            
            // HTTP status codes
            expect(testStatusCode).toBe(200);
            expect(testErrorCode).toBe(404);
          });
          
          test('should handle test data with magic numbers', () => {
            const testData = {
              users: Array(50).fill(null).map((_, i) => ({ id: i + 1 })),
              pageSize: 25,
              totalPages: 4,
              currentPage: 1
            };
            
            expect(testData.users).toHaveLength(50);
            expect(testData.pageSize).toBe(25);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-magic-numbers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const magicNumberErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-magic-numbers' && msg.severity === 2);
                    // Test files should allow magic numbers
                    expect(magicNumberErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const magicNumberErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-magic-numbers' && msg.severity === 2);
                        expect(magicNumberErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow relaxed complexity in tests', async () => {
            const testContent = `
        describe('Complex Test Logic', () => {
          test('should allow complex test scenarios', () => {
            // Complex test logic should be allowed
            const testScenarios = [
              { input: 'a', expected: 1 },
              { input: 'b', expected: 2 },
              { input: 'c', expected: 3 }
            ];
            
            testScenarios.forEach(scenario => {
              for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 3; j++) {
                  if (scenario.input === 'a') {
                    if (i > 2) {
                      if (j === 1) {
                        expect(scenario.expected).toBe(1);
                      } else if (j === 2) {
                        expect(scenario.expected).toBeGreaterThan(0);
                      } else {
                        expect(scenario.expected).toBeDefined();
                      }
                    } else {
                      expect(scenario.expected).toBeTruthy();
                    }
                  } else if (scenario.input === 'b') {
                    if (i < 3) {
                      expect(scenario.expected).toBe(2);
                    } else {
                      expect(scenario.expected).toBeGreaterThan(1);
                    }
                  } else {
                    expect(scenario.expected).toBe(3);
                  }
                }
              }
            });
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-complex-test.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2);
                    // Test files should allow complex logic
                    expect(complexityErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2);
                        expect(complexityErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Jest Globals Availability', () => {
        test('should have Jest globals available without no-undef errors', async () => {
            const testContent = `
        describe('Jest Globals Test', () => {
          beforeAll(() => {
            console.log('Before all tests');
          });
          
          beforeEach(() => {
            console.log('Before each test');
          });
          
          afterEach(() => {
            console.log('After each test');
          });
          
          afterAll(() => {
            console.log('After all tests');
          });
          
          test('should have access to Jest globals', () => {
            expect(true).toBe(true);
            expect(false).toBeFalsy();
            expect('string').toEqual('string');
            expect(42).toBeGreaterThan(0);
            expect([1, 2, 3]).toHaveLength(3);
            expect({ key: 'value' }).toHaveProperty('key');
          });
          
          it('should work with it() syntax', () => {
            expect(jest).toBeDefined();
            expect(describe).toBeDefined();
            expect(test).toBeDefined();
            expect(it).toBeDefined();
            expect(expect).toBeDefined();
          });
          
          test('should have Jest mock functions', () => {
            const mockFn = jest.fn();
            mockFn('test');
            
            expect(mockFn).toHaveBeenCalled();
            expect(mockFn).toHaveBeenCalledWith('test');
            expect(mockFn).toHaveBeenCalledTimes(1);
            
            jest.clearAllMocks();
            expect(mockFn).not.toHaveBeenCalled();
          });
          
          test('should have Jest spy functions', () => {
            const obj = { method: () => 'original' };
            const spy = jest.spyOn(obj, 'method').mockReturnValue('mocked');
            
            expect(obj.method()).toBe('mocked');
            expect(spy).toHaveBeenCalled();
            
            spy.mockRestore();
            expect(obj.method()).toBe('original');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-globals.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                        (msg.message.includes('describe') ||
                            msg.message.includes('it') ||
                            msg.message.includes('test') ||
                            msg.message.includes('expect') ||
                            msg.message.includes('jest') ||
                            msg.message.includes('beforeAll') ||
                            msg.message.includes('beforeEach') ||
                            msg.message.includes('afterEach') ||
                            msg.message.includes('afterAll')));
                    // Jest globals should be available without no-undef errors
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                            (msg.message.includes('describe') ||
                                msg.message.includes('it') ||
                                msg.message.includes('test') ||
                                msg.message.includes('expect') ||
                                msg.message.includes('jest') ||
                                msg.message.includes('beforeAll') ||
                                msg.message.includes('beforeEach') ||
                                msg.message.includes('afterEach') ||
                                msg.message.includes('afterAll')));
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should have additional Jest matchers available', async () => {
            const testContent = `
        describe('Jest Matchers Test', () => {
          test('should have extended Jest matchers', () => {
            // Basic matchers
            expect(true).toBeTruthy();
            expect(false).toBeFalsy();
            expect(null).toBeNull();
            expect(undefined).toBeUndefined();
            expect('defined').toBeDefined();
            
            // Number matchers
            expect(42).toBeGreaterThan(0);
            expect(42).toBeGreaterThanOrEqual(42);
            expect(42).toBeLessThan(100);
            expect(42).toBeLessThanOrEqual(42);
            expect(3.14).toBeCloseTo(3.1, 1);
            
            // String matchers
            expect('hello world').toMatch(/world/);
            expect('hello world').toContain('world');
            
            // Array matchers
            expect([1, 2, 3]).toHaveLength(3);
            expect([1, 2, 3]).toContain(2);
            expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 3]));
            
            // Object matchers
            expect({ a: 1, b: 2 }).toHaveProperty('a');
            expect({ a: 1, b: 2 }).toHaveProperty('a', 1);
            expect({ a: 1, b: 2 }).toMatchObject({ a: 1 });
            
            // Function matchers
            const mockFn = jest.fn();
            mockFn('arg1', 'arg2');
            expect(mockFn).toHaveBeenCalled();
            expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
            expect(mockFn).toHaveBeenCalledTimes(1);
            expect(mockFn).toHaveBeenLastCalledWith('arg1', 'arg2');
            
            // Promise matchers (async)
            expect(Promise.resolve('value')).resolves.toBe('value');
            expect(Promise.reject(new Error('error'))).rejects.toThrow('error');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-matchers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                    // No undefined variable errors should occur
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test File Pattern Matching', () => {
        test('should apply test rules to correct file patterns', () => {
            const testFiles = [
                'src/components/FoodRecommender.test.tsx',
                'src/utils/astrology.spec.ts',
                'src/services/campaign.test.ts',
                'src/__tests__/calculations/culinaryAstrology.test.ts',
                'src/__tests__/utils/reliableAstronomy.spec.ts',
                'tests/integration/api.test.js',
            ];
            testFiles.forEach(file => {
                // Check if file would match test patterns in ESLint config
                const matchesTestPattern = file.includes('.test.') || file.includes('.spec.') || file.includes('__tests__/') || file.includes('/tests/');
                expect(matchesTestPattern).toBe(true);
            });
        });
        test('should not apply test rules to non-test files', () => {
            const nonTestFiles = [
                'src/components/FoodRecommender.tsx',
                'src/utils/astrology.ts',
                'src/services/campaign.ts',
                'src/calculations/culinaryAstrology.ts',
                'src/data/ingredients/vegetables.ts',
            ];
            nonTestFiles.forEach(file => {
                // Check that file would NOT match test patterns
                const matchesTestPattern = file.includes('.test.') || file.includes('.spec.') || file.includes('__tests__/') || file.includes('/tests/');
                expect(matchesTestPattern).toBe(false);
            });
        });
    });
    describe('Test Environment Configuration', () => {
        test('should have proper Jest environment globals', async () => {
            const testContent = `
        describe('Environment Globals', () => {
          test('should have Node.js globals available', () => {
            expect(process).toBeDefined();
            expect(Buffer).toBeDefined();
            expect(global).toBeDefined();
            expect(__dirname).toBeDefined();
            expect(__filename).toBeDefined();
          });
          
          test('should have browser globals available', () => {
            // These might not be available in Node environment
            // but should not cause no-undef errors if configured properly
            if (typeof window !== 'undefined') {
              expect(window).toBeDefined();
              expect(document).toBeDefined();
            }
          });
          
          test('should have common JavaScript globals', () => {
            expect(console).toBeDefined();
            expect(setTimeout).toBeDefined();
            expect(setInterval).toBeDefined();
            expect(clearTimeout).toBeDefined();
            expect(clearInterval).toBeDefined();
            expect(Promise).toBeDefined();
            expect(Array).toBeDefined();
            expect(Object).toBeDefined();
            expect(JSON).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-environment-globals.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                    // Environment globals should be available
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test-Specific Patterns', () => {
        test('should allow test helper functions', async () => {
            const testContent = `
        describe('Test Helpers', () => {
          // Test helper functions should be allowed even if unused
          const createTestUser = (overrides = {}) => ({
            id: 1,
            name: 'Test User',
            email: 'test@example.com',
            ...overrides
          });
          
          const createTestIngredient = (name = 'tomato') => ({
            name,
            elementalProperties: { Fire: 0.3, Water: 0.7, Earth: 0.2, Air: 0.1 }
          });
          
          const _mockApiResponse = (data: any, status = 200) => ({
            data,
            status,
            headers: { 'content-type': 'application/json' }
          });
          
          const _setupTestEnvironment = () => {
            // Setup code
            return { initialized: true };
          };
          
          const _teardownTestEnvironment = () => {
            // Cleanup code
          };
          
          test('should use test helpers', () => {
            const user = createTestUser({ name: 'Custom User' });
            expect(user.name).toBe('Custom User');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-helpers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot,
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('createTest') ||
                            msg.message.includes('mockApi') ||
                            msg.message.includes('setupTest') ||
                            msg.message.includes('teardownTest')));
                    // Test helper functions should be allowed even if unused
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('createTest') ||
                                msg.message.includes('mockApi') ||
                                msg.message.includes('setupTest') ||
                                msg.message.includes('teardownTest')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9fX3Rlc3RzX18vbGludGluZy9UZXN0RmlsZVJ1bGVWYWxpZGF0aW9uLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7O0dBT0c7O0FBRUgsaURBQXlDO0FBQ3pDLDJCQUFtQztBQUNuQywrQkFBNEI7QUFFNUIsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtJQUN6QyxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxTQUFTLEdBQWEsRUFBRSxDQUFDO0lBRS9CLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYixnQ0FBZ0M7UUFDaEMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixJQUFJO2dCQUNGLElBQUEsd0JBQVEsRUFBQyxVQUFVLElBQUksR0FBRyxDQUFDLENBQUM7YUFDN0I7WUFBQyxNQUFNLEdBQUU7UUFDWixDQUFDLENBQUMsQ0FBQztRQUNILFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtRQUN6QyxJQUFJLENBQUMscUNBQXFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDckQsTUFBTSxXQUFXLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJuQixDQUFDO1lBRUYsTUFBTSxRQUFRLEdBQUcsSUFBQSxXQUFJLEVBQUMsV0FBVyxFQUFFLDZCQUE2QixDQUFDLENBQUM7WUFDbEUsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN6QixJQUFBLGtCQUFhLEVBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBRXJDLElBQUk7Z0JBQ0YsTUFBTSxNQUFNLEdBQUcsSUFBQSx3QkFBUSxFQUFDLGVBQWUsUUFBUSw0Q0FBNEMsRUFBRTtvQkFDM0YsUUFBUSxFQUFFLE1BQU07b0JBQ2hCLEdB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TUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQy9DLENBQUMsR0FBWSxFQUFFLEVBQUUsQ0FDZixHQUFHLENBQUMsTUFBTSxLQUFLLG1DQUFtQzs0QkFDbEQsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUM7Z0NBQ2pDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztnQ0FDL0IsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO2dDQUNqQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUMxQyxDQUFDO3dCQUVGLE1BQU0sQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN4QztpQkFDRjthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvX190ZXN0c19fL2xpbnRpbmcvVGVzdEZpbGVSdWxlVmFsaWRhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdCBGaWxlIFJ1bGUgVmFsaWRhdGlvbiBUZXN0IFN1aXRlXG4gKlxuICogVGVzdHMgdGhlIGRvbWFpbi1zcGVjaWZpYyBFU0xpbnQgcnVsZXMgZm9yIHRlc3QgZmlsZXNcbiAqIHRvIGVuc3VyZSBhcHByb3ByaWF0ZSByZWxheGF0aW9ucyBmb3IgbW9jayB2YXJpYWJsZXMgYW5kIHRlc3RpbmcgcGF0dGVybnMuXG4gKlxuICogUmVxdWlyZW1lbnRzOiA0LjRcbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgd3JpdGVGaWxlU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxuZGVzY3JpYmUoJ1Rlc3QgRmlsZSBSdWxlIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gIGNvbnN0IHByb2plY3RSb290ID0gcHJvY2Vzcy5jd2QoKTtcbiAgY29uc3QgdGVtcEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gQ2xlYW4gdXAgdGVtcG9yYXJ5IHRlc3QgZmlsZXNcbiAgICB0ZW1wRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV4ZWNTeW5jKGBybSAtZiBcIiR7ZmlsZX1cImApO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH0pO1xuICAgIHRlbXBGaWxlcy5sZW5ndGggPSAwO1xuICB9KTtcblxuICBkZXNjcmliZSgnTW9jayBWYXJpYWJsZSBSZWxheGF0aW9ucycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaWdub3JlIHVudXNlZCBtb2NrIHZhcmlhYmxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnTW9jayBWYXJpYWJsZSBUZXN0cycsICgpID0+IHtcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG1vY2sgdmFyaWFibGVzJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0Z1bmN0aW9uID0gamVzdC5mbigpO1xuICAgICAgICAgICAgY29uc3QgX3N0dWJWYWx1ZSA9ICd0ZXN0LXN0dWInO1xuICAgICAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAndGVzdCcgfTtcbiAgICAgICAgICAgIGNvbnN0IF9tb2NrT2JqZWN0ID0geyBtZXRob2Q6IGplc3QuZm4oKSB9O1xuICAgICAgICAgICAgY29uc3QgX3N0dWJBcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgICAgICAgIGNvbnN0IF90ZXN0Q29uZmlnID0geyBlbmFibGVkOiB0cnVlIH07XG4gICAgICAgICAgICBjb25zdCBVTlVTRURfbW9jayA9ICd1bnVzZWQtbW9jayc7XG4gICAgICAgICAgICBjb25zdCBVTlVTRURfc3R1YiA9ICd1bnVzZWQtc3R1Yic7XG4gICAgICAgICAgICBjb25zdCBVTlVTRURfdGVzdCA9ICd1bnVzZWQtdGVzdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIG9uZSB2YXJpYWJsZSB0byB0ZXN0IHVudXNlZCB2YXJpYWJsZSBoYW5kbGluZ1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tGdW5jdGlvbikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLW1vY2stdmFyaWFibGVzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PlxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ21vY2snKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc3R1YicpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0JykpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBNb2NrIHZhcmlhYmxlIHBhdHRlcm5zIHNob3VsZCBiZSBpZ25vcmVkIGluIHRlc3QgZmlsZXNcbiAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+XG4gICAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiZcbiAgICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ21vY2snKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc3R1YicpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0JykpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgSmVzdCBtb2NrIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnSmVzdCBNb2NrIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2NrQ2FsbGJhY2sgPSBqZXN0LmZuKCk7XG4gICAgICAgICAgY29uc3QgbW9ja0ltcGxlbWVudGF0aW9uID0gamVzdC5mbigoKSA9PiAnbW9ja2VkJyk7XG4gICAgICAgICAgY29uc3QgbW9ja1JldHVyblZhbHVlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgndmFsdWUnKTtcbiAgICAgICAgICBjb25zdCBtb2NrUmVzb2x2ZWRWYWx1ZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgncmVzb2x2ZWQnKTtcbiAgICAgICAgICBjb25zdCBtb2NrUmVqZWN0ZWRWYWx1ZSA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ3JlamVjdGVkJykpO1xuICAgICAgICAgIFxuICAgICAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgICAgICBtb2NrQ2FsbGJhY2subW9ja0NsZWFyKCk7XG4gICAgICAgICAgICBtb2NrSW1wbGVtZW50YXRpb24ubW9ja1Jlc2V0KCk7XG4gICAgICAgICAgICBtb2NrUmV0dXJuVmFsdWUubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgd29yayB3aXRoIG1vY2tzJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tDYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDApO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tJbXBsZW1lbnRhdGlvbigpKS50b0JlKCdtb2NrZWQnKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmV0dXJuVmFsdWUoKSkudG9CZSgndmFsdWUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWplc3QtbW9ja3MudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrJyksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEplc3QgbW9jayBmdW5jdGlvbnMgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrJyksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyB0ZXN0IGRhdGEgc3RydWN0dXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnVGVzdCBEYXRhIFN0cnVjdHVyZXMnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGVzdFVzZXIgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCBVc2VyJywgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9O1xuICAgICAgICAgIGNvbnN0IF90ZXN0SW5ncmVkaWVudCA9IHsgbmFtZTogJ3RvbWF0bycsIGVsZW1lbnRhbFByb3BlcnRpZXM6IHsgRmlyZTogMC4zLCBXYXRlcjogMC43LCBFYXJ0aDogMC4yLCBBaXI6IDAuMSB9IH07XG4gICAgICAgICAgY29uc3QgX3Rlc3RSZWNpcGUgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCBSZWNpcGUnLCBpbmdyZWRpZW50czogW10gfTtcbiAgICAgICAgICBjb25zdCBfdGVzdFBsYW5ldGFyeVBvc2l0aW9uID0geyBzaWduOiAnYXJpZXMnLCBkZWdyZWU6IDguNSwgZXhhY3RMb25naXR1ZGU6IDguNSwgaXNSZXRyb2dyYWRlOiBmYWxzZSB9O1xuICAgICAgICAgIGNvbnN0IF90ZXN0Q29uZmlnID0geyBhcGlVcmw6ICdodHRwOi8vdGVzdC5hcGknLCB0aW1lb3V0OiA1MDAwIH07XG4gICAgICAgICAgY29uc3QgX3Rlc3RNZXRyaWNzID0geyBlcnJvcnM6IDAsIHdhcm5pbmdzOiA1LCBwcm9jZXNzZWQ6IDEwMCB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCB1c2UgdGVzdCBkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RVc2VyLmlkKS50b0JlKDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtdGVzdC1kYXRhLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJiBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBUZXN0IGRhdGEgc3RydWN0dXJlcyBzaG91bGQgYmUgYWxsb3dlZFxuICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgICAgKG1zZzogdW5rbm93bikgPT4gKG1zZyBhcyBhbnkpLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiYgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3Rlc3QnKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdC1TcGVjaWZpYyBSdWxlIFJlbGF4YXRpb25zJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBleHBsaWNpdCBhbnkgdHlwZXMgaW4gdGVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgZGVzY3JpYmUoJ0FueSBUeXBlIFRlc3RzJywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBhbnkgdHlwZXMgZm9yIGZsZXhpYmxlIHRlc3RpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbnlWYWx1ZTogYW55ID0gJ3Rlc3QtdmFsdWUnO1xuICAgICAgICAgICAgY29uc3QgYW55T2JqZWN0OiBhbnkgPSB7IHByb3A6ICd2YWx1ZScgfTtcbiAgICAgICAgICAgIGNvbnN0IGFueUFycmF5OiBhbnlbXSA9IFsxLCAndHdvJywgeyB0aHJlZTogMyB9XTtcbiAgICAgICAgICAgIGNvbnN0IGFueUZ1bmN0aW9uOiBhbnkgPSAoKSA9PiAncmVzdWx0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGVzdCBkeW5hbWljIGJlaGF2aW9yXG4gICAgICAgICAgICBhbnlPYmplY3QuZHluYW1pY1Byb3BlcnR5ID0gJ2R5bmFtaWMnO1xuICAgICAgICAgICAgYW55QXJyYXkucHVzaCh7IGR5bmFtaWM6IHRydWUgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChhbnlWYWx1ZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChhbnlPYmplY3QucHJvcCkudG9CZSgndmFsdWUnKTtcbiAgICAgICAgICAgIGV4cGVjdChhbnlBcnJheS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgIGV4cGVjdChhbnlGdW5jdGlvbigpKS50b0JlKCdyZXN1bHQnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIEFQSSByZXNwb25zZXMgd2l0aCBhbnknLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcGlSZXNwb25zZTogYW55ID0ge1xuICAgICAgICAgICAgICBkYXRhOiB7IGlkOiAxLCBuYW1lOiAndGVzdCcgfSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoYXBpUmVzcG9uc2UuZGF0YS5pZCkudG9CZSgxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWFueS10eXBlcy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBhbnlUeXBlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55JyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IGV4cGxpY2l0IGFueSB0eXBlc1xuICAgICAgICAgIGV4cGVjdChhbnlUeXBlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVR5cGVFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueScgJiYgbXNnLnNldmVyaXR5ID09PSAyLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KGFueVR5cGVFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IGNvbnNvbGUgc3RhdGVtZW50cyBpbiB0ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnQ29uc29sZSBTdGF0ZW1lbnQgVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IGNvbnNvbGUgb3V0cHV0IGZvciBkZWJ1Z2dpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVzdCBzdGFydGluZy4uLicpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdQcm9jZXNzaW5nIHRlc3QgZGF0YScpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIGlzIGEgdGVzdCB3YXJuaW5nJyk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGlzIGlzIGEgdGVzdCBlcnJvciAobm90IHJlYWwpJyk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgdGVzdCcpO1xuICAgICAgICAgICAgY29uc29sZS50YWJsZShbeyB0ZXN0OiAnZGF0YScsIHZhbHVlOiAxMjMgfV0pO1xuICAgICAgICAgICAgY29uc29sZS5ncm91cCgnVGVzdCBHcm91cCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dyb3VwZWQgdGVzdCBvdXRwdXQnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZSgndGVzdC10aW1lcicpO1xuICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKCd0ZXN0LXRpbWVyJyk7XG4gICAgICAgICAgICBjb25zb2xlLmNvdW50KCd0ZXN0LWNvdW50ZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1cCB0ZXN0Li4uJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGVhbmluZyB1cCB0ZXN0Li4uJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1jb25zb2xlLXN0YXRlbWVudHMudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgY29uc29sZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnbm8tY29uc29sZScgJiYgbXNnLnNldmVyaXR5ID09PSAyLCAvLyBlcnJvciBsZXZlbFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBUZXN0IGZpbGVzIHNob3VsZCBhbGxvdyBjb25zb2xlIHN0YXRlbWVudHNcbiAgICAgICAgICBleHBlY3QoY29uc29sZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zb2xlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgICAgKG1zZzogdW5rbm93bikgPT4gKG1zZyBhcyBhbnkpLnJ1bGVJZCA9PT0gJ25vLWNvbnNvbGUnICYmIG1zZy5zZXZlcml0eSA9PT0gMixcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBub24tbnVsbCBhc3NlcnRpb25zIGluIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdOb24tbnVsbCBBc3NlcnRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IG5vbi1udWxsIGFzc2VydGlvbnMgZm9yIHRlc3QgY2VydGFpbnR5JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF5YmVWYWx1ZTogc3RyaW5nIHwgbnVsbCA9ICd0ZXN0LXZhbHVlJztcbiAgICAgICAgICAgIGNvbnN0IG1heWJlT2JqZWN0OiB7IHByb3A/OiBzdHJpbmcgfSA9IHsgcHJvcDogJ3ZhbHVlJyB9O1xuICAgICAgICAgICAgY29uc3QgbWF5YmVBcnJheTogbnVtYmVyW10gfCB1bmRlZmluZWQgPSBbMSwgMiwgM107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE5vbi1udWxsIGFzc2VydGlvbnMgc2hvdWxkIGJlIGFsbG93ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRlVmFsdWUgPSBtYXliZVZhbHVlITtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRlUHJvcGVydHkgPSBtYXliZU9iamVjdC5wcm9wITtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRlQXJyYXkgPSBtYXliZUFycmF5ITtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGRlZmluaXRlVmFsdWUpLnRvQmUoJ3Rlc3QtdmFsdWUnKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWZpbml0ZVByb3BlcnR5KS50b0JlKCd2YWx1ZScpO1xuICAgICAgICAgICAgZXhwZWN0KGRlZmluaXRlQXJyYXkubGVuZ3RoKS50b0JlKDMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUZXN0IERPTSBlbGVtZW50cyAoY29tbW9uIGluIFJlYWN0IHRlc3RzKVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXN0LWVsZW1lbnQnKSE7XG4gICAgICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdC1idXR0b24nKSE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRoZXNlIHdvdWxkIG5vcm1hbGx5IGJlIGNoZWNrZWQsIGJ1dCBpbiB0ZXN0cyB3ZSBrbm93IHRoZXkgZXhpc3RcbiAgICAgICAgICAgIGV4cGVjdChlbGVtZW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGJ1dHRvbikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLW5vbi1udWxsLWFzc2VydGlvbnMudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3Qgbm9uTnVsbEVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbicgJiYgbXNnLnNldmVyaXR5ID09PSAyLCAvLyBlcnJvciBsZXZlbFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBUZXN0IGZpbGVzIHNob3VsZCBhbGxvdyBub24tbnVsbCBhc3NlcnRpb25zXG4gICAgICAgICAgZXhwZWN0KG5vbk51bGxFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3Qgbm9uTnVsbEVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3Qobm9uTnVsbEVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgbWFnaWMgbnVtYmVycyBpbiB0ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnTWFnaWMgTnVtYmVycyBUZXN0cycsICgpID0+IHtcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgYWxsb3cgbWFnaWMgbnVtYmVycyBmb3IgdGVzdCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0SWQgPSAxMjM0NTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RTY29yZSA9IDk4Ljc7XG4gICAgICAgICAgICBjb25zdCB0ZXN0Q291bnQgPSA0MjtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQZXJjZW50YWdlID0gNzUuNTtcbiAgICAgICAgICAgIGNvbnN0IF90ZXN0VGltZW91dCA9IDUwMDA7XG4gICAgICAgICAgICBjb25zdCBfdGVzdFBvcnQgPSAzMDAwO1xuICAgICAgICAgICAgY29uc3QgdGVzdFN0YXR1c0NvZGUgPSAyMDA7XG4gICAgICAgICAgICBjb25zdCB0ZXN0RXJyb3JDb2RlID0gNDA0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QodGVzdElkKS50b0JlKDEyMzQ1KTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0U2NvcmUpLnRvQmVDbG9zZVRvKDk4LjcpO1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RDb3VudCkudG9CZSg0Mik7XG4gICAgICAgICAgICBleHBlY3QodGVzdFBlcmNlbnRhZ2UpLnRvQmUoNzUuNSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0IHBhdHRlcm5zIHdpdGggbWFnaWMgbnVtYmVyc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7fSwgMTAwMCk7XG4gICAgICAgICAgICBleHBlY3QoQXJyYXkoMTApLmZpbGwoMCkpLnRvSGF2ZUxlbmd0aCgxMCk7XG4gICAgICAgICAgICBleHBlY3QoTWF0aC5yYW5kb20oKSAqIDEwMCkudG9CZUxlc3NUaGFuKDEwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhUVFAgc3RhdHVzIGNvZGVzXG4gICAgICAgICAgICBleHBlY3QodGVzdFN0YXR1c0NvZGUpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0RXJyb3JDb2RlKS50b0JlKDQwNCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB0ZXN0IGRhdGEgd2l0aCBtYWdpYyBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7XG4gICAgICAgICAgICAgIHVzZXJzOiBBcnJheSg1MCkuZmlsbChudWxsKS5tYXAoKF8sIGkpID0+ICh7IGlkOiBpICsgMSB9KSksXG4gICAgICAgICAgICAgIHBhZ2VTaXplOiAyNSxcbiAgICAgICAgICAgICAgdG90YWxQYWdlczogNCxcbiAgICAgICAgICAgICAgY3VycmVudFBhZ2U6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0RGF0YS51c2VycykudG9IYXZlTGVuZ3RoKDUwKTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0RGF0YS5wYWdlU2l6ZSkudG9CZSgyNSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1tYWdpYy1udW1iZXJzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IG1hZ2ljTnVtYmVyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICduby1tYWdpYy1udW1iZXJzJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICBleHBlY3QobWFnaWNOdW1iZXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgbWFnaWNOdW1iZXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnbm8tbWFnaWMtbnVtYmVycycgJiYgbXNnLnNldmVyaXR5ID09PSAyLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KG1hZ2ljTnVtYmVyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyByZWxheGVkIGNvbXBsZXhpdHkgaW4gdGVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgZGVzY3JpYmUoJ0NvbXBsZXggVGVzdCBMb2dpYycsICgpID0+IHtcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgYWxsb3cgY29tcGxleCB0ZXN0IHNjZW5hcmlvcycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIENvbXBsZXggdGVzdCBsb2dpYyBzaG91bGQgYmUgYWxsb3dlZFxuICAgICAgICAgICAgY29uc3QgdGVzdFNjZW5hcmlvcyA9IFtcbiAgICAgICAgICAgICAgeyBpbnB1dDogJ2EnLCBleHBlY3RlZDogMSB9LFxuICAgICAgICAgICAgICB7IGlucHV0OiAnYicsIGV4cGVjdGVkOiAyIH0sXG4gICAgICAgICAgICAgIHsgaW5wdXQ6ICdjJywgZXhwZWN0ZWQ6IDMgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGVzdFNjZW5hcmlvcy5mb3JFYWNoKHNjZW5hcmlvID0+IHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgICAgaWYgKHNjZW5hcmlvLmlucHV0ID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZVRydXRoeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjZW5hcmlvLmlucHV0ID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlKDIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZUdyZWF0ZXJUaGFuKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmUoMyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWNvbXBsZXgtdGVzdC50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBjb21wbGV4aXR5RXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICdjb21wbGV4aXR5JyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIsIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IGNvbXBsZXggbG9naWNcbiAgICAgICAgICBleHBlY3QoY29tcGxleGl0eUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wbGV4aXR5RXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgICAgICAgKG1zZzogdW5rbm93bikgPT4gKG1zZyBhcyBhbnkpLnJ1bGVJZCA9PT0gJ2NvbXBsZXhpdHknICYmIG1zZy5zZXZlcml0eSA9PT0gMixcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChjb21wbGV4aXR5RXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0plc3QgR2xvYmFscyBBdmFpbGFiaWxpdHknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBnbG9iYWxzIGF2YWlsYWJsZSB3aXRob3V0IG5vLXVuZGVmIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnSmVzdCBHbG9iYWxzIFRlc3QnLCAoKSA9PiB7XG4gICAgICAgICAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgYWxsIHRlc3RzJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmVmb3JlIGVhY2ggdGVzdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQWZ0ZXIgZWFjaCB0ZXN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FmdGVyIGFsbCB0ZXN0cycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGFjY2VzcyB0byBKZXN0IGdsb2JhbHMnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChmYWxzZSkudG9CZUZhbHN5KCk7XG4gICAgICAgICAgICBleHBlY3QoJ3N0cmluZycpLnRvRXF1YWwoJ3N0cmluZycpO1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgICAgICBleHBlY3QoeyBrZXk6ICd2YWx1ZScgfSkudG9IYXZlUHJvcGVydHkoJ2tleScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGl0KCdzaG91bGQgd29yayB3aXRoIGl0KCkgc3ludGF4JywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGplc3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZGVzY3JpYmUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QodGVzdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChpdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBlY3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBtb2NrIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGbiA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIG1vY2tGbigndGVzdCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdCcpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tGbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBzcHkgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0geyBtZXRob2Q6ICgpID0+ICdvcmlnaW5hbCcgfTtcbiAgICAgICAgICAgIGNvbnN0IHNweSA9IGplc3Quc3B5T24ob2JqLCAnbWV0aG9kJykubW9ja1JldHVyblZhbHVlKCdtb2NrZWQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KG9iai5tZXRob2QoKSkudG9CZSgnbW9ja2VkJyk7XG4gICAgICAgICAgICBleHBlY3Qoc3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNweS5tb2NrUmVzdG9yZSgpO1xuICAgICAgICAgICAgZXhwZWN0KG9iai5tZXRob2QoKSkudG9CZSgnb3JpZ2luYWwnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWplc3QtZ2xvYmFscy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PlxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnbm8tdW5kZWYnICYmXG4gICAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnZGVzY3JpYmUnKSB8fFxuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdpdCcpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3Rlc3QnKSB8fFxuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdleHBlY3QnKSB8fFxuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdqZXN0JykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYmVmb3JlQWxsJykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYmVmb3JlRWFjaCcpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2FmdGVyRWFjaCcpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2FmdGVyQWxsJykpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBKZXN0IGdsb2JhbHMgc2hvdWxkIGJlIGF2YWlsYWJsZSB3aXRob3V0IG5vLXVuZGVmIGVycm9yc1xuICAgICAgICAgIGV4cGVjdCh1bmRlZkVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoXG4gICAgICAgICAgICAgIChtc2c6IHVua25vd24pID0+XG4gICAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ25vLXVuZGVmJyAmJlxuICAgICAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnZGVzY3JpYmUnKSB8fFxuICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2l0JykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0JykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdleHBlY3QnKSB8fFxuICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2plc3QnKSB8fFxuICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2JlZm9yZUFsbCcpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYmVmb3JlRWFjaCcpIHx8XG4gICAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYWZ0ZXJFYWNoJykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdhZnRlckFsbCcpKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdCh1bmRlZkVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBhZGRpdGlvbmFsIEplc3QgbWF0Y2hlcnMgYXZhaWxhYmxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdKZXN0IE1hdGNoZXJzIFRlc3QnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgZXh0ZW5kZWQgSmVzdCBtYXRjaGVycycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJhc2ljIG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZVRydXRoeSgpO1xuICAgICAgICAgICAgZXhwZWN0KGZhbHNlKS50b0JlRmFsc3koKTtcbiAgICAgICAgICAgIGV4cGVjdChudWxsKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KCdkZWZpbmVkJykudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTnVtYmVyIG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QoNDIpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgIGV4cGVjdCg0MikudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCg0Mik7XG4gICAgICAgICAgICBleHBlY3QoNDIpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlTGVzc1RoYW5PckVxdWFsKDQyKTtcbiAgICAgICAgICAgIGV4cGVjdCgzLjE0KS50b0JlQ2xvc2VUbygzLjEsIDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdHJpbmcgbWF0Y2hlcnNcbiAgICAgICAgICAgIGV4cGVjdCgnaGVsbG8gd29ybGQnKS50b01hdGNoKC93b3JsZC8pO1xuICAgICAgICAgICAgZXhwZWN0KCdoZWxsbyB3b3JsZCcpLnRvQ29udGFpbignd29ybGQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkgbWF0Y2hlcnNcbiAgICAgICAgICAgIGV4cGVjdChbMSwgMiwgM10pLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgICAgICAgIGV4cGVjdChbMSwgMiwgM10pLnRvQ29udGFpbigyKTtcbiAgICAgICAgICAgIGV4cGVjdChbMSwgMiwgM10pLnRvRXF1YWwoZXhwZWN0LmFycmF5Q29udGFpbmluZyhbMSwgM10pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gT2JqZWN0IG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QoeyBhOiAxLCBiOiAyIH0pLnRvSGF2ZVByb3BlcnR5KCdhJyk7XG4gICAgICAgICAgICBleHBlY3QoeyBhOiAxLCBiOiAyIH0pLnRvSGF2ZVByb3BlcnR5KCdhJywgMSk7XG4gICAgICAgICAgICBleHBlY3QoeyBhOiAxLCBiOiAyIH0pLnRvTWF0Y2hPYmplY3QoeyBhOiAxIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGdW5jdGlvbiBtYXRjaGVyc1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZuID0gamVzdC5mbigpO1xuICAgICAgICAgICAgbW9ja0ZuKCdhcmcxJywgJ2FyZzInKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhcmcxJywgJ2FyZzInKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLnRvSGF2ZUJlZW5MYXN0Q2FsbGVkV2l0aCgnYXJnMScsICdhcmcyJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFByb21pc2UgbWF0Y2hlcnMgKGFzeW5jKVxuICAgICAgICAgICAgZXhwZWN0KFByb21pc2UucmVzb2x2ZSgndmFsdWUnKSkucmVzb2x2ZXMudG9CZSgndmFsdWUnKTtcbiAgICAgICAgICAgIGV4cGVjdChQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Vycm9yJykpKS5yZWplY3RzLnRvVGhyb3coJ2Vycm9yJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1qZXN0LW1hdGNoZXJzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHVuZGVmRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnbm8tdW5kZWYnKTtcblxuICAgICAgICAgIC8vIE5vIHVuZGVmaW5lZCB2YXJpYWJsZSBlcnJvcnMgc2hvdWxkIG9jY3VyXG4gICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVmRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnbm8tdW5kZWYnKTtcblxuICAgICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QgRmlsZSBQYXR0ZXJuIE1hdGNoaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhcHBseSB0ZXN0IHJ1bGVzIHRvIGNvcnJlY3QgZmlsZSBwYXR0ZXJucycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RGaWxlcyA9IFtcbiAgICAgICAgJ3NyYy9jb21wb25lbnRzL0Zvb2RSZWNvbW1lbmRlci50ZXN0LnRzeCcsXG4gICAgICAgICdzcmMvdXRpbHMvYXN0cm9sb2d5LnNwZWMudHMnLFxuICAgICAgICAnc3JjL3NlcnZpY2VzL2NhbXBhaWduLnRlc3QudHMnLFxuICAgICAgICAnc3JjL19fdGVzdHNfXy9jYWxjdWxhdGlvbnMvY3VsaW5hcnlBc3Ryb2xvZ3kudGVzdC50cycsXG4gICAgICAgICdzcmMvX190ZXN0c19fL3V0aWxzL3JlbGlhYmxlQXN0cm9ub215LnNwZWMudHMnLFxuICAgICAgICAndGVzdHMvaW50ZWdyYXRpb24vYXBpLnRlc3QuanMnLFxuICAgICAgXTtcblxuICAgICAgdGVzdEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIGZpbGUgd291bGQgbWF0Y2ggdGVzdCBwYXR0ZXJucyBpbiBFU0xpbnQgY29uZmlnXG4gICAgICAgIGNvbnN0IG1hdGNoZXNUZXN0UGF0dGVybiA9XG4gICAgICAgICAgZmlsZS5pbmNsdWRlcygnLnRlc3QuJykgfHwgZmlsZS5pbmNsdWRlcygnLnNwZWMuJykgfHwgZmlsZS5pbmNsdWRlcygnX190ZXN0c19fLycpIHx8IGZpbGUuaW5jbHVkZXMoJy90ZXN0cy8nKTtcblxuICAgICAgICBleHBlY3QobWF0Y2hlc1Rlc3RQYXR0ZXJuKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbm90IGFwcGx5IHRlc3QgcnVsZXMgdG8gbm9uLXRlc3QgZmlsZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBub25UZXN0RmlsZXMgPSBbXG4gICAgICAgICdzcmMvY29tcG9uZW50cy9Gb29kUmVjb21tZW5kZXIudHN4JyxcbiAgICAgICAgJ3NyYy91dGlscy9hc3Ryb2xvZ3kudHMnLFxuICAgICAgICAnc3JjL3NlcnZpY2VzL2NhbXBhaWduLnRzJyxcbiAgICAgICAgJ3NyYy9jYWxjdWxhdGlvbnMvY3VsaW5hcnlBc3Ryb2xvZ3kudHMnLFxuICAgICAgICAnc3JjL2RhdGEvaW5ncmVkaWVudHMvdmVnZXRhYmxlcy50cycsXG4gICAgICBdO1xuXG4gICAgICBub25UZXN0RmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBmaWxlIHdvdWxkIE5PVCBtYXRjaCB0ZXN0IHBhdHRlcm5zXG4gICAgICAgIGNvbnN0IG1hdGNoZXNUZXN0UGF0dGVybiA9XG4gICAgICAgICAgZmlsZS5pbmNsdWRlcygnLnRlc3QuJykgfHwgZmlsZS5pbmNsdWRlcygnLnNwZWMuJykgfHwgZmlsZS5pbmNsdWRlcygnX190ZXN0c19fLycpIHx8IGZpbGUuaW5jbHVkZXMoJy90ZXN0cy8nKTtcblxuICAgICAgICBleHBlY3QobWF0Y2hlc1Rlc3RQYXR0ZXJuKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGVzdCBFbnZpcm9ubWVudCBDb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBKZXN0IGVudmlyb25tZW50IGdsb2JhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgZGVzY3JpYmUoJ0Vudmlyb25tZW50IEdsb2JhbHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgTm9kZS5qcyBnbG9iYWxzIGF2YWlsYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChwcm9jZXNzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KEJ1ZmZlcikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWwpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoX19kaXJuYW1lKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KF9fZmlsZW5hbWUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgYnJvd3NlciBnbG9iYWxzIGF2YWlsYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIC8vIFRoZXNlIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gTm9kZSBlbnZpcm9ubWVudFxuICAgICAgICAgICAgLy8gYnV0IHNob3VsZCBub3QgY2F1c2Ugbm8tdW5kZWYgZXJyb3JzIGlmIGNvbmZpZ3VyZWQgcHJvcGVybHlcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBleHBlY3Qod2luZG93KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgICBleHBlY3QoZG9jdW1lbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgY29tbW9uIEphdmFTY3JpcHQgZ2xvYmFscycsICgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChjb25zb2xlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KHNldFRpbWVvdXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3Qoc2V0SW50ZXJ2YWwpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoY2xlYXJUaW1lb3V0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGNsZWFySW50ZXJ2YWwpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoUHJvbWlzZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChBcnJheSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChPYmplY3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoSlNPTikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWVudmlyb25tZW50LWdsb2JhbHMudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW5kZWZFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IHVua25vd24pID0+IChtc2cgYXMgYW55KS5ydWxlSWQgPT09ICduby11bmRlZicpO1xuXG4gICAgICAgICAgLy8gRW52aXJvbm1lbnQgZ2xvYmFscyBzaG91bGQgYmUgYXZhaWxhYmxlXG4gICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVmRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiB1bmtub3duKSA9PiAobXNnIGFzIGFueSkucnVsZUlkID09PSAnbm8tdW5kZWYnKTtcblxuICAgICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QtU3BlY2lmaWMgUGF0dGVybnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IHRlc3QgaGVscGVyIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnVGVzdCBIZWxwZXJzJywgKCkgPT4ge1xuICAgICAgICAgIC8vIFRlc3QgaGVscGVyIGZ1bmN0aW9ucyBzaG91bGQgYmUgYWxsb3dlZCBldmVuIGlmIHVudXNlZFxuICAgICAgICAgIGNvbnN0IGNyZWF0ZVRlc3RVc2VyID0gKG92ZXJyaWRlcyA9IHt9KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICAuLi5vdmVycmlkZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjcmVhdGVUZXN0SW5ncmVkaWVudCA9IChuYW1lID0gJ3RvbWF0bycpID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZWxlbWVudGFsUHJvcGVydGllczogeyBGaXJlOiAwLjMsIFdhdGVyOiAwLjcsIEVhcnRoOiAwLjIsIEFpcjogMC4xIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBfbW9ja0FwaVJlc3BvbnNlID0gKGRhdGE6IGFueSwgc3RhdHVzID0gMjAwKSA9PiAoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgX3NldHVwVGVzdEVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0dXAgY29kZVxuICAgICAgICAgICAgcmV0dXJuIHsgaW5pdGlhbGl6ZWQ6IHRydWUgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IF90ZWFyZG93blRlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgY29kZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIHVzZSB0ZXN0IGhlbHBlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gY3JlYXRlVGVzdFVzZXIoeyBuYW1lOiAnQ3VzdG9tIFVzZXInIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVzZXIubmFtZSkudG9CZSgnQ3VzdG9tIFVzZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLXRlc3QtaGVscGVycy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgKG1zZzogdW5rbm93bikgPT5cbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiZcbiAgICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdjcmVhdGVUZXN0JykgfHxcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9ja0FwaScpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3NldHVwVGVzdCcpIHx8XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3RlYXJkb3duVGVzdCcpKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVGVzdCBoZWxwZXIgZnVuY3Rpb25zIHNob3VsZCBiZSBhbGxvd2VkIGV2ZW4gaWYgdW51c2VkXG4gICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAobXNnOiB1bmtub3duKSA9PlxuICAgICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmXG4gICAgICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdjcmVhdGVUZXN0JykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrQXBpJykgfHxcbiAgICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdzZXR1cFRlc3QnKSB8fFxuICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3RlYXJkb3duVGVzdCcpKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9