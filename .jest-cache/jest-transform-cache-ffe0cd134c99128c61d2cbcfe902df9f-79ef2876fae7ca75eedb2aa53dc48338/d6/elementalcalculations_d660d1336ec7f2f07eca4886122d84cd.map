{"file":"/Users/GregCastro/Desktop/WhatToEatNext/src/calculations/elementalcalculations.ts","mappings":"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","names":[],"sources":["/Users/GregCastro/Desktop/WhatToEatNext/src/calculations/elementalcalculations.ts"],"sourcesContent":["import { ElementalEnergy, ElementType, signElementMap } from '@/types/elements';\nimport { DEFAULT_ELEMENTAL_PROPERTIES } from '@/constants/elementalConstants';\nimport type {\n  Season} from '@/types/alchemy';\n\n// Define the types needed for ElementalCalculator\ninterface ElementalProperties {\n  Fire: number;\n  Water: number;\n  Earth: number;\n  Air: number;\n  [key: string]: number; // Allow indexing with string\n}\n\n/**\n * ElementalCalculator class for managing and calculating elemental state\n */\nexport class ElementalCalculator {\n  private static instance: ElementalCalculator;\n  private currentBalance: ElementalProperties = DEFAULT_ELEMENTAL_PROPERTIES;\n  private initialized = false;\n\n  private constructor() {}\n\n  static getInstance(): ElementalCalculator {\n    if (!ElementalCalculator.instance) {\n      ElementalCalculator.instance = new ElementalCalculator();\n    }\n    return ElementalCalculator.instance;\n  }\n\n  static initialize(): void {\n    const instance = ElementalCalculator.getInstance();\n    instance.currentBalance = { ...DEFAULT_ELEMENTAL_PROPERTIES };\n    instance.initialized = true;\n  }\n\n  static getCurrentElementalState(): ElementalProperties {\n    const instance = ElementalCalculator.getInstance();\n    if (!instance.initialized) {\n      ElementalCalculator.initialize();\n    }\n    return instance.currentBalance;\n  }\n\n  /**\n   * Calculate the seasonal effectiveness of a recipe\n   * @param recipe The recipe to evaluate\n   * @param season The current season\n   * @returns A score from 0-100 representing the effectiveness\n   */\n  static calculateSeasonalEffectiveness(\n    recipe: unknown,\n    season: string\n  ): number {\n    const recipeData = recipe as any;\n    if (!recipeData?.elementalProperties) return 0;\n\n    const seasonalModifiers = this.getSeasonalModifiers(season as Season);\n    let score = 0;\n\n    // Calculate base seasonal alignment\n    Object.entries(recipeData.elementalProperties).forEach(([element, value]) => {\n      const modifier =\n        seasonalModifiers[element as keyof ElementalProperties] || 0;\n      score += (value as number) * modifier * 100;\n    });\n\n    // Apply seasonal bonuses/penalties\n    if (recipeData.season) {\n      const seasons = Array.isArray(recipeData.season)\n        ? recipeData.season\n        : [recipeData.season];\n      if (\n        seasons\n          .map((s: string) => s.toLowerCase())\n          .includes(season.toLowerCase())\n      ) {\n        score += 20;\n      }\n    }\n\n    return Math.max(0, Math.min(100, Math.round(score)));\n  }\n\n  /**\n   * Get elemental modifiers for a specific season\n   */\n  static getSeasonalModifiers(season: Season): ElementalProperties {\n    const baseModifiers = { ...DEFAULT_ELEMENTAL_PROPERTIES };\n\n    // Normalize season to lowercase for consistency with type definition\n    const seasonLower = season.toLowerCase() as Season;\n\n    switch (seasonLower) {\n      case 'spring':\n        baseModifiers.Air = 0.4;\n        baseModifiers.Fire = 0.3;\n        baseModifiers.Water = 0.2;\n        baseModifiers.Earth = 0.1;\n        break;\n      case 'summer':\n        baseModifiers.Fire = 0.4;\n        baseModifiers.Air = 0.3;\n        baseModifiers.Earth = 0.2;\n        baseModifiers.Water = 0.1;\n        break;\n      case 'autumn':\n      case 'fall':\n        baseModifiers.Earth = 0.4;\n        baseModifiers.Air = 0.3;\n        baseModifiers.Water = 0.2;\n        baseModifiers.Fire = 0.1;\n        break;\n      case 'winter':\n        baseModifiers.Water = 0.4;\n        baseModifiers.Earth = 0.3;\n        baseModifiers.Fire = 0.2;\n        baseModifiers.Air = 0.1;\n        break;\n      case 'all':\n        // Balanced for 'all' season\n        baseModifiers.Fire = 0.25;\n        baseModifiers.Water = 0.25;\n        baseModifiers.Earth = 0.25;\n        baseModifiers.Air = 0.25;\n        break;\n      default:\n        // Balanced for unknown seasons\n        baseModifiers.Fire = 0.25;\n        baseModifiers.Water = 0.25;\n        baseModifiers.Earth = 0.25;\n        baseModifiers.Air = 0.25;\n    }\n\n    return baseModifiers;\n  }\n\n  /**\n   * Calculate harmony score for given elemental properties\n   * @param properties Elemental properties to evaluate\n   * @returns Harmony score between 0 and 1\n   */\n  static calculateHarmony(properties: ElementalProperties): number {\n    if (!properties) return 0;\n\n    // Check if properties are balanced\n    const values = Object.values(properties);\n    const average = values.reduce((sum, val) => sum + val, 0) / values.length;\n\n    // Calculate variance from the ideal (perfect balance would be 0 variance)\n    const variance =\n      values.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) /\n      values.length;\n\n    // Convert variance to harmony score (0-1)\n    return Math.max(0, Math.min(1, 1 - Math.sqrt(variance)));\n  }\n\n  /**\n   * Calculate elemental state based on provided properties and conditions\n   * @param baseProperties Base elemental properties\n   * @param phase Optional phase/condition\n   * @param time Optional time factor\n   * @returns Enhanced elemental properties with additional information\n   */\n  calculateElementalState(\n    baseProperties: ElementalProperties,\n    phase = 'default',\n    time = 'neutral'\n  ): {\n    properties: ElementalProperties;\n    seasonalInfluence: ElementalProperties;\n  } {\n    // Start with the base properties\n    const properties = { ...baseProperties };\n\n    // Create default seasonal influence\n    const seasonalInfluence: ElementalProperties = {\n      Fire: 0.25,\n      Water: 0.25,\n      Earth: 0.25,\n      Air: 0.25};\n\n    // Apply time-based modifiers\n    if (time === 'day') {\n      properties.Fire = properties.Fire * 1.1;\n      properties.Air = properties.Air * 1.05;\n    } else if (time === 'night') {\n      properties.Water = properties.Water * 1.1;\n      properties.Earth = properties.Earth * 1.05;\n    }\n\n    // Normalize the properties to ensure they still sum to 1\n    const total = Object.values(properties).reduce((sum, val) => sum + val, 0);\n\n    if (total > 0) {\n      Object.keys(properties).forEach((key) => {\n        properties[key] = properties[key] / total;\n\n        // Update seasonal influence based on the normalized properties\n        seasonalInfluence[key] = properties[key] * 1.5;\n      });\n    }\n\n    return {\n      properties,\n      seasonalInfluence};\n  }\n}\n\n/**\n * Gets the planetary influencers for a specific element\n * @param planetaryPositions The current planetary positions\n * @param elementType The element type to get influencers for\n * @returns Array of planetary influencers\n */\nfunction getPlanetaryInfluencers(\n  planetaryPositions: Record<string, unknown>,\n  elementType: ElementType\n): string[] {\n  // Define which planets influence which elements - Pattern JJ-1: ElementType System Unification\n  const elementInfluencers: Record<ElementType, string[]> = {\n    Fire: ['sun', 'mars', 'jupiter'],\n    Water: ['moon', 'venus', 'neptune'],\n    Earth: ['venus', 'saturn', 'pluto'],\n    Air: ['mercury', 'uranus', 'jupiter'],\n    // Added extended elements mapped to core planetary influences\n    Metal: ['venus', 'saturn', 'mercury'], // Structure, clarity, precision - maps to Earth/Air qualities\n    Wood: ['sun', 'mars', 'jupiter'],      // Growth, flexibility, expansion - maps to Fire qualities  \n    Void: ['mercury', 'uranus', 'neptune'] // Space, potential, emptiness - maps to Air/Water qualities\n  };\n\n  // Get the potential influencers for this element\n  const potentialInfluencers = elementInfluencers[elementType] || [];\n\n  // Return only the planets that are actually present in the positions data\n  return potentialInfluencers.filter(\n    (planet) =>\n      planetaryPositions[planet] &&\n      typeof planetaryPositions[planet] === 'object'\n  );\n}\n\n/**\n * Calculates the elemental energies based on planetary positions\n *\n * @param planetaryPositions The current positions of planets\n * @param isDaytime Whether it's daytime or nighttime\n * @returns Array of elemental energies\n */\nexport function calculateElementalEnergies(\n  planetaryPositions: Record<string, unknown>,\n  isDaytime = true\n): ElementalEnergy[] {\n  if (!planetaryPositions || Object.keys(planetaryPositions).length === 0) {\n    // console.warn('No planetary positions provided for elemental calculation');\n    return getDefaultElementalEnergies();\n  }\n\n  // Initialize energy values for each element\n  const energyValues: Record<ElementType, number> = {\n    Fire: 0,\n    Water: 0,\n    Earth: 0,\n    Air: 0,\n    // Pattern JJ-1: ElementType System Unification - Add extended elements with base element mapping\n    Metal: 0, // Maps to Earth-like properties\n    Wood: 0,  // Maps to Fire-like properties\n    Void: 0   // Maps to Air-like properties\n  };\n\n  // Define planetary influences (weights)\n  const planetWeights: Record<string, number> = {\n    sun: 0.25,\n    moon: 0.2,\n    mercury: 0.1,\n    venus: 0.1,\n    mars: 0.1,\n    jupiter: 0.1,\n    saturn: 0.1,\n    uranus: 0.05,\n    neptune: 0.05,\n    pluto: 0.05};\n\n  // Calculate element values based on planetary positions\n  let totalWeight = 0;\n\n  for (const [planet, position] of Object.entries(planetaryPositions)) {\n    const weight = planetWeights[planet.toLowerCase()] || 0.05;\n\n    // Skip if position doesn't have a sign\n    const positionData = position as any;\n    if (!positionData?.sign) continue;\n\n    // Convert the sign to lowercase to ensure matching\n    const sign = positionData.sign.toLowerCase();\n    const element = signElementMap[sign];\n\n    if (element) {\n      energyValues[element] += weight;\n      totalWeight += weight;\n    }\n  }\n\n  // Apply day/night modifiers\n  if (isDaytime) {\n    energyValues.Fire *= 1.2;\n    energyValues.Air *= 1.1;\n  } else {\n    energyValues.Water *= 1.2;\n    energyValues.Earth *= 1.1;\n  }\n\n  // Normalize values to ensure they sum to 1\n  if (totalWeight > 0) {\n    const sum = Object.values(energyValues).reduce(\n      (acc, value) => acc + value,\n      0\n    );\n\n    for (const element of Object.keys(energyValues) as ElementType[]) {\n      energyValues[element] = sum > 0 ? energyValues[element] / sum : 0;\n    }\n  }\n\n  // Create ElementalEnergy objects\n  const energies: ElementalEnergy[] = Object.entries(energyValues)\n    .filter(([_, strength]) => strength > 0)\n    .map(([type, strength]) => ({\n      type: type as ElementType,\n      strength,\n      influence: getPlanetaryInfluencers(\n        planetaryPositions,\n        type as ElementType\n      )}));\n\n  return energies;\n}\n\n/**\n * Returns default elemental energies when no data is available\n */\nfunction getDefaultElementalEnergies(): ElementalEnergy[] {\n  return [\n    { type: 'Fire', strength: 0.25, influence: [] },\n    { type: 'Water', strength: 0.25, influence: [] },\n    { type: 'Earth', strength: 0.25, influence: [] },\n    { type: 'Air', strength: 0.25, influence: [] },\n  ];\n}\n\n// Process a zodiac sign and its relevant position to update energy values\nfunction _processZodiacInfluence(sign: string, weight: number, energyValues: ElementalProperties): void {\n  const element = signElementMap[sign];\n\n  if (element) {\n    energyValues[element] += weight;\n  }\n}\n"],"version":3}