2c158164f394575702f2cc16b3d88670
"use strict";
/**
 * SafetyValidator Tests
 * Comprehensive test suite for the Safety Validation System
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock execSync for command execution tests
jest.mock('child_process');
// Mock fs for file system tests
jest.mock('fs');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const SafetyValidator_1 = require("../SafetyValidator");
const types_1 = require("../types");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('SafetyValidator', () => {
    let validator;
    beforeEach(() => {
        validator = new SafetyValidator_1.SafetyValidator();
        jest.clearAllMocks();
    });
    describe('TypeScript Compilation Validation', () => {
        test('handles successful compilation', async () => {
            mockExecSync.mockReturnValue('');
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(true);
            expect(result.compilationErrors).toHaveLength(0);
            expect(result.performanceMetrics).toBeDefined();
        });
        test('handles compilation errors', async () => {
            const errorOutput = `
        src/test.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/test.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        Found 2 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = errorOutput;
                throw error;
            });
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors).toHaveLength(2);
            expect(result.compilationErrors[0]).toContain('error TS2322');
            expect(result.compilationErrors[1]).toContain('error TS2304');
        });
        test('handles compilation timeout', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('Timeout');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors).toContain('Timeout');
        });
    });
    describe('Build Validation After Batch', () => {
        test('validates build successfully', async () => {
            mockExecSync.mockReturnValue('');
            const result = await validator.validateBuildAfterBatch(['test.ts']);
            expect(result.buildSuccessful).toBe(true);
            expect(result.performanceMetrics).toBeDefined();
            expect(result.performanceMetrics.buildTime).toBeGreaterThan(0);
        });
        test('includes test validation when requested', async () => {
            mockExecSync.mockReturnValue('');
            const result = await validator.validateBuildAfterBatch(['test.ts'], true);
            expect(result.buildSuccessful).toBe(true);
            expect(result.testResults).toBeDefined();
            expect(result.testResults.testsPass).toBe(true);
        });
        test('handles performance threshold violations', async () => {
            // Mock slow build
            mockExecSync.mockImplementation(() => {
                // Simulate slow execution
                const start = Date.now();
                while (Date.now() - start < 100) {
                    // Busy wait to simulate slow build
                }
                return '';
            });
            const slowValidator = new SafetyValidator_1.SafetyValidator(60000, {
                maximumBuildTime: 50 // Very low threshold
            });
            const result = await slowValidator.validateBuildAfterBatch(['test.ts']);
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors.some(error => error.includes('Build time') && error.includes('exceeds threshold'))).toBe(true);
        });
    });
    describe('Rollback Validation', () => {
        test('validates rollback capability successfully', async () => {
            const originalFiles = new Map([['test.ts', 'test.ts']]);
            const backupFiles = new Map([['test.ts', 'test.ts.backup']]);
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue('backup content');
            mockFs.mkdirSync.mockReturnValue(undefined);
            mockFs.writeFileSync.mockReturnValue(undefined);
            mockFs.rmSync.mockReturnValue(undefined);
            const result = await validator.validateRollbackCapability(originalFiles, backupFiles);
            expect(result.canRollback).toBe(true);
            expect(result.backupIntegrity).toBe(true);
            expect(result.rollbackErrors).toHaveLength(0);
        });
        test('detects missing backup files', async () => {
            const originalFiles = new Map([['test.ts', 'test.ts']]);
            const backupFiles = new Map([['test.ts', 'missing.backup']]);
            mockFs.existsSync.mockReturnValue(false);
            const result = await validator.validateRollbackCapability(originalFiles, backupFiles);
            expect(result.canRollback).toBe(false);
            expect(result.backupIntegrity).toBe(false);
            expect(result.rollbackErrors).toContain('Backup file missing: missing.backup');
        });
        test('detects empty backup files', async () => {
            const originalFiles = new Map([['test.ts', 'test.ts']]);
            const backupFiles = new Map([['test.ts', 'empty.backup']]);
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue(''); // Empty backup
            const result = await validator.validateRollbackCapability(originalFiles, backupFiles);
            expect(result.backupIntegrity).toBe(false);
            expect(result.rollbackErrors).toContain('Backup file is empty: empty.backup');
        });
    });
    describe('Safety Score Calculation', () => {
        test('calculates safety score for array replacement', () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, context);
            expect(result.isValid).toBe(true);
            expect(result.safetyScore).toBeGreaterThan(0.9);
            expect(result.validationErrors).toHaveLength(0);
        });
        test('reduces safety score for error handling contexts', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const errorContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'catch (error: any) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, errorContext);
            expect(result.safetyScore).toBeLessThan(0.8);
            expect(result.warnings.some(w => w.includes('Error handling context'))).toBe(true);
        });
        test('boosts safety score for test files', () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const testContext = {
                filePath: 'test.test.ts',
                lineNumber: 1,
                codeSnippet: 'const mockData: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: true,
                domainContext: {
                    domain: types_1.CodeDomain.TEST,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, testContext);
            expect(result.safetyScore).toBeGreaterThan(0.8);
        });
        test('warns about external API contexts', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'api.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const apiContext = {
                filePath: 'api.ts',
                lineNumber: 1,
                codeSnippet: 'const response: any = await fetch("/api/data");',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.SERVICE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, apiContext);
            expect(result.warnings.some(w => w.includes('External API context'))).toBe(true);
            expect(result.recommendations.some(r => r.includes('Verify API response types'))).toBe(true);
        });
        test('handles function parameter replacements with caution', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'function.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const functionContext = {
                filePath: 'function.ts',
                lineNumber: 1,
                codeSnippet: 'function process(data: any) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, functionContext);
            expect(result.warnings.some(w => w.includes('Function parameter replacement'))).toBe(true);
        });
    });
    describe('Safety Thresholds Management', () => {
        test('gets current safety thresholds', () => {
            const thresholds = validator.getSafetyThresholds();
            expect(thresholds.minimumSafetyScore).toBeDefined();
            expect(thresholds.maximumErrorCount).toBeDefined();
            expect(thresholds.maximumBuildTime).toBeDefined();
        });
        test('updates safety thresholds', () => {
            const newThresholds = {
                minimumSafetyScore: 0.9,
                maximumBuildTime: 60000
            };
            validator.updateSafetyThresholds(newThresholds);
            const updatedThresholds = validator.getSafetyThresholds();
            expect(updatedThresholds.minimumSafetyScore).toBe(0.9);
            expect(updatedThresholds.maximumBuildTime).toBe(60000);
        });
    });
    describe('Performance Metrics Validation', () => {
        test('validates acceptable performance metrics', () => {
            const fastValidator = new SafetyValidator_1.SafetyValidator(60000, {
                maximumBuildTime: 30000
            });
            const mockReplacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const mockContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = fastValidator.calculateSafetyScore(mockReplacement, mockContext);
            expect(result.isValid).toBe(true);
        });
    });
    describe('Error Output Parsing', () => {
        test('parses TypeScript errors correctly', async () => {
            const complexErrorOutput = `
        src/file1.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/file2.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        src/file3.ts(20,15): error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
        Found 3 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = complexErrorOutput;
                throw error;
            });
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors).toHaveLength(3);
            expect(result.compilationErrors[0]).toContain('TS2322');
            expect(result.compilationErrors[1]).toContain('TS2304');
            expect(result.compilationErrors[2]).toContain('TS2345');
        });
        test('limits error count to maximum threshold', async () => {
            const manyErrorsOutput = Array.from({ length: 20 }, (_, i) => `src/file${i}.ts(${i},5): error TS2322: Type error ${i}.`).join('\n');
            mockExecSync.mockImplementation(() => {
                const error = new Error('Many errors');
                error.stdout = manyErrorsOutput;
                throw error;
            });
            const limitedValidator = new SafetyValidator_1.SafetyValidator(60000, {
                maximumErrorCount: 5
            });
            const result = await limitedValidator.validateTypeScriptCompilation();
            expect(result.compilationErrors.length).toBeLessThanOrEqual(5);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZXR5VmFsaWRhdG9yLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9ILDRDQUE0QztBQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBRzNCLGdDQUFnQztBQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBVmhCLGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFDekIsd0RBQXFEO0FBQ3JELG9DQUE4RTtBQUk5RSxNQUFNLFlBQVksR0FBRyx3QkFBZ0QsQ0FBQztBQUl0RSxNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBRTVDLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEVBQUU7SUFDL0IsSUFBSSxTQUEwQixDQUFDO0lBRS9CLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxTQUFTLEdBQUcsSUFBSSxpQ0FBZSxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLG1DQUFtQyxFQUFFLEdBQUcsRUFBRTtRQUNqRCxJQUFJLENBQUMsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDaEQsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUVqQyxNQUFNLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO1lBRS9ELE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakQsTUFB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RSxDQUFDLEVBQUUsRUFBRSxDQUMzRCxXQUFXLENBQUMsT0FBTyxDQUFDLGlDQUFpQyxDQUFDLEdBQUcsQ0FDMUQsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixZQUFZLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFO2dCQUNuQyxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQVEsQ0FBQztnQkFDOUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQztnQkFDaEMsTUFBTSxLQUFLLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxpQ0FBZSxDQUFDLEtBQUssRUFBRTtnQkFDbEQsaUJBQWlCLEVBQUUsQ0FBQzthQUNyQixDQUFDLENBQUM7WUFFSCxNQUFNLE1BQU0sR0FBRyxNQUFNLGdCQUFnQixDQUFDLDZCQUE2QixFQUFFLENBQUM7WUFFdEUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZXR5VmFsaWRhdG9yLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTYWZldHlWYWxpZGF0b3IgVGVzdHNcbiAqIENvbXByZWhlbnNpdmUgdGVzdCBzdWl0ZSBmb3IgdGhlIFNhZmV0eSBWYWxpZGF0aW9uIFN5c3RlbVxuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBTYWZldHlWYWxpZGF0b3IgfSBmcm9tICcuLi9TYWZldHlWYWxpZGF0b3InO1xuaW1wb3J0IHsgQ2xhc3NpZmljYXRpb25Db250ZXh0LCBDb2RlRG9tYWluLCBUeXBlUmVwbGFjZW1lbnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vIE1vY2sgZXhlY1N5bmMgZm9yIGNvbW1hbmQgZXhlY3V0aW9uIHRlc3RzXG5qZXN0Lm1vY2soJ2NoaWxkX3Byb2Nlc3MnKTtcbmNvbnN0IG1vY2tFeGVjU3luYyA9IGV4ZWNTeW5jIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGV4ZWNTeW5jPjtcblxuLy8gTW9jayBmcyBmb3IgZmlsZSBzeXN0ZW0gdGVzdHNcbmplc3QubW9jaygnZnMnKTtcbmNvbnN0IG1vY2tGcyA9IGZzIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBmcz47XG5cbmRlc2NyaWJlKCdTYWZldHlWYWxpZGF0b3InLCAoKSA9PiB7XG4gIGxldCB2YWxpZGF0b3I6IFNhZmV0eVZhbGlkYXRvcjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICB2YWxpZGF0b3IgPSBuZXcgU2FmZXR5VmFsaWRhdG9yKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUeXBlU2NyaXB0IENvbXBpbGF0aW9uIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnaGFuZGxlcyBzdWNjZXNzZnVsIGNvbXBpbGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucGVyZm9ybWFuY2VNZXRyaWNzKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb21waWxhdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck91dHB1dCA9IGBcbiAgICAgICAgc3JjL3Rlc3QudHMoMTAsNSk6IGVycm9yIFRTMjMyMjogVHlwZSAnc3RyaW5nJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlICdudW1iZXInLlxuICAgICAgICBzcmMvdGVzdC50cygxNSwxMCk6IGVycm9yIFRTMjMwNDogQ2Fubm90IGZpbmQgbmFtZSAndW5rbm93blZhcmlhYmxlJy5cbiAgICAgICAgRm91bmQgMiBlcnJvcnMuXG4gICAgICBgO1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gZXJyb3JPdXRwdXQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzWzBdKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMyMicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1sxXSkudG9Db250YWluKCdlcnJvciBUUzIzMDQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY29tcGlsYXRpb24gdGltZW91dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGltZW91dCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdUSU1FT1VUJztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVHlwZVNjcmlwdENvbXBpbGF0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYnVpbGRTdWNjZXNzZnVsKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvQ29udGFpbignVGltZW91dCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQnVpbGQgVmFsaWRhdGlvbiBBZnRlciBCYXRjaCcsICgpID0+IHtcbiAgICB0ZXN0KCd2YWxpZGF0ZXMgYnVpbGQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZUJ1aWxkQWZ0ZXJCYXRjaChbJ3Rlc3QudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYnVpbGRTdWNjZXNzZnVsKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wZXJmb3JtYW5jZU1ldHJpY3MpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LnBlcmZvcm1hbmNlTWV0cmljcyEuYnVpbGRUaW1lKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdpbmNsdWRlcyB0ZXN0IHZhbGlkYXRpb24gd2hlbiByZXF1ZXN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlQnVpbGRBZnRlckJhdGNoKFsndGVzdC50cyddLCB0cnVlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5idWlsZFN1Y2Nlc3NmdWwpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnRlc3RSZXN1bHRzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50ZXN0UmVzdWx0cyEudGVzdHNQYXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBwZXJmb3JtYW5jZSB0aHJlc2hvbGQgdmlvbGF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc2xvdyBidWlsZFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIC8vIFNpbXVsYXRlIHNsb3cgZXhlY3V0aW9uXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydCA8IDEwMCkge1xuICAgICAgICAgIC8vIEJ1c3kgd2FpdCB0byBzaW11bGF0ZSBzbG93IGJ1aWxkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNsb3dWYWxpZGF0b3IgPSBuZXcgU2FmZXR5VmFsaWRhdG9yKDYwMDAwLCB7XG4gICAgICAgIG1heGltdW1CdWlsZFRpbWU6IDUwIC8vIFZlcnkgbG93IHRocmVzaG9sZFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNsb3dWYWxpZGF0b3IudmFsaWRhdGVCdWlsZEFmdGVyQmF0Y2goWyd0ZXN0LnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzLnNvbWUoZXJyb3IgPT5cbiAgICAgICAgZXJyb3IuaW5jbHVkZXMoJ0J1aWxkIHRpbWUnKSAmJiBlcnJvci5pbmNsdWRlcygnZXhjZWVkcyB0aHJlc2hvbGQnKVxuICAgICAgKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JvbGxiYWNrIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgndmFsaWRhdGVzIHJvbGxiYWNrIGNhcGFiaWxpdHkgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGaWxlcyA9IG5ldyBNYXAoW1sndGVzdC50cycsICd0ZXN0LnRzJ11dKTtcbiAgICAgIGNvbnN0IGJhY2t1cEZpbGVzID0gbmV3IE1hcChbWyd0ZXN0LnRzJywgJ3Rlc3QudHMuYmFja3VwJ11dKTtcblxuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2JhY2t1cCBjb250ZW50Jyk7XG4gICAgICBtb2NrRnMubWtkaXJTeW5jLm1vY2tSZXR1cm5WYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0ZzLndyaXRlRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRnMucm1TeW5jLm1vY2tSZXR1cm5WYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVSb2xsYmFja0NhcGFiaWxpdHkob3JpZ2luYWxGaWxlcywgYmFja3VwRmlsZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmNhblJvbGxiYWNrKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5iYWNrdXBJbnRlZ3JpdHkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrRXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkZXRlY3RzIG1pc3NpbmcgYmFja3VwIGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGaWxlcyA9IG5ldyBNYXAoW1sndGVzdC50cycsICd0ZXN0LnRzJ11dKTtcbiAgICAgIGNvbnN0IGJhY2t1cEZpbGVzID0gbmV3IE1hcChbWyd0ZXN0LnRzJywgJ21pc3NpbmcuYmFja3VwJ11dKTtcblxuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlUm9sbGJhY2tDYXBhYmlsaXR5KG9yaWdpbmFsRmlsZXMsIGJhY2t1cEZpbGVzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jYW5Sb2xsYmFjaykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmJhY2t1cEludGVncml0eSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrRXJyb3JzKS50b0NvbnRhaW4oJ0JhY2t1cCBmaWxlIG1pc3Npbmc6IG1pc3NpbmcuYmFja3VwJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkZXRlY3RzIGVtcHR5IGJhY2t1cCBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRmlsZXMgPSBuZXcgTWFwKFtbJ3Rlc3QudHMnLCAndGVzdC50cyddXSk7XG4gICAgICBjb25zdCBiYWNrdXBGaWxlcyA9IG5ldyBNYXAoW1sndGVzdC50cycsICdlbXB0eS5iYWNrdXAnXV0pO1xuXG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7IC8vIEVtcHR5IGJhY2t1cFxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVSb2xsYmFja0NhcGFiaWxpdHkob3JpZ2luYWxGaWxlcywgYmFja3VwRmlsZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJhY2t1cEludGVncml0eSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrRXJyb3JzKS50b0NvbnRhaW4oJ0JhY2t1cCBmaWxlIGlzIGVtcHR5OiBlbXB0eS5iYWNrdXAnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhZmV0eSBTY29yZSBDYWxjdWxhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdjYWxjdWxhdGVzIHNhZmV0eSBzY29yZSBmb3IgYXJyYXkgcmVwbGFjZW1lbnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci5jYWxjdWxhdGVTYWZldHlTY29yZShyZXBsYWNlbWVudCwgY29udGV4dCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2FmZXR5U2NvcmUpLnRvQmVHcmVhdGVyVGhhbigwLjkpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZGF0aW9uRXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyZWR1Y2VzIHNhZmV0eSBzY29yZSBmb3IgZXJyb3IgaGFuZGxpbmcgY29udGV4dHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bicsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlcnJvckNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjYXRjaCAoZXJyb3I6IGFueSkgeycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci5jYWxjdWxhdGVTYWZldHlTY29yZShyZXBsYWNlbWVudCwgZXJyb3JDb250ZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zYWZldHlTY29yZSkudG9CZUxlc3NUaGFuKDAuOCk7XG4gICAgICBleHBlY3QocmVzdWx0Lndhcm5pbmdzLnNvbWUodyA9PiB3LmluY2x1ZGVzKCdFcnJvciBoYW5kbGluZyBjb250ZXh0JykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnYm9vc3RzIHNhZmV0eSBzY29yZSBmb3IgdGVzdCBmaWxlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRlc3RDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBtb2NrRGF0YTogYW55W10gPSBbXTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiB0cnVlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlRFU1QsXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci5jYWxjdWxhdGVTYWZldHlTY29yZShyZXBsYWNlbWVudCwgdGVzdENvbnRleHQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eVNjb3JlKS50b0JlR3JlYXRlclRoYW4oMC44KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3dhcm5zIGFib3V0IGV4dGVybmFsIEFQSSBjb250ZXh0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duJyxcbiAgICAgICAgZmlsZVBhdGg6ICdhcGkudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgYXBpQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ2FwaS50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgcmVzcG9uc2U6IGFueSA9IGF3YWl0IGZldGNoKFwiL2FwaS9kYXRhXCIpOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlNFUlZJQ0UsXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci5jYWxjdWxhdGVTYWZldHlTY29yZShyZXBsYWNlbWVudCwgYXBpQ29udGV4dCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQud2FybmluZ3Muc29tZSh3ID0+IHcuaW5jbHVkZXMoJ0V4dGVybmFsIEFQSSBjb250ZXh0JykpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZWNvbW1lbmRhdGlvbnMuc29tZShyID0+IHIuaW5jbHVkZXMoJ1ZlcmlmeSBBUEkgcmVzcG9uc2UgdHlwZXMnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGZ1bmN0aW9uIHBhcmFtZXRlciByZXBsYWNlbWVudHMgd2l0aCBjYXV0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd24nLFxuICAgICAgICBmaWxlUGF0aDogJ2Z1bmN0aW9uLnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGZ1bmN0aW9uQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ2Z1bmN0aW9uLnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBwcm9jZXNzKGRhdGE6IGFueSkgeycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci5jYWxjdWxhdGVTYWZldHlTY29yZShyZXBsYWNlbWVudCwgZnVuY3Rpb25Db250ZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC53YXJuaW5ncy5zb21lKHcgPT4gdy5pbmNsdWRlcygnRnVuY3Rpb24gcGFyYW1ldGVyIHJlcGxhY2VtZW50JykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FmZXR5IFRocmVzaG9sZHMgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdnZXRzIGN1cnJlbnQgc2FmZXR5IHRocmVzaG9sZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0aHJlc2hvbGRzID0gdmFsaWRhdG9yLmdldFNhZmV0eVRocmVzaG9sZHMoKTtcblxuICAgICAgZXhwZWN0KHRocmVzaG9sZHMubWluaW11bVNhZmV0eVNjb3JlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHRocmVzaG9sZHMubWF4aW11bUVycm9yQ291bnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodGhyZXNob2xkcy5tYXhpbXVtQnVpbGRUaW1lKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndXBkYXRlcyBzYWZldHkgdGhyZXNob2xkcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld1RocmVzaG9sZHMgPSB7XG4gICAgICAgIG1pbmltdW1TYWZldHlTY29yZTogMC45LFxuICAgICAgICBtYXhpbXVtQnVpbGRUaW1lOiA2MDAwMFxuICAgICAgfTtcblxuICAgICAgdmFsaWRhdG9yLnVwZGF0ZVNhZmV0eVRocmVzaG9sZHMobmV3VGhyZXNob2xkcyk7XG4gICAgICBjb25zdCB1cGRhdGVkVGhyZXNob2xkcyA9IHZhbGlkYXRvci5nZXRTYWZldHlUaHJlc2hvbGRzKCk7XG5cbiAgICAgIGV4cGVjdCh1cGRhdGVkVGhyZXNob2xkcy5taW5pbXVtU2FmZXR5U2NvcmUpLnRvQmUoMC45KTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkVGhyZXNob2xkcy5tYXhpbXVtQnVpbGRUaW1lKS50b0JlKDYwMDAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIE1ldHJpY3MgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCd2YWxpZGF0ZXMgYWNjZXB0YWJsZSBwZXJmb3JtYW5jZSBtZXRyaWNzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZmFzdFZhbGlkYXRvciA9IG5ldyBTYWZldHlWYWxpZGF0b3IoNjAwMDAsIHtcbiAgICAgICAgbWF4aW11bUJ1aWxkVGltZTogMzAwMDBcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrUmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZmFzdFZhbGlkYXRvci5jYWxjdWxhdGVTYWZldHlTY29yZShtb2NrUmVwbGFjZW1lbnQsIG1vY2tDb250ZXh0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIE91dHB1dCBQYXJzaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3BhcnNlcyBUeXBlU2NyaXB0IGVycm9ycyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wbGV4RXJyb3JPdXRwdXQgPSBgXG4gICAgICAgIHNyYy9maWxlMS50cygxMCw1KTogZXJyb3IgVFMyMzIyOiBUeXBlICdzdHJpbmcnIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHR5cGUgJ251bWJlcicuXG4gICAgICAgIHNyYy9maWxlMi50cygxNSwxMCk6IGVycm9yIFRTMjMwNDogQ2Fubm90IGZpbmQgbmFtZSAndW5rbm93blZhcmlhYmxlJy5cbiAgICAgICAgc3JjL2ZpbGUzLnRzKDIwLDE1KTogZXJyb3IgVFMyMzQ1OiBBcmd1bWVudCBvZiB0eXBlICdudW1iZXInIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHBhcmFtZXRlciBvZiB0eXBlICdzdHJpbmcnLlxuICAgICAgICBGb3VuZCAzIGVycm9ycy5cbiAgICAgIGA7XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICBlcnJvci5zdGRvdXQgPSBjb21wbGV4RXJyb3JPdXRwdXQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzWzBdKS50b0NvbnRhaW4oJ1RTMjMyMicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1sxXSkudG9Db250YWluKCdUUzIzMDQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnNbMl0pLnRvQ29udGFpbignVFMyMzQ1Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdsaW1pdHMgZXJyb3IgY291bnQgdG8gbWF4aW11bSB0aHJlc2hvbGQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYW55RXJyb3JzT3V0cHV0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjAgfSwgKF8sIGkpID0+XG4gICAgICAgIGBzcmMvZmlsZSR7aX0udHMoJHtpfSw1KTogZXJyb3IgVFMyMzIyOiBUeXBlIGVycm9yICR7aX0uYFxuICAgICAgKS5qb2luKCdcXG4nKTtcblxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdNYW55IGVycm9ycycpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gbWFueUVycm9yc091dHB1dDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbGltaXRlZFZhbGlkYXRvciA9IG5ldyBTYWZldHlWYWxpZGF0b3IoNjAwMDAsIHtcbiAgICAgICAgbWF4aW11bUVycm9yQ291bnQ6IDVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaW1pdGVkVmFsaWRhdG9yLnZhbGlkYXRlVHlwZVNjcmlwdENvbXBpbGF0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMubGVuZ3RoKS50b0JlTGVzc1RoYW5PckVxdWFsKDUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9