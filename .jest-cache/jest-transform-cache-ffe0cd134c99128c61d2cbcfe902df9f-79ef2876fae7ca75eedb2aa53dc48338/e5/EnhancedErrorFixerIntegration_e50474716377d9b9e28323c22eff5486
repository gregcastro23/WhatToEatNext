90f0fe148d8a5ae8483e52f180027f17
"use strict";
/**
 * Enhanced Error Fixer Integration for Perfect Codebase Campaign
 *
 * Wrapper for scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js
 * Implements batch processing with --max-files=15 --auto-fix parameters
 * Creates build validation after every 5 files processed
 *
 * Requirements: 1.6, 1.7, 7.1
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnhancedErrorFixerIntegration = void 0;
const child_process_1 = require("child_process");
class EnhancedErrorFixerIntegration {
    ENHANCED_FIXER_PATH = 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js';
    DEFAULT_BATCH_SIZE = 15;
    BUILD_VALIDATION_INTERVAL = 5;
    /**
     * Execute Enhanced Error Fixer v3.0 with specified options
     */
    async executeEnhancedFixer(options = {}) {
        const startTime = Date.now();
        console.log('üöÄ Starting Enhanced TypeScript Error Fixer v3.0...');
        // Prepare command arguments
        const args = this.buildFixerArguments(options);
        try {
            // Execute the Enhanced Error Fixer
            const result = await this.runFixerCommand(args);
            // Validate build after fixing
            const buildValidationPassed = await this.validateBuild();
            const executionTime = Date.now() - startTime;
            return {
                success: result.success,
                filesProcessed: result.filesProcessed,
                errorsFixed: result.errorsFixed,
                errorsRemaining: result.errorsRemaining,
                buildValidationPassed,
                executionTime,
                safetyScore: result.safetyScore,
                warnings: result.warnings,
                errors: result.errors
            };
        }
        catch (error) {
            console.error('‚ùå Enhanced Error Fixer execution failed:', error);
            return {
                success: false,
                filesProcessed: 0,
                errorsFixed: 0,
                errorsRemaining: await this.getCurrentErrorCount(),
                buildValidationPassed: false,
                executionTime: Date.now() - startTime,
                warnings: [],
                errors: [error instanceof Error ? error.message : String(error)]
            };
        }
    }
    /**
     * Execute batch processing with build validation after every 5 files
     */
    async executeBatchProcessing(options) {
        console.log(`üîÑ Starting batch processing with ${options.batchSize} files per batch...`);
        const results = [];
        let batchNumber = 1;
        let totalFilesProcessed = 0;
        let totalErrorsFixed = 0;
        const maxIterations = options.maxBatches || 50; // Prevent infinite loops
        const startTime = Date.now();
        const maxExecutionTime = 30 * 60 * 1000; // 30 minutes max
        while (batchNumber <= maxIterations) {
            console.log(`\nüì¶ Processing Batch ${batchNumber}/${maxIterations}...`);
            // Check execution time limit
            if (Date.now() - startTime > maxExecutionTime) {
                console.log(`‚è∞ Maximum execution time (30 minutes) reached, stopping`);
                break;
            }
            // Check if we should stop (max batches reached)
            if (options.maxBatches && batchNumber > options.maxBatches) {
                console.log(`‚úã Reached maximum batch limit (${options.maxBatches})`);
                break;
            }
            // Check current error count with timeout protection
            let currentErrors = 0;
            try {
                currentErrors = await this.getCurrentErrorCount();
            }
            catch (error) {
                console.warn('‚ö†Ô∏è  Error count check failed, assuming errors remain');
                currentErrors = 1; // Assume errors exist to continue safely
            }
            if (currentErrors === 0) {
                console.log('üéâ No more TypeScript errors found!');
                break;
            }
            // Execute fixer for this batch
            const batchResult = await this.executeEnhancedFixer({
                maxFiles: options.batchSize,
                autoFix: true,
                validateSafety: true
            });
            results.push(batchResult);
            totalFilesProcessed += batchResult.filesProcessed;
            totalErrorsFixed += batchResult.errorsFixed;
            console.log(`üìä Batch ${batchNumber} Results:`);
            console.log(`  Files processed: ${batchResult.filesProcessed}`);
            console.log(`  Errors fixed: ${batchResult.errorsFixed}`);
            console.log(`  Build validation: ${batchResult.buildValidationPassed ? '‚úÖ' : '‚ùå'}`);
            // Stop on build failure if configured
            if (options.stopOnBuildFailure && !batchResult.buildValidationPassed) {
                console.log('üõë Stopping batch processing due to build failure');
                break;
            }
            // Stop if no progress made
            if (batchResult.filesProcessed === 0 && batchResult.errorsFixed === 0) {
                console.log('‚è∏Ô∏è  No progress made in this batch, stopping');
                break;
            }
            // Build validation after every N files (as specified in requirements)
            if (totalFilesProcessed % options.buildValidationInterval === 0) {
                console.log(`üîç Performing build validation after ${totalFilesProcessed} files...`);
                const buildValid = await this.validateBuild();
                if (!buildValid && options.stopOnBuildFailure) {
                    console.log('üõë Build validation failed, stopping batch processing');
                    break;
                }
            }
            batchNumber++;
        }
        console.log(`\nüìà Batch Processing Summary:`);
        console.log(`  Total batches: ${results.length}`);
        console.log(`  Total files processed: ${totalFilesProcessed}`);
        console.log(`  Total errors fixed: ${totalErrorsFixed}`);
        console.log(`  Remaining errors: ${await this.getCurrentErrorCount()}`);
        return results;
    }
    /**
     * Build command arguments for Enhanced Error Fixer
     */
    buildFixerArguments(options) {
        const args = [];
        if (options.maxFiles) {
            args.push(`--max-files=${options.maxFiles}`);
        }
        if (options.autoFix) {
            args.push('--auto-fix');
        }
        if (options.dryRun) {
            args.push('--dry-run');
        }
        if (options.validateSafety) {
            args.push('--validate-safety');
        }
        if (options.silent) {
            args.push('--silent');
        }
        if (options.json) {
            args.push('--json');
        }
        return args;
    }
    /**
     * Execute the Enhanced Error Fixer command
     */
    async runFixerCommand(args) {
        return new Promise((resolve, reject) => {
            const command = 'node';
            const fullArgs = [this.ENHANCED_FIXER_PATH, ...args];
            console.log(`üîß Executing: ${command} ${fullArgs.join(' ')}`);
            const child = (0, child_process_1.spawn)(command, fullArgs, {
                stdio: ['pipe', 'pipe', 'pipe'],
                cwd: process.cwd()
            });
            let stdout = '';
            let stderr = '';
            child.stdout.on('data', (data) => {
                stdout += data.toString();
                // Show real-time output if not silent
                if (!args.includes('--silent')) {
                    process.stdout.write(data);
                }
            });
            child.stderr.on('data', (data) => {
                stderr += data.toString();
                if (!args.includes('--silent')) {
                    process.stderr.write(data);
                }
            });
            child.on('close', (code) => {
                const success = code === 0;
                const output = stdout + stderr;
                // Parse output for metrics
                const result = this.parseFixerOutput(output, success);
                if (success) {
                    resolve(result);
                }
                else {
                    resolve({
                        ...result,
                        success: false,
                        errors: [...result.errors, `Process exited with code ${code}`]
                    });
                }
            });
            child.on('error', (error) => {
                reject(error);
            });
        });
    }
    /**
     * Parse Enhanced Error Fixer output to extract metrics
     */
    parseFixerOutput(output, success) {
        const warnings = [];
        const errors = [];
        // Extract metrics from output
        let filesProcessed = 0;
        let errorsFixed = 0;
        const errorsRemaining = 0;
        let safetyScore;
        // Parse files processed
        const filesMatch = output.match(/(?:processed|fixed)\s+(\d+)\s+files?/i);
        if (filesMatch) {
            filesProcessed = parseInt(filesMatch[1]);
        }
        // Parse errors fixed
        const errorsFixedMatch = output.match(/(?:fixed|resolved)\s+(\d+)\s+errors?/i);
        if (errorsFixedMatch) {
            errorsFixed = parseInt(errorsFixedMatch[1]);
        }
        // Parse safety score
        const safetyMatch = output.match(/safety\s+score[:\s]+(\d+(?:\.\d+)?)/i);
        if (safetyMatch) {
            safetyScore = parseFloat(safetyMatch[1]);
        }
        // Extract warnings
        const warningMatches = output.match(/‚ö†Ô∏è[^\n]*/g);
        if (warningMatches) {
            warnings.push(...warningMatches);
        }
        // Extract errors
        const errorMatches = output.match(/‚ùå[^\n]*/g);
        if (errorMatches) {
            errors.push(...errorMatches);
        }
        return {
            success,
            filesProcessed,
            errorsFixed,
            errorsRemaining,
            safetyScore,
            warnings,
            errors
        };
    }
    /**
     * Validate build after error fixing
     */
    async validateBuild() {
        try {
            console.log('üîç Validating build...');
            const startTime = Date.now();
            (0, child_process_1.execSync)('yarn build', {
                stdio: 'pipe',
                timeout: 120000 // 2 minute timeout
            });
            const buildTime = Date.now() - startTime;
            console.log(`‚úÖ Build validation passed (${buildTime}ms)`);
            return true;
        }
        catch (error) {
            console.log('‚ùå Build validation failed');
            if (error instanceof Error) {
                console.log(`   Error: ${error.message}`);
            }
            return false;
        }
    }
    /**
     * Get current TypeScript error count
     */
    async getCurrentErrorCount() {
        try {
            const output = (0, child_process_1.execSync)('yarn tsc --noEmit --skipLibCheck 2>&1 | grep -c "error TS"', {
                encoding: 'utf8',
                stdio: 'pipe',
                timeout: 30000 // 30 second timeout
            });
            return parseInt(output.trim()) || 0;
        }
        catch (error) {
            // If grep finds no matches, it returns exit code 1, or timeout occurred
            console.warn('TypeScript error count check failed or timed out:', error.message);
            return 0;
        }
    }
    /**
     * Show Enhanced Error Fixer metrics
     */
    async showMetrics() {
        try {
            console.log('üìä Fetching Enhanced Error Fixer metrics...');
            const result = await this.runFixerCommand(['--show-metrics', '--json']);
            if (result.success) {
                console.log('‚úÖ Metrics retrieved successfully');
            }
            else {
                console.log('‚ö†Ô∏è  Could not retrieve all metrics');
            }
        }
        catch (error) {
            console.error('‚ùå Failed to show metrics:', error);
        }
    }
    /**
     * Validate safety before running fixes
     */
    async validateSafety() {
        try {
            console.log('üõ°Ô∏è  Validating safety...');
            const result = await this.runFixerCommand(['--validate-safety', '--json']);
            // Parse safety validation result
            // This would need to be implemented based on the actual output format
            // For now, return a basic safety check
            return {
                safe: result.success,
                safetyScore: result.safetyScore || 0.5,
                issues: result.errors,
                recommendedBatchSize: this.DEFAULT_BATCH_SIZE
            };
        }
        catch (error) {
            console.error('‚ùå Safety validation failed:', error);
            return {
                safe: false,
                safetyScore: 0,
                issues: [error instanceof Error ? error.message : String(error)],
                recommendedBatchSize: 3 // Conservative batch size
            };
        }
    }
    /**
     * Execute with recommended safety settings (Requirements 1.6, 1.7)
     */
    async executeWithSafetyProtocols() {
        console.log('üõ°Ô∏è  Executing Enhanced Error Fixer with safety protocols...');
        // First, validate safety
        const safetyCheck = await this.validateSafety();
        if (!safetyCheck.safe) {
            console.log('‚ö†Ô∏è  Safety validation failed:');
            safetyCheck.issues.forEach(issue => console.log(`   - ${issue}`));
            // Use conservative settings
            return await this.executeEnhancedFixer({
                maxFiles: 3,
                autoFix: false,
                dryRun: true,
                validateSafety: true
            });
        }
        // Execute with recommended batch size
        return await this.executeEnhancedFixer({
            maxFiles: Math.min(safetyCheck.recommendedBatchSize, this.DEFAULT_BATCH_SIZE),
            autoFix: true,
            validateSafety: true
        });
    }
}
exports.EnhancedErrorFixerIntegration = EnhancedErrorFixerIntegration;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9FbmhhbmNlZEVycm9yRml4ZXJJbnRlZ3JhdGlvbi50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0dBUUc7OztBQUVILGlEQUFnRDtBQWtDaEQsTUFBYSw2QkFBNkI7SUFDdkIsbUJBQW1CLEdBQUcsK0RBQStELENBQUM7SUFDdEYsa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLHlCQUF5QixHQUFHLENBQUMsQ0FBQztJQUUvQzs7T0FFRztJQUNILEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxVQUF3QixFQUFFO1FBQ25ELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUU3QixPQUFPLENBQUMsR0FBRyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7UUFFbkUsNEJBQTRCO1FBQzVCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUUvQyxJQUFJO1lBQ0YsbUNBQW1DO1lBQ25DLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVoRCw4QkFBOEI7WUFDOUIsTUFBTSxxQkFBcUIsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUV6RCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFDO1lBRTdDLE9BQU87Z0JBQ0wsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO2dCQUN2QixjQUFjLEVBQUUsTUFBTSxDQUFDLGNBQWM7Z0JBQ3JDLFdBQVcsRUFBRSxNQUFNLENBQUMsV0FBVztnQkFDL0IsZUFBZSxFQUFFLE1BQU0sQ0FBQyxlQUFlO2dCQUN2QyxxQkFBcUI7Z0JBQ3JCLGFBQWE7Z0JBQ2IsV0FBVyxFQUFFLE1BQU0sQ0FBQyxXQUFXO2dCQUMvQixRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVE7Z0JB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L1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9FbmhhbmNlZEVycm9yRml4ZXJJbnRlZ3JhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuaGFuY2VkIEVycm9yIEZpeGVyIEludGVncmF0aW9uIGZvciBQZXJmZWN0IENvZGViYXNlIENhbXBhaWduXG4gKiBcbiAqIFdyYXBwZXIgZm9yIHNjcmlwdHMvdHlwZXNjcmlwdC1maXhlcy9maXgtdHlwZXNjcmlwdC1lcnJvcnMtZW5oYW5jZWQtdjMuanNcbiAqIEltcGxlbWVudHMgYmF0Y2ggcHJvY2Vzc2luZyB3aXRoIC0tbWF4LWZpbGVzPTE1IC0tYXV0by1maXggcGFyYW1ldGVyc1xuICogQ3JlYXRlcyBidWlsZCB2YWxpZGF0aW9uIGFmdGVyIGV2ZXJ5IDUgZmlsZXMgcHJvY2Vzc2VkXG4gKiBcbiAqIFJlcXVpcmVtZW50czogMS42LCAxLjcsIDcuMVxuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jLCBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyB0ZXJtaW5hbEZyZWV6ZVByZXZlbnRpb25TeXN0ZW0gfSBmcm9tICcuL1Rlcm1pbmFsRnJlZXplUHJldmVudGlvblN5c3RlbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRml4ZXJPcHRpb25zIHtcbiAgbWF4RmlsZXM/OiBudW1iZXI7XG4gIGF1dG9GaXg/OiBib29sZWFuO1xuICBkcnlSdW4/OiBib29sZWFuO1xuICB2YWxpZGF0ZVNhZmV0eT86IGJvb2xlYW47XG4gIHNpbGVudD86IGJvb2xlYW47XG4gIGpzb24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpeGVyUmVzdWx0IHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZmlsZXNQcm9jZXNzZWQ6IG51bWJlcjtcbiAgZXJyb3JzRml4ZWQ6IG51bWJlcjtcbiAgZXJyb3JzUmVtYWluaW5nOiBudW1iZXI7XG4gIGJ1aWxkVmFsaWRhdGlvblBhc3NlZDogYm9vbGVhbjtcbiAgZXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICBzYWZldHlTY29yZT86IG51bWJlcjtcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xuICBlcnJvcnM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoUHJvY2Vzc2luZ09wdGlvbnMge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgYnVpbGRWYWxpZGF0aW9uSW50ZXJ2YWw6IG51bWJlcjtcbiAgbWF4QmF0Y2hlcz86IG51bWJlcjtcbiAgc3RvcE9uQnVpbGRGYWlsdXJlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEVuaGFuY2VkRXJyb3JGaXhlckludGVncmF0aW9uIHtcbiAgcHJpdmF0ZSByZWFkb25seSBFTkhBTkNFRF9GSVhFUl9QQVRIID0gJ3NjcmlwdHMvdHlwZXNjcmlwdC1maXhlcy9maXgtdHlwZXNjcmlwdC1lcnJvcnMtZW5oYW5jZWQtdjMuanMnO1xuICBwcml2YXRlIHJlYWRvbmx5IERFRkFVTFRfQkFUQ0hfU0laRSA9IDE1O1xuICBwcml2YXRlIHJlYWRvbmx5IEJVSUxEX1ZBTElEQVRJT05fSU5URVJWQUwgPSA1O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIEVuaGFuY2VkIEVycm9yIEZpeGVyIHYzLjAgd2l0aCBzcGVjaWZpZWQgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZUVuaGFuY2VkRml4ZXIob3B0aW9uczogRml4ZXJPcHRpb25zID0ge30pOiBQcm9taXNlPEZpeGVyUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+agCBTdGFydGluZyBFbmhhbmNlZCBUeXBlU2NyaXB0IEVycm9yIEZpeGVyIHYzLjAuLi4nKTtcbiAgICBcbiAgICAvLyBQcmVwYXJlIGNvbW1hbmQgYXJndW1lbnRzXG4gICAgY29uc3QgYXJncyA9IHRoaXMuYnVpbGRGaXhlckFyZ3VtZW50cyhvcHRpb25zKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRXhlY3V0ZSB0aGUgRW5oYW5jZWQgRXJyb3IgRml4ZXJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuRml4ZXJDb21tYW5kKGFyZ3MpO1xuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBidWlsZCBhZnRlciBmaXhpbmdcbiAgICAgIGNvbnN0IGJ1aWxkVmFsaWRhdGlvblBhc3NlZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVCdWlsZCgpO1xuICAgICAgXG4gICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiByZXN1bHQuZmlsZXNQcm9jZXNzZWQsXG4gICAgICAgIGVycm9yc0ZpeGVkOiByZXN1bHQuZXJyb3JzRml4ZWQsXG4gICAgICAgIGVycm9yc1JlbWFpbmluZzogcmVzdWx0LmVycm9yc1JlbWFpbmluZyxcbiAgICAgICAgYnVpbGRWYWxpZGF0aW9uUGFzc2VkLFxuICAgICAgICBleGVjdXRpb25UaW1lLFxuICAgICAgICBzYWZldHlTY29yZTogcmVzdWx0LnNhZmV0eVNjb3JlLFxuICAgICAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnNcbiAgICAgIH07XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVuaGFuY2VkIEVycm9yIEZpeGVyIGV4ZWN1dGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZmlsZXNQcm9jZXNzZWQ6IDAsXG4gICAgICAgIGVycm9yc0ZpeGVkOiAwLFxuICAgICAgICBlcnJvcnNSZW1haW5pbmc6IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEVycm9yQ291bnQoKSxcbiAgICAgICAgYnVpbGRWYWxpZGF0aW9uUGFzc2VkOiBmYWxzZSxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgICBlcnJvcnM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcildXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGJhdGNoIHByb2Nlc3Npbmcgd2l0aCBidWlsZCB2YWxpZGF0aW9uIGFmdGVyIGV2ZXJ5IDUgZmlsZXNcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVCYXRjaFByb2Nlc3Npbmcob3B0aW9uczogQmF0Y2hQcm9jZXNzaW5nT3B0aW9ucyk6IFByb21pc2U8Rml4ZXJSZXN1bHRbXT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFN0YXJ0aW5nIGJhdGNoIHByb2Nlc3Npbmcgd2l0aCAke29wdGlvbnMuYmF0Y2hTaXplfSBmaWxlcyBwZXIgYmF0Y2guLi5gKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHRzOiBGaXhlclJlc3VsdFtdID0gW107XG4gICAgbGV0IGJhdGNoTnVtYmVyID0gMTtcbiAgICBsZXQgdG90YWxGaWxlc1Byb2Nlc3NlZCA9IDA7XG4gICAgbGV0IHRvdGFsRXJyb3JzRml4ZWQgPSAwO1xuICAgIFxuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSBvcHRpb25zLm1heEJhdGNoZXMgfHwgNTA7IC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1heEV4ZWN1dGlvblRpbWUgPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlcyBtYXhcbiAgICBcbiAgICB3aGlsZSAoYmF0Y2hOdW1iZXIgPD0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coYFxcbvCfk6YgUHJvY2Vzc2luZyBCYXRjaCAke2JhdGNoTnVtYmVyfS8ke21heEl0ZXJhdGlvbnN9Li4uYCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGV4ZWN1dGlvbiB0aW1lIGxpbWl0XG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IG1heEV4ZWN1dGlvblRpbWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKPsCBNYXhpbXVtIGV4ZWN1dGlvbiB0aW1lICgzMCBtaW51dGVzKSByZWFjaGVkLCBzdG9wcGluZ2ApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHN0b3AgKG1heCBiYXRjaGVzIHJlYWNoZWQpXG4gICAgICBpZiAob3B0aW9ucy5tYXhCYXRjaGVzICYmIGJhdGNoTnVtYmVyID4gb3B0aW9ucy5tYXhCYXRjaGVzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIsgUmVhY2hlZCBtYXhpbXVtIGJhdGNoIGxpbWl0ICgke29wdGlvbnMubWF4QmF0Y2hlc30pYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBjdXJyZW50IGVycm9yIGNvdW50IHdpdGggdGltZW91dCBwcm90ZWN0aW9uXG4gICAgICBsZXQgY3VycmVudEVycm9ycyA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50RXJyb3JzID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50RXJyb3JDb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gIEVycm9yIGNvdW50IGNoZWNrIGZhaWxlZCwgYXNzdW1pbmcgZXJyb3JzIHJlbWFpbicpO1xuICAgICAgICBjdXJyZW50RXJyb3JzID0gMTsgLy8gQXNzdW1lIGVycm9ycyBleGlzdCB0byBjb250aW51ZSBzYWZlbHlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRFcnJvcnMgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CfjokgTm8gbW9yZSBUeXBlU2NyaXB0IGVycm9ycyBmb3VuZCEnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV4ZWN1dGUgZml4ZXIgZm9yIHRoaXMgYmF0Y2hcbiAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlRW5oYW5jZWRGaXhlcih7XG4gICAgICAgIG1heEZpbGVzOiBvcHRpb25zLmJhdGNoU2l6ZSxcbiAgICAgICAgYXV0b0ZpeDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVTYWZldHk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXN1bHRzLnB1c2goYmF0Y2hSZXN1bHQpO1xuICAgICAgdG90YWxGaWxlc1Byb2Nlc3NlZCArPSBiYXRjaFJlc3VsdC5maWxlc1Byb2Nlc3NlZDtcbiAgICAgIHRvdGFsRXJyb3JzRml4ZWQgKz0gYmF0Y2hSZXN1bHQuZXJyb3JzRml4ZWQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEJhdGNoICR7YmF0Y2hOdW1iZXJ9IFJlc3VsdHM6YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICBGaWxlcyBwcm9jZXNzZWQ6ICR7YmF0Y2hSZXN1bHQuZmlsZXNQcm9jZXNzZWR9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICBFcnJvcnMgZml4ZWQ6ICR7YmF0Y2hSZXN1bHQuZXJyb3JzRml4ZWR9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICBCdWlsZCB2YWxpZGF0aW9uOiAke2JhdGNoUmVzdWx0LmJ1aWxkVmFsaWRhdGlvblBhc3NlZCA/ICfinIUnIDogJ+KdjCd9YCk7XG4gICAgICBcbiAgICAgIC8vIFN0b3Agb24gYnVpbGQgZmFpbHVyZSBpZiBjb25maWd1cmVkXG4gICAgICBpZiAob3B0aW9ucy5zdG9wT25CdWlsZEZhaWx1cmUgJiYgIWJhdGNoUmVzdWx0LmJ1aWxkVmFsaWRhdGlvblBhc3NlZCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+bkSBTdG9wcGluZyBiYXRjaCBwcm9jZXNzaW5nIGR1ZSB0byBidWlsZCBmYWlsdXJlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdG9wIGlmIG5vIHByb2dyZXNzIG1hZGVcbiAgICAgIGlmIChiYXRjaFJlc3VsdC5maWxlc1Byb2Nlc3NlZCA9PT0gMCAmJiBiYXRjaFJlc3VsdC5lcnJvcnNGaXhlZCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+477iPICBObyBwcm9ncmVzcyBtYWRlIGluIHRoaXMgYmF0Y2gsIHN0b3BwaW5nJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCdWlsZCB2YWxpZGF0aW9uIGFmdGVyIGV2ZXJ5IE4gZmlsZXMgKGFzIHNwZWNpZmllZCBpbiByZXF1aXJlbWVudHMpXG4gICAgICBpZiAodG90YWxGaWxlc1Byb2Nlc3NlZCAlIG9wdGlvbnMuYnVpbGRWYWxpZGF0aW9uSW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gUGVyZm9ybWluZyBidWlsZCB2YWxpZGF0aW9uIGFmdGVyICR7dG90YWxGaWxlc1Byb2Nlc3NlZH0gZmlsZXMuLi5gKTtcbiAgICAgICAgY29uc3QgYnVpbGRWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVCdWlsZCgpO1xuICAgICAgICBpZiAoIWJ1aWxkVmFsaWQgJiYgb3B0aW9ucy5zdG9wT25CdWlsZEZhaWx1cmUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+bkSBCdWlsZCB2YWxpZGF0aW9uIGZhaWxlZCwgc3RvcHBpbmcgYmF0Y2ggcHJvY2Vzc2luZycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGJhdGNoTnVtYmVyKys7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBcXG7wn5OIIEJhdGNoIFByb2Nlc3NpbmcgU3VtbWFyeTpgKTtcbiAgICBjb25zb2xlLmxvZyhgICBUb3RhbCBiYXRjaGVzOiAke3Jlc3VsdHMubGVuZ3RofWApO1xuICAgIGNvbnNvbGUubG9nKGAgIFRvdGFsIGZpbGVzIHByb2Nlc3NlZDogJHt0b3RhbEZpbGVzUHJvY2Vzc2VkfWApO1xuICAgIGNvbnNvbGUubG9nKGAgIFRvdGFsIGVycm9ycyBmaXhlZDogJHt0b3RhbEVycm9yc0ZpeGVkfWApO1xuICAgIGNvbnNvbGUubG9nKGAgIFJlbWFpbmluZyBlcnJvcnM6ICR7YXdhaXQgdGhpcy5nZXRDdXJyZW50RXJyb3JDb3VudCgpfWApO1xuICAgIFxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGNvbW1hbmQgYXJndW1lbnRzIGZvciBFbmhhbmNlZCBFcnJvciBGaXhlclxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZEZpeGVyQXJndW1lbnRzKG9wdGlvbnM6IEZpeGVyT3B0aW9ucyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBhcmdzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmIChvcHRpb25zLm1heEZpbGVzKSB7XG4gICAgICBhcmdzLnB1c2goYC0tbWF4LWZpbGVzPSR7b3B0aW9ucy5tYXhGaWxlc31gKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuYXV0b0ZpeCkge1xuICAgICAgYXJncy5wdXNoKCctLWF1dG8tZml4Jyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChvcHRpb25zLmRyeVJ1bikge1xuICAgICAgYXJncy5wdXNoKCctLWRyeS1ydW4nKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGVTYWZldHkpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS12YWxpZGF0ZS1zYWZldHknKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7XG4gICAgICBhcmdzLnB1c2goJy0tc2lsZW50Jyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChvcHRpb25zLmpzb24pIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1qc29uJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIEVuaGFuY2VkIEVycm9yIEZpeGVyIGNvbW1hbmRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcnVuRml4ZXJDb21tYW5kKGFyZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTx7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBmaWxlc1Byb2Nlc3NlZDogbnVtYmVyO1xuICAgIGVycm9yc0ZpeGVkOiBudW1iZXI7XG4gICAgZXJyb3JzUmVtYWluaW5nOiBudW1iZXI7XG4gICAgc2FmZXR5U2NvcmU/OiBudW1iZXI7XG4gICAgd2FybmluZ3M6IHN0cmluZ1tdO1xuICAgIGVycm9yczogc3RyaW5nW107XG4gIH0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY29tbWFuZCA9ICdub2RlJztcbiAgICAgIGNvbnN0IGZ1bGxBcmdzID0gW3RoaXMuRU5IQU5DRURfRklYRVJfUEFUSCwgLi4uYXJnc107XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SnIEV4ZWN1dGluZzogJHtjb21tYW5kfSAke2Z1bGxBcmdzLmpvaW4oJyAnKX1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bihjb21tYW5kLCBmdWxsQXJncywge1xuICAgICAgICBzdGRpbzogWydwaXBlJywgJ3BpcGUnLCAncGlwZSddLFxuICAgICAgICBjd2Q6IHByb2Nlc3MuY3dkKClcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBsZXQgc3Rkb3V0ID0gJyc7XG4gICAgICBsZXQgc3RkZXJyID0gJyc7XG4gICAgICBcbiAgICAgIGNoaWxkLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZG91dCArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIFNob3cgcmVhbC10aW1lIG91dHB1dCBpZiBub3Qgc2lsZW50XG4gICAgICAgIGlmICghYXJncy5pbmNsdWRlcygnLS1zaWxlbnQnKSkge1xuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgc3RkZXJyICs9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCFhcmdzLmluY2x1ZGVzKCctLXNpbGVudCcpKSB7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gY29kZSA9PT0gMDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3Rkb3V0ICsgc3RkZXJyO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2Ugb3V0cHV0IGZvciBtZXRyaWNzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2VGaXhlck91dHB1dChvdXRwdXQsIHN1Y2Nlc3MpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yczogWy4uLnJlc3VsdC5lcnJvcnMsIGBQcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjaGlsZC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIEVuaGFuY2VkIEVycm9yIEZpeGVyIG91dHB1dCB0byBleHRyYWN0IG1ldHJpY3NcbiAgICovXG4gIHByaXZhdGUgcGFyc2VGaXhlck91dHB1dChvdXRwdXQ6IHN0cmluZywgc3VjY2VzczogYm9vbGVhbik6IHtcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIGZpbGVzUHJvY2Vzc2VkOiBudW1iZXI7XG4gICAgZXJyb3JzRml4ZWQ6IG51bWJlcjtcbiAgICBlcnJvcnNSZW1haW5pbmc6IG51bWJlcjtcbiAgICBzYWZldHlTY29yZT86IG51bWJlcjtcbiAgICB3YXJuaW5nczogc3RyaW5nW107XG4gICAgZXJyb3JzOiBzdHJpbmdbXTtcbiAgfSB7XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgbWV0cmljcyBmcm9tIG91dHB1dFxuICAgIGxldCBmaWxlc1Byb2Nlc3NlZCA9IDA7XG4gICAgbGV0IGVycm9yc0ZpeGVkID0gMDtcbiAgICBjb25zdCBlcnJvcnNSZW1haW5pbmcgPSAwO1xuICAgIGxldCBzYWZldHlTY29yZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIFxuICAgIC8vIFBhcnNlIGZpbGVzIHByb2Nlc3NlZFxuICAgIGNvbnN0IGZpbGVzTWF0Y2ggPSBvdXRwdXQubWF0Y2goLyg/OnByb2Nlc3NlZHxmaXhlZClcXHMrKFxcZCspXFxzK2ZpbGVzPy9pKTtcbiAgICBpZiAoZmlsZXNNYXRjaCkge1xuICAgICAgZmlsZXNQcm9jZXNzZWQgPSBwYXJzZUludChmaWxlc01hdGNoWzFdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGFyc2UgZXJyb3JzIGZpeGVkXG4gICAgY29uc3QgZXJyb3JzRml4ZWRNYXRjaCA9IG91dHB1dC5tYXRjaCgvKD86Zml4ZWR8cmVzb2x2ZWQpXFxzKyhcXGQrKVxccytlcnJvcnM/L2kpO1xuICAgIGlmIChlcnJvcnNGaXhlZE1hdGNoKSB7XG4gICAgICBlcnJvcnNGaXhlZCA9IHBhcnNlSW50KGVycm9yc0ZpeGVkTWF0Y2hbMV0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBQYXJzZSBzYWZldHkgc2NvcmVcbiAgICBjb25zdCBzYWZldHlNYXRjaCA9IG91dHB1dC5tYXRjaCgvc2FmZXR5XFxzK3Njb3JlWzpcXHNdKyhcXGQrKD86XFwuXFxkKyk/KS9pKTtcbiAgICBpZiAoc2FmZXR5TWF0Y2gpIHtcbiAgICAgIHNhZmV0eVNjb3JlID0gcGFyc2VGbG9hdChzYWZldHlNYXRjaFsxXSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4dHJhY3Qgd2FybmluZ3NcbiAgICBjb25zdCB3YXJuaW5nTWF0Y2hlcyA9IG91dHB1dC5tYXRjaCgv4pqg77iPW15cXG5dKi9nKTtcbiAgICBpZiAod2FybmluZ01hdGNoZXMpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goLi4ud2FybmluZ01hdGNoZXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBFeHRyYWN0IGVycm9yc1xuICAgIGNvbnN0IGVycm9yTWF0Y2hlcyA9IG91dHB1dC5tYXRjaCgv4p2MW15cXG5dKi9nKTtcbiAgICBpZiAoZXJyb3JNYXRjaGVzKSB7XG4gICAgICBlcnJvcnMucHVzaCguLi5lcnJvck1hdGNoZXMpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzcyxcbiAgICAgIGZpbGVzUHJvY2Vzc2VkLFxuICAgICAgZXJyb3JzRml4ZWQsXG4gICAgICBlcnJvcnNSZW1haW5pbmcsXG4gICAgICBzYWZldHlTY29yZSxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgZXJyb3JzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBidWlsZCBhZnRlciBlcnJvciBmaXhpbmdcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdmFsaWRhdGVCdWlsZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gVmFsaWRhdGluZyBidWlsZC4uLicpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgZXhlY1N5bmMoJ3lhcm4gYnVpbGQnLCB7IFxuICAgICAgICBzdGRpbzogJ3BpcGUnLFxuICAgICAgICB0aW1lb3V0OiAxMjAwMDAgLy8gMiBtaW51dGUgdGltZW91dFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGJ1aWxkVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEJ1aWxkIHZhbGlkYXRpb24gcGFzc2VkICgke2J1aWxkVGltZX1tcylgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgQnVpbGQgdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBUeXBlU2NyaXB0IGVycm9yIGNvdW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEN1cnJlbnRFcnJvckNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKCd5YXJuIHRzYyAtLW5vRW1pdCAtLXNraXBMaWJDaGVjayAyPiYxIHwgZ3JlcCAtYyBcImVycm9yIFRTXCInLCB7IFxuICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICBzdGRpbzogJ3BpcGUnLFxuICAgICAgICB0aW1lb3V0OiAzMDAwMCAvLyAzMCBzZWNvbmQgdGltZW91dFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VJbnQob3V0cHV0LnRyaW0oKSkgfHwgMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgZ3JlcCBmaW5kcyBubyBtYXRjaGVzLCBpdCByZXR1cm5zIGV4aXQgY29kZSAxLCBvciB0aW1lb3V0IG9jY3VycmVkXG4gICAgICBjb25zb2xlLndhcm4oJ1R5cGVTY3JpcHQgZXJyb3IgY291bnQgY2hlY2sgZmFpbGVkIG9yIHRpbWVkIG91dDonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IEVuaGFuY2VkIEVycm9yIEZpeGVyIG1ldHJpY3NcbiAgICovXG4gIGFzeW5jIHNob3dNZXRyaWNzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBGZXRjaGluZyBFbmhhbmNlZCBFcnJvciBGaXhlciBtZXRyaWNzLi4uJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuRml4ZXJDb21tYW5kKFsnLS1zaG93LW1ldHJpY3MnLCAnLS1qc29uJ10pO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBNZXRyaWNzIHJldHJpZXZlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIENvdWxkIG5vdCByZXRyaWV2ZSBhbGwgbWV0cmljcycpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc2hvdyBtZXRyaWNzOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgc2FmZXR5IGJlZm9yZSBydW5uaW5nIGZpeGVzXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZVNhZmV0eSgpOiBQcm9taXNlPHtcbiAgICBzYWZlOiBib29sZWFuO1xuICAgIHNhZmV0eVNjb3JlOiBudW1iZXI7XG4gICAgaXNzdWVzOiBzdHJpbmdbXTtcbiAgICByZWNvbW1lbmRlZEJhdGNoU2l6ZTogbnVtYmVyO1xuICB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5uh77iPICBWYWxpZGF0aW5nIHNhZmV0eS4uLicpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkZpeGVyQ29tbWFuZChbJy0tdmFsaWRhdGUtc2FmZXR5JywgJy0tanNvbiddKTtcbiAgICAgIFxuICAgICAgLy8gUGFyc2Ugc2FmZXR5IHZhbGlkYXRpb24gcmVzdWx0XG4gICAgICAvLyBUaGlzIHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgYmFzZWQgb24gdGhlIGFjdHVhbCBvdXRwdXQgZm9ybWF0XG4gICAgICAvLyBGb3Igbm93LCByZXR1cm4gYSBiYXNpYyBzYWZldHkgY2hlY2tcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2FmZTogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgIHNhZmV0eVNjb3JlOiByZXN1bHQuc2FmZXR5U2NvcmUgfHwgMC41LFxuICAgICAgICBpc3N1ZXM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICAgIHJlY29tbWVuZGVkQmF0Y2hTaXplOiB0aGlzLkRFRkFVTFRfQkFUQ0hfU0laRVxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgU2FmZXR5IHZhbGlkYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2FmZTogZmFsc2UsXG4gICAgICAgIHNhZmV0eVNjb3JlOiAwLFxuICAgICAgICBpc3N1ZXM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcildLFxuICAgICAgICByZWNvbW1lbmRlZEJhdGNoU2l6ZTogMyAvLyBDb25zZXJ2YXRpdmUgYmF0Y2ggc2l6ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSB3aXRoIHJlY29tbWVuZGVkIHNhZmV0eSBzZXR0aW5ncyAoUmVxdWlyZW1lbnRzIDEuNiwgMS43KVxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZVdpdGhTYWZldHlQcm90b2NvbHMoKTogUHJvbWlzZTxGaXhlclJlc3VsdD4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5uh77iPICBFeGVjdXRpbmcgRW5oYW5jZWQgRXJyb3IgRml4ZXIgd2l0aCBzYWZldHkgcHJvdG9jb2xzLi4uJyk7XG4gICAgXG4gICAgLy8gRmlyc3QsIHZhbGlkYXRlIHNhZmV0eVxuICAgIGNvbnN0IHNhZmV0eUNoZWNrID0gYXdhaXQgdGhpcy52YWxpZGF0ZVNhZmV0eSgpO1xuICAgIFxuICAgIGlmICghc2FmZXR5Q2hlY2suc2FmZSkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyAgU2FmZXR5IHZhbGlkYXRpb24gZmFpbGVkOicpO1xuICAgICAgc2FmZXR5Q2hlY2suaXNzdWVzLmZvckVhY2goaXNzdWUgPT4gY29uc29sZS5sb2coYCAgIC0gJHtpc3N1ZX1gKSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBjb25zZXJ2YXRpdmUgc2V0dGluZ3NcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVFbmhhbmNlZEZpeGVyKHtcbiAgICAgICAgbWF4RmlsZXM6IDMsXG4gICAgICAgIGF1dG9GaXg6IGZhbHNlLCAvLyBEcnkgcnVuIG9ubHlcbiAgICAgICAgZHJ5UnVuOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNhZmV0eTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4ZWN1dGUgd2l0aCByZWNvbW1lbmRlZCBiYXRjaCBzaXplXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZUVuaGFuY2VkRml4ZXIoe1xuICAgICAgbWF4RmlsZXM6IE1hdGgubWluKHNhZmV0eUNoZWNrLnJlY29tbWVuZGVkQmF0Y2hTaXplLCB0aGlzLkRFRkFVTFRfQkFUQ0hfU0laRSksXG4gICAgICBhdXRvRml4OiB0cnVlLFxuICAgICAgdmFsaWRhdGVTYWZldHk6IHRydWVcbiAgICB9KTtcbiAgfVxufSJdLCJ2ZXJzaW9uIjozfQ==