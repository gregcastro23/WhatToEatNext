3639d35d184e1d0d209495c4fdf2418b
"use strict";
/**
 * Test File Rule Validation Test Suite
 *
 * Tests the domain-specific ESLint rules for test files
 * to ensure appropriate relaxations for mock variables and testing patterns.
 *
 * Requirements: 4.4
 */
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
describe('Test File Rule Validation', () => {
    const projectRoot = process.cwd();
    const tempFiles = [];
    afterEach(() => {
        // Clean up temporary test files
        tempFiles.forEach(file => {
            try {
                (0, child_process_1.execSync)(`rm -f "${file}"`);
            }
            catch { }
        });
        tempFiles.length = 0;
    });
    describe('Mock Variable Relaxations', () => {
        test('should ignore unused mock variables', async () => {
            const testContent = `
        describe('Mock Variable Tests', () => {
          test('should handle mock variables', () => {
            const mockFunction = jest.fn();
            const stubValue = 'test-stub';
            const testData = { id: 1, name: 'test' };
            const mockObject = { method: jest.fn() };
            const stubArray = [1, 2, 3];
            const testConfig = { enabled: true };
            const UNUSED_mock = 'unused-mock';
            const UNUSED_stub = 'unused-stub';
            const UNUSED_test = 'unused-test';
            
            // Only use one variable to test unused variable handling
            expect(mockFunction).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-mock-variables.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('mock') || msg.message.includes('stub') ||
                            msg.message.includes('test')));
                    // Mock variable patterns should be ignored in test files
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('mock') || msg.message.includes('stub') ||
                                msg.message.includes('test')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow Jest mock functions', async () => {
            const testContent = `
        describe('Jest Mock Functions', () => {
          const mockCallback = jest.fn();
          const mockImplementation = jest.fn(() => 'mocked');
          const mockReturnValue = jest.fn().mockReturnValue('value');
          const mockResolvedValue = jest.fn().mockResolvedValue('resolved');
          const mockRejectedValue = jest.fn().mockRejectedValue(new Error('rejected'));
          
          beforeEach(() => {
            jest.clearAllMocks();
            mockCallback.mockClear();
            mockImplementation.mockReset();
            mockReturnValue.mockRestore();
          });
          
          test('should work with mocks', () => {
            expect(mockCallback).toHaveBeenCalledTimes(0);
            expect(mockImplementation()).toBe('mocked');
            expect(mockReturnValue()).toBe('value');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-mocks.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        msg.message.includes('mock'));
                    // Jest mock functions should be allowed
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            msg.message.includes('mock'));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow test data structures', async () => {
            const testContent = `
        describe('Test Data Structures', () => {
          const testUser = { id: 1, name: 'Test User', email: 'test@example.com' };
          const testIngredient = { name: 'tomato', elementalProperties: { Fire: 0.3, Water: 0.7, Earth: 0.2, Air: 0.1 } };
          const testRecipe = { id: 1, name: 'Test Recipe', ingredients: [] };
          const testPlanetaryPosition = { sign: 'aries', degree: 8.5, exactLongitude: 8.5, isRetrograde: false };
          const testConfig = { apiUrl: 'http://test.api', timeout: 5000 };
          const testMetrics = { errors: 0, warnings: 5, processed: 100 };
          
          test('should use test data', () => {
            expect(testUser.id).toBe(1);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-data.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        msg.message.includes('test'));
                    // Test data structures should be allowed
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            msg.message.includes('test'));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test-Specific Rule Relaxations', () => {
        test('should allow explicit any types in tests', async () => {
            const testContent = `
        describe('Any Type Tests', () => {
          test('should allow any types for flexible testing', () => {
            const anyValue: any = 'test-value';
            const anyObject: any = { prop: 'value' };
            const anyArray: any[] = [1, 'two', { three: 3 }];
            const anyFunction: any = () => 'result';
            
            // Test dynamic behavior
            anyObject.dynamicProperty = 'dynamic';
            anyArray.push({ dynamic: true });
            
            expect(anyValue).toBeDefined();
            expect(anyObject.prop).toBe('value');
            expect(anyArray.length).toBeGreaterThan(0);
            expect(anyFunction()).toBe('result');
          });
          
          test('should handle API responses with any', () => {
            const apiResponse: any = {
              data: { id: 1, name: 'test' },
              status: 200,
              headers: { 'content-type': 'application/json' }
            };
            
            expect(apiResponse.data.id).toBe(1);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-any-types.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const anyTypeErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2 // error level
                    );
                    // Test files should allow explicit any types
                    expect(anyTypeErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const anyTypeErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2);
                        expect(anyTypeErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow console statements in tests', async () => {
            const testContent = `
        describe('Console Statement Tests', () => {
          test('should allow console output for debugging', () => {
            console.log('Test starting...');
            console.info('Processing test data');
            console.warn('This is a test warning');
            console.error('This is a test error (not real)');
            console.debug('Debug information for test');
            console.table([{ test: 'data', value: 123 }]);
            console.group('Test Group');
            console.log('Grouped test output');
            console.groupEnd();
            console.time('test-timer');
            console.timeEnd('test-timer');
            console.count('test-counter');
            
            expect(true).toBe(true);
          });
          
          beforeEach(() => {
            console.log('Setting up test...');
          });
          
          afterEach(() => {
            console.log('Cleaning up test...');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-console-statements.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2 // error level
                    );
                    // Test files should allow console statements
                    expect(consoleErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2);
                        expect(consoleErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow non-null assertions in tests', async () => {
            const testContent = `
        describe('Non-null Assertion Tests', () => {
          test('should allow non-null assertions for test certainty', () => {
            const maybeValue: string | null = 'test-value';
            const maybeObject: { prop?: string } = { prop: 'value' };
            const maybeArray: number[] | undefined = [1, 2, 3];
            
            // Non-null assertions should be allowed in tests
            const definiteValue = maybeValue!;
            const definiteProperty = maybeObject.prop!;
            const definiteArray = maybeArray!;
            
            expect(definiteValue).toBe('test-value');
            expect(definiteProperty).toBe('value');
            expect(definiteArray.length).toBe(3);
            
            // Test DOM elements (common in React tests)
            const element = document.querySelector('.test-element')!;
            const button = document.getElementById('test-button')!;
            
            // These would normally be checked, but in tests we know they exist
            expect(element).toBeDefined();
            expect(button).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-non-null-assertions.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const nonNullErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2 // error level
                    );
                    // Test files should allow non-null assertions
                    expect(nonNullErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const nonNullErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2);
                        expect(nonNullErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow magic numbers in tests', async () => {
            const testContent = `
        describe('Magic Numbers Tests', () => {
          test('should allow magic numbers for test values', () => {
            const testId = 12345;
            const testScore = 98.7;
            const testCount = 42;
            const testPercentage = 75.5;
            const testTimeout = 5000;
            const testPort = 3000;
            const testStatusCode = 200;
            const testErrorCode = 404;
            
            expect(testId).toBe(12345);
            expect(testScore).toBeCloseTo(98.7);
            expect(testCount).toBe(42);
            expect(testPercentage).toBe(75.5);
            
            // Common test patterns with magic numbers
            setTimeout(() => {}, 1000);
            expect(Array(10).fill(0)).toHaveLength(10);
            expect(Math.random() * 100).toBeLessThan(100);
            
            // HTTP status codes
            expect(testStatusCode).toBe(200);
            expect(testErrorCode).toBe(404);
          });
          
          test('should handle test data with magic numbers', () => {
            const testData = {
              users: Array(50).fill(null).map((_, i) => ({ id: i + 1 })),
              pageSize: 25,
              totalPages: 4,
              currentPage: 1
            };
            
            expect(testData.users).toHaveLength(50);
            expect(testData.pageSize).toBe(25);
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-magic-numbers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const magicNumberErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-magic-numbers' && msg.severity === 2 // error level
                    );
                    // Test files should allow magic numbers
                    expect(magicNumberErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const magicNumberErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-magic-numbers' && msg.severity === 2);
                        expect(magicNumberErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should allow relaxed complexity in tests', async () => {
            const testContent = `
        describe('Complex Test Logic', () => {
          test('should allow complex test scenarios', () => {
            // Complex test logic should be allowed
            const testScenarios = [
              { input: 'a', expected: 1 },
              { input: 'b', expected: 2 },
              { input: 'c', expected: 3 }
            ];
            
            testScenarios.forEach(scenario => {
              for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 3; j++) {
                  if (scenario.input === 'a') {
                    if (i > 2) {
                      if (j === 1) {
                        expect(scenario.expected).toBe(1);
                      } else if (j === 2) {
                        expect(scenario.expected).toBeGreaterThan(0);
                      } else {
                        expect(scenario.expected).toBeDefined();
                      }
                    } else {
                      expect(scenario.expected).toBeTruthy();
                    }
                  } else if (scenario.input === 'b') {
                    if (i < 3) {
                      expect(scenario.expected).toBe(2);
                    } else {
                      expect(scenario.expected).toBeGreaterThan(1);
                    }
                  } else {
                    expect(scenario.expected).toBe(3);
                  }
                }
              }
            });
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-complex-test.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2 // error level
                    );
                    // Test files should allow complex logic
                    expect(complexityErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2);
                        expect(complexityErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Jest Globals Availability', () => {
        test('should have Jest globals available without no-undef errors', async () => {
            const testContent = `
        describe('Jest Globals Test', () => {
          beforeAll(() => {
            console.log('Before all tests');
          });
          
          beforeEach(() => {
            console.log('Before each test');
          });
          
          afterEach(() => {
            console.log('After each test');
          });
          
          afterAll(() => {
            console.log('After all tests');
          });
          
          test('should have access to Jest globals', () => {
            expect(true).toBe(true);
            expect(false).toBeFalsy();
            expect('string').toEqual('string');
            expect(42).toBeGreaterThan(0);
            expect([1, 2, 3]).toHaveLength(3);
            expect({ key: 'value' }).toHaveProperty('key');
          });
          
          it('should work with it() syntax', () => {
            expect(jest).toBeDefined();
            expect(describe).toBeDefined();
            expect(test).toBeDefined();
            expect(it).toBeDefined();
            expect(expect).toBeDefined();
          });
          
          test('should have Jest mock functions', () => {
            const mockFn = jest.fn();
            mockFn('test');
            
            expect(mockFn).toHaveBeenCalled();
            expect(mockFn).toHaveBeenCalledWith('test');
            expect(mockFn).toHaveBeenCalledTimes(1);
            
            jest.clearAllMocks();
            expect(mockFn).not.toHaveBeenCalled();
          });
          
          test('should have Jest spy functions', () => {
            const obj = { method: () => 'original' };
            const spy = jest.spyOn(obj, 'method').mockReturnValue('mocked');
            
            expect(obj.method()).toBe('mocked');
            expect(spy).toHaveBeenCalled();
            
            spy.mockRestore();
            expect(obj.method()).toBe('original');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-globals.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                        (msg.message.includes('describe') || msg.message.includes('it') ||
                            msg.message.includes('test') || msg.message.includes('expect') ||
                            msg.message.includes('jest') || msg.message.includes('beforeAll') ||
                            msg.message.includes('beforeEach') || msg.message.includes('afterEach') ||
                            msg.message.includes('afterAll')));
                    // Jest globals should be available without no-undef errors
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                            (msg.message.includes('describe') || msg.message.includes('it') ||
                                msg.message.includes('test') || msg.message.includes('expect') ||
                                msg.message.includes('jest') || msg.message.includes('beforeAll') ||
                                msg.message.includes('beforeEach') || msg.message.includes('afterEach') ||
                                msg.message.includes('afterAll')));
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
        test('should have additional Jest matchers available', async () => {
            const testContent = `
        describe('Jest Matchers Test', () => {
          test('should have extended Jest matchers', () => {
            // Basic matchers
            expect(true).toBeTruthy();
            expect(false).toBeFalsy();
            expect(null).toBeNull();
            expect(undefined).toBeUndefined();
            expect('defined').toBeDefined();
            
            // Number matchers
            expect(42).toBeGreaterThan(0);
            expect(42).toBeGreaterThanOrEqual(42);
            expect(42).toBeLessThan(100);
            expect(42).toBeLessThanOrEqual(42);
            expect(3.14).toBeCloseTo(3.1, 1);
            
            // String matchers
            expect('hello world').toMatch(/world/);
            expect('hello world').toContain('world');
            
            // Array matchers
            expect([1, 2, 3]).toHaveLength(3);
            expect([1, 2, 3]).toContain(2);
            expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 3]));
            
            // Object matchers
            expect({ a: 1, b: 2 }).toHaveProperty('a');
            expect({ a: 1, b: 2 }).toHaveProperty('a', 1);
            expect({ a: 1, b: 2 }).toMatchObject({ a: 1 });
            
            // Function matchers
            const mockFn = jest.fn();
            mockFn('arg1', 'arg2');
            expect(mockFn).toHaveBeenCalled();
            expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
            expect(mockFn).toHaveBeenCalledTimes(1);
            expect(mockFn).toHaveBeenLastCalledWith('arg1', 'arg2');
            
            // Promise matchers (async)
            expect(Promise.resolve('value')).resolves.toBe('value');
            expect(Promise.reject(new Error('error'))).rejects.toThrow('error');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-matchers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                    // No undefined variable errors should occur
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test File Pattern Matching', () => {
        test('should apply test rules to correct file patterns', () => {
            const testFiles = [
                'src/components/FoodRecommender.test.tsx',
                'src/utils/astrology.spec.ts',
                'src/services/campaign.test.ts',
                'src/__tests__/calculations/culinaryAstrology.test.ts',
                'src/__tests__/utils/reliableAstronomy.spec.ts',
                'tests/integration/api.test.js'
            ];
            testFiles.forEach(file => {
                // Check if file would match test patterns in ESLint config
                const matchesTestPattern = file.includes('.test.') ||
                    file.includes('.spec.') ||
                    file.includes('__tests__/') ||
                    file.includes('/tests/');
                expect(matchesTestPattern).toBe(true);
            });
        });
        test('should not apply test rules to non-test files', () => {
            const nonTestFiles = [
                'src/components/FoodRecommender.tsx',
                'src/utils/astrology.ts',
                'src/services/campaign.ts',
                'src/calculations/culinaryAstrology.ts',
                'src/data/ingredients/vegetables.ts'
            ];
            nonTestFiles.forEach(file => {
                // Check that file would NOT match test patterns
                const matchesTestPattern = file.includes('.test.') ||
                    file.includes('.spec.') ||
                    file.includes('__tests__/') ||
                    file.includes('/tests/');
                expect(matchesTestPattern).toBe(false);
            });
        });
    });
    describe('Test Environment Configuration', () => {
        test('should have proper Jest environment globals', async () => {
            const testContent = `
        describe('Environment Globals', () => {
          test('should have Node.js globals available', () => {
            expect(process).toBeDefined();
            expect(Buffer).toBeDefined();
            expect(global).toBeDefined();
            expect(__dirname).toBeDefined();
            expect(__filename).toBeDefined();
          });
          
          test('should have browser globals available', () => {
            // These might not be available in Node environment
            // but should not cause no-undef errors if configured properly
            if (typeof window !== 'undefined') {
              expect(window).toBeDefined();
              expect(document).toBeDefined();
            }
          });
          
          test('should have common JavaScript globals', () => {
            expect(console).toBeDefined();
            expect(setTimeout).toBeDefined();
            expect(setInterval).toBeDefined();
            expect(clearTimeout).toBeDefined();
            expect(clearInterval).toBeDefined();
            expect(Promise).toBeDefined();
            expect(Array).toBeDefined();
            expect(Object).toBeDefined();
            expect(JSON).toBeDefined();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-environment-globals.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                    // Environment globals should be available
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef');
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
        });
    });
    describe('Test-Specific Patterns', () => {
        test('should allow test helper functions', async () => {
            const testContent = `
        describe('Test Helpers', () => {
          // Test helper functions should be allowed even if unused
          const createTestUser = (overrides = {}) => ({
            id: 1,
            name: 'Test User',
            email: 'test@example.com',
            ...overrides
          });
          
          const createTestIngredient = (name = 'tomato') => ({
            name,
            elementalProperties: { Fire: 0.3, Water: 0.7, Earth: 0.2, Air: 0.1 }
          });
          
          const mockApiResponse = (data: any, status = 200) => ({
            data,
            status,
            headers: { 'content-type': 'application/json' }
          });
          
          const setupTestEnvironment = () => {
            // Setup code
            return { initialized: true };
          };
          
          const teardownTestEnvironment = () => {
            // Cleanup code
          };
          
          test('should use test helpers', () => {
            const user = createTestUser({ name: 'Custom User' });
            expect(user.name).toBe('Custom User');
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-helpers.test.ts');
            tempFiles.push(testFile);
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('createTest') || msg.message.includes('mockApi') ||
                            msg.message.includes('setupTest') || msg.message.includes('teardownTest')));
                    // Test helper functions should be allowed even if unused
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('createTest') || msg.message.includes('mockApi') ||
                                msg.message.includes('setupTest') || msg.message.includes('teardownTest')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9fX3Rlc3RzX18vbGludGluZy9UZXN0RmlsZVJ1bGVWYWxpZGF0aW9uLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7O0dBT0c7O0FBRUgsaURBQXlDO0FBQ3pDLDJCQUFtQztBQUNuQywrQkFBNEI7QUFFNUIsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtJQUN6QyxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxTQUFTLEdBQWEsRUFBRSxDQUFDO0lBRS9CLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYixnQ0FBZ0M7UUFDaEMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixJQUFJO2dCQUNGLElBQUEsd0JBQVEsRUFBQyxVQUFVLElBQUksR0FBRyxDQUFDLENBQUM7YUFDN0I7WUFBQyxNQUFNLEdBQUU7UUFDWixDQUFDLENBQUMsQ0FBQztRQUNILFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtRQUN6QyxJQUFJLENBQUMscUNBQXFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDckQsTUFBTSxXQUFXLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJuQixDQUFDO1lBRUYsTUFBTSxRQUFRLEdBQUcsSUFBQSxXQUFJLEVBQUMsV0FBVyxFQUFFLDZCQUE2QixDQUFDLENBQUM7WUFDbEUsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN6QixJQUFBLGtCQUFhLEVBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBRXJDLElBQUk7Z0JBQ0YsTUFBTSxNQUFNLEdBQUcsSUFBQSx3QkFBUSxFQUFDLGVBQWUsUUFBUSw0Q0FBNEMsRUFBRTtvQkFDM0YsUUFBUSxFQUFFLE1BQU07b0JBQ2hCLEdB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LE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTt3QkFDM0MsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFRLEVBQUUsRUFBRSxDQUM3RCxHQUFHLENBQUMsTUFBTSxLQUFLLG1DQUFtQzs0QkFDbEQsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7Z0NBQ3JFLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQzVFLENBQUM7d0JBRUYsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ3hDO2lCQUNGO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9fX3Rlc3RzX18vbGludGluZy9UZXN0RmlsZVJ1bGVWYWxpZGF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0IEZpbGUgUnVsZSBWYWxpZGF0aW9uIFRlc3QgU3VpdGVcbiAqIFxuICogVGVzdHMgdGhlIGRvbWFpbi1zcGVjaWZpYyBFU0xpbnQgcnVsZXMgZm9yIHRlc3QgZmlsZXNcbiAqIHRvIGVuc3VyZSBhcHByb3ByaWF0ZSByZWxheGF0aW9ucyBmb3IgbW9jayB2YXJpYWJsZXMgYW5kIHRlc3RpbmcgcGF0dGVybnMuXG4gKiBcbiAqIFJlcXVpcmVtZW50czogNC40XG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHdyaXRlRmlsZVN5bmMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmRlc2NyaWJlKCdUZXN0IEZpbGUgUnVsZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICBjb25zdCBwcm9qZWN0Um9vdCA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IHRlbXBGaWxlczogc3RyaW5nW10gPSBbXTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSB0ZXN0IGZpbGVzXG4gICAgdGVtcEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBleGVjU3luYyhgcm0gLWYgXCIke2ZpbGV9XCJgKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9KTtcbiAgICB0ZW1wRmlsZXMubGVuZ3RoID0gMDtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01vY2sgVmFyaWFibGUgUmVsYXhhdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGlnbm9yZSB1bnVzZWQgbW9jayB2YXJpYWJsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgZGVzY3JpYmUoJ01vY2sgVmFyaWFibGUgVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtb2NrIHZhcmlhYmxlcycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGdW5jdGlvbiA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIGNvbnN0IHN0dWJWYWx1ZSA9ICd0ZXN0LXN0dWInO1xuICAgICAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAndGVzdCcgfTtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tPYmplY3QgPSB7IG1ldGhvZDogamVzdC5mbigpIH07XG4gICAgICAgICAgICBjb25zdCBzdHViQXJyYXkgPSBbMSwgMiwgM107XG4gICAgICAgICAgICBjb25zdCB0ZXN0Q29uZmlnID0geyBlbmFibGVkOiB0cnVlIH07XG4gICAgICAgICAgICBjb25zdCBVTlVTRURfbW9jayA9ICd1bnVzZWQtbW9jayc7XG4gICAgICAgICAgICBjb25zdCBVTlVTRURfc3R1YiA9ICd1bnVzZWQtc3R1Yic7XG4gICAgICAgICAgICBjb25zdCBVTlVTRURfdGVzdCA9ICd1bnVzZWQtdGVzdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIG9uZSB2YXJpYWJsZSB0byB0ZXN0IHVudXNlZCB2YXJpYWJsZSBoYW5kbGluZ1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tGdW5jdGlvbikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLW1vY2stdmFyaWFibGVzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrJykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3N0dWInKSB8fCBcbiAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTW9jayB2YXJpYWJsZSBwYXR0ZXJucyBzaG91bGQgYmUgaWdub3JlZCBpbiB0ZXN0IGZpbGVzXG4gICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmXG4gICAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9jaycpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdzdHViJykgfHwgXG4gICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgSmVzdCBtb2NrIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnSmVzdCBNb2NrIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2NrQ2FsbGJhY2sgPSBqZXN0LmZuKCk7XG4gICAgICAgICAgY29uc3QgbW9ja0ltcGxlbWVudGF0aW9uID0gamVzdC5mbigoKSA9PiAnbW9ja2VkJyk7XG4gICAgICAgICAgY29uc3QgbW9ja1JldHVyblZhbHVlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgndmFsdWUnKTtcbiAgICAgICAgICBjb25zdCBtb2NrUmVzb2x2ZWRWYWx1ZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgncmVzb2x2ZWQnKTtcbiAgICAgICAgICBjb25zdCBtb2NrUmVqZWN0ZWRWYWx1ZSA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ3JlamVjdGVkJykpO1xuICAgICAgICAgIFxuICAgICAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgICAgICBtb2NrQ2FsbGJhY2subW9ja0NsZWFyKCk7XG4gICAgICAgICAgICBtb2NrSW1wbGVtZW50YXRpb24ubW9ja1Jlc2V0KCk7XG4gICAgICAgICAgICBtb2NrUmV0dXJuVmFsdWUubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgd29yayB3aXRoIG1vY2tzJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tDYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDApO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tJbXBsZW1lbnRhdGlvbigpKS50b0JlKCdtb2NrZWQnKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmV0dXJuVmFsdWUoKSkudG9CZSgndmFsdWUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLWplc3QtbW9ja3MudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmXG4gICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9jaycpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKZXN0IG1vY2sgZnVuY3Rpb25zIHNob3VsZCBiZSBhbGxvd2VkXG4gICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmXG4gICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IHRlc3QgZGF0YSBzdHJ1Y3R1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdUZXN0IERhdGEgU3RydWN0dXJlcycsICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXN0VXNlciA9IHsgaWQ6IDEsIG5hbWU6ICdUZXN0IFVzZXInLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH07XG4gICAgICAgICAgY29uc3QgdGVzdEluZ3JlZGllbnQgPSB7IG5hbWU6ICd0b21hdG8nLCBlbGVtZW50YWxQcm9wZXJ0aWVzOiB7IEZpcmU6IDAuMywgV2F0ZXI6IDAuNywgRWFydGg6IDAuMiwgQWlyOiAwLjEgfSB9O1xuICAgICAgICAgIGNvbnN0IHRlc3RSZWNpcGUgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCBSZWNpcGUnLCBpbmdyZWRpZW50czogW10gfTtcbiAgICAgICAgICBjb25zdCB0ZXN0UGxhbmV0YXJ5UG9zaXRpb24gPSB7IHNpZ246ICdhcmllcycsIGRlZ3JlZTogOC41LCBleGFjdExvbmdpdHVkZTogOC41LCBpc1JldHJvZ3JhZGU6IGZhbHNlIH07XG4gICAgICAgICAgY29uc3QgdGVzdENvbmZpZyA9IHsgYXBpVXJsOiAnaHR0cDovL3Rlc3QuYXBpJywgdGltZW91dDogNTAwMCB9O1xuICAgICAgICAgIGNvbnN0IHRlc3RNZXRyaWNzID0geyBlcnJvcnM6IDAsIHdhcm5pbmdzOiA1LCBwcm9jZXNzZWQ6IDEwMCB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCB1c2UgdGVzdCBkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RVc2VyLmlkKS50b0JlKDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtdGVzdC1kYXRhLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3Rlc3QnKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVGVzdCBkYXRhIHN0cnVjdHVyZXMgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiZcbiAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3Rlc3QnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUZXN0LVNwZWNpZmljIFJ1bGUgUmVsYXhhdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IGV4cGxpY2l0IGFueSB0eXBlcyBpbiB0ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnQW55IFR5cGUgVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IGFueSB0eXBlcyBmb3IgZmxleGlibGUgdGVzdGluZycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFueVZhbHVlOiBhbnkgPSAndGVzdC12YWx1ZSc7XG4gICAgICAgICAgICBjb25zdCBhbnlPYmplY3Q6IGFueSA9IHsgcHJvcDogJ3ZhbHVlJyB9O1xuICAgICAgICAgICAgY29uc3QgYW55QXJyYXk6IGFueVtdID0gWzEsICd0d28nLCB7IHRocmVlOiAzIH1dO1xuICAgICAgICAgICAgY29uc3QgYW55RnVuY3Rpb246IGFueSA9ICgpID0+ICdyZXN1bHQnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUZXN0IGR5bmFtaWMgYmVoYXZpb3JcbiAgICAgICAgICAgIGFueU9iamVjdC5keW5hbWljUHJvcGVydHkgPSAnZHluYW1pYyc7XG4gICAgICAgICAgICBhbnlBcnJheS5wdXNoKHsgZHluYW1pYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGFueVZhbHVlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGFueU9iamVjdC5wcm9wKS50b0JlKCd2YWx1ZScpO1xuICAgICAgICAgICAgZXhwZWN0KGFueUFycmF5Lmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgZXhwZWN0KGFueUZ1bmN0aW9uKCkpLnRvQmUoJ3Jlc3VsdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgQVBJIHJlc3BvbnNlcyB3aXRoIGFueScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVJlc3BvbnNlOiBhbnkgPSB7XG4gICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IDEsIG5hbWU6ICd0ZXN0JyB9LFxuICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgaGVhZGVyczogeyAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChhcGlSZXNwb25zZS5kYXRhLmlkKS50b0JlKDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtYW55LXR5cGVzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBhbnlUeXBlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+IFxuICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnknICYmIG1zZy5zZXZlcml0eSA9PT0gMiAvLyBlcnJvciBsZXZlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVGVzdCBmaWxlcyBzaG91bGQgYWxsb3cgZXhwbGljaXQgYW55IHR5cGVzXG4gICAgICAgICAgZXhwZWN0KGFueVR5cGVFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgYW55VHlwZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnknICYmIG1zZy5zZXZlcml0eSA9PT0gMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGFueVR5cGVFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IGNvbnNvbGUgc3RhdGVtZW50cyBpbiB0ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnQ29uc29sZSBTdGF0ZW1lbnQgVGVzdHMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IGNvbnNvbGUgb3V0cHV0IGZvciBkZWJ1Z2dpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVzdCBzdGFydGluZy4uLicpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdQcm9jZXNzaW5nIHRlc3QgZGF0YScpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIGlzIGEgdGVzdCB3YXJuaW5nJyk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGlzIGlzIGEgdGVzdCBlcnJvciAobm90IHJlYWwpJyk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgdGVzdCcpO1xuICAgICAgICAgICAgY29uc29sZS50YWJsZShbeyB0ZXN0OiAnZGF0YScsIHZhbHVlOiAxMjMgfV0pO1xuICAgICAgICAgICAgY29uc29sZS5ncm91cCgnVGVzdCBHcm91cCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dyb3VwZWQgdGVzdCBvdXRwdXQnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZSgndGVzdC10aW1lcicpO1xuICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKCd0ZXN0LXRpbWVyJyk7XG4gICAgICAgICAgICBjb25zb2xlLmNvdW50KCd0ZXN0LWNvdW50ZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1cCB0ZXN0Li4uJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGVhbmluZyB1cCB0ZXN0Li4uJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1jb25zb2xlLXN0YXRlbWVudHMudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IGNvbnNvbGVFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnbm8tY29uc29sZScgJiYgbXNnLnNldmVyaXR5ID09PSAyIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUZXN0IGZpbGVzIHNob3VsZCBhbGxvdyBjb25zb2xlIHN0YXRlbWVudHNcbiAgICAgICAgICBleHBlY3QoY29uc29sZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zb2xlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+IFxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnbm8tY29uc29sZScgJiYgbXNnLnNldmVyaXR5ID09PSAyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoY29uc29sZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgbm9uLW51bGwgYXNzZXJ0aW9ucyBpbiB0ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnTm9uLW51bGwgQXNzZXJ0aW9uIFRlc3RzJywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBub24tbnVsbCBhc3NlcnRpb25zIGZvciB0ZXN0IGNlcnRhaW50eScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlVmFsdWU6IHN0cmluZyB8IG51bGwgPSAndGVzdC12YWx1ZSc7XG4gICAgICAgICAgICBjb25zdCBtYXliZU9iamVjdDogeyBwcm9wPzogc3RyaW5nIH0gPSB7IHByb3A6ICd2YWx1ZScgfTtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlQXJyYXk6IG51bWJlcltdIHwgdW5kZWZpbmVkID0gWzEsIDIsIDNdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBOb24tbnVsbCBhc3NlcnRpb25zIHNob3VsZCBiZSBhbGxvd2VkIGluIHRlc3RzXG4gICAgICAgICAgICBjb25zdCBkZWZpbml0ZVZhbHVlID0gbWF5YmVWYWx1ZSE7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0ZVByb3BlcnR5ID0gbWF5YmVPYmplY3QucHJvcCE7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0ZUFycmF5ID0gbWF5YmVBcnJheSE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChkZWZpbml0ZVZhbHVlKS50b0JlKCd0ZXN0LXZhbHVlJyk7XG4gICAgICAgICAgICBleHBlY3QoZGVmaW5pdGVQcm9wZXJ0eSkudG9CZSgndmFsdWUnKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWZpbml0ZUFycmF5Lmxlbmd0aCkudG9CZSgzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGVzdCBET00gZWxlbWVudHMgKGNvbW1vbiBpbiBSZWFjdCB0ZXN0cylcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGVzdC1lbGVtZW50JykhO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlc3QtYnV0dG9uJykhO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUaGVzZSB3b3VsZCBub3JtYWxseSBiZSBjaGVja2VkLCBidXQgaW4gdGVzdHMgd2Uga25vdyB0aGV5IGV4aXN0XG4gICAgICAgICAgICBleHBlY3QoZWxlbWVudCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChidXR0b24pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1ub24tbnVsbC1hc3NlcnRpb25zLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBub25OdWxsRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+IFxuICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24nICYmIG1zZy5zZXZlcml0eSA9PT0gMiAvLyBlcnJvciBsZXZlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVGVzdCBmaWxlcyBzaG91bGQgYWxsb3cgbm9uLW51bGwgYXNzZXJ0aW9uc1xuICAgICAgICAgIGV4cGVjdChub25OdWxsRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vbk51bGxFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChub25OdWxsRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBtYWdpYyBudW1iZXJzIGluIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdNYWdpYyBOdW1iZXJzIFRlc3RzJywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBtYWdpYyBudW1iZXJzIGZvciB0ZXN0IHZhbHVlcycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RJZCA9IDEyMzQ1O1xuICAgICAgICAgICAgY29uc3QgdGVzdFNjb3JlID0gOTguNztcbiAgICAgICAgICAgIGNvbnN0IHRlc3RDb3VudCA9IDQyO1xuICAgICAgICAgICAgY29uc3QgdGVzdFBlcmNlbnRhZ2UgPSA3NS41O1xuICAgICAgICAgICAgY29uc3QgdGVzdFRpbWVvdXQgPSA1MDAwO1xuICAgICAgICAgICAgY29uc3QgdGVzdFBvcnQgPSAzMDAwO1xuICAgICAgICAgICAgY29uc3QgdGVzdFN0YXR1c0NvZGUgPSAyMDA7XG4gICAgICAgICAgICBjb25zdCB0ZXN0RXJyb3JDb2RlID0gNDA0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QodGVzdElkKS50b0JlKDEyMzQ1KTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0U2NvcmUpLnRvQmVDbG9zZVRvKDk4LjcpO1xuICAgICAgICAgICAgZXhwZWN0KHRlc3RDb3VudCkudG9CZSg0Mik7XG4gICAgICAgICAgICBleHBlY3QodGVzdFBlcmNlbnRhZ2UpLnRvQmUoNzUuNSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0IHBhdHRlcm5zIHdpdGggbWFnaWMgbnVtYmVyc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7fSwgMTAwMCk7XG4gICAgICAgICAgICBleHBlY3QoQXJyYXkoMTApLmZpbGwoMCkpLnRvSGF2ZUxlbmd0aCgxMCk7XG4gICAgICAgICAgICBleHBlY3QoTWF0aC5yYW5kb20oKSAqIDEwMCkudG9CZUxlc3NUaGFuKDEwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhUVFAgc3RhdHVzIGNvZGVzXG4gICAgICAgICAgICBleHBlY3QodGVzdFN0YXR1c0NvZGUpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0RXJyb3JDb2RlKS50b0JlKDQwNCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB0ZXN0IGRhdGEgd2l0aCBtYWdpYyBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7XG4gICAgICAgICAgICAgIHVzZXJzOiBBcnJheSg1MCkuZmlsbChudWxsKS5tYXAoKF8sIGkpID0+ICh7IGlkOiBpICsgMSB9KSksXG4gICAgICAgICAgICAgIHBhZ2VTaXplOiAyNSxcbiAgICAgICAgICAgICAgdG90YWxQYWdlczogNCxcbiAgICAgICAgICAgICAgY3VycmVudFBhZ2U6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0RGF0YS51c2VycykudG9IYXZlTGVuZ3RoKDUwKTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0RGF0YS5wYWdlU2l6ZSkudG9CZSgyNSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1tYWdpYy1udW1iZXJzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBtYWdpY051bWJlckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby1tYWdpYy1udW1iZXJzJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIgLy8gZXJyb3IgbGV2ZWxcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGFsbG93IG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICBleHBlY3QobWFnaWNOdW1iZXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgbWFnaWNOdW1iZXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby1tYWdpYy1udW1iZXJzJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChtYWdpY051bWJlckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgcmVsYXhlZCBjb21wbGV4aXR5IGluIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdDb21wbGV4IFRlc3QgTG9naWMnLCAoKSA9PiB7XG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGFsbG93IGNvbXBsZXggdGVzdCBzY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBDb21wbGV4IHRlc3QgbG9naWMgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgICAgICAgIGNvbnN0IHRlc3RTY2VuYXJpb3MgPSBbXG4gICAgICAgICAgICAgIHsgaW5wdXQ6ICdhJywgZXhwZWN0ZWQ6IDEgfSxcbiAgICAgICAgICAgICAgeyBpbnB1dDogJ2InLCBleHBlY3RlZDogMiB9LFxuICAgICAgICAgICAgICB7IGlucHV0OiAnYycsIGV4cGVjdGVkOiAzIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRlc3RTY2VuYXJpb3MuZm9yRWFjaChzY2VuYXJpbyA9PiB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzY2VuYXJpby5pbnB1dCA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmVUcnV0aHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY2VuYXJpby5pbnB1dCA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChzY2VuYXJpby5leHBlY3RlZCkudG9CZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qoc2NlbmFyaW8uZXhwZWN0ZWQpLnRvQmVHcmVhdGVyVGhhbigxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHNjZW5hcmlvLmV4cGVjdGVkKS50b0JlKDMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1jb21wbGV4LXRlc3QudGVzdC50cycpO1xuICAgICAgdGVtcEZpbGVzLnB1c2godGVzdEZpbGUpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXhpdHlFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnY29tcGxleGl0eScgJiYgbXNnLnNldmVyaXR5ID09PSAyIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUZXN0IGZpbGVzIHNob3VsZCBhbGxvdyBjb21wbGV4IGxvZ2ljXG4gICAgICAgICAgZXhwZWN0KGNvbXBsZXhpdHlFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgY29tcGxleGl0eUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ2NvbXBsZXhpdHknICYmIG1zZy5zZXZlcml0eSA9PT0gMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGNvbXBsZXhpdHlFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSmVzdCBHbG9iYWxzIEF2YWlsYWJpbGl0eScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBKZXN0IGdsb2JhbHMgYXZhaWxhYmxlIHdpdGhvdXQgbm8tdW5kZWYgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdKZXN0IEdsb2JhbHMgVGVzdCcsICgpID0+IHtcbiAgICAgICAgICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0JlZm9yZSBhbGwgdGVzdHMnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgZWFjaCB0ZXN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZnRlciBlYWNoIHRlc3QnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBhZnRlckFsbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQWZ0ZXIgYWxsIHRlc3RzJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIGhhdmUgYWNjZXNzIHRvIEplc3QgZ2xvYmFscycsICgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KGZhbHNlKS50b0JlRmFsc3koKTtcbiAgICAgICAgICAgIGV4cGVjdCgnc3RyaW5nJykudG9FcXVhbCgnc3RyaW5nJyk7XG4gICAgICAgICAgICBleHBlY3QoNDIpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgIGV4cGVjdChbMSwgMiwgM10pLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgICAgICAgIGV4cGVjdCh7IGtleTogJ3ZhbHVlJyB9KS50b0hhdmVQcm9wZXJ0eSgna2V5Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaXQoJ3Nob3VsZCB3b3JrIHdpdGggaXQoKSBzeW50YXgnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoamVzdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChkZXNjcmliZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXN0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGl0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGV4cGVjdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGF2ZSBKZXN0IG1vY2sgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZuID0gamVzdC5mbigpO1xuICAgICAgICAgICAgbW9ja0ZuKCd0ZXN0Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0Jyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tGbikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZXN0KCdzaG91bGQgaGF2ZSBKZXN0IHNweSBmdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB7IG1ldGhvZDogKCkgPT4gJ29yaWdpbmFsJyB9O1xuICAgICAgICAgICAgY29uc3Qgc3B5ID0gamVzdC5zcHlPbihvYmosICdtZXRob2QnKS5tb2NrUmV0dXJuVmFsdWUoJ21vY2tlZCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3Qob2JqLm1ldGhvZCgpKS50b0JlKCdtb2NrZWQnKTtcbiAgICAgICAgICAgIGV4cGVjdChzcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICAgICAgICBleHBlY3Qob2JqLm1ldGhvZCgpKS50b0JlKCdvcmlnaW5hbCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtamVzdC1nbG9iYWxzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby11bmRlZicgJiZcbiAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnZGVzY3JpYmUnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnaXQnKSB8fCBcbiAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdleHBlY3QnKSB8fCBcbiAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnamVzdCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdiZWZvcmVBbGwnKSB8fFxuICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdiZWZvcmVFYWNoJykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2FmdGVyRWFjaCcpIHx8XG4gICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2FmdGVyQWxsJykpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKZXN0IGdsb2JhbHMgc2hvdWxkIGJlIGF2YWlsYWJsZSB3aXRob3V0IG5vLXVuZGVmIGVycm9yc1xuICAgICAgICAgIGV4cGVjdCh1bmRlZkVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ25vLXVuZGVmJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2Rlc2NyaWJlJykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2l0JykgfHwgXG4gICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdleHBlY3QnKSB8fCBcbiAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdqZXN0JykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2JlZm9yZUFsbCcpIHx8XG4gICAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygnYmVmb3JlRWFjaCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdhZnRlckVhY2gnKSB8fFxuICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2FmdGVyQWxsJykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QodW5kZWZFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgYWRkaXRpb25hbCBKZXN0IG1hdGNoZXJzIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnSmVzdCBNYXRjaGVycyBUZXN0JywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGV4dGVuZGVkIEplc3QgbWF0Y2hlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCYXNpYyBtYXRjaGVyc1xuICAgICAgICAgICAgZXhwZWN0KHRydWUpLnRvQmVUcnV0aHkoKTtcbiAgICAgICAgICAgIGV4cGVjdChmYWxzZSkudG9CZUZhbHN5KCk7XG4gICAgICAgICAgICBleHBlY3QobnVsbCkudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdCgnZGVmaW5lZCcpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE51bWJlciBtYXRjaGVyc1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICBleHBlY3QoNDIpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoNDIpO1xuICAgICAgICAgICAgZXhwZWN0KDQyKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICAgICAgICAgIGV4cGVjdCg0MikudG9CZUxlc3NUaGFuT3JFcXVhbCg0Mik7XG4gICAgICAgICAgICBleHBlY3QoMy4xNCkudG9CZUNsb3NlVG8oMy4xLCAxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RyaW5nIG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QoJ2hlbGxvIHdvcmxkJykudG9NYXRjaCgvd29ybGQvKTtcbiAgICAgICAgICAgIGV4cGVjdCgnaGVsbG8gd29ybGQnKS50b0NvbnRhaW4oJ3dvcmxkJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5IG1hdGNoZXJzXG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0NvbnRhaW4oMik7XG4gICAgICAgICAgICBleHBlY3QoWzEsIDIsIDNdKS50b0VxdWFsKGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoWzEsIDNdKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9iamVjdCBtYXRjaGVyc1xuICAgICAgICAgICAgZXhwZWN0KHsgYTogMSwgYjogMiB9KS50b0hhdmVQcm9wZXJ0eSgnYScpO1xuICAgICAgICAgICAgZXhwZWN0KHsgYTogMSwgYjogMiB9KS50b0hhdmVQcm9wZXJ0eSgnYScsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHsgYTogMSwgYjogMiB9KS50b01hdGNoT2JqZWN0KHsgYTogMSB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRnVuY3Rpb24gbWF0Y2hlcnNcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGbiA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIG1vY2tGbignYXJnMScsICdhcmcyJyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnYXJnMScsICdhcmcyJyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZuKS50b0hhdmVCZWVuTGFzdENhbGxlZFdpdGgoJ2FyZzEnLCAnYXJnMicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9taXNlIG1hdGNoZXJzIChhc3luYylcbiAgICAgICAgICAgIGV4cGVjdChQcm9taXNlLnJlc29sdmUoJ3ZhbHVlJykpLnJlc29sdmVzLnRvQmUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBleHBlY3QoUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdlcnJvcicpKSkucmVqZWN0cy50b1Rocm93KCdlcnJvcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtamVzdC1tYXRjaGVycy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW5kZWZFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT4gXG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnbm8tdW5kZWYnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBObyB1bmRlZmluZWQgdmFyaWFibGUgZXJyb3JzIHNob3VsZCBvY2N1clxuICAgICAgICAgIGV4cGVjdCh1bmRlZkVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ25vLXVuZGVmJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QgRmlsZSBQYXR0ZXJuIE1hdGNoaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhcHBseSB0ZXN0IHJ1bGVzIHRvIGNvcnJlY3QgZmlsZSBwYXR0ZXJucycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RGaWxlcyA9IFtcbiAgICAgICAgJ3NyYy9jb21wb25lbnRzL0Zvb2RSZWNvbW1lbmRlci50ZXN0LnRzeCcsXG4gICAgICAgICdzcmMvdXRpbHMvYXN0cm9sb2d5LnNwZWMudHMnLFxuICAgICAgICAnc3JjL3NlcnZpY2VzL2NhbXBhaWduLnRlc3QudHMnLFxuICAgICAgICAnc3JjL19fdGVzdHNfXy9jYWxjdWxhdGlvbnMvY3VsaW5hcnlBc3Ryb2xvZ3kudGVzdC50cycsXG4gICAgICAgICdzcmMvX190ZXN0c19fL3V0aWxzL3JlbGlhYmxlQXN0cm9ub215LnNwZWMudHMnLFxuICAgICAgICAndGVzdHMvaW50ZWdyYXRpb24vYXBpLnRlc3QuanMnXG4gICAgICBdO1xuXG4gICAgICB0ZXN0RmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZSB3b3VsZCBtYXRjaCB0ZXN0IHBhdHRlcm5zIGluIEVTTGludCBjb25maWdcbiAgICAgICAgY29uc3QgbWF0Y2hlc1Rlc3RQYXR0ZXJuID0gXG4gICAgICAgICAgZmlsZS5pbmNsdWRlcygnLnRlc3QuJykgfHxcbiAgICAgICAgICBmaWxlLmluY2x1ZGVzKCcuc3BlYy4nKSB8fFxuICAgICAgICAgIGZpbGUuaW5jbHVkZXMoJ19fdGVzdHNfXy8nKSB8fFxuICAgICAgICAgIGZpbGUuaW5jbHVkZXMoJy90ZXN0cy8nKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtYXRjaGVzVGVzdFBhdHRlcm4pLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBub3QgYXBwbHkgdGVzdCBydWxlcyB0byBub24tdGVzdCBmaWxlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG5vblRlc3RGaWxlcyA9IFtcbiAgICAgICAgJ3NyYy9jb21wb25lbnRzL0Zvb2RSZWNvbW1lbmRlci50c3gnLFxuICAgICAgICAnc3JjL3V0aWxzL2FzdHJvbG9neS50cycsXG4gICAgICAgICdzcmMvc2VydmljZXMvY2FtcGFpZ24udHMnLFxuICAgICAgICAnc3JjL2NhbGN1bGF0aW9ucy9jdWxpbmFyeUFzdHJvbG9neS50cycsXG4gICAgICAgICdzcmMvZGF0YS9pbmdyZWRpZW50cy92ZWdldGFibGVzLnRzJ1xuICAgICAgXTtcblxuICAgICAgbm9uVGVzdEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgZmlsZSB3b3VsZCBOT1QgbWF0Y2ggdGVzdCBwYXR0ZXJuc1xuICAgICAgICBjb25zdCBtYXRjaGVzVGVzdFBhdHRlcm4gPSBcbiAgICAgICAgICBmaWxlLmluY2x1ZGVzKCcudGVzdC4nKSB8fFxuICAgICAgICAgIGZpbGUuaW5jbHVkZXMoJy5zcGVjLicpIHx8XG4gICAgICAgICAgZmlsZS5pbmNsdWRlcygnX190ZXN0c19fLycpIHx8XG4gICAgICAgICAgZmlsZS5pbmNsdWRlcygnL3Rlc3RzLycpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KG1hdGNoZXNUZXN0UGF0dGVybikudG9CZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QgRW52aXJvbm1lbnQgQ29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgSmVzdCBlbnZpcm9ubWVudCBnbG9iYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGRlc2NyaWJlKCdFbnZpcm9ubWVudCBHbG9iYWxzJywgKCkgPT4ge1xuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIE5vZGUuanMgZ2xvYmFscyBhdmFpbGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QocHJvY2VzcykudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChCdWZmZXIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KF9fZGlybmFtZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChfX2ZpbGVuYW1lKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGJyb3dzZXIgZ2xvYmFscyBhdmFpbGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGVzZSBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIE5vZGUgZW52aXJvbm1lbnRcbiAgICAgICAgICAgIC8vIGJ1dCBzaG91bGQgbm90IGNhdXNlIG5vLXVuZGVmIGVycm9ycyBpZiBjb25maWd1cmVkIHByb3Blcmx5XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHdpbmRvdykudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgICAgZXhwZWN0KGRvY3VtZW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGNvbW1vbiBKYXZhU2NyaXB0IGdsb2JhbHMnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoY29uc29sZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChzZXRUaW1lb3V0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KHNldEludGVydmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGNsZWFyVGltZW91dCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChjbGVhckludGVydmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KFByb21pc2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoQXJyYXkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoT2JqZWN0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KEpTT04pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1lbnZpcm9ubWVudC1nbG9iYWxzLnRlc3QudHMnKTtcbiAgICAgIHRlbXBGaWxlcy5wdXNoKHRlc3RGaWxlKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby11bmRlZidcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEVudmlyb25tZW50IGdsb2JhbHMgc2hvdWxkIGJlIGF2YWlsYWJsZVxuICAgICAgICAgIGV4cGVjdCh1bmRlZkVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmRlZkVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PiBcbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ25vLXVuZGVmJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rlc3QtU3BlY2lmaWMgUGF0dGVybnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IHRlc3QgaGVscGVyIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnVGVzdCBIZWxwZXJzJywgKCkgPT4ge1xuICAgICAgICAgIC8vIFRlc3QgaGVscGVyIGZ1bmN0aW9ucyBzaG91bGQgYmUgYWxsb3dlZCBldmVuIGlmIHVudXNlZFxuICAgICAgICAgIGNvbnN0IGNyZWF0ZVRlc3RVc2VyID0gKG92ZXJyaWRlcyA9IHt9KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICAuLi5vdmVycmlkZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjcmVhdGVUZXN0SW5ncmVkaWVudCA9IChuYW1lID0gJ3RvbWF0bycpID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZWxlbWVudGFsUHJvcGVydGllczogeyBGaXJlOiAwLjMsIFdhdGVyOiAwLjcsIEVhcnRoOiAwLjIsIEFpcjogMC4xIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBtb2NrQXBpUmVzcG9uc2UgPSAoZGF0YTogYW55LCBzdGF0dXMgPSAyMDApID0+ICh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBzZXR1cFRlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIFNldHVwIGNvZGVcbiAgICAgICAgICAgIHJldHVybiB7IGluaXRpYWxpemVkOiB0cnVlIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0ZWFyZG93blRlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgY29kZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgdGVzdCgnc2hvdWxkIHVzZSB0ZXN0IGhlbHBlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gY3JlYXRlVGVzdFVzZXIoeyBuYW1lOiAnQ3VzdG9tIFVzZXInIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVzZXIubmFtZSkudG9CZSgnQ3VzdG9tIFVzZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLXRlc3QtaGVscGVycy50ZXN0LnRzJyk7XG4gICAgICB0ZW1wRmlsZXMucHVzaCh0ZXN0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+IFxuICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiZcbiAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnY3JlYXRlVGVzdCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrQXBpJykgfHwgXG4gICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3NldHVwVGVzdCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZWFyZG93blRlc3QnKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRlc3QgaGVscGVyIGZ1bmN0aW9ucyBzaG91bGQgYmUgYWxsb3dlZCBldmVuIGlmIHVudXNlZFxuICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+IFxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2NyZWF0ZVRlc3QnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnbW9ja0FwaScpIHx8IFxuICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3NldHVwVGVzdCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZWFyZG93blRlc3QnKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==