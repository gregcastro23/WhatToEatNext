{"file":"/Users/GregCastro/Desktop/WhatToEatNext/src/services/campaign/unintentional-any-elimination/SafeTypeReplacer.ts","mappings":"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","names":[],"sources":["/Users/GregCastro/Desktop/WhatToEatNext/src/services/campaign/unintentional-any-elimination/SafeTypeReplacer.ts"],"sourcesContent":["/**\n * Safe Type Replacer\n * Performs safe replacements of unintentional `any` types with more specific types\n *\n * Core Features:\n * - Atomic replacement operations with automatic rollback\n * - TypeScript compilation validation after each replacement\n * - Comprehensive backup system for all modified files\n * - Safety scoring system for replacement confidence\n */\n\nimport { execSync } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport {\n    ClassificationContext,\n    ReplacementResult,\n    ReplacementStrategy,\n    SafetyProtocolError,\n    TypeReplacement\n} from './types';\n\nexport class SafeTypeReplacer {\n  private strategies: ReplacementStrategy[];\n  private backupDirectory: string;\n  private safetyThreshold: number;\n  private validationTimeout: number;\n  private maxRetries: number;\n\n  constructor(\n    backupDirectory = './.any-elimination-backups',\n    safetyThreshold = 0.7,\n    validationTimeout = 30000,\n    maxRetries = 3\n  ) {\n    this.backupDirectory = backupDirectory;\n    this.safetyThreshold = safetyThreshold;\n    this.validationTimeout = validationTimeout;\n    this.maxRetries = maxRetries;\n    this.strategies = this.initializeStrategies();\n    this.ensureBackupDirectory();\n  }\n\n  /**\n   * Apply a single type replacement with comprehensive safety validation\n   * Implements atomic operations with automatic rollback on any failure\n   */\n  async applyReplacement(replacement: TypeReplacement): Promise<ReplacementResult> {\n    // Pre-validation: Check safety score\n    const safetyScore = this.calculateSafetyScore(replacement);\n    if (safetyScore < this.safetyThreshold) {\n      return {\n        success: false,\n        appliedReplacements: [],\n        failedReplacements: [replacement],\n        compilationErrors: [`Safety score ${safetyScore} below threshold ${this.safetyThreshold}`],\n        rollbackPerformed: false\n      };\n    }\n\n    const backupPath = await this.createBackup(replacement.filePath);\n    let retryCount = 0;\n\n    while (retryCount < this.maxRetries) {\n      try {\n        // Atomic replacement operation\n        const result = await this.performAtomicReplacement(replacement, backupPath);\n\n        if (result.success) {\n          // Verify rollback capability before declaring success\n          const rollbackVerification = await this.verifyRollbackCapability(replacement.filePath, backupPath);\n          if (!rollbackVerification.success) {\n            await this.rollbackFromBackup(replacement.filePath, backupPath);\n            return {\n              success: false,\n              appliedReplacements: [],\n              failedReplacements: [replacement],\n              compilationErrors: [`Rollback verification failed: ${rollbackVerification.error}`],\n              rollbackPerformed: true,\n              backupPath\n            };\n          }\n\n          return result;\n        } else {\n          // If replacement failed with specific errors, return immediately (don't retry)\n          return result;\n        }\n\n      } catch (error) {\n        retryCount++;\n        if (retryCount >= this.maxRetries) {\n          // Final rollback on exhausted retries\n          await this.rollbackFromBackup(replacement.filePath, backupPath);\n          return {\n            success: false,\n            appliedReplacements: [],\n            failedReplacements: [replacement],\n            compilationErrors: [error instanceof Error ? error.message : String(error)],\n            rollbackPerformed: true,\n            backupPath\n          };\n        }\n\n        // Wait briefly before retry\n        await new Promise(resolve => setTimeout(resolve, 100 * retryCount));\n      }\n    }\n\n    // Should not reach here, but handle edge case\n    await this.rollbackFromBackup(replacement.filePath, backupPath);\n    return {\n      success: false,\n      appliedReplacements: [],\n      failedReplacements: [replacement],\n      compilationErrors: ['Maximum retries exceeded'],\n      rollbackPerformed: true,\n      backupPath\n    };\n  }\n\n  /**\n   * Process multiple replacements in batch with atomic operations\n   */\n  async processBatch(replacements: TypeReplacement[]): Promise<ReplacementResult> {\n    const backupPaths: Map<string, string> = new Map();\n    const appliedReplacements: TypeReplacement[] = [];\n    const failedReplacements: TypeReplacement[] = [];\n    const compilationErrors: string[] = [];\n\n    try {\n      // Create backups for all files\n      for (const replacement of replacements) {\n        if (!backupPaths.has(replacement.filePath)) {\n          const backupPath = await this.createBackup(replacement.filePath);\n          backupPaths.set(replacement.filePath, backupPath);\n        }\n      }\n\n      // Group replacements by file for efficient processing\n      const replacementsByFile = this.groupReplacementsByFile(replacements);\n\n      // Apply replacements file by file\n      for (const [filePath, fileReplacements] of Array.from(replacementsByFile.entries())) {\n        try {\n          const result = await this.applyReplacementsToFile(filePath, fileReplacements);\n          appliedReplacements.push(...result.applied);\n          failedReplacements.push(...result.failed);\n\n          if (result.failed.length > 0) {\n            compilationErrors.push(...result.errors);\n          }\n        } catch (error) {\n          failedReplacements.push(...fileReplacements);\n          compilationErrors.push(error instanceof Error ? error.message : String(error));\n        }\n      }\n\n      // Validate overall TypeScript compilation\n      const overallCompilation = await this.validateTypeScriptCompilation();\n      if (!overallCompilation.success) {\n        // Rollback all changes\n        await this.rollbackAllFiles(backupPaths);\n\n        return {\n          success: false,\n          appliedReplacements: [],\n          failedReplacements: replacements,\n          compilationErrors: overallCompilation.errors,\n          rollbackPerformed: true\n        };\n      }\n\n      const success = failedReplacements.length === 0;\n      return {\n        success,\n        appliedReplacements,\n        failedReplacements,\n        compilationErrors,\n        rollbackPerformed: false\n      };\n\n    } catch (error) {\n      // Emergency rollback\n      await this.rollbackAllFiles(backupPaths);\n\n      throw new SafetyProtocolError(\n        'Batch replacement failed with emergency rollback',\n        Array.from(backupPaths.values())[0] || '',\n        Array.from(backupPaths.keys())\n      );\n    }\n  }\n\n  private initializeStrategies(): ReplacementStrategy[] {\n    return [\n      // Array type replacement strategy\n      {\n        pattern: /:\\s*any\\[\\]/g,\n        replacement: (match: string) => match.replace('any[]', 'unknown[]'),\n        validator: (context: ClassificationContext) =>\n          context.codeSnippet.includes('any[]'),\n        priority: 1\n      },\n\n      // Record type replacement strategy\n      {\n        pattern: /:\\s*Record<\\s*string\\s*,\\s*any\\s*>/g,\n        replacement: (match: string) => match.replace('any', 'unknown'),\n        validator: (context: ClassificationContext) =>\n          context.codeSnippet.includes('Record<string, any>'),\n        priority: 2\n      },\n\n      // Generic Record replacement\n      {\n        pattern: /:\\s*Record<\\s*number\\s*,\\s*any\\s*>/g,\n        replacement: (match: string) => match.replace('any', 'unknown'),\n        validator: (context: ClassificationContext) =>\n          context.codeSnippet.includes('Record<number, any>'),\n        priority: 2\n      },\n\n      // Index signature replacement\n      {\n        pattern: /\\[key:\\s*string\\]\\s*:\\s*any/g,\n        replacement: (match: string) => match.replace('any', 'unknown'),\n        validator: (context: ClassificationContext) =>\n          context.codeSnippet.includes('[key: string]: any'),\n        priority: 3\n      },\n\n      // Simple variable type replacement\n      {\n        pattern: /:\\s*any(?=\\s*[=;,\\)])/g,\n        replacement: (match: string) => match.replace('any', 'unknown'),\n        validator: (context: ClassificationContext) =>\n          !context.codeSnippet.includes('catch') &&\n          !context.codeSnippet.includes('error'),\n        priority: 4\n      }\n    ];\n  }\n\n  private async createBackup(filePath: string): Promise<string> {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = path.basename(filePath);\n    const backupFileName = `${fileName}.${timestamp}.backup`;\n    const backupPath = path.join(this.backupDirectory, backupFileName);\n\n    const originalContent = fs.readFileSync(filePath, 'utf8');\n    fs.writeFileSync(backupPath, originalContent, 'utf8');\n\n    return backupPath;\n  }\n\n  private async rollbackFromBackup(filePath: string, backupPath: string): Promise<void> {\n    if (fs.existsSync(backupPath)) {\n      const backupContent = fs.readFileSync(backupPath, 'utf8');\n      fs.writeFileSync(filePath, backupContent, 'utf8');\n    }\n  }\n\n  private async rollbackAllFiles(backupPaths: Map<string, string>): Promise<void> {\n    for (const [filePath, backupPath] of Array.from(backupPaths.entries())) {\n      await this.rollbackFromBackup(filePath, backupPath);\n    }\n  }\n\n  private groupReplacementsByFile(replacements: TypeReplacement[]): Map<string, TypeReplacement[]> {\n    const grouped = new Map<string, TypeReplacement[]>();\n\n    for (const replacement of replacements) {\n      if (!grouped.has(replacement.filePath)) {\n        grouped.set(replacement.filePath, []);\n      }\n      grouped.get(replacement.filePath)!.push(replacement);\n    }\n\n    // Sort replacements within each file by line number (descending to avoid line number shifts)\n    for (const fileReplacements of grouped.values()) {\n      fileReplacements.sort((a, b) => b.lineNumber - a.lineNumber);\n    }\n\n    return grouped;\n  }\n\n  private async applyReplacementsToFile(\n    filePath: string,\n    replacements: TypeReplacement[]\n  ): Promise<{ applied: TypeReplacement[], failed: TypeReplacement[], errors: string[] }> {\n    const applied: TypeReplacement[] = [];\n    const failed: TypeReplacement[] = [];\n    const errors: string[] = [];\n\n    try {\n      let content = fs.readFileSync(filePath, 'utf8');\n      let lines = content.split('\\n');\n\n      for (const replacement of replacements) {\n        try {\n          const lineIndex = replacement.lineNumber - 1;\n          if (lineIndex < 0 || lineIndex >= lines.length) {\n            failed.push(replacement);\n            errors.push(`Invalid line number ${replacement.lineNumber} for file ${filePath}`);\n            continue;\n          }\n\n          const originalLine = lines[lineIndex];\n          const modifiedLine = originalLine.replace(replacement.original, replacement.replacement);\n\n          if (originalLine === modifiedLine) {\n            failed.push(replacement);\n            errors.push(`Pattern \"${replacement.original}\" not found in line: ${originalLine}`);\n            continue;\n          }\n\n          lines[lineIndex] = modifiedLine;\n          applied.push(replacement);\n\n        } catch (error) {\n          failed.push(replacement);\n          errors.push(error instanceof Error ? error.message : String(error));\n        }\n      }\n\n      // Write the modified content back to file\n      const modifiedContent = lines.join('\\n');\n      fs.writeFileSync(filePath, modifiedContent, 'utf8');\n\n    } catch (error) {\n      // If file-level operation fails, mark all replacements as failed\n      failed.push(...replacements);\n      errors.push(error instanceof Error ? error.message : String(error));\n    }\n\n    return { applied, failed, errors };\n  }\n\n  private async validateTypeScriptCompilation(): Promise<{ success: boolean, errors: string[] }> {\n    try {\n      // Use the same pattern as existing campaign system\n      execSync('yarn tsc --noEmit --skipLibCheck', {\n        encoding: 'utf8',\n        stdio: 'pipe',\n        timeout: 30000 // 30 second timeout\n      });\n\n      return { success: true, errors: [] };\n\n    } catch (error) {\n      const errorOutput = error instanceof Error && 'stdout' in error\n        ? (error as any).stdout || (error as any).stderr || error.message\n        : String(error);\n\n      // Extract TypeScript errors\n      const tsErrors = errorOutput\n        .split('\\n')\n        .filter((line: string) => line.includes('error TS'))\n        .slice(0, 10); // Limit to first 10 errors for readability\n\n      // If no TypeScript errors found, include the general error message\n      const errors = tsErrors.length > 0 ? tsErrors : [errorOutput];\n\n      return { success: false, errors };\n    }\n  }\n\n  private ensureBackupDirectory(): void {\n    if (!fs.existsSync(this.backupDirectory)) {\n      fs.mkdirSync(this.backupDirectory, { recursive: true });\n    }\n  }\n\n  /**\n   * Perform atomic replacement operation with comprehensive validation\n   */\n  private async performAtomicReplacement(\n    replacement: TypeReplacement,\n    backupPath: string\n  ): Promise<ReplacementResult> {\n    try {\n      // Read original file content\n      const originalContent = fs.readFileSync(replacement.filePath, 'utf8');\n      const lines = originalContent.split('\\n');\n\n      // Validate line number\n      const lineIndex = replacement.lineNumber - 1;\n      if (lineIndex < 0 || lineIndex >= lines.length) {\n        return {\n          success: false,\n          appliedReplacements: [],\n          failedReplacements: [replacement],\n          compilationErrors: [`Invalid line number ${replacement.lineNumber} for file ${replacement.filePath}`],\n          rollbackPerformed: false,\n          backupPath\n        };\n      }\n\n      // Apply replacement\n      const originalLine = lines[lineIndex];\n      const modifiedLine = originalLine.replace(replacement.original, replacement.replacement);\n\n      // Verify replacement was applied\n      if (originalLine === modifiedLine) {\n        return {\n          success: false,\n          appliedReplacements: [],\n          failedReplacements: [replacement],\n          compilationErrors: [`Pattern \"${replacement.original}\" not found in line: ${originalLine}`],\n          rollbackPerformed: false,\n          backupPath\n        };\n      }\n\n      // Write modified content\n      lines[lineIndex] = modifiedLine;\n      const modifiedContent = lines.join('\\n');\n      fs.writeFileSync(replacement.filePath, modifiedContent, 'utf8');\n\n      // Validate TypeScript compilation\n      const compilationResult = await this.validateTypeScriptCompilation();\n      if (!compilationResult.success) {\n        // Rollback on compilation failure\n        await this.rollbackFromBackup(replacement.filePath, backupPath);\n        return {\n          success: false,\n          appliedReplacements: [],\n          failedReplacements: [replacement],\n          compilationErrors: compilationResult.errors,\n          rollbackPerformed: true,\n          backupPath\n        };\n      }\n\n      return {\n        success: true,\n        appliedReplacements: [replacement],\n        failedReplacements: [],\n        compilationErrors: [],\n        rollbackPerformed: false,\n        backupPath\n      };\n\n    } catch (error) {\n      // Don't rollback here - let the calling method handle it\n      throw error;\n    }\n  }\n\n  /**\n   * Verify that rollback capability is working correctly\n   */\n  private async verifyRollbackCapability(\n    filePath: string,\n    backupPath: string\n  ): Promise<{ success: boolean, error?: string }> {\n    try {\n      // Read backup content\n      if (!fs.existsSync(backupPath)) {\n        return { success: false, error: 'Backup file does not exist' };\n      }\n\n      const backupContent = fs.readFileSync(backupPath, 'utf8');\n\n      // For testing purposes, we'll just verify the backup exists and is readable\n      // In a real scenario, we might do a more comprehensive test\n      if (backupContent.length === 0) {\n        return { success: false, error: 'Backup file is empty' };\n      }\n\n      return { success: true };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Calculate safety score for a replacement based on multiple factors\n   */\n  private calculateSafetyScore(replacement: TypeReplacement): number {\n    let score = replacement.confidence; // Base score from classification confidence\n\n    // Adjust based on replacement type\n    if (replacement.replacement.includes('unknown')) {\n      score += 0.1; // unknown is generally safer than any\n    }\n\n    // Adjust based on file type\n    if (replacement.filePath.includes('.test.') || replacement.filePath.includes('__tests__')) {\n      score += 0.05; // Test files are safer to modify\n    }\n\n    // Adjust based on replacement pattern complexity\n    if (replacement.original === 'any[]') {\n      score += 0.15; // Array replacements are very safe\n    } else if (replacement.original.includes('Record<string, any>')) {\n      score += 0.1; // Record replacements are generally safe\n    } else if (replacement.original.includes('function') || replacement.original.includes('=>')) {\n      score -= 0.1; // Function-related replacements are riskier\n    }\n\n    // Adjust based on line context (if available in the replacement)\n    const lineContent = replacement.original;\n    if (lineContent.includes('catch') || lineContent.includes('error')) {\n      score -= 0.2; // Error handling contexts are riskier\n    }\n\n    if (lineContent.includes('interface') || lineContent.includes('type ')) {\n      score += 0.05; // Type definitions are safer\n    }\n\n    // Ensure score stays within bounds\n    return Math.max(0, Math.min(1, score));\n  }\n\n  /**\n   * Get replacement strategies sorted by priority\n   */\n  getStrategies(): ReplacementStrategy[] {\n    return [...this.strategies].sort((a, b) => a.priority - b.priority);\n  }\n\n  /**\n   * Add a custom replacement strategy\n   */\n  addStrategy(strategy: ReplacementStrategy): void {\n    this.strategies.push(strategy);\n    this.strategies.sort((a, b) => a.priority - b.priority);\n  }\n\n  /**\n   * Get backup directory path\n   */\n  getBackupDirectory(): string {\n    return this.backupDirectory;\n  }\n\n  /**\n   * Clean up old backup files (older than specified days)\n   */\n  cleanupOldBackups(daysToKeep = 7): void {\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);\n\n      const files = fs.readdirSync(this.backupDirectory);\n\n      for (const file of files) {\n        if (file.endsWith('.backup')) {\n          const filePath = path.join(this.backupDirectory, file);\n          const stats = fs.statSync(filePath);\n\n          if (stats.mtime < cutoffDate) {\n            fs.unlinkSync(filePath);\n          }\n        }\n      }\n    } catch (error) {\n      // Log error but don't throw - cleanup is not critical\n      console.warn('Failed to cleanup old backups:', error);\n    }\n  }\n}\n"],"version":3}