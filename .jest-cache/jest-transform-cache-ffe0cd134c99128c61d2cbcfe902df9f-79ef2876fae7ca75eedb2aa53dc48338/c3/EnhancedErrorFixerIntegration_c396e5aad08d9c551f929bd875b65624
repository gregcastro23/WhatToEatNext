fb186680866dfee5b519d62e376bdc02
"use strict";
/**
 * Enhanced Error Fixer Integration for Perfect Codebase Campaign
 *
 * Wrapper for scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js
 * Implements batch processing with --max-files=15 --auto-fix parameters
 * Creates build validation after every 5 files processed
 *
 * Requirements: 1.6, 1.7, 7.1
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnhancedErrorFixerIntegration = void 0;
const child_process_1 = require("child_process");
class EnhancedErrorFixerIntegration {
    ENHANCED_FIXER_PATH = 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js';
    DEFAULT_BATCH_SIZE = 15;
    BUILD_VALIDATION_INTERVAL = 5;
    /**
     * Execute Enhanced Error Fixer v3.0 with specified options
     */
    async executeEnhancedFixer(options = {}) {
        const startTime = Date.now();
        console.log('üöÄ Starting Enhanced TypeScript Error Fixer v3.0...');
        // Prepare command arguments
        const args = this.buildFixerArguments(options);
        try {
            // Execute the Enhanced Error Fixer
            const result = await this.runFixerCommand(args);
            // Validate build after fixing
            const buildValidationPassed = await this.validateBuild();
            const executionTime = Date.now() - startTime;
            return {
                success: result.success,
                filesProcessed: result.filesProcessed,
                errorsFixed: result.errorsFixed,
                errorsRemaining: result.errorsRemaining,
                buildValidationPassed,
                executionTime,
                safetyScore: result.safetyScore,
                warnings: result.warnings,
                errors: result.errors,
            };
        }
        catch (error) {
            console.error('‚ùå Enhanced Error Fixer execution failed:', error);
            return {
                success: false,
                filesProcessed: 0,
                errorsFixed: 0,
                errorsRemaining: await this.getCurrentErrorCount(),
                buildValidationPassed: false,
                executionTime: Date.now() - startTime,
                warnings: [],
                errors: [error instanceof Error ? error.message : String(error)],
            };
        }
    }
    /**
     * Execute batch processing with build validation after every 5 files
     */
    async executeBatchProcessing(options) {
        console.log(`üîÑ Starting batch processing with ${options.batchSize} files per batch...`);
        const results = [];
        let batchNumber = 1;
        let totalFilesProcessed = 0;
        let totalErrorsFixed = 0;
        const maxIterations = options.maxBatches || 50; // Prevent infinite loops
        const startTime = Date.now();
        const maxExecutionTime = 30 * 60 * 1000; // 30 minutes max
        while (batchNumber <= maxIterations) {
            console.log(`\nüì¶ Processing Batch ${batchNumber}/${maxIterations}...`);
            // Check execution time limit
            if (Date.now() - startTime > maxExecutionTime) {
                console.log(`‚è∞ Maximum execution time (30 minutes) reached, stopping`);
                break;
            }
            // Check if we should stop (max batches reached)
            if (options.maxBatches && batchNumber > options.maxBatches) {
                console.log(`‚úã Reached maximum batch limit (${options.maxBatches})`);
                break;
            }
            // Check current error count with timeout protection
            let currentErrors = 0;
            try {
                currentErrors = await this.getCurrentErrorCount();
            }
            catch (error) {
                console.warn('‚ö†Ô∏è  Error count check failed, assuming errors remain');
                currentErrors = 1; // Assume errors exist to continue safely
            }
            if (currentErrors === 0) {
                console.log('üéâ No more TypeScript errors found!');
                break;
            }
            // Execute fixer for this batch
            const batchResult = await this.executeEnhancedFixer({
                maxFiles: options.batchSize,
                autoFix: true,
                validateSafety: true,
            });
            results.push(batchResult);
            totalFilesProcessed += batchResult.filesProcessed;
            totalErrorsFixed += batchResult.errorsFixed;
            console.log(`üìä Batch ${batchNumber} Results:`);
            console.log(`  Files processed: ${batchResult.filesProcessed}`);
            console.log(`  Errors fixed: ${batchResult.errorsFixed}`);
            console.log(`  Build validation: ${batchResult.buildValidationPassed ? '‚úÖ' : '‚ùå'}`);
            // Stop on build failure if configured
            if (options.stopOnBuildFailure && !batchResult.buildValidationPassed) {
                console.log('üõë Stopping batch processing due to build failure');
                break;
            }
            // Stop if no progress made
            if (batchResult.filesProcessed === 0 && batchResult.errorsFixed === 0) {
                console.log('‚è∏Ô∏è  No progress made in this batch, stopping');
                break;
            }
            // Build validation after every N files (as specified in requirements)
            if (totalFilesProcessed % options.buildValidationInterval === 0) {
                console.log(`üîç Performing build validation after ${totalFilesProcessed} files...`);
                const buildValid = await this.validateBuild();
                if (!buildValid && options.stopOnBuildFailure) {
                    console.log('üõë Build validation failed, stopping batch processing');
                    break;
                }
            }
            batchNumber++;
        }
        console.log(`\nüìà Batch Processing Summary:`);
        console.log(`  Total batches: ${results.length}`);
        console.log(`  Total files processed: ${totalFilesProcessed}`);
        console.log(`  Total errors fixed: ${totalErrorsFixed}`);
        console.log(`  Remaining errors: ${await this.getCurrentErrorCount()}`);
        return results;
    }
    /**
     * Build command arguments for Enhanced Error Fixer
     */
    buildFixerArguments(options) {
        const args = [];
        if (options.maxFiles) {
            args.push(`--max-files=${options.maxFiles}`);
        }
        if (options.autoFix) {
            args.push('--auto-fix');
        }
        if (options.dryRun) {
            args.push('--dry-run');
        }
        if (options.validateSafety) {
            args.push('--validate-safety');
        }
        if (options.silent) {
            args.push('--silent');
        }
        if (options.json) {
            args.push('--json');
        }
        return args;
    }
    /**
     * Execute the Enhanced Error Fixer command
     */
    async runFixerCommand(args) {
        return new Promise((resolve, reject) => {
            const command = 'node';
            const fullArgs = [this.ENHANCED_FIXER_PATH, ...args];
            console.log(`üîß Executing: ${command} ${fullArgs.join(' ')}`);
            const child = (0, child_process_1.spawn)(command, fullArgs, {
                stdio: ['pipe', 'pipe', 'pipe'],
                cwd: process.cwd(),
            });
            let stdout = '';
            let stderr = '';
            child.stdout.on('data', data => {
                stdout += data.toString();
                // Show real-time output if not silent
                if (!args.includes('--silent')) {
                    process.stdout.write(data);
                }
            });
            child.stderr.on('data', data => {
                stderr += data.toString();
                if (!args.includes('--silent')) {
                    process.stderr.write(data);
                }
            });
            child.on('close', code => {
                const success = code === 0;
                const output = stdout + stderr;
                // Parse output for metrics
                const result = this.parseFixerOutput(output, success);
                if (success) {
                    resolve(result);
                }
                else {
                    resolve({
                        ...result,
                        success: false,
                        errors: [...result.errors, `Process exited with code ${code}`],
                    });
                }
            });
            child.on('error', error => {
                reject(error);
            });
        });
    }
    /**
     * Parse Enhanced Error Fixer output to extract metrics
     */
    parseFixerOutput(output, success) {
        const warnings = [];
        const errors = [];
        // Extract metrics from output
        let filesProcessed = 0;
        let errorsFixed = 0;
        const errorsRemaining = 0;
        let safetyScore;
        // Parse files processed
        const filesMatch = output.match(/(?:processed|fixed)\s+(\d+)\s+files?/i);
        if (filesMatch) {
            filesProcessed = parseInt(filesMatch[1]);
        }
        // Parse errors fixed
        const errorsFixedMatch = output.match(/(?:fixed|resolved)\s+(\d+)\s+errors?/i);
        if (errorsFixedMatch) {
            errorsFixed = parseInt(errorsFixedMatch[1]);
        }
        // Parse safety score
        const safetyMatch = output.match(/safety\s+score[:\s]+(\d+(?:\.\d+)?)/i);
        if (safetyMatch) {
            safetyScore = parseFloat(safetyMatch[1]);
        }
        // Extract warnings
        const warningMatches = output.match(/‚ö†Ô∏è[^\n]*/g);
        if (warningMatches) {
            warnings.push(...warningMatches);
        }
        // Extract errors
        const errorMatches = output.match(/‚ùå[^\n]*/g);
        if (errorMatches) {
            errors.push(...errorMatches);
        }
        return {
            success,
            filesProcessed,
            errorsFixed,
            errorsRemaining,
            safetyScore,
            warnings,
            errors,
        };
    }
    /**
     * Validate build after error fixing
     */
    async validateBuild() {
        try {
            console.log('üîç Validating build...');
            const startTime = Date.now();
            (0, child_process_1.execSync)('yarn build', {
                stdio: 'pipe',
                timeout: 120000, // 2 minute timeout
            });
            const buildTime = Date.now() - startTime;
            console.log(`‚úÖ Build validation passed (${buildTime}ms)`);
            return true;
        }
        catch (error) {
            console.log('‚ùå Build validation failed');
            if (error instanceof Error) {
                console.log(`   Error: ${error.message}`);
            }
            return false;
        }
    }
    /**
     * Get current TypeScript error count
     */
    async getCurrentErrorCount() {
        try {
            const output = (0, child_process_1.execSync)('yarn tsc --noEmit --skipLibCheck 2>&1 | grep -c "error TS"', {
                encoding: 'utf8',
                stdio: 'pipe',
                timeout: 30000, // 30 second timeout
            });
            return parseInt(output.trim()) || 0;
        }
        catch (error) {
            // If grep finds no matches, it returns exit code 1, or timeout occurred
            console.warn('TypeScript error count check failed or timed out:', error.message);
            return 0;
        }
    }
    /**
     * Show Enhanced Error Fixer metrics
     */
    async showMetrics() {
        try {
            console.log('üìä Fetching Enhanced Error Fixer metrics...');
            const result = await this.runFixerCommand(['--show-metrics', '--json']);
            if (result.success) {
                console.log('‚úÖ Metrics retrieved successfully');
            }
            else {
                console.log('‚ö†Ô∏è  Could not retrieve all metrics');
            }
        }
        catch (error) {
            console.error('‚ùå Failed to show metrics:', error);
        }
    }
    /**
     * Validate safety before running fixes
     */
    async validateSafety() {
        try {
            console.log('üõ°Ô∏è  Validating safety...');
            const result = await this.runFixerCommand(['--validate-safety', '--json']);
            // Parse safety validation result
            // This would need to be implemented based on the actual output format
            // For now, return a basic safety check
            return {
                safe: result.success,
                safetyScore: result.safetyScore || 0.5,
                issues: result.errors,
                recommendedBatchSize: this.DEFAULT_BATCH_SIZE,
            };
        }
        catch (error) {
            console.error('‚ùå Safety validation failed:', error);
            return {
                safe: false,
                safetyScore: 0,
                issues: [error instanceof Error ? error.message : String(error)],
                recommendedBatchSize: 3, // Conservative batch size
            };
        }
    }
    /**
     * Execute with recommended safety settings (Requirements 1.6, 1.7)
     */
    async executeWithSafetyProtocols() {
        console.log('üõ°Ô∏è  Executing Enhanced Error Fixer with safety protocols...');
        // First, validate safety
        const safetyCheck = await this.validateSafety();
        if (!safetyCheck.safe) {
            console.log('‚ö†Ô∏è  Safety validation failed:');
            safetyCheck.issues.forEach(issue => console.log(`   - ${issue}`));
            // Use conservative settings
            return await this.executeEnhancedFixer({
                maxFiles: 3,
                autoFix: false,
                dryRun: true,
                validateSafety: true,
            });
        }
        // Execute with recommended batch size
        return await this.executeEnhancedFixer({
            maxFiles: Math.min(safetyCheck.recommendedBatchSize, this.DEFAULT_BATCH_SIZE),
            autoFix: true,
            validateSafety: true,
        });
    }
}
exports.EnhancedErrorFixerIntegration = EnhancedErrorFixerIntegration;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5jb25zb2xpZGF0aW9uLWJhY2t1cHMtMjAyNS0wOC0yM1QxNy01NC0xMC0wOTJaL3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9FbmhhbmNlZEVycm9yRml4ZXJJbnRlZ3JhdGlvbi50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0dBUUc7OztBQUVILGlEQUFnRDtBQWtDaEQsTUFBYSw2QkFBNkI7SUFDdkIsbUJBQW1CLEdBQ2xDLCtEQUErRCxDQUFDO0lBQ2pELGtCQUFrQixHQUFHLEVBQUUsQ0FBQztJQUN4Qix5QkFBeUIsR0FBRyxDQUFDLENBQUM7SUFFL0M7O09BRUc7SUFDSCxLQUFLLENBQUMsb0JBQW9CLENBQUMsVUFBd0IsRUFBRTtRQUNuRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFN0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO1FBRW5FLDRCQUE0QjtRQUM1QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFL0MsSUFBSTtZQUNGLG1DQUFtQztZQUNuQyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFaEQsOEJBQThCO1lBQzlCLE1BQU0scUJBQXFCLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7WUFFekQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQztZQUU3QyxPQUFPO2dCQUNMLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTztnQkFDdkIsY0FBYyxFQUFFLE1BQU0sQ0FBQyxjQUFjO2dCQUNyQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7Z0JBQy9CLGVBQWUsRUFBRSxNQUFNLENBQUMsZUFBZTtnQkFDdkMscUJBQXFCO2dCQUNyQixhQUFhO2dCQUNiLFdBQVcsRUFBRSxN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RUFxYkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5jb25zb2xpZGF0aW9uLWJhY2t1cHMtMjAyNS0wOC0yM1QxNy01NC0xMC0wOTJaL3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9FbmhhbmNlZEVycm9yRml4ZXJJbnRlZ3JhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuaGFuY2VkIEVycm9yIEZpeGVyIEludGVncmF0aW9uIGZvciBQZXJmZWN0IENvZGViYXNlIENhbXBhaWduXG4gKlxuICogV3JhcHBlciBmb3Igc2NyaXB0cy90eXBlc2NyaXB0LWZpeGVzL2ZpeC10eXBlc2NyaXB0LWVycm9ycy1lbmhhbmNlZC12My5qc1xuICogSW1wbGVtZW50cyBiYXRjaCBwcm9jZXNzaW5nIHdpdGggLS1tYXgtZmlsZXM9MTUgLS1hdXRvLWZpeCBwYXJhbWV0ZXJzXG4gKiBDcmVhdGVzIGJ1aWxkIHZhbGlkYXRpb24gYWZ0ZXIgZXZlcnkgNSBmaWxlcyBwcm9jZXNzZWRcbiAqXG4gKiBSZXF1aXJlbWVudHM6IDEuNiwgMS43LCA3LjFcbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYywgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgdGVybWluYWxGcmVlemVQcmV2ZW50aW9uU3lzdGVtIH0gZnJvbSAnLi9UZXJtaW5hbEZyZWV6ZVByZXZlbnRpb25TeXN0ZW0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpeGVyT3B0aW9ucyB7XG4gIG1heEZpbGVzPzogbnVtYmVyO1xuICBhdXRvRml4PzogYm9vbGVhbjtcbiAgZHJ5UnVuPzogYm9vbGVhbjtcbiAgdmFsaWRhdGVTYWZldHk/OiBib29sZWFuO1xuICBzaWxlbnQ/OiBib29sZWFuO1xuICBqc29uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaXhlclJlc3VsdCB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGZpbGVzUHJvY2Vzc2VkOiBudW1iZXI7XG4gIGVycm9yc0ZpeGVkOiBudW1iZXI7XG4gIGVycm9yc1JlbWFpbmluZzogbnVtYmVyO1xuICBidWlsZFZhbGlkYXRpb25QYXNzZWQ6IGJvb2xlYW47XG4gIGV4ZWN1dGlvblRpbWU6IG51bWJlcjtcbiAgc2FmZXR5U2NvcmU/OiBudW1iZXI7XG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcbiAgZXJyb3JzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaFByb2Nlc3NpbmdPcHRpb25zIHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG4gIGJ1aWxkVmFsaWRhdGlvbkludGVydmFsOiBudW1iZXI7XG4gIG1heEJhdGNoZXM/OiBudW1iZXI7XG4gIHN0b3BPbkJ1aWxkRmFpbHVyZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBFbmhhbmNlZEVycm9yRml4ZXJJbnRlZ3JhdGlvbiB7XG4gIHByaXZhdGUgcmVhZG9ubHkgRU5IQU5DRURfRklYRVJfUEFUSCA9XG4gICAgJ3NjcmlwdHMvdHlwZXNjcmlwdC1maXhlcy9maXgtdHlwZXNjcmlwdC1lcnJvcnMtZW5oYW5jZWQtdjMuanMnO1xuICBwcml2YXRlIHJlYWRvbmx5IERFRkFVTFRfQkFUQ0hfU0laRSA9IDE1O1xuICBwcml2YXRlIHJlYWRvbmx5IEJVSUxEX1ZBTElEQVRJT05fSU5URVJWQUwgPSA1O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIEVuaGFuY2VkIEVycm9yIEZpeGVyIHYzLjAgd2l0aCBzcGVjaWZpZWQgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZUVuaGFuY2VkRml4ZXIob3B0aW9uczogRml4ZXJPcHRpb25zID0ge30pOiBQcm9taXNlPEZpeGVyUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIEVuaGFuY2VkIFR5cGVTY3JpcHQgRXJyb3IgRml4ZXIgdjMuMC4uLicpO1xuXG4gICAgLy8gUHJlcGFyZSBjb21tYW5kIGFyZ3VtZW50c1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmJ1aWxkRml4ZXJBcmd1bWVudHMob3B0aW9ucyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gRXhlY3V0ZSB0aGUgRW5oYW5jZWQgRXJyb3IgRml4ZXJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuRml4ZXJDb21tYW5kKGFyZ3MpO1xuXG4gICAgICAvLyBWYWxpZGF0ZSBidWlsZCBhZnRlciBmaXhpbmdcbiAgICAgIGNvbnN0IGJ1aWxkVmFsaWRhdGlvblBhc3NlZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVCdWlsZCgpO1xuXG4gICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiByZXN1bHQuZmlsZXNQcm9jZXNzZWQsXG4gICAgICAgIGVycm9yc0ZpeGVkOiByZXN1bHQuZXJyb3JzRml4ZWQsXG4gICAgICAgIGVycm9yc1JlbWFpbmluZzogcmVzdWx0LmVycm9yc1JlbWFpbmluZyxcbiAgICAgICAgYnVpbGRWYWxpZGF0aW9uUGFzc2VkLFxuICAgICAgICBleGVjdXRpb25UaW1lLFxuICAgICAgICBzYWZldHlTY29yZTogcmVzdWx0LnNhZmV0eVNjb3JlLFxuICAgICAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRW5oYW5jZWQgRXJyb3IgRml4ZXIgZXhlY3V0aW9uIGZhaWxlZDonLCBlcnJvcik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogMCxcbiAgICAgICAgZXJyb3JzRml4ZWQ6IDAsXG4gICAgICAgIGVycm9yc1JlbWFpbmluZzogYXdhaXQgdGhpcy5nZXRDdXJyZW50RXJyb3JDb3VudCgpLFxuICAgICAgICBidWlsZFZhbGlkYXRpb25QYXNzZWQ6IGZhbHNlLFxuICAgICAgICBleGVjdXRpb25UaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICB3YXJuaW5nczogW10sXG4gICAgICAgIGVycm9yczogW2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKV0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGJhdGNoIHByb2Nlc3Npbmcgd2l0aCBidWlsZCB2YWxpZGF0aW9uIGFmdGVyIGV2ZXJ5IDUgZmlsZXNcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVCYXRjaFByb2Nlc3Npbmcob3B0aW9uczogQmF0Y2hQcm9jZXNzaW5nT3B0aW9ucyk6IFByb21pc2U8Rml4ZXJSZXN1bHRbXT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFN0YXJ0aW5nIGJhdGNoIHByb2Nlc3Npbmcgd2l0aCAke29wdGlvbnMuYmF0Y2hTaXplfSBmaWxlcyBwZXIgYmF0Y2guLi5gKTtcblxuICAgIGNvbnN0IHJlc3VsdHM6IEZpeGVyUmVzdWx0W10gPSBbXTtcbiAgICBsZXQgYmF0Y2hOdW1iZXIgPSAxO1xuICAgIGxldCB0b3RhbEZpbGVzUHJvY2Vzc2VkID0gMDtcbiAgICBsZXQgdG90YWxFcnJvcnNGaXhlZCA9IDA7XG5cbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gb3B0aW9ucy5tYXhCYXRjaGVzIHx8IDUwOyAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtYXhFeGVjdXRpb25UaW1lID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXMgbWF4XG5cbiAgICB3aGlsZSAoYmF0Y2hOdW1iZXIgPD0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coYFxcbvCfk6YgUHJvY2Vzc2luZyBCYXRjaCAke2JhdGNoTnVtYmVyfS8ke21heEl0ZXJhdGlvbnN9Li4uYCk7XG5cbiAgICAgIC8vIENoZWNrIGV4ZWN1dGlvbiB0aW1lIGxpbWl0XG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IG1heEV4ZWN1dGlvblRpbWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKPsCBNYXhpbXVtIGV4ZWN1dGlvbiB0aW1lICgzMCBtaW51dGVzKSByZWFjaGVkLCBzdG9wcGluZ2ApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHN0b3AgKG1heCBiYXRjaGVzIHJlYWNoZWQpXG4gICAgICBpZiAob3B0aW9ucy5tYXhCYXRjaGVzICYmIGJhdGNoTnVtYmVyID4gb3B0aW9ucy5tYXhCYXRjaGVzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIsgUmVhY2hlZCBtYXhpbXVtIGJhdGNoIGxpbWl0ICgke29wdGlvbnMubWF4QmF0Y2hlc30pYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBjdXJyZW50IGVycm9yIGNvdW50IHdpdGggdGltZW91dCBwcm90ZWN0aW9uXG4gICAgICBsZXQgY3VycmVudEVycm9ycyA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50RXJyb3JzID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50RXJyb3JDb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gIEVycm9yIGNvdW50IGNoZWNrIGZhaWxlZCwgYXNzdW1pbmcgZXJyb3JzIHJlbWFpbicpO1xuICAgICAgICBjdXJyZW50RXJyb3JzID0gMTsgLy8gQXNzdW1lIGVycm9ycyBleGlzdCB0byBjb250aW51ZSBzYWZlbHlcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRFcnJvcnMgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CfjokgTm8gbW9yZSBUeXBlU2NyaXB0IGVycm9ycyBmb3VuZCEnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4ZWN1dGUgZml4ZXIgZm9yIHRoaXMgYmF0Y2hcbiAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlRW5oYW5jZWRGaXhlcih7XG4gICAgICAgIG1heEZpbGVzOiBvcHRpb25zLmJhdGNoU2l6ZSxcbiAgICAgICAgYXV0b0ZpeDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVTYWZldHk6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0cy5wdXNoKGJhdGNoUmVzdWx0KTtcbiAgICAgIHRvdGFsRmlsZXNQcm9jZXNzZWQgKz0gYmF0Y2hSZXN1bHQuZmlsZXNQcm9jZXNzZWQ7XG4gICAgICB0b3RhbEVycm9yc0ZpeGVkICs9IGJhdGNoUmVzdWx0LmVycm9yc0ZpeGVkO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBCYXRjaCAke2JhdGNoTnVtYmVyfSBSZXN1bHRzOmApO1xuICAgICAgY29uc29sZS5sb2coYCAgRmlsZXMgcHJvY2Vzc2VkOiAke2JhdGNoUmVzdWx0LmZpbGVzUHJvY2Vzc2VkfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgRXJyb3JzIGZpeGVkOiAke2JhdGNoUmVzdWx0LmVycm9yc0ZpeGVkfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgQnVpbGQgdmFsaWRhdGlvbjogJHtiYXRjaFJlc3VsdC5idWlsZFZhbGlkYXRpb25QYXNzZWQgPyAn4pyFJyA6ICfinYwnfWApO1xuXG4gICAgICAvLyBTdG9wIG9uIGJ1aWxkIGZhaWx1cmUgaWYgY29uZmlndXJlZFxuICAgICAgaWYgKG9wdGlvbnMuc3RvcE9uQnVpbGRGYWlsdXJlICYmICFiYXRjaFJlc3VsdC5idWlsZFZhbGlkYXRpb25QYXNzZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgYmF0Y2ggcHJvY2Vzc2luZyBkdWUgdG8gYnVpbGQgZmFpbHVyZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcCBpZiBubyBwcm9ncmVzcyBtYWRlXG4gICAgICBpZiAoYmF0Y2hSZXN1bHQuZmlsZXNQcm9jZXNzZWQgPT09IDAgJiYgYmF0Y2hSZXN1bHQuZXJyb3JzRml4ZWQgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPuO+4jyAgTm8gcHJvZ3Jlc3MgbWFkZSBpbiB0aGlzIGJhdGNoLCBzdG9wcGluZycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgdmFsaWRhdGlvbiBhZnRlciBldmVyeSBOIGZpbGVzIChhcyBzcGVjaWZpZWQgaW4gcmVxdWlyZW1lbnRzKVxuICAgICAgaWYgKHRvdGFsRmlsZXNQcm9jZXNzZWQgJSBvcHRpb25zLmJ1aWxkVmFsaWRhdGlvbkludGVydmFsID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFBlcmZvcm1pbmcgYnVpbGQgdmFsaWRhdGlvbiBhZnRlciAke3RvdGFsRmlsZXNQcm9jZXNzZWR9IGZpbGVzLi4uYCk7XG4gICAgICAgIGNvbnN0IGJ1aWxkVmFsaWQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlQnVpbGQoKTtcbiAgICAgICAgaWYgKCFidWlsZFZhbGlkICYmIG9wdGlvbnMuc3RvcE9uQnVpbGRGYWlsdXJlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfm5EgQnVpbGQgdmFsaWRhdGlvbiBmYWlsZWQsIHN0b3BwaW5nIGJhdGNoIHByb2Nlc3NpbmcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiYXRjaE51bWJlcisrO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBcXG7wn5OIIEJhdGNoIFByb2Nlc3NpbmcgU3VtbWFyeTpgKTtcbiAgICBjb25zb2xlLmxvZyhgICBUb3RhbCBiYXRjaGVzOiAke3Jlc3VsdHMubGVuZ3RofWApO1xuICAgIGNvbnNvbGUubG9nKGAgIFRvdGFsIGZpbGVzIHByb2Nlc3NlZDogJHt0b3RhbEZpbGVzUHJvY2Vzc2VkfWApO1xuICAgIGNvbnNvbGUubG9nKGAgIFRvdGFsIGVycm9ycyBmaXhlZDogJHt0b3RhbEVycm9yc0ZpeGVkfWApO1xuICAgIGNvbnNvbGUubG9nKGAgIFJlbWFpbmluZyBlcnJvcnM6ICR7YXdhaXQgdGhpcy5nZXRDdXJyZW50RXJyb3JDb3VudCgpfWApO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgY29tbWFuZCBhcmd1bWVudHMgZm9yIEVuaGFuY2VkIEVycm9yIEZpeGVyXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkRml4ZXJBcmd1bWVudHMob3B0aW9uczogRml4ZXJPcHRpb25zKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGFyZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5tYXhGaWxlcykge1xuICAgICAgYXJncy5wdXNoKGAtLW1heC1maWxlcz0ke29wdGlvbnMubWF4RmlsZXN9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXV0b0ZpeCkge1xuICAgICAgYXJncy5wdXNoKCctLWF1dG8tZml4Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICBhcmdzLnB1c2goJy0tZHJ5LXJ1bicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlU2FmZXR5KSB7XG4gICAgICBhcmdzLnB1c2goJy0tdmFsaWRhdGUtc2FmZXR5Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7XG4gICAgICBhcmdzLnB1c2goJy0tc2lsZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuanNvbikge1xuICAgICAgYXJncy5wdXNoKCctLWpzb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBFbmhhbmNlZCBFcnJvciBGaXhlciBjb21tYW5kXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJ1bkZpeGVyQ29tbWFuZChhcmdzOiBzdHJpbmdbXSk6IFByb21pc2U8e1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgZmlsZXNQcm9jZXNzZWQ6IG51bWJlcjtcbiAgICBlcnJvcnNGaXhlZDogbnVtYmVyO1xuICAgIGVycm9yc1JlbWFpbmluZzogbnVtYmVyO1xuICAgIHNhZmV0eVNjb3JlPzogbnVtYmVyO1xuICAgIHdhcm5pbmdzOiBzdHJpbmdbXTtcbiAgICBlcnJvcnM6IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSAnbm9kZSc7XG4gICAgICBjb25zdCBmdWxsQXJncyA9IFt0aGlzLkVOSEFOQ0VEX0ZJWEVSX1BBVEgsIC4uLmFyZ3NdO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+UpyBFeGVjdXRpbmc6ICR7Y29tbWFuZH0gJHtmdWxsQXJncy5qb2luKCcgJyl9YCk7XG5cbiAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oY29tbWFuZCwgZnVsbEFyZ3MsIHtcbiAgICAgICAgc3RkaW86IFsncGlwZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgICAgICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCBzdGRvdXQgPSAnJztcbiAgICAgIGxldCBzdGRlcnIgPSAnJztcblxuICAgICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIHN0ZG91dCArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIFNob3cgcmVhbC10aW1lIG91dHB1dCBpZiBub3Qgc2lsZW50XG4gICAgICAgIGlmICghYXJncy5pbmNsdWRlcygnLS1zaWxlbnQnKSkge1xuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghYXJncy5pbmNsdWRlcygnLS1zaWxlbnQnKSkge1xuICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub24oJ2Nsb3NlJywgY29kZSA9PiB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBjb2RlID09PSAwO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBzdGRvdXQgKyBzdGRlcnI7XG5cbiAgICAgICAgLy8gUGFyc2Ugb3V0cHV0IGZvciBtZXRyaWNzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2VGaXhlck91dHB1dChvdXRwdXQsIHN1Y2Nlc3MpO1xuXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IFsuLi5yZXN1bHQuZXJyb3JzLCBgUHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIEVuaGFuY2VkIEVycm9yIEZpeGVyIG91dHB1dCB0byBleHRyYWN0IG1ldHJpY3NcbiAgICovXG4gIHByaXZhdGUgcGFyc2VGaXhlck91dHB1dChcbiAgICBvdXRwdXQ6IHN0cmluZyxcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICApOiB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBmaWxlc1Byb2Nlc3NlZDogbnVtYmVyO1xuICAgIGVycm9yc0ZpeGVkOiBudW1iZXI7XG4gICAgZXJyb3JzUmVtYWluaW5nOiBudW1iZXI7XG4gICAgc2FmZXR5U2NvcmU/OiBudW1iZXI7XG4gICAgd2FybmluZ3M6IHN0cmluZ1tdO1xuICAgIGVycm9yczogc3RyaW5nW107XG4gIH0ge1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIEV4dHJhY3QgbWV0cmljcyBmcm9tIG91dHB1dFxuICAgIGxldCBmaWxlc1Byb2Nlc3NlZCA9IDA7XG4gICAgbGV0IGVycm9yc0ZpeGVkID0gMDtcbiAgICBjb25zdCBlcnJvcnNSZW1haW5pbmcgPSAwO1xuICAgIGxldCBzYWZldHlTY29yZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgLy8gUGFyc2UgZmlsZXMgcHJvY2Vzc2VkXG4gICAgY29uc3QgZmlsZXNNYXRjaCA9IG91dHB1dC5tYXRjaCgvKD86cHJvY2Vzc2VkfGZpeGVkKVxccysoXFxkKylcXHMrZmlsZXM/L2kpO1xuICAgIGlmIChmaWxlc01hdGNoKSB7XG4gICAgICBmaWxlc1Byb2Nlc3NlZCA9IHBhcnNlSW50KGZpbGVzTWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGVycm9ycyBmaXhlZFxuICAgIGNvbnN0IGVycm9yc0ZpeGVkTWF0Y2ggPSBvdXRwdXQubWF0Y2goLyg/OmZpeGVkfHJlc29sdmVkKVxccysoXFxkKylcXHMrZXJyb3JzPy9pKTtcbiAgICBpZiAoZXJyb3JzRml4ZWRNYXRjaCkge1xuICAgICAgZXJyb3JzRml4ZWQgPSBwYXJzZUludChlcnJvcnNGaXhlZE1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBzYWZldHkgc2NvcmVcbiAgICBjb25zdCBzYWZldHlNYXRjaCA9IG91dHB1dC5tYXRjaCgvc2FmZXR5XFxzK3Njb3JlWzpcXHNdKyhcXGQrKD86XFwuXFxkKyk/KS9pKTtcbiAgICBpZiAoc2FmZXR5TWF0Y2gpIHtcbiAgICAgIHNhZmV0eVNjb3JlID0gcGFyc2VGbG9hdChzYWZldHlNYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCB3YXJuaW5nc1xuICAgIGNvbnN0IHdhcm5pbmdNYXRjaGVzID0gb3V0cHV0Lm1hdGNoKC/imqDvuI9bXlxcbl0qL2cpO1xuICAgIGlmICh3YXJuaW5nTWF0Y2hlcykge1xuICAgICAgd2FybmluZ3MucHVzaCguLi53YXJuaW5nTWF0Y2hlcyk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBlcnJvcnNcbiAgICBjb25zdCBlcnJvck1hdGNoZXMgPSBvdXRwdXQubWF0Y2goL+KdjFteXFxuXSovZyk7XG4gICAgaWYgKGVycm9yTWF0Y2hlcykge1xuICAgICAgZXJyb3JzLnB1c2goLi4uZXJyb3JNYXRjaGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzcyxcbiAgICAgIGZpbGVzUHJvY2Vzc2VkLFxuICAgICAgZXJyb3JzRml4ZWQsXG4gICAgICBlcnJvcnNSZW1haW5pbmcsXG4gICAgICBzYWZldHlTY29yZSxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgZXJyb3JzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYnVpbGQgYWZ0ZXIgZXJyb3IgZml4aW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlQnVpbGQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFZhbGlkYXRpbmcgYnVpbGQuLi4nKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGV4ZWNTeW5jKCd5YXJuIGJ1aWxkJywge1xuICAgICAgICBzdGRpbzogJ3BpcGUnLFxuICAgICAgICB0aW1lb3V0OiAxMjAwMDAsIC8vIDIgbWludXRlIHRpbWVvdXRcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBidWlsZFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYOKchSBCdWlsZCB2YWxpZGF0aW9uIHBhc3NlZCAoJHtidWlsZFRpbWV9bXMpYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBCdWlsZCB2YWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IFR5cGVTY3JpcHQgZXJyb3IgY291bnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q3VycmVudEVycm9yQ291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoJ3lhcm4gdHNjIC0tbm9FbWl0IC0tc2tpcExpYkNoZWNrIDI+JjEgfCBncmVwIC1jIFwiZXJyb3IgVFNcIicsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgdGltZW91dDogMzAwMDAsIC8vIDMwIHNlY29uZCB0aW1lb3V0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZUludChvdXRwdXQudHJpbSgpKSB8fCAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiBncmVwIGZpbmRzIG5vIG1hdGNoZXMsIGl0IHJldHVybnMgZXhpdCBjb2RlIDEsIG9yIHRpbWVvdXQgb2NjdXJyZWRcbiAgICAgIGNvbnNvbGUud2FybignVHlwZVNjcmlwdCBlcnJvciBjb3VudCBjaGVjayBmYWlsZWQgb3IgdGltZWQgb3V0OicsIChlcnJvciBhcyBFcnJvcikubWVzc2FnZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBFbmhhbmNlZCBFcnJvciBGaXhlciBtZXRyaWNzXG4gICAqL1xuICBhc3luYyBzaG93TWV0cmljcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogRmV0Y2hpbmcgRW5oYW5jZWQgRXJyb3IgRml4ZXIgbWV0cmljcy4uLicpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkZpeGVyQ29tbWFuZChbJy0tc2hvdy1tZXRyaWNzJywgJy0tanNvbiddKTtcblxuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWV0cmljcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPICBDb3VsZCBub3QgcmV0cmlldmUgYWxsIG1ldHJpY3MnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzaG93IG1ldHJpY3M6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBzYWZldHkgYmVmb3JlIHJ1bm5pbmcgZml4ZXNcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlU2FmZXR5KCk6IFByb21pc2U8e1xuICAgIHNhZmU6IGJvb2xlYW47XG4gICAgc2FmZXR5U2NvcmU6IG51bWJlcjtcbiAgICBpc3N1ZXM6IHN0cmluZ1tdO1xuICAgIHJlY29tbWVuZGVkQmF0Y2hTaXplOiBudW1iZXI7XG4gIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfm6HvuI8gIFZhbGlkYXRpbmcgc2FmZXR5Li4uJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuRml4ZXJDb21tYW5kKFsnLS12YWxpZGF0ZS1zYWZldHknLCAnLS1qc29uJ10pO1xuXG4gICAgICAvLyBQYXJzZSBzYWZldHkgdmFsaWRhdGlvbiByZXN1bHRcbiAgICAgIC8vIFRoaXMgd291bGQgbmVlZCB0byBiZSBpbXBsZW1lbnRlZCBiYXNlZCBvbiB0aGUgYWN0dWFsIG91dHB1dCBmb3JtYXRcbiAgICAgIC8vIEZvciBub3csIHJldHVybiBhIGJhc2ljIHNhZmV0eSBjaGVja1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYWZlOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgc2FmZXR5U2NvcmU6IHJlc3VsdC5zYWZldHlTY29yZSB8fCAwLjUsXG4gICAgICAgIGlzc3VlczogcmVzdWx0LmVycm9ycyxcbiAgICAgICAgcmVjb21tZW5kZWRCYXRjaFNpemU6IHRoaXMuREVGQVVMVF9CQVRDSF9TSVpFLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFNhZmV0eSB2YWxpZGF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNhZmU6IGZhbHNlLFxuICAgICAgICBzYWZldHlTY29yZTogMCxcbiAgICAgICAgaXNzdWVzOiBbZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXSxcbiAgICAgICAgcmVjb21tZW5kZWRCYXRjaFNpemU6IDMsIC8vIENvbnNlcnZhdGl2ZSBiYXRjaCBzaXplXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHdpdGggcmVjb21tZW5kZWQgc2FmZXR5IHNldHRpbmdzIChSZXF1aXJlbWVudHMgMS42LCAxLjcpXG4gICAqL1xuICBhc3luYyBleGVjdXRlV2l0aFNhZmV0eVByb3RvY29scygpOiBQcm9taXNlPEZpeGVyUmVzdWx0PiB7XG4gICAgY29uc29sZS5sb2coJ/Cfm6HvuI8gIEV4ZWN1dGluZyBFbmhhbmNlZCBFcnJvciBGaXhlciB3aXRoIHNhZmV0eSBwcm90b2NvbHMuLi4nKTtcblxuICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBzYWZldHlcbiAgICBjb25zdCBzYWZldHlDaGVjayA9IGF3YWl0IHRoaXMudmFsaWRhdGVTYWZldHkoKTtcblxuICAgIGlmICghc2FmZXR5Q2hlY2suc2FmZSkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyAgU2FmZXR5IHZhbGlkYXRpb24gZmFpbGVkOicpO1xuICAgICAgc2FmZXR5Q2hlY2suaXNzdWVzLmZvckVhY2goaXNzdWUgPT4gY29uc29sZS5sb2coYCAgIC0gJHtpc3N1ZX1gKSk7XG5cbiAgICAgIC8vIFVzZSBjb25zZXJ2YXRpdmUgc2V0dGluZ3NcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVFbmhhbmNlZEZpeGVyKHtcbiAgICAgICAgbWF4RmlsZXM6IDMsXG4gICAgICAgIGF1dG9GaXg6IGZhbHNlLCAvLyBEcnkgcnVuIG9ubHlcbiAgICAgICAgZHJ5UnVuOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNhZmV0eTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGUgd2l0aCByZWNvbW1lbmRlZCBiYXRjaCBzaXplXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZUVuaGFuY2VkRml4ZXIoe1xuICAgICAgbWF4RmlsZXM6IE1hdGgubWluKHNhZmV0eUNoZWNrLnJlY29tbWVuZGVkQmF0Y2hTaXplLCB0aGlzLkRFRkFVTFRfQkFUQ0hfU0laRSksXG4gICAgICBhdXRvRml4OiB0cnVlLFxuICAgICAgdmFsaWRhdGVTYWZldHk6IHRydWUsXG4gICAgfSk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==