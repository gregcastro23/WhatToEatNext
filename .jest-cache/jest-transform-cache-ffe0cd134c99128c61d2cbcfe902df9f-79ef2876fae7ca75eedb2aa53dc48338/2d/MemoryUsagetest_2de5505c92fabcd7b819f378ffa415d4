07732a07a42f7a265dcb8f32183a8c8e
"use strict";
/**
 * Performance Tests for Memory Usage Validation
 * Perfect Codebase Campaign - Memory Performance Testing
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ProgressTracker_1 = require("../../ProgressTracker");
const CampaignController_1 = require("../../CampaignController");
const SafetyProtocol_1 = require("../../SafetyProtocol");
const campaign_1 = require("../../../../types/campaign");
describe('Memory Usage Performance Tests', () => {
    let progressTracker;
    let campaignController;
    let safetyProtocol;
    let mockConfig;
    beforeEach(() => {
        const safetySettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7,
        };
        mockConfig = {
            phases: [
                {
                    id: 'memory-test-phase',
                    name: 'Memory Test Phase',
                    description: 'Phase for memory testing',
                    tools: [
                        {
                            scriptPath: 'scripts/memory/test-script.js',
                            parameters: { maxFiles: 100 },
                            batchSize: 100,
                            safetyLevel: campaign_1.SafetyLevel.MEDIUM,
                        },
                    ],
                    successCriteria: { buildTime: 10 },
                    safetyCheckpoints: [],
                },
            ],
            safetySettings,
            progressTargets: {
                typeScriptErrors: 0,
                lintingWarnings: 0,
                buildTime: 10,
                enterpriseSystems: 200,
            },
            toolConfiguration: {
                enhancedErrorFixer: 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js',
                explicitAnyFixer: 'scripts/typescript-fixes/fix-explicit-any-systematic.js',
                unusedVariablesFixer: 'scripts/typescript-fixes/fix-unused-variables-enhanced.js',
                consoleStatementFixer: 'scripts/lint-fixes/fix-console-statements-only.js',
            },
        };
        progressTracker = new ProgressTracker_1.ProgressTracker();
        campaignController = new CampaignController_1.CampaignController(mockConfig);
        safetyProtocol = new SafetyProtocol_1.SafetyProtocol(safetySettings);
        // Reset mocks
        jest.clearAllMocks();
    });
    describe('Memory Usage Monitoring', () => {
        it('should track memory usage under 50MB target', async () => {
            const originalMemoryUsage = process.memoryUsage;
            process.memoryUsage = jest.fn().mockReturnValue({
                heapUsed: 40 * 1024 * 1024,
                heapTotal: 80 * 1024 * 1024,
                external: 5 * 1024 * 1024,
                rss: 100 * 1024 * 1024,
                arrayBuffers: 2 * 1024 * 1024,
            });
            const memoryUsage = await progressTracker.getMemoryUsage();
            expect(memoryUsage).toBe(40);
            expect(memoryUsage).toBeLessThan(50); // Under target
            process.memoryUsage = originalMemoryUsage;
        });
        it('should detect memory usage spikes', async () => {
            const originalMemoryUsage = process.memoryUsage;
            process.memoryUsage = jest.fn().mockReturnValue({
                heapUsed: 75 * 1024 * 1024,
                heapTotal: 150 * 1024 * 1024,
                external: 10 * 1024 * 1024,
                rss: 200 * 1024 * 1024,
                arrayBuffers: 5 * 1024 * 1024,
            });
            const memoryUsage = await progressTracker.getMemoryUsage();
            expect(memoryUsage).toBe(75);
            expect(memoryUsage).toBeGreaterThan(50); // Exceeds target
            process.memoryUsage = originalMemoryUsage;
        });
        it('should handle memory measurement errors gracefully', async () => {
            const originalMemoryUsage = process.memoryUsage;
            process.memoryUsage = jest.fn().mockImplementation(() => {
                throw new Error('Memory measurement failed');
            });
            const memoryUsage = await progressTracker.getMemoryUsage();
            expect(memoryUsage).toBe(0); // Error handling returns 0
            process.memoryUsage = originalMemoryUsage;
        });
        it('should track memory usage trends over time', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const memoryReadings = [];
            let callCount = 0;
            process.memoryUsage = jest.fn().mockImplementation(() => {
                callCount++;
                // Simulate memory usage that increases then decreases (garbage collection)
                const baseMemory = 30;
                const variation = Math.sin(callCount * 0.5) * 10; // ±10MB variation
                const heapUsed = (baseMemory + variation) * 1024 * 1024;
                return {
                    heapUsed,
                    heapTotal: heapUsed * 2,
                    external: 5 * 1024 * 1024,
                    rss: heapUsed * 1.5,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Collect multiple memory readings
            for (let i = 0; i < 10; i++) {
                const memoryUsage = await progressTracker.getMemoryUsage();
                memoryReadings.push(memoryUsage);
            }
            expect(memoryReadings.length).toBe(10);
            expect(memoryReadings.every(reading => reading > 0)).toBe(true);
            // Memory should vary but stay within reasonable bounds
            const maxMemory = Math.max(...memoryReadings);
            const minMemory = Math.min(...memoryReadings);
            expect(maxMemory).toBeLessThan(50); // Should stay under target
            expect(minMemory).toBeGreaterThan(15); // Should have reasonable minimum
            process.memoryUsage = originalMemoryUsage;
        });
    });
    describe('Memory Leak Detection', () => {
        it('should detect potential memory leaks in progress tracking', async () => {
            const originalMemoryUsage = process.memoryUsage;
            let simulatedMemoryLeak = 30; // Start at 30MB
            process.memoryUsage = jest.fn().mockImplementation(() => {
                // Simulate memory leak - memory increases with each call
                simulatedMemoryLeak += 2; // 2MB increase per call
                return {
                    heapUsed: simulatedMemoryLeak * 1024 * 1024,
                    heapTotal: simulatedMemoryLeak * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: simulatedMemoryLeak * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            const memoryReadings = [];
            // Simulate multiple operations that could cause memory leaks
            for (let i = 0; i < 15; i++) {
                const memoryUsage = await progressTracker.getMemoryUsage();
                memoryReadings.push(memoryUsage);
            }
            // Should detect increasing memory usage pattern
            const firstReading = memoryReadings[0];
            const lastReading = memoryReadings[memoryReadings.length - 1];
            expect(lastReading).toBeGreaterThan(firstReading);
            expect(lastReading).toBeGreaterThan(50); // Should exceed target, indicating leak
            process.memoryUsage = originalMemoryUsage;
        });
        it('should validate memory cleanup in safety protocol', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const memoryUsage = 35; // Start at 35MB
            process.memoryUsage = jest.fn().mockImplementation(() => {
                return {
                    heapUsed: memoryUsage * 1024 * 1024,
                    heapTotal: memoryUsage * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: memoryUsage * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Create many safety events to test memory management
            for (let i = 0; i < 1100; i++) {
                safetyProtocol.addSafetyEvent({
                    type: 'CHECKPOINT_CREATED',
                    timestamp: new Date(),
                    description: `Event ${i}`,
                    severity: 'INFO',
                    action: 'TEST',
                });
            }
            const events = safetyProtocol.getSafetyEvents();
            // Should limit events to prevent memory issues
            expect(events.length).toBe(500); // Should be trimmed
            // Memory should remain stable
            const finalMemoryUsage = await progressTracker.getMemoryUsage();
            expect(finalMemoryUsage).toBeLessThan(50);
            process.memoryUsage = originalMemoryUsage;
        });
        it('should validate memory cleanup in progress tracker', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const memoryUsage = 30; // Start at 30MB
            process.memoryUsage = jest.fn().mockImplementation(() => {
                return {
                    heapUsed: memoryUsage * 1024 * 1024,
                    heapTotal: memoryUsage * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: memoryUsage * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Mock progress metrics to create history
            jest
                .spyOn(progressTracker, 'getProgressMetrics')
                .mockImplementation(async () => {
                return {
                    typeScriptErrors: {
                        current: 86,
                        target: 0,
                        reduction: 0,
                        percentage: 0,
                    },
                    lintingWarnings: {
                        current: 4506,
                        target: 0,
                        reduction: 0,
                        percentage: 0,
                    },
                    buildPerformance: {
                        currentTime: 8.5,
                        targetTime: 10,
                        cacheHitRate: 0.8,
                        memoryUsage: memoryUsage,
                    },
                    enterpriseSystems: {
                        current: 0,
                        target: 200,
                        transformedExports: 0,
                    },
                };
            });
            // Generate large metrics history
            for (let i = 0; i < 110; i++) {
                await progressTracker.getProgressMetrics();
            }
            const history = progressTracker.getMetricsHistory();
            // Should limit history to prevent memory issues
            expect(history.length).toBe(50); // Should be trimmed
            // Memory should remain stable
            const finalMemoryUsage = await progressTracker.getMemoryUsage();
            expect(finalMemoryUsage).toBeLessThan(50);
            process.memoryUsage = originalMemoryUsage;
        });
    });
    describe('Memory Efficiency Testing', () => {
        it('should efficiently handle large file processing', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const baseMemory = 35;
            process.memoryUsage = jest.fn().mockImplementation(() => {
                // Memory should not increase significantly with large file counts
                const memoryIncrease = Math.min(10, Math.random() * 5); // Max 10MB increase
                return {
                    heapUsed: (baseMemory + memoryIncrease) * 1024 * 1024,
                    heapTotal: (baseMemory + memoryIncrease) * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: (baseMemory + memoryIncrease) * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Simulate processing large number of files
            const largeFileList = Array.from({ length: 1000 }, (_, i) => `file${i}.ts`);
            // Mock campaign execution with large file processing
            jest.spyOn(campaignController, 'executeTool').mockResolvedValue({
                filesProcessed: largeFileList,
                changesApplied: largeFileList.length,
                success: true,
            });
            const phase = mockConfig.phases[0];
            const result = await campaignController.executePhase(phase);
            expect(result.success).toBe(true);
            expect(result.filesProcessed).toBe(1000);
            // Memory should remain efficient even with large file processing
            const memoryUsage = await progressTracker.getMemoryUsage();
            expect(memoryUsage).toBeLessThan(50);
            process.memoryUsage = originalMemoryUsage;
        });
        it('should efficiently manage concurrent operations', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const baseMemory = 30;
            process.memoryUsage = jest.fn().mockImplementation(() => {
                // Memory should remain stable during concurrent operations
                const variation = Math.random() * 5; // ±5MB variation
                return {
                    heapUsed: (baseMemory + variation) * 1024 * 1024,
                    heapTotal: (baseMemory + variation) * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: (baseMemory + variation) * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Run multiple concurrent operations
            const promises = Array.from({ length: 10 }, async () => {
                return Promise.all([
                    progressTracker.getMemoryUsage(),
                    progressTracker.getProgressMetrics(),
                    safetyProtocol.validateGitState(),
                ]);
            });
            const results = await Promise.all(promises);
            expect(results.length).toBe(10);
            expect(results.every(result => result.length === 3)).toBe(true);
            // Memory should remain stable
            const finalMemoryUsage = await progressTracker.getMemoryUsage();
            expect(finalMemoryUsage).toBeLessThan(50);
            process.memoryUsage = originalMemoryUsage;
        });
        it('should handle memory pressure gracefully', async () => {
            const originalMemoryUsage = process.memoryUsage;
            let memoryPressure = false;
            process.memoryUsage = jest.fn().mockImplementation(() => {
                // Simulate memory pressure scenario
                const baseMemory = memoryPressure ? 48 : 35; // High memory when under pressure
                return {
                    heapUsed: baseMemory * 1024 * 1024,
                    heapTotal: baseMemory * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: baseMemory * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Normal operation
            let memoryUsage = await progressTracker.getMemoryUsage();
            expect(memoryUsage).toBe(35);
            // Simulate memory pressure
            memoryPressure = true;
            memoryUsage = await progressTracker.getMemoryUsage();
            expect(memoryUsage).toBe(48);
            expect(memoryUsage).toBeLessThan(50); // Still under target
            // System should handle pressure gracefully
            const metrics = await progressTracker.getProgressMetrics();
            expect(metrics).toBeDefined();
            expect(metrics.buildPerformance.memoryUsage).toBe(48);
            process.memoryUsage = originalMemoryUsage;
        });
    });
    describe('Memory Performance Benchmarks', () => {
        it('should benchmark memory allocation patterns', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const memorySnapshots = [];
            let allocationCount = 0;
            process.memoryUsage = jest.fn().mockImplementation(() => {
                allocationCount++;
                // Simulate realistic memory allocation pattern
                const baseMemory = 30;
                const cyclicPattern = Math.sin(allocationCount * 0.3) * 8; // ±8MB cyclic pattern
                const growthTrend = allocationCount * 0.1; // Slight growth trend
                const totalMemory = baseMemory + cyclicPattern + growthTrend;
                return {
                    heapUsed: totalMemory * 1024 * 1024,
                    heapTotal: totalMemory * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: totalMemory * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Collect memory snapshots during various operations
            for (let i = 0; i < 20; i++) {
                const memoryUsage = await progressTracker.getMemoryUsage();
                memorySnapshots.push(memoryUsage);
                // Perform some operations to trigger memory allocation
                await progressTracker.getProgressMetrics();
            }
            expect(memorySnapshots.length).toBe(20);
            // Analyze memory allocation patterns
            const maxMemory = Math.max(...memorySnapshots);
            const minMemory = Math.min(...memorySnapshots);
            const avgMemory = memorySnapshots.reduce((sum, mem) => sum + mem, 0) /
                memorySnapshots.length;
            expect(maxMemory).toBeLessThan(50); // Should stay under target
            expect(minMemory).toBeGreaterThan(20); // Should have reasonable minimum
            expect(avgMemory).toBeLessThan(45); // Average should be well under target
            // Memory variance should be reasonable
            const variance = memorySnapshots.reduce((sum, mem) => sum + Math.pow(mem - avgMemory, 2), 0) / memorySnapshots.length;
            const standardDeviation = Math.sqrt(variance);
            expect(standardDeviation).toBeLessThan(10); // Should have reasonable variance
            process.memoryUsage = originalMemoryUsage;
        });
        it('should validate memory efficiency across different operations', async () => {
            const originalMemoryUsage = process.memoryUsage;
            const operationMemoryUsage = {
                typeScriptCheck: [],
                lintingCheck: [],
                enterpriseCount: [],
                buildTime: [],
                progressMetrics: [],
            };
            let operationType = 'default';
            process.memoryUsage = jest.fn().mockImplementation(() => {
                // Different memory usage patterns for different operations
                let baseMemory = 30;
                switch (operationType) {
                    case 'typeScriptCheck':
                        baseMemory = 35; // TypeScript checking uses more memory
                        break;
                    case 'lintingCheck':
                        baseMemory = 32; // Linting uses moderate memory
                        break;
                    case 'enterpriseCount':
                        baseMemory = 28; // Simple grep uses less memory
                        break;
                    case 'buildTime':
                        baseMemory = 40; // Build process uses more memory
                        break;
                    case 'progressMetrics':
                        baseMemory = 33; // Metrics collection uses moderate memory
                        break;
                }
                return {
                    heapUsed: baseMemory * 1024 * 1024,
                    heapTotal: baseMemory * 2 * 1024 * 1024,
                    external: 5 * 1024 * 1024,
                    rss: baseMemory * 1.5 * 1024 * 1024,
                    arrayBuffers: 2 * 1024 * 1024,
                };
            });
            // Test different operations and their memory usage
            const operations = [
                {
                    name: 'typeScriptCheck',
                    fn: () => progressTracker.getTypeScriptErrorCount(),
                },
                {
                    name: 'lintingCheck',
                    fn: () => progressTracker.getLintingWarningCount(),
                },
                {
                    name: 'enterpriseCount',
                    fn: () => progressTracker.getEnterpriseSystemCount(),
                },
                { name: 'buildTime', fn: () => progressTracker.getBuildTime() },
                {
                    name: 'progressMetrics',
                    fn: () => progressTracker.getProgressMetrics(),
                },
            ];
            for (const operation of operations) {
                operationType = operation.name;
                // Run operation multiple times to get average memory usage
                for (let i = 0; i < 5; i++) {
                    await operation.fn();
                    const memoryUsage = await progressTracker.getMemoryUsage();
                    operationMemoryUsage[operation.name].push(memoryUsage);
                }
            }
            // Validate memory usage for each operation type
            for (const [opName, memoryReadings] of Object.entries(operationMemoryUsage)) {
                expect(memoryReadings.length).toBe(5);
                const avgMemory = memoryReadings.reduce((sum, mem) => sum + mem, 0) /
                    memoryReadings.length;
                expect(avgMemory).toBeLessThan(50); // All operations should stay under target
                // Memory usage should be consistent for the same operation
                const maxMemory = Math.max(...memoryReadings);
                const minMemory = Math.min(...memoryReadings);
                expect(maxMemory - minMemory).toBeLessThan(5); // Should have low variance
            }
            process.memoryUsage = originalMemoryUsage;
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9fX3Rlc3RzX18vcGVyZm9ybWFuY2UvTWVtb3J5VXNhZ2UudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOztBQUVILDJEQUF3RDtBQUN4RCxpRUFBOEQ7QUFDOUQseURBQXNEO0FBQ3RELHlEQUtvQztBQUVwQyxRQUFRLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxFQUFFO0lBQzlDLElBQUksZUFBZ0MsQ0FBQztJQUNyQyxJQUFJLGtCQUFzQyxDQUFDO0lBQzNDLElBQUksY0FBOEIsQ0FBQztJQUNuQyxJQUFJLFVBQTBCLENBQUM7SUFFL0IsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLE1BQU0sY0FBYyxHQUFtQjtZQUNyQyxnQkFBZ0IsRUFBRSxFQUFFO1lBQ3BCLHdCQUF3QixFQUFFLENBQUM7WUFDM0IsdUJBQXVCLEVBQUUsRUFBRTtZQUMzQiwwQkFBMEIsRUFBRSxJQUFJO1lBQ2hDLHdCQUF3QixFQUFFLElBQUk7WUFDOUIsa0JBQWtCLEVBQUUsQ0FBQztTQUN0QixDQUFDO1FBRUYsVUFBVSxHQUFHO1lBQ1gsTUFBTSxFQUFFO2dCQUNOO29CQUNFLEVBQUUsRUFBRSxtQkFBbUI7b0JBQ3ZCLElBQUksRUFBRSxtQkFBbUI7b0JBQ3pCLFdBQVcsRUFBRSwwQkFBMEI7b0JBQ3ZDLEtBQUssRUFBRTt3QkFDTDs0QkFDRSxVQUFVLEVBQUUsK0JBQStCOzRCQUMzQyxVQUFVLEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFOzRCQUM3QixTQUFTLEVBQUUsR0FBRzs0QkFDZCxXQUFXLEVBQUUsc0JBQVcsQ0FBQyxNQUFNO3lCQUNoQztxQkFDRjtvQkFDRCxlQUFlLEVBQUUsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFO29CQUNsQyxpQkFBaUIsRUFBRSxFQUFFO2lCQUN0QjthQUNGO1lBQ0QsY0FBYztZQUNkLGVBQWUsRUFBRTtnQkFDZixnQkFBZ0IsRUFBRSxDQUFD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LE9BQU8sQ0FBQyxXQUFXLEdBQUcsbUJBQW1CLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvc2VydmljZXMvY2FtcGFpZ24vX190ZXN0c19fL3BlcmZvcm1hbmNlL01lbW9yeVVzYWdlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBUZXN0cyBmb3IgTWVtb3J5IFVzYWdlIFZhbGlkYXRpb25cbiAqIFBlcmZlY3QgQ29kZWJhc2UgQ2FtcGFpZ24gLSBNZW1vcnkgUGVyZm9ybWFuY2UgVGVzdGluZ1xuICovXG5cbmltcG9ydCB7IFByb2dyZXNzVHJhY2tlciB9IGZyb20gJy4uLy4uL1Byb2dyZXNzVHJhY2tlcic7XG5pbXBvcnQgeyBDYW1wYWlnbkNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi9DYW1wYWlnbkNvbnRyb2xsZXInO1xuaW1wb3J0IHsgU2FmZXR5UHJvdG9jb2wgfSBmcm9tICcuLi8uLi9TYWZldHlQcm90b2NvbCc7XG5pbXBvcnQge1xuICBDYW1wYWlnbkNvbmZpZyxcbiAgU2FmZXR5U2V0dGluZ3MsXG4gIFNhZmV0eUxldmVsLFxuICBQcm9ncmVzc01ldHJpY3MsXG59IGZyb20gJy4uLy4uLy4uLy4uL3R5cGVzL2NhbXBhaWduJztcblxuZGVzY3JpYmUoJ01lbW9yeSBVc2FnZSBQZXJmb3JtYW5jZSBUZXN0cycsICgpID0+IHtcbiAgbGV0IHByb2dyZXNzVHJhY2tlcjogUHJvZ3Jlc3NUcmFja2VyO1xuICBsZXQgY2FtcGFpZ25Db250cm9sbGVyOiBDYW1wYWlnbkNvbnRyb2xsZXI7XG4gIGxldCBzYWZldHlQcm90b2NvbDogU2FmZXR5UHJvdG9jb2w7XG4gIGxldCBtb2NrQ29uZmlnOiBDYW1wYWlnbkNvbmZpZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBjb25zdCBzYWZldHlTZXR0aW5nczogU2FmZXR5U2V0dGluZ3MgPSB7XG4gICAgICBtYXhGaWxlc1BlckJhdGNoOiAyNSxcbiAgICAgIGJ1aWxkVmFsaWRhdGlvbkZyZXF1ZW5jeTogNSxcbiAgICAgIHRlc3RWYWxpZGF0aW9uRnJlcXVlbmN5OiAxMCxcbiAgICAgIGNvcnJ1cHRpb25EZXRlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgYXV0b21hdGljUm9sbGJhY2tFbmFibGVkOiB0cnVlLFxuICAgICAgc3Rhc2hSZXRlbnRpb25EYXlzOiA3LFxuICAgIH07XG5cbiAgICBtb2NrQ29uZmlnID0ge1xuICAgICAgcGhhc2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ21lbW9yeS10ZXN0LXBoYXNlJyxcbiAgICAgICAgICBuYW1lOiAnTWVtb3J5IFRlc3QgUGhhc2UnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUGhhc2UgZm9yIG1lbW9yeSB0ZXN0aW5nJyxcbiAgICAgICAgICB0b29sczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzY3JpcHRQYXRoOiAnc2NyaXB0cy9tZW1vcnkvdGVzdC1zY3JpcHQuanMnLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7IG1heEZpbGVzOiAxMDAgfSxcbiAgICAgICAgICAgICAgYmF0Y2hTaXplOiAxMDAsXG4gICAgICAgICAgICAgIHNhZmV0eUxldmVsOiBTYWZldHlMZXZlbC5NRURJVU0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgc3VjY2Vzc0NyaXRlcmlhOiB7IGJ1aWxkVGltZTogMTAgfSxcbiAgICAgICAgICBzYWZldHlDaGVja3BvaW50czogW10sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgc2FmZXR5U2V0dGluZ3MsXG4gICAgICBwcm9ncmVzc1RhcmdldHM6IHtcbiAgICAgICAgdHlwZVNjcmlwdEVycm9yczogMCxcbiAgICAgICAgbGludGluZ1dhcm5pbmdzOiAwLFxuICAgICAgICBidWlsZFRpbWU6IDEwLFxuICAgICAgICBlbnRlcnByaXNlU3lzdGVtczogMjAwLFxuICAgICAgfSxcbiAgICAgIHRvb2xDb25maWd1cmF0aW9uOiB7XG4gICAgICAgIGVuaGFuY2VkRXJyb3JGaXhlcjpcbiAgICAgICAgICAnc2NyaXB0cy90eXBlc2NyaXB0LWZpeGVzL2ZpeC10eXBlc2NyaXB0LWVycm9ycy1lbmhhbmNlZC12My5qcycsXG4gICAgICAgIGV4cGxpY2l0QW55Rml4ZXI6XG4gICAgICAgICAgJ3NjcmlwdHMvdHlwZXNjcmlwdC1maXhlcy9maXgtZXhwbGljaXQtYW55LXN5c3RlbWF0aWMuanMnLFxuICAgICAgICB1bnVzZWRWYXJpYWJsZXNGaXhlcjpcbiAgICAgICAgICAnc2NyaXB0cy90eXBlc2NyaXB0LWZpeGVzL2ZpeC11bnVzZWQtdmFyaWFibGVzLWVuaGFuY2VkLmpzJyxcbiAgICAgICAgY29uc29sZVN0YXRlbWVudEZpeGVyOlxuICAgICAgICAgICdzY3JpcHRzL2xpbnQtZml4ZXMvZml4LWNvbnNvbGUtc3RhdGVtZW50cy1vbmx5LmpzJyxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHByb2dyZXNzVHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoKTtcbiAgICBjYW1wYWlnbkNvbnRyb2xsZXIgPSBuZXcgQ2FtcGFpZ25Db250cm9sbGVyKG1vY2tDb25maWcpO1xuICAgIHNhZmV0eVByb3RvY29sID0gbmV3IFNhZmV0eVByb3RvY29sKHNhZmV0eVNldHRpbmdzKTtcblxuICAgIC8vIFJlc2V0IG1vY2tzXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgVXNhZ2UgTW9uaXRvcmluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRyYWNrIG1lbW9yeSB1c2FnZSB1bmRlciA1ME1CIHRhcmdldCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlO1xuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBoZWFwVXNlZDogNDAgKiAxMDI0ICogMTAyNCwgLy8gNDBNQlxuICAgICAgICBoZWFwVG90YWw6IDgwICogMTAyNCAqIDEwMjQsXG4gICAgICAgIGV4dGVybmFsOiA1ICogMTAyNCAqIDEwMjQsXG4gICAgICAgIHJzczogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICAgIGFycmF5QnVmZmVyczogMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldE1lbW9yeVVzYWdlKCk7XG5cbiAgICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZSg0MCk7XG4gICAgICBleHBlY3QobWVtb3J5VXNhZ2UpLnRvQmVMZXNzVGhhbig1MCk7IC8vIFVuZGVyIHRhcmdldFxuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gb3JpZ2luYWxNZW1vcnlVc2FnZTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IG1lbW9yeSB1c2FnZSBzcGlrZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1lbW9yeVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZTtcbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgaGVhcFVzZWQ6IDc1ICogMTAyNCAqIDEwMjQsIC8vIDc1TUIgLSBleGNlZWRzIHRhcmdldFxuICAgICAgICBoZWFwVG90YWw6IDE1MCAqIDEwMjQgKiAxMDI0LFxuICAgICAgICBleHRlcm5hbDogMTAgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgcnNzOiAyMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgYXJyYXlCdWZmZXJzOiA1ICogMTAyNCAqIDEwMjQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0TWVtb3J5VXNhZ2UoKTtcblxuICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlKS50b0JlKDc1KTtcbiAgICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZUdyZWF0ZXJUaGFuKDUwKTsgLy8gRXhjZWVkcyB0YXJnZXRcblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IG9yaWdpbmFsTWVtb3J5VXNhZ2U7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtZW1vcnkgbWVhc3VyZW1lbnQgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1lbW9yeVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZTtcbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZW1vcnkgbWVhc3VyZW1lbnQgZmFpbGVkJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0TWVtb3J5VXNhZ2UoKTtcblxuICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlKS50b0JlKDApOyAvLyBFcnJvciBoYW5kbGluZyByZXR1cm5zIDBcblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IG9yaWdpbmFsTWVtb3J5VXNhZ2U7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRyYWNrIG1lbW9yeSB1c2FnZSB0cmVuZHMgb3ZlciB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2U7XG4gICAgICBjb25zdCBtZW1vcnlSZWFkaW5nczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICAvLyBTaW11bGF0ZSBtZW1vcnkgdXNhZ2UgdGhhdCBpbmNyZWFzZXMgdGhlbiBkZWNyZWFzZXMgKGdhcmJhZ2UgY29sbGVjdGlvbilcbiAgICAgICAgY29uc3QgYmFzZU1lbW9yeSA9IDMwO1xuICAgICAgICBjb25zdCB2YXJpYXRpb24gPSBNYXRoLnNpbihjYWxsQ291bnQgKiAwLjUpICogMTA7IC8vIMKxMTBNQiB2YXJpYXRpb25cbiAgICAgICAgY29uc3QgaGVhcFVzZWQgPSAoYmFzZU1lbW9yeSArIHZhcmlhdGlvbikgKiAxMDI0ICogMTAyNDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYXBVc2VkLFxuICAgICAgICAgIGhlYXBUb3RhbDogaGVhcFVzZWQgKiAyLFxuICAgICAgICAgIGV4dGVybmFsOiA1ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgcnNzOiBoZWFwVXNlZCAqIDEuNSxcbiAgICAgICAgICBhcnJheUJ1ZmZlcnM6IDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDb2xsZWN0IG11bHRpcGxlIG1lbW9yeSByZWFkaW5nc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldE1lbW9yeVVzYWdlKCk7XG4gICAgICAgIG1lbW9yeVJlYWRpbmdzLnB1c2gobWVtb3J5VXNhZ2UpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QobWVtb3J5UmVhZGluZ3MubGVuZ3RoKS50b0JlKDEwKTtcbiAgICAgIGV4cGVjdChtZW1vcnlSZWFkaW5ncy5ldmVyeShyZWFkaW5nID0+IHJlYWRpbmcgPiAwKSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gTWVtb3J5IHNob3VsZCB2YXJ5IGJ1dCBzdGF5IHdpdGhpbiByZWFzb25hYmxlIGJvdW5kc1xuICAgICAgY29uc3QgbWF4TWVtb3J5ID0gTWF0aC5tYXgoLi4ubWVtb3J5UmVhZGluZ3MpO1xuICAgICAgY29uc3QgbWluTWVtb3J5ID0gTWF0aC5taW4oLi4ubWVtb3J5UmVhZGluZ3MpO1xuICAgICAgZXhwZWN0KG1heE1lbW9yeSkudG9CZUxlc3NUaGFuKDUwKTsgLy8gU2hvdWxkIHN0YXkgdW5kZXIgdGFyZ2V0XG4gICAgICBleHBlY3QobWluTWVtb3J5KS50b0JlR3JlYXRlclRoYW4oMTUpOyAvLyBTaG91bGQgaGF2ZSByZWFzb25hYmxlIG1pbmltdW1cblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IG9yaWdpbmFsTWVtb3J5VXNhZ2U7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTGVhayBEZXRlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgcG90ZW50aWFsIG1lbW9yeSBsZWFrcyBpbiBwcm9ncmVzcyB0cmFja2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlO1xuICAgICAgbGV0IHNpbXVsYXRlZE1lbW9yeUxlYWsgPSAzMDsgLy8gU3RhcnQgYXQgMzBNQlxuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIC8vIFNpbXVsYXRlIG1lbW9yeSBsZWFrIC0gbWVtb3J5IGluY3JlYXNlcyB3aXRoIGVhY2ggY2FsbFxuICAgICAgICBzaW11bGF0ZWRNZW1vcnlMZWFrICs9IDI7IC8vIDJNQiBpbmNyZWFzZSBwZXIgY2FsbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYXBVc2VkOiBzaW11bGF0ZWRNZW1vcnlMZWFrICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgaGVhcFRvdGFsOiBzaW11bGF0ZWRNZW1vcnlMZWFrICogMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGV4dGVybmFsOiA1ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgcnNzOiBzaW11bGF0ZWRNZW1vcnlMZWFrICogMS41ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgYXJyYXlCdWZmZXJzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVtb3J5UmVhZGluZ3M6IG51bWJlcltdID0gW107XG5cbiAgICAgIC8vIFNpbXVsYXRlIG11bHRpcGxlIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCBjYXVzZSBtZW1vcnkgbGVha3NcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRNZW1vcnlVc2FnZSgpO1xuICAgICAgICBtZW1vcnlSZWFkaW5ncy5wdXNoKG1lbW9yeVVzYWdlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIGRldGVjdCBpbmNyZWFzaW5nIG1lbW9yeSB1c2FnZSBwYXR0ZXJuXG4gICAgICBjb25zdCBmaXJzdFJlYWRpbmcgPSBtZW1vcnlSZWFkaW5nc1swXTtcbiAgICAgIGNvbnN0IGxhc3RSZWFkaW5nID0gbWVtb3J5UmVhZGluZ3NbbWVtb3J5UmVhZGluZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAgIGV4cGVjdChsYXN0UmVhZGluZykudG9CZUdyZWF0ZXJUaGFuKGZpcnN0UmVhZGluZyk7XG4gICAgICBleHBlY3QobGFzdFJlYWRpbmcpLnRvQmVHcmVhdGVyVGhhbig1MCk7IC8vIFNob3VsZCBleGNlZWQgdGFyZ2V0LCBpbmRpY2F0aW5nIGxlYWtcblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IG9yaWdpbmFsTWVtb3J5VXNhZ2U7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIG1lbW9yeSBjbGVhbnVwIGluIHNhZmV0eSBwcm90b2NvbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlO1xuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSAzNTsgLy8gU3RhcnQgYXQgMzVNQlxuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhcFVzZWQ6IG1lbW9yeVVzYWdlICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgaGVhcFRvdGFsOiBtZW1vcnlVc2FnZSAqIDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBleHRlcm5hbDogNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIHJzczogbWVtb3J5VXNhZ2UgKiAxLjUgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBhcnJheUJ1ZmZlcnM6IDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgbWFueSBzYWZldHkgZXZlbnRzIHRvIHRlc3QgbWVtb3J5IG1hbmFnZW1lbnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTEwMDsgaSsrKSB7XG4gICAgICAgIChzYWZldHlQcm90b2NvbCBhcyBhbnkpLmFkZFNhZmV0eUV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnQ0hFQ0tQT0lOVF9DUkVBVEVEJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBFdmVudCAke2l9YCxcbiAgICAgICAgICBzZXZlcml0eTogJ0lORk8nLFxuICAgICAgICAgIGFjdGlvbjogJ1RFU1QnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXZlbnRzID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG5cbiAgICAgIC8vIFNob3VsZCBsaW1pdCBldmVudHMgdG8gcHJldmVudCBtZW1vcnkgaXNzdWVzXG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZSg1MDApOyAvLyBTaG91bGQgYmUgdHJpbW1lZFxuXG4gICAgICAvLyBNZW1vcnkgc2hvdWxkIHJlbWFpbiBzdGFibGVcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5VXNhZ2UgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0TWVtb3J5VXNhZ2UoKTtcbiAgICAgIGV4cGVjdChmaW5hbE1lbW9yeVVzYWdlKS50b0JlTGVzc1RoYW4oNTApO1xuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gb3JpZ2luYWxNZW1vcnlVc2FnZTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgbWVtb3J5IGNsZWFudXAgaW4gcHJvZ3Jlc3MgdHJhY2tlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlO1xuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSAzMDsgLy8gU3RhcnQgYXQgMzBNQlxuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhcFVzZWQ6IG1lbW9yeVVzYWdlICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgaGVhcFRvdGFsOiBtZW1vcnlVc2FnZSAqIDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBleHRlcm5hbDogNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIHJzczogbWVtb3J5VXNhZ2UgKiAxLjUgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBhcnJheUJ1ZmZlcnM6IDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIHByb2dyZXNzIG1ldHJpY3MgdG8gY3JlYXRlIGhpc3RvcnlcbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldFByb2dyZXNzTWV0cmljcycpXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlU2NyaXB0RXJyb3JzOiB7XG4gICAgICAgICAgICAgIGN1cnJlbnQ6IDg2LFxuICAgICAgICAgICAgICB0YXJnZXQ6IDAsXG4gICAgICAgICAgICAgIHJlZHVjdGlvbjogMCxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW50aW5nV2FybmluZ3M6IHtcbiAgICAgICAgICAgICAgY3VycmVudDogNDUwNixcbiAgICAgICAgICAgICAgdGFyZ2V0OiAwLFxuICAgICAgICAgICAgICByZWR1Y3Rpb246IDAsXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnVpbGRQZXJmb3JtYW5jZToge1xuICAgICAgICAgICAgICBjdXJyZW50VGltZTogOC41LFxuICAgICAgICAgICAgICB0YXJnZXRUaW1lOiAxMCxcbiAgICAgICAgICAgICAgY2FjaGVIaXRSYXRlOiAwLjgsXG4gICAgICAgICAgICAgIG1lbW9yeVVzYWdlOiBtZW1vcnlVc2FnZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRlcnByaXNlU3lzdGVtczoge1xuICAgICAgICAgICAgICBjdXJyZW50OiAwLFxuICAgICAgICAgICAgICB0YXJnZXQ6IDIwMCxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtZWRFeHBvcnRzOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgbGFyZ2UgbWV0cmljcyBoaXN0b3J5XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDExMDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRQcm9ncmVzc01ldHJpY3MoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGlzdG9yeSA9IHByb2dyZXNzVHJhY2tlci5nZXRNZXRyaWNzSGlzdG9yeSgpO1xuXG4gICAgICAvLyBTaG91bGQgbGltaXQgaGlzdG9yeSB0byBwcmV2ZW50IG1lbW9yeSBpc3N1ZXNcbiAgICAgIGV4cGVjdChoaXN0b3J5Lmxlbmd0aCkudG9CZSg1MCk7IC8vIFNob3VsZCBiZSB0cmltbWVkXG5cbiAgICAgIC8vIE1lbW9yeSBzaG91bGQgcmVtYWluIHN0YWJsZVxuICAgICAgY29uc3QgZmluYWxNZW1vcnlVc2FnZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRNZW1vcnlVc2FnZSgpO1xuICAgICAgZXhwZWN0KGZpbmFsTWVtb3J5VXNhZ2UpLnRvQmVMZXNzVGhhbig1MCk7XG5cbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBvcmlnaW5hbE1lbW9yeVVzYWdlO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IEVmZmljaWVuY3kgVGVzdGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVmZmljaWVudGx5IGhhbmRsZSBsYXJnZSBmaWxlIHByb2Nlc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1lbW9yeVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZTtcbiAgICAgIGNvbnN0IGJhc2VNZW1vcnkgPSAzNTtcblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAvLyBNZW1vcnkgc2hvdWxkIG5vdCBpbmNyZWFzZSBzaWduaWZpY2FudGx5IHdpdGggbGFyZ2UgZmlsZSBjb3VudHNcbiAgICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBNYXRoLm1pbigxMCwgTWF0aC5yYW5kb20oKSAqIDUpOyAvLyBNYXggMTBNQiBpbmNyZWFzZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYXBVc2VkOiAoYmFzZU1lbW9yeSArIG1lbW9yeUluY3JlYXNlKSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGhlYXBUb3RhbDogKGJhc2VNZW1vcnkgKyBtZW1vcnlJbmNyZWFzZSkgKiAyICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgZXh0ZXJuYWw6IDUgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICByc3M6IChiYXNlTWVtb3J5ICsgbWVtb3J5SW5jcmVhc2UpICogMS41ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgYXJyYXlCdWZmZXJzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gU2ltdWxhdGUgcHJvY2Vzc2luZyBsYXJnZSBudW1iZXIgb2YgZmlsZXNcbiAgICAgIGNvbnN0IGxhcmdlRmlsZUxpc3QgPSBBcnJheS5mcm9tKFxuICAgICAgICB7IGxlbmd0aDogMTAwMCB9LFxuICAgICAgICAoXywgaSkgPT4gYGZpbGUke2l9LnRzYFxuICAgICAgKTtcblxuICAgICAgLy8gTW9jayBjYW1wYWlnbiBleGVjdXRpb24gd2l0aCBsYXJnZSBmaWxlIHByb2Nlc3NpbmdcbiAgICAgIGplc3Quc3B5T24oY2FtcGFpZ25Db250cm9sbGVyIGFzIGFueSwgJ2V4ZWN1dGVUb29sJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogbGFyZ2VGaWxlTGlzdCxcbiAgICAgICAgY2hhbmdlc0FwcGxpZWQ6IGxhcmdlRmlsZUxpc3QubGVuZ3RoLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBoYXNlID0gbW9ja0NvbmZpZy5waGFzZXNbMF07XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYW1wYWlnbkNvbnRyb2xsZXIuZXhlY3V0ZVBoYXNlKHBoYXNlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5maWxlc1Byb2Nlc3NlZCkudG9CZSgxMDAwKTtcblxuICAgICAgLy8gTWVtb3J5IHNob3VsZCByZW1haW4gZWZmaWNpZW50IGV2ZW4gd2l0aCBsYXJnZSBmaWxlIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldE1lbW9yeVVzYWdlKCk7XG4gICAgICBleHBlY3QobWVtb3J5VXNhZ2UpLnRvQmVMZXNzVGhhbig1MCk7XG5cbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBvcmlnaW5hbE1lbW9yeVVzYWdlO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlZmZpY2llbnRseSBtYW5hZ2UgY29uY3VycmVudCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2U7XG4gICAgICBjb25zdCBiYXNlTWVtb3J5ID0gMzA7XG5cbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgLy8gTWVtb3J5IHNob3VsZCByZW1haW4gc3RhYmxlIGR1cmluZyBjb25jdXJyZW50IG9wZXJhdGlvbnNcbiAgICAgICAgY29uc3QgdmFyaWF0aW9uID0gTWF0aC5yYW5kb20oKSAqIDU7IC8vIMKxNU1CIHZhcmlhdGlvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYXBVc2VkOiAoYmFzZU1lbW9yeSArIHZhcmlhdGlvbikgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBoZWFwVG90YWw6IChiYXNlTWVtb3J5ICsgdmFyaWF0aW9uKSAqIDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBleHRlcm5hbDogNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIHJzczogKGJhc2VNZW1vcnkgKyB2YXJpYXRpb24pICogMS41ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgYXJyYXlCdWZmZXJzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gUnVuIG11bHRpcGxlIGNvbmN1cnJlbnQgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgcHJvZ3Jlc3NUcmFja2VyLmdldE1lbW9yeVVzYWdlKCksXG4gICAgICAgICAgcHJvZ3Jlc3NUcmFja2VyLmdldFByb2dyZXNzTWV0cmljcygpLFxuICAgICAgICAgIHNhZmV0eVByb3RvY29sLnZhbGlkYXRlR2l0U3RhdGUoKSxcbiAgICAgICAgXSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlKDEwKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQubGVuZ3RoID09PSAzKSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gTWVtb3J5IHNob3VsZCByZW1haW4gc3RhYmxlXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeVVzYWdlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldE1lbW9yeVVzYWdlKCk7XG4gICAgICBleHBlY3QoZmluYWxNZW1vcnlVc2FnZSkudG9CZUxlc3NUaGFuKDUwKTtcblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IG9yaWdpbmFsTWVtb3J5VXNhZ2U7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtZW1vcnkgcHJlc3N1cmUgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlO1xuICAgICAgbGV0IG1lbW9yeVByZXNzdXJlID0gZmFsc2U7XG5cbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgLy8gU2ltdWxhdGUgbWVtb3J5IHByZXNzdXJlIHNjZW5hcmlvXG4gICAgICAgIGNvbnN0IGJhc2VNZW1vcnkgPSBtZW1vcnlQcmVzc3VyZSA/IDQ4IDogMzU7IC8vIEhpZ2ggbWVtb3J5IHdoZW4gdW5kZXIgcHJlc3N1cmVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWFwVXNlZDogYmFzZU1lbW9yeSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGhlYXBUb3RhbDogYmFzZU1lbW9yeSAqIDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBleHRlcm5hbDogNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIHJzczogYmFzZU1lbW9yeSAqIDEuNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGFycmF5QnVmZmVyczogMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE5vcm1hbCBvcGVyYXRpb25cbiAgICAgIGxldCBtZW1vcnlVc2FnZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRNZW1vcnlVc2FnZSgpO1xuICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlKS50b0JlKDM1KTtcblxuICAgICAgLy8gU2ltdWxhdGUgbWVtb3J5IHByZXNzdXJlXG4gICAgICBtZW1vcnlQcmVzc3VyZSA9IHRydWU7XG4gICAgICBtZW1vcnlVc2FnZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRNZW1vcnlVc2FnZSgpO1xuICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlKS50b0JlKDQ4KTtcbiAgICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZUxlc3NUaGFuKDUwKTsgLy8gU3RpbGwgdW5kZXIgdGFyZ2V0XG5cbiAgICAgIC8vIFN5c3RlbSBzaG91bGQgaGFuZGxlIHByZXNzdXJlIGdyYWNlZnVsbHlcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0UHJvZ3Jlc3NNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmJ1aWxkUGVyZm9ybWFuY2UubWVtb3J5VXNhZ2UpLnRvQmUoNDgpO1xuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gb3JpZ2luYWxNZW1vcnlVc2FnZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01lbW9yeSBQZXJmb3JtYW5jZSBCZW5jaG1hcmtzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYmVuY2htYXJrIG1lbW9yeSBhbGxvY2F0aW9uIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2U7XG4gICAgICBjb25zdCBtZW1vcnlTbmFwc2hvdHM6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgYWxsb2NhdGlvbkNvdW50ID0gMDtcblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBhbGxvY2F0aW9uQ291bnQrKztcbiAgICAgICAgLy8gU2ltdWxhdGUgcmVhbGlzdGljIG1lbW9yeSBhbGxvY2F0aW9uIHBhdHRlcm5cbiAgICAgICAgY29uc3QgYmFzZU1lbW9yeSA9IDMwO1xuICAgICAgICBjb25zdCBjeWNsaWNQYXR0ZXJuID0gTWF0aC5zaW4oYWxsb2NhdGlvbkNvdW50ICogMC4zKSAqIDg7IC8vIMKxOE1CIGN5Y2xpYyBwYXR0ZXJuXG4gICAgICAgIGNvbnN0IGdyb3d0aFRyZW5kID0gYWxsb2NhdGlvbkNvdW50ICogMC4xOyAvLyBTbGlnaHQgZ3Jvd3RoIHRyZW5kXG4gICAgICAgIGNvbnN0IHRvdGFsTWVtb3J5ID0gYmFzZU1lbW9yeSArIGN5Y2xpY1BhdHRlcm4gKyBncm93dGhUcmVuZDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYXBVc2VkOiB0b3RhbE1lbW9yeSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGhlYXBUb3RhbDogdG90YWxNZW1vcnkgKiAyICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgZXh0ZXJuYWw6IDUgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICByc3M6IHRvdGFsTWVtb3J5ICogMS41ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgYXJyYXlCdWZmZXJzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gQ29sbGVjdCBtZW1vcnkgc25hcHNob3RzIGR1cmluZyB2YXJpb3VzIG9wZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRNZW1vcnlVc2FnZSgpO1xuICAgICAgICBtZW1vcnlTbmFwc2hvdHMucHVzaChtZW1vcnlVc2FnZSk7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBzb21lIG9wZXJhdGlvbnMgdG8gdHJpZ2dlciBtZW1vcnkgYWxsb2NhdGlvblxuICAgICAgICBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0UHJvZ3Jlc3NNZXRyaWNzKCk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtZW1vcnlTbmFwc2hvdHMubGVuZ3RoKS50b0JlKDIwKTtcblxuICAgICAgLy8gQW5hbHl6ZSBtZW1vcnkgYWxsb2NhdGlvbiBwYXR0ZXJuc1xuICAgICAgY29uc3QgbWF4TWVtb3J5ID0gTWF0aC5tYXgoLi4ubWVtb3J5U25hcHNob3RzKTtcbiAgICAgIGNvbnN0IG1pbk1lbW9yeSA9IE1hdGgubWluKC4uLm1lbW9yeVNuYXBzaG90cyk7XG4gICAgICBjb25zdCBhdmdNZW1vcnkgPVxuICAgICAgICBtZW1vcnlTbmFwc2hvdHMucmVkdWNlKChzdW0sIG1lbSkgPT4gc3VtICsgbWVtLCAwKSAvXG4gICAgICAgIG1lbW9yeVNuYXBzaG90cy5sZW5ndGg7XG5cbiAgICAgIGV4cGVjdChtYXhNZW1vcnkpLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBzdGF5IHVuZGVyIHRhcmdldFxuICAgICAgZXhwZWN0KG1pbk1lbW9yeSkudG9CZUdyZWF0ZXJUaGFuKDIwKTsgLy8gU2hvdWxkIGhhdmUgcmVhc29uYWJsZSBtaW5pbXVtXG4gICAgICBleHBlY3QoYXZnTWVtb3J5KS50b0JlTGVzc1RoYW4oNDUpOyAvLyBBdmVyYWdlIHNob3VsZCBiZSB3ZWxsIHVuZGVyIHRhcmdldFxuXG4gICAgICAvLyBNZW1vcnkgdmFyaWFuY2Ugc2hvdWxkIGJlIHJlYXNvbmFibGVcbiAgICAgIGNvbnN0IHZhcmlhbmNlID1cbiAgICAgICAgbWVtb3J5U25hcHNob3RzLnJlZHVjZShcbiAgICAgICAgICAoc3VtLCBtZW0pID0+IHN1bSArIE1hdGgucG93KG1lbSAtIGF2Z01lbW9yeSwgMiksXG4gICAgICAgICAgMFxuICAgICAgICApIC8gbWVtb3J5U25hcHNob3RzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICAgIGV4cGVjdChzdGFuZGFyZERldmlhdGlvbikudG9CZUxlc3NUaGFuKDEwKTsgLy8gU2hvdWxkIGhhdmUgcmVhc29uYWJsZSB2YXJpYW5jZVxuXG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gb3JpZ2luYWxNZW1vcnlVc2FnZTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgbWVtb3J5IGVmZmljaWVuY3kgYWNyb3NzIGRpZmZlcmVudCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2U7XG4gICAgICBjb25zdCBvcGVyYXRpb25NZW1vcnlVc2FnZTogUmVjb3JkPHN0cmluZywgbnVtYmVyW10+ID0ge1xuICAgICAgICB0eXBlU2NyaXB0Q2hlY2s6IFtdLFxuICAgICAgICBsaW50aW5nQ2hlY2s6IFtdLFxuICAgICAgICBlbnRlcnByaXNlQ291bnQ6IFtdLFxuICAgICAgICBidWlsZFRpbWU6IFtdLFxuICAgICAgICBwcm9ncmVzc01ldHJpY3M6IFtdLFxuICAgICAgfTtcblxuICAgICAgbGV0IG9wZXJhdGlvblR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIC8vIERpZmZlcmVudCBtZW1vcnkgdXNhZ2UgcGF0dGVybnMgZm9yIGRpZmZlcmVudCBvcGVyYXRpb25zXG4gICAgICAgIGxldCBiYXNlTWVtb3J5ID0gMzA7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3R5cGVTY3JpcHRDaGVjayc6XG4gICAgICAgICAgICBiYXNlTWVtb3J5ID0gMzU7IC8vIFR5cGVTY3JpcHQgY2hlY2tpbmcgdXNlcyBtb3JlIG1lbW9yeVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbGludGluZ0NoZWNrJzpcbiAgICAgICAgICAgIGJhc2VNZW1vcnkgPSAzMjsgLy8gTGludGluZyB1c2VzIG1vZGVyYXRlIG1lbW9yeVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZW50ZXJwcmlzZUNvdW50JzpcbiAgICAgICAgICAgIGJhc2VNZW1vcnkgPSAyODsgLy8gU2ltcGxlIGdyZXAgdXNlcyBsZXNzIG1lbW9yeVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYnVpbGRUaW1lJzpcbiAgICAgICAgICAgIGJhc2VNZW1vcnkgPSA0MDsgLy8gQnVpbGQgcHJvY2VzcyB1c2VzIG1vcmUgbWVtb3J5XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwcm9ncmVzc01ldHJpY3MnOlxuICAgICAgICAgICAgYmFzZU1lbW9yeSA9IDMzOyAvLyBNZXRyaWNzIGNvbGxlY3Rpb24gdXNlcyBtb2RlcmF0ZSBtZW1vcnlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWFwVXNlZDogYmFzZU1lbW9yeSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGhlYXBUb3RhbDogYmFzZU1lbW9yeSAqIDIgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICBleHRlcm5hbDogNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIHJzczogYmFzZU1lbW9yeSAqIDEuNSAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgIGFycmF5QnVmZmVyczogMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRlc3QgZGlmZmVyZW50IG9wZXJhdGlvbnMgYW5kIHRoZWlyIG1lbW9yeSB1c2FnZVxuICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd0eXBlU2NyaXB0Q2hlY2snLFxuICAgICAgICAgIGZuOiAoKSA9PiBwcm9ncmVzc1RyYWNrZXIuZ2V0VHlwZVNjcmlwdEVycm9yQ291bnQoKSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdsaW50aW5nQ2hlY2snLFxuICAgICAgICAgIGZuOiAoKSA9PiBwcm9ncmVzc1RyYWNrZXIuZ2V0TGludGluZ1dhcm5pbmdDb3VudCgpLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2VudGVycHJpc2VDb3VudCcsXG4gICAgICAgICAgZm46ICgpID0+IHByb2dyZXNzVHJhY2tlci5nZXRFbnRlcnByaXNlU3lzdGVtQ291bnQoKSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiAnYnVpbGRUaW1lJywgZm46ICgpID0+IHByb2dyZXNzVHJhY2tlci5nZXRCdWlsZFRpbWUoKSB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Byb2dyZXNzTWV0cmljcycsXG4gICAgICAgICAgZm46ICgpID0+IHByb2dyZXNzVHJhY2tlci5nZXRQcm9ncmVzc01ldHJpY3MoKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgb3BlcmF0aW9uVHlwZSA9IG9wZXJhdGlvbi5uYW1lO1xuXG4gICAgICAgIC8vIFJ1biBvcGVyYXRpb24gbXVsdGlwbGUgdGltZXMgdG8gZ2V0IGF2ZXJhZ2UgbWVtb3J5IHVzYWdlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgYXdhaXQgb3BlcmF0aW9uLmZuKCk7XG4gICAgICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0TWVtb3J5VXNhZ2UoKTtcbiAgICAgICAgICBvcGVyYXRpb25NZW1vcnlVc2FnZVtvcGVyYXRpb24ubmFtZV0ucHVzaChtZW1vcnlVc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgbWVtb3J5IHVzYWdlIGZvciBlYWNoIG9wZXJhdGlvbiB0eXBlXG4gICAgICBmb3IgKGNvbnN0IFtvcE5hbWUsIG1lbW9yeVJlYWRpbmdzXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgb3BlcmF0aW9uTWVtb3J5VXNhZ2VcbiAgICAgICkpIHtcbiAgICAgICAgZXhwZWN0KG1lbW9yeVJlYWRpbmdzLmxlbmd0aCkudG9CZSg1KTtcblxuICAgICAgICBjb25zdCBhdmdNZW1vcnkgPVxuICAgICAgICAgIG1lbW9yeVJlYWRpbmdzLnJlZHVjZSgoc3VtLCBtZW0pID0+IHN1bSArIG1lbSwgMCkgL1xuICAgICAgICAgIG1lbW9yeVJlYWRpbmdzLmxlbmd0aDtcbiAgICAgICAgZXhwZWN0KGF2Z01lbW9yeSkudG9CZUxlc3NUaGFuKDUwKTsgLy8gQWxsIG9wZXJhdGlvbnMgc2hvdWxkIHN0YXkgdW5kZXIgdGFyZ2V0XG5cbiAgICAgICAgLy8gTWVtb3J5IHVzYWdlIHNob3VsZCBiZSBjb25zaXN0ZW50IGZvciB0aGUgc2FtZSBvcGVyYXRpb25cbiAgICAgICAgY29uc3QgbWF4TWVtb3J5ID0gTWF0aC5tYXgoLi4ubWVtb3J5UmVhZGluZ3MpO1xuICAgICAgICBjb25zdCBtaW5NZW1vcnkgPSBNYXRoLm1pbiguLi5tZW1vcnlSZWFkaW5ncyk7XG4gICAgICAgIGV4cGVjdChtYXhNZW1vcnkgLSBtaW5NZW1vcnkpLnRvQmVMZXNzVGhhbig1KTsgLy8gU2hvdWxkIGhhdmUgbG93IHZhcmlhbmNlXG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubWVtb3J5VXNhZ2UgPSBvcmlnaW5hbE1lbW9yeVVzYWdlO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9