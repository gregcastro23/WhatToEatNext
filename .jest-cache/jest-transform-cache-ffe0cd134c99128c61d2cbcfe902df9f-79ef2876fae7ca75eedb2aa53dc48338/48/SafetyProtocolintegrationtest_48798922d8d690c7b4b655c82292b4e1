abd5ccfa204a93bedbc4d7d81e6549e6
"use strict";
/**
 * Integration Tests for Safety Protocol with Corruption Simulation
 * Perfect Codebase Campaign - Safety Protocol Integration Testing
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('child_process');
jest.mock('fs');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const campaign_1 = require("../../../../types/campaign");
const CampaignController_1 = require("../../CampaignController");
const ProgressTracker_1 = require("../../ProgressTracker");
const SafetyProtocol_1 = require("../../SafetyProtocol");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('Safety Protocol Integration Tests', () => {
    let safetyProtocol;
    let campaignController;
    let progressTracker;
    let mockSafetySettings;
    let mockConfig;
    beforeEach(() => {
        mockSafetySettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7,
        };
        mockConfig = {
            phases: [
                {
                    id: 'test-phase',
                    name: 'Test Phase',
                    description: 'Test phase for safety protocol integration',
                    tools: [
                        {
                            scriptPath: 'scripts/test-script.js',
                            parameters: { maxFiles: 10, autoFix: true },
                            batchSize: 10,
                            safetyLevel: campaign_1.SafetyLevel.HIGH,
                        },
                    ],
                    successCriteria: { typeScriptErrors: 0 },
                    safetyCheckpoints: [],
                },
            ],
            safetySettings: mockSafetySettings,
            progressTargets: { typeScriptErrors: 0, lintingWarnings: 0, buildTime: 10, enterpriseSystems: 200 },
            toolConfiguration: {
                enhancedErrorFixer: 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js',
                explicitAnyFixer: 'scripts/typescript-fixes/fix-explicit-any-systematic.js',
                unusedVariablesFixer: 'scripts/typescript-fixes/fix-unused-variables-enhanced.js',
                consoleStatementFixer: 'scripts/lint-fixes/fix-console-statements-only.js',
            },
        };
        safetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSafetySettings);
        campaignController = new CampaignController_1.CampaignController(mockConfig);
        progressTracker = new ProgressTracker_1.ProgressTracker();
        // Reset mocks
        jest.clearAllMocks();
        // Default mock implementations
        mockExecSync.mockReturnValue('');
        mockFs.existsSync.mockReturnValue(true);
        mockFs.readFileSync.mockReturnValue('valid content');
        mockFs.writeFileSync.mockImplementation(() => { });
    });
    describe('Corruption Detection and Recovery', () => {
        describe('Git Merge Conflict Simulation', () => {
            it('should detect and handle git merge conflicts', async () => {
                const corruptedContent = `
          function test() {
          <<<<<<< HEAD
            return 'version 1';
          =======
            return 'version 2';
          >>>>>>> branch
          }
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.CRITICAL);
                expect(report.recommendedAction).toBe(campaign_1.RecoveryAction.EMERGENCY_RESTORE);
                expect(report.corruptionPatterns.some(p => p.description.includes('Git merge conflict'))).toBe(true);
            });
            it('should trigger emergency rollback for critical corruption', async () => {
                const corruptedContent = '<<<<<<< HEAD\nconflict\n=======\nother\n>>>>>>> branch';
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                // Create a stash first
                mockExecSync.mockImplementation(command => {
                    const cmd = command.toString();
                    if (cmd.includes('git stash push'))
                        return '';
                    if (cmd.includes('git stash list'))
                        return 'stash@{0}: emergency-stash';
                    if (cmd.includes('git stash apply'))
                        return '';
                    if (cmd.includes('git status --porcelain'))
                        return '';
                    if (cmd.includes('git branch --show-current'))
                        return 'main';
                    return '';
                });
                const stashId = await safetyProtocol.createStash('Emergency stash');
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                if (report.severity === campaign_1.CorruptionSeverity.CRITICAL) {
                    await safetyProtocol.emergencyRollback();
                }
                expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash apply'), expect.any(Object));
            });
        });
        describe('Import/Export Corruption Simulation', () => {
            it('should detect corrupted import statements', async () => {
                const corruptedContent = `
          import @/types from './types';
          import @/services from './services';
          import { } from './empty';
          import something from "undefined";
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectImportExportCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.length).toBeGreaterThan(0);
            });
            it('should detect double commas in destructuring', async () => {
                const corruptedContent = `
import type type Something, { a, b } from './module';
          export { x,, y };
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectImportExportCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.some(p => p.description.includes('Double comma'))).toBe(true);
            });
            it('should detect duplicate keywords in imports', async () => {
                const corruptedContent = `
          export default default value;
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectImportExportCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            });
        });
        describe('Syntax Corruption Simulation', () => {
            it('should detect unbalanced brackets', async () => {
                const corruptedContent = `
          function test() {
            if (condition) {
              return 'missing closing brace';
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            });
            it('should detect incomplete statements', async () => {
                const corruptedContent = `
          export
          import
          function
          const
        `;
                mockFs.readFileSync.mockReturnValue(corruptedContent);
                const report = await safetyProtocol.detectCorruption(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            });
        });
        describe('TypeScript Syntax Validation', () => {
            it('should validate syntax using TypeScript compiler', async () => {
                mockExecSync.mockReturnValue('No errors found');
                const report = await safetyProtocol.validateSyntaxWithTypeScript(['test-file.ts']);
                expect(mockExecSync).toHaveBeenCalledWith('yarn tsc --noEmit --skipLibCheck 2>&1', expect.any(Object));
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
            });
            it('should detect TypeScript syntax errors', async () => {
                mockExecSync.mockReturnValue(`
          test-file.ts(10,5): error TS1005: Unexpected token 'function'
          test-file.ts(15,10): error TS1109: Expression expected
        `);
                const report = await safetyProtocol.validateSyntaxWithTypeScript(['test-file.ts']);
                expect(report.detectedFiles).toContain('test-file.ts');
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.some(p => p.pattern === 'TYPESCRIPT_SYNTAX_ERROR')).toBe(true);
            });
            it('should handle TypeScript compilation failures', async () => {
                mockExecSync.mockImplementation(() => {
                    const error = new Error('TypeScript compilation failed');
                    error.stdout = 'Unexpected token at line 5';
                    throw error;
                });
                const report = await safetyProtocol.validateSyntaxWithTypeScript(['test-file.ts']);
                expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
                expect(report.corruptionPatterns.some(p => p.pattern === 'TYPESCRIPT_COMPILATION_ERROR')).toBe(true);
            });
        });
    });
    describe('Real-time Monitoring Integration', () => {
        beforeEach(() => {
            jest.useFakeTimers();
        });
        afterEach(() => {
            jest.useRealTimers();
        });
        it('should monitor files in real-time during script execution', async () => {
            const testFiles = ['file1.ts', 'file2.ts'];
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: [],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.LOW,
                recommendedAction: campaign_1.RecoveryAction.CONTINUE,
            });
            safetyProtocol.startRealTimeMonitoring(testFiles, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            expect(safetyProtocol.detectCorruption).toHaveBeenCalledWith(testFiles);
            safetyProtocol.stopRealTimeMonitoring();
        });
        it('should trigger emergency rollback on critical corruption during monitoring', async () => {
            const testFiles = ['file1.ts'];
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: ['file1.ts'],
                corruptionPatterns: [
                    {
                        pattern: 'CRITICAL_CORRUPTION',
                        description: 'Critical corruption detected',
                        files: ['file1.ts'],
                    },
                ],
                severity: campaign_1.CorruptionSeverity.CRITICAL,
                recommendedAction: campaign_1.RecoveryAction.EMERGENCY_RESTORE,
            });
            jest.spyOn(safetyProtocol, 'emergencyRollback').mockResolvedValue();
            safetyProtocol.startRealTimeMonitoring(testFiles, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // Wait for async operations
            await new Promise(resolve => setTimeout(resolve, 0));
            expect(safetyProtocol.emergencyRollback).toHaveBeenCalled();
        });
        it('should record safety events during real-time monitoring', async () => {
            const testFiles = ['file1.ts'];
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: ['file1.ts'],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.MEDIUM,
                recommendedAction: campaign_1.RecoveryAction.RETRY,
            });
            safetyProtocol.startRealTimeMonitoring(testFiles, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // Wait for async operations
            await new Promise(resolve => setTimeout(resolve, 0));
            const events = safetyProtocol.getSafetyEvents();
            expect(events.some(e => e.type === campaign_1.SafetyEventType.CORRUPTION_DETECTED)).toBe(true);
            safetyProtocol.stopRealTimeMonitoring();
        });
    });
    describe('Git Operations Integration', () => {
        beforeEach(() => {
            mockExecSync.mockImplementation(command => {
                const cmd = command.toString();
                if (cmd.includes('git status --porcelain'))
                    return '';
                if (cmd.includes('git stash push'))
                    return '';
                if (cmd.includes('git stash list'))
                    return 'stash@{0}: test-stash';
                if (cmd.includes('git stash apply'))
                    return '';
                if (cmd.includes('git branch --show-current'))
                    return 'main';
                return '';
            });
        });
        it('should create and manage git stashes throughout campaign', async () => {
            // Create multiple stashes for different phases
            const stash1 = await safetyProtocol.createStash('Phase 1 checkpoint', 'phase1');
            const stash2 = await safetyProtocol.createStash('Phase 2 checkpoint', 'phase2');
            expect(stash1).toMatch(/^campaign-phase1-\d+-/);
            expect(stash2).toMatch(/^campaign-phase2-\d+-/);
            const stashes = await safetyProtocol.listStashes();
            expect(stashes.length).toBe(2);
        });
        it('should apply stashes by phase for targeted rollbacks', async () => {
            // Create stashes for different phases
            await safetyProtocol.createStash('Phase 1 checkpoint', 'phase1');
            await safetyProtocol.createStash('Phase 2 checkpoint', 'phase2');
            await safetyProtocol.createStash('Another Phase 1 checkpoint', 'phase1');
            // Apply latest Phase 1 stash
            const appliedStashId = await safetyProtocol.applyStashByPhase('phase1');
            expect(appliedStashId).toMatch(/^campaign-phase1-\d+-/);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash apply'), expect.any(Object));
        });
        it('should validate git state before operations', async () => {
            const validation = await safetyProtocol.validateGitState();
            expect(validation.success).toBe(true);
            expect(mockExecSync).toHaveBeenCalledWith('git status --porcelain', expect.any(Object));
        });
        it('should handle git operation failures gracefully', async () => {
            mockExecSync.mockImplementation(command => {
                if (command.toString().includes('git stash push')) {
                    throw new Error('Git stash failed');
                }
                return '';
            });
            await expect(safetyProtocol.createStash('Test stash')).rejects.toThrow('Failed to create git stash: Git stash failed');
            const events = safetyProtocol.getSafetyEvents();
            expect(events.some(e => e.type === campaign_1.SafetyEventType.EMERGENCY_RECOVERY)).toBe(true);
        });
    });
    describe('Stash Management and Cleanup', () => {
        beforeEach(() => {
            mockExecSync.mockImplementation(command => {
                const cmd = command.toString();
                if (cmd.includes('git status --porcelain'))
                    return '';
                if (cmd.includes('git stash push'))
                    return '';
                if (cmd.includes('git stash list'))
                    return 'stash@{0}: test-stash';
                if (cmd.includes('git stash drop'))
                    return '';
                if (cmd.includes('git branch --show-current'))
                    return 'main';
                return '';
            });
        });
        it('should cleanup old stashes based on retention policy', async () => {
            // Create old stashes
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            const recentDate = new Date();
            recentDate.setDate(recentDate.getDate() - 3); // 3 days old
            // Manually add stashes to simulate age
            const oldStash = {
                id: 'old-stash',
                description: 'Old stash',
                timestamp: oldDate,
                branch: 'main',
                ref: 'stash@{1}',
            };
            const recentStash = {
                id: 'recent-stash',
                description: 'Recent stash',
                timestamp: recentDate,
                branch: 'main',
                ref: 'stash@{0}',
            };
            safetyProtocol.stashes.set('old-stash', oldStash);
            safetyProtocol.stashes.set('recent-stash', recentStash);
            await safetyProtocol.cleanupOldStashes();
            const stashes = await safetyProtocol.listStashes();
            expect(stashes.some(s => s.id === 'old-stash')).toBe(false);
            expect(stashes.some(s => s.id === 'recent-stash')).toBe(true);
        });
        it('should generate stash statistics for reporting', async () => {
            // Create stashes for different phases
            await safetyProtocol.createStash('Phase 1 checkpoint', 'phase1');
            await safetyProtocol.createStash('Phase 2 checkpoint', 'phase2');
            await safetyProtocol.createStash('Another Phase 1 checkpoint', 'phase1');
            const stats = safetyProtocol.getStashStatistics();
            expect(stats.total).toBe(3);
            expect(stats.byPhase.phase1).toBe(2);
            expect(stats.byPhase.phase2).toBe(1);
            expect(stats.oldestStash).toBeInstanceOf(Date);
            expect(stats.newestStash).toBeInstanceOf(Date);
        });
    });
    describe('Integration with Campaign Controller', () => {
        it('should integrate safety protocols with phase execution', async () => {
            const phase = mockConfig.phases[0];
            // Mock successful execution with safety protocols
            jest.spyOn(campaignController, 'createSafetyCheckpoint').mockResolvedValue('checkpoint-1');
            jest.spyOn(campaignController, 'getCurrentMetrics').mockResolvedValue({
                typeScriptErrors: { current: 0, target: 0, reduction: 86, percentage: 100 },
                lintingWarnings: { current: 4506, target: 0, reduction: 0, percentage: 0 },
                buildPerformance: { currentTime: 8.5, targetTime: 10, cacheHitRate: 0.8, memoryUsage: 45 },
                enterpriseSystems: { current: 0, target: 200, transformedExports: 0 },
            });
            const result = await campaignController.executePhase(phase);
            expect(result.success).toBe(true);
            expect(result.safetyEvents.length).toBeGreaterThan(0);
            expect(campaignController['createSafetyCheckpoint']).toHaveBeenCalled();
        });
        it('should handle rollback scenarios during phase execution', async () => {
            const phase = mockConfig.phases[0];
            // Mock validation failure that triggers rollback
            jest.spyOn(campaignController, 'validatePhaseProgress').mockResolvedValue({
                success: false,
                errors: ['Corruption detected'],
                warnings: [],
            });
            jest.spyOn(campaignController, 'rollbackToCheckpoint').mockResolvedValue();
            await expect(campaignController.executePhase(phase)).rejects.toThrow('Tool execution failed: Corruption detected');
            expect(campaignController.rollbackToCheckpoint).toHaveBeenCalled();
        });
    });
    describe('File System Integration', () => {
        it('should handle file read errors during corruption detection', async () => {
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('Permission denied');
            });
            const report = await safetyProtocol.detectCorruption(['protected-file.ts']);
            expect(report.detectedFiles).toContain('protected-file.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.pattern === 'FILE_READ_ERROR')).toBe(true);
        });
        it('should skip non-existent files gracefully', async () => {
            mockFs.existsSync.mockReturnValue(false);
            const report = await safetyProtocol.detectCorruption(['non-existent.ts']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
        it('should handle mixed file types appropriately', async () => {
            const files = ['script.ts', 'style.css', 'config.json', 'readme.md'];
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue('valid content');
            const report = await safetyProtocol.detectImportExportCorruption(files);
            // Should only process TypeScript/JavaScript files
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
    });
    describe('Safety Event Tracking', () => {
        it('should track safety events throughout integration scenarios', async () => {
            // Create stash
            await safetyProtocol.createStash('Test stash');
            // Detect corruption
            mockFs.readFileSync.mockReturnValue('<<<<<<< HEAD\nconflict\n>>>>>>> branch');
            await safetyProtocol.detectCorruption(['test-file.ts']);
            // Apply stash
            await safetyProtocol.applyStash((await safetyProtocol.listStashes())[0].id);
            const events = safetyProtocol.getSafetyEvents();
            expect(events.some(e => e.type === campaign_1.SafetyEventType.CHECKPOINT_CREATED)).toBe(true);
            expect(events.some(e => e.type === campaign_1.SafetyEventType.CORRUPTION_DETECTED)).toBe(true);
            expect(events.some(e => e.type === campaign_1.SafetyEventType.ROLLBACK_TRIGGERED)).toBe(true);
        });
        it('should maintain event history with proper severity levels', async () => {
            // Generate events of different severities
            await safetyProtocol.createStash('Info event'); // INFO
            mockFs.readFileSync.mockReturnValue('<<<<<<< HEAD\nconflict\n>>>>>>> branch');
            await safetyProtocol.detectCorruption(['test-file.ts']); // CRITICAL
            const events = safetyProtocol.getSafetyEvents();
            const severities = events.map(e => e.severity);
            expect(severities).toContain(campaign_1.SafetyEventSeverity.INFO);
            expect(severities).toContain(campaign_1.SafetyEventSeverity.CRITICAL);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL3NlcnZpY2VzL2NhbXBhaWduL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9TYWZldHlQcm90b2NvbC5pbnRlZ3JhdGlvbi50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkgsb0JBQW9CO0FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQWxCaEIsaURBQXlDO0FBQ3pDLHVDQUF5QjtBQUV6Qix5REFRb0M7QUFDcEMsaUVBQThEO0FBQzlELDJEQUF3RDtBQUN4RCx5REFBc0Q7QUFNdEQsTUFBTSxZQUFZLEdBQUcsd0JBQWdELENBQUM7QUFDdEUsTUFBTSxNQUFNLEdBQUcsRUFBNEIsQ0FBQztBQUU1QyxRQUFRLENBQUMsbUNBQW1DLEVBQUUsR0FBRyxFQUFFO0lBQ2pELElBQUksY0FBOEIsQ0FBQztJQUNuQyxJQUFJLGtCQUFzQyxDQUFDO0lBQzNDLElBQUksZUFBZ0MsQ0FBQztJQUNyQyxJQUFJLGtCQUFrQyxDQUFDO0lBQ3ZDLElBQUksVUFBMEIsQ0FBQztJQUUvQixVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2Qsa0JBQWtCLEdBQUc7WUFDbkIsZ0JBQWdCLEVBQUUsRUFBRTtZQUNwQix3QkFBd0IsRUFBRSxDQUFDO1lBQzNCLHVCQUF1QixFQUFFLEVBQUU7WUFDM0IsMEJBQTBCLEVBQUUsSUFBSTtZQUNoQyx3QkFBd0IsRUFBRSxJQUFJO1lBQzlCLGtCQUFrQixFQUFFLENBQUM7U0FDdEIsQ0FBQztRQUVGLFVBQVUsR0FBRztZQUNYLE1BQU0sRUFBRTtnQkFDTjtvQkFDRSxFQUFFLEVBQUUsWUFBWTtvQkFDaEIsSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLFdBQVcsRUFBRSw0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LGNBQWMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUNoRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLENBQUMsOEJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyw4QkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL3NlcnZpY2VzL2NhbXBhaWduL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9TYWZldHlQcm90b2NvbC5pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZWdyYXRpb24gVGVzdHMgZm9yIFNhZmV0eSBQcm90b2NvbCB3aXRoIENvcnJ1cHRpb24gU2ltdWxhdGlvblxuICogUGVyZmVjdCBDb2RlYmFzZSBDYW1wYWlnbiAtIFNhZmV0eSBQcm90b2NvbCBJbnRlZ3JhdGlvbiBUZXN0aW5nXG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcblxuaW1wb3J0IHtcbiAgU2FmZXR5U2V0dGluZ3MsXG4gIENvcnJ1cHRpb25TZXZlcml0eSxcbiAgUmVjb3ZlcnlBY3Rpb24sXG4gIFNhZmV0eUV2ZW50VHlwZSxcbiAgU2FmZXR5RXZlbnRTZXZlcml0eSxcbiAgQ2FtcGFpZ25Db25maWcsXG4gIFNhZmV0eUxldmVsLFxufSBmcm9tICcuLi8uLi8uLi8uLi90eXBlcy9jYW1wYWlnbic7XG5pbXBvcnQgeyBDYW1wYWlnbkNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi9DYW1wYWlnbkNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vUHJvZ3Jlc3NUcmFja2VyJztcbmltcG9ydCB7IFNhZmV0eVByb3RvY29sIH0gZnJvbSAnLi4vLi4vU2FmZXR5UHJvdG9jb2wnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJyk7XG5qZXN0Lm1vY2soJ2ZzJyk7XG5cbmNvbnN0IG1vY2tFeGVjU3luYyA9IGV4ZWNTeW5jIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGV4ZWNTeW5jPjtcbmNvbnN0IG1vY2tGcyA9IGZzIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBmcz47XG5cbmRlc2NyaWJlKCdTYWZldHkgUHJvdG9jb2wgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBzYWZldHlQcm90b2NvbDogU2FmZXR5UHJvdG9jb2w7XG4gIGxldCBjYW1wYWlnbkNvbnRyb2xsZXI6IENhbXBhaWduQ29udHJvbGxlcjtcbiAgbGV0IHByb2dyZXNzVHJhY2tlcjogUHJvZ3Jlc3NUcmFja2VyO1xuICBsZXQgbW9ja1NhZmV0eVNldHRpbmdzOiBTYWZldHlTZXR0aW5ncztcbiAgbGV0IG1vY2tDb25maWc6IENhbXBhaWduQ29uZmlnO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTYWZldHlTZXR0aW5ncyA9IHtcbiAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDI1LFxuICAgICAgYnVpbGRWYWxpZGF0aW9uRnJlcXVlbmN5OiA1LFxuICAgICAgdGVzdFZhbGlkYXRpb25GcmVxdWVuY3k6IDEwLFxuICAgICAgY29ycnVwdGlvbkRldGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICBhdXRvbWF0aWNSb2xsYmFja0VuYWJsZWQ6IHRydWUsXG4gICAgICBzdGFzaFJldGVudGlvbkRheXM6IDcsXG4gICAgfTtcblxuICAgIG1vY2tDb25maWcgPSB7XG4gICAgICBwaGFzZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndGVzdC1waGFzZScsXG4gICAgICAgICAgbmFtZTogJ1Rlc3QgUGhhc2UnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBwaGFzZSBmb3Igc2FmZXR5IHByb3RvY29sIGludGVncmF0aW9uJyxcbiAgICAgICAgICB0b29sczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzY3JpcHRQYXRoOiAnc2NyaXB0cy90ZXN0LXNjcmlwdC5qcycsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHsgbWF4RmlsZXM6IDEwLCBhdXRvRml4OiB0cnVlIH0sXG4gICAgICAgICAgICAgIGJhdGNoU2l6ZTogMTAsXG4gICAgICAgICAgICAgIHNhZmV0eUxldmVsOiBTYWZldHlMZXZlbC5ISUdILFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHN1Y2Nlc3NDcml0ZXJpYTogeyB0eXBlU2NyaXB0RXJyb3JzOiAwIH0sXG4gICAgICAgICAgc2FmZXR5Q2hlY2twb2ludHM6IFtdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHNhZmV0eVNldHRpbmdzOiBtb2NrU2FmZXR5U2V0dGluZ3MsXG4gICAgICBwcm9ncmVzc1RhcmdldHM6IHsgdHlwZVNjcmlwdEVycm9yczogMCwgbGludGluZ1dhcm5pbmdzOiAwLCBidWlsZFRpbWU6IDEwLCBlbnRlcnByaXNlU3lzdGVtczogMjAwIH0sXG4gICAgICB0b29sQ29uZmlndXJhdGlvbjoge1xuICAgICAgICBlbmhhbmNlZEVycm9yRml4ZXI6ICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LXR5cGVzY3JpcHQtZXJyb3JzLWVuaGFuY2VkLXYzLmpzJyxcbiAgICAgICAgZXhwbGljaXRBbnlGaXhlcjogJ3NjcmlwdHMvdHlwZXNjcmlwdC1maXhlcy9maXgtZXhwbGljaXQtYW55LXN5c3RlbWF0aWMuanMnLFxuICAgICAgICB1bnVzZWRWYXJpYWJsZXNGaXhlcjogJ3NjcmlwdHMvdHlwZXNjcmlwdC1maXhlcy9maXgtdW51c2VkLXZhcmlhYmxlcy1lbmhhbmNlZC5qcycsXG4gICAgICAgIGNvbnNvbGVTdGF0ZW1lbnRGaXhlcjogJ3NjcmlwdHMvbGludC1maXhlcy9maXgtY29uc29sZS1zdGF0ZW1lbnRzLW9ubHkuanMnLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgc2FmZXR5UHJvdG9jb2wgPSBuZXcgU2FmZXR5UHJvdG9jb2wobW9ja1NhZmV0eVNldHRpbmdzKTtcbiAgICBjYW1wYWlnbkNvbnRyb2xsZXIgPSBuZXcgQ2FtcGFpZ25Db250cm9sbGVyKG1vY2tDb25maWcpO1xuICAgIHByb2dyZXNzVHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoKTtcblxuICAgIC8vIFJlc2V0IG1vY2tzXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG5cbiAgICAvLyBEZWZhdWx0IG1vY2sgaW1wbGVtZW50YXRpb25zXG4gICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG4gICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCd2YWxpZCBjb250ZW50Jyk7XG4gICAgbW9ja0ZzLndyaXRlRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvcnJ1cHRpb24gRGV0ZWN0aW9uIGFuZCBSZWNvdmVyeScsICgpID0+IHtcbiAgICBkZXNjcmliZSgnR2l0IE1lcmdlIENvbmZsaWN0IFNpbXVsYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCBhbmQgaGFuZGxlIGdpdCBtZXJnZSBjb25mbGljdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvcnJ1cHRlZENvbnRlbnQgPSBgXG4gICAgICAgICAgZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgICAgICA8PDw8PDw8IEhFQURcbiAgICAgICAgICAgIHJldHVybiAndmVyc2lvbiAxJztcbiAgICAgICAgICA9PT09PT09XG4gICAgICAgICAgICByZXR1cm4gJ3ZlcnNpb24gMic7XG4gICAgICAgICAgPj4+Pj4+PiBicmFuY2hcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoY29ycnVwdGVkQ29udGVudCk7XG5cbiAgICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ3Rlc3QtZmlsZS50cyddKTtcblxuICAgICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbigndGVzdC1maWxlLnRzJyk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkNSSVRJQ0FMKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5yZWNvbW1lbmRlZEFjdGlvbikudG9CZShSZWNvdmVyeUFjdGlvbi5FTUVSR0VOQ1lfUkVTVE9SRSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdHaXQgbWVyZ2UgY29uZmxpY3QnKSkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB0cmlnZ2VyIGVtZXJnZW5jeSByb2xsYmFjayBmb3IgY3JpdGljYWwgY29ycnVwdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ycnVwdGVkQ29udGVudCA9ICc8PDw8PDw8IEhFQURcXG5jb25mbGljdFxcbj09PT09PT1cXG5vdGhlclxcbj4+Pj4+Pj4gYnJhbmNoJztcbiAgICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoY29ycnVwdGVkQ29udGVudCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc3Rhc2ggZmlyc3RcbiAgICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbihjb21tYW5kID0+IHtcbiAgICAgICAgICBjb25zdCBjbWQgPSBjb21tYW5kLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXNoIHB1c2gnKSkgcmV0dXJuICcnO1xuICAgICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBsaXN0JykpIHJldHVybiAnc3Rhc2hAezB9OiBlbWVyZ2VuY3ktc3Rhc2gnO1xuICAgICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBhcHBseScpKSByZXR1cm4gJyc7XG4gICAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXR1cyAtLXBvcmNlbGFpbicpKSByZXR1cm4gJyc7XG4gICAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IGJyYW5jaCAtLXNob3ctY3VycmVudCcpKSByZXR1cm4gJ21haW4nO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3Rhc2hJZCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdFbWVyZ2VuY3kgc3Rhc2gnKTtcblxuICAgICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsndGVzdC1maWxlLnRzJ10pO1xuXG4gICAgICAgIGlmIChyZXBvcnQuc2V2ZXJpdHkgPT09IENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCkge1xuICAgICAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmVtZXJnZW5jeVJvbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nQ29udGFpbmluZygnZ2l0IHN0YXNoIGFwcGx5JyksIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdJbXBvcnQvRXhwb3J0IENvcnJ1cHRpb24gU2ltdWxhdGlvbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZGV0ZWN0IGNvcnJ1cHRlZCBpbXBvcnQgc3RhdGVtZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ycnVwdGVkQ29udGVudCA9IGBcbiAgICAgICAgICBpbXBvcnQgQC90eXBlcyBmcm9tICcuL3R5cGVzJztcbiAgICAgICAgICBpbXBvcnQgQC9zZXJ2aWNlcyBmcm9tICcuL3NlcnZpY2VzJztcbiAgICAgICAgICBpbXBvcnQgeyB9IGZyb20gJy4vZW1wdHknO1xuICAgICAgICAgIGltcG9ydCBzb21ldGhpbmcgZnJvbSBcInVuZGVmaW5lZFwiO1xuICAgICAgICBgO1xuXG4gICAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGNvcnJ1cHRlZENvbnRlbnQpO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBkZXRlY3QgZG91YmxlIGNvbW1hcyBpbiBkZXN0cnVjdHVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb3JydXB0ZWRDb250ZW50ID0gYFxuaW1wb3J0IHR5cGUgdHlwZSBTb21ldGhpbmcsIHsgYSwgYiB9IGZyb20gJy4vbW9kdWxlJztcbiAgICAgICAgICBleHBvcnQgeyB4LCwgeSB9O1xuICAgICAgICBgO1xuXG4gICAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGNvcnJ1cHRlZENvbnRlbnQpO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0RvdWJsZSBjb21tYScpKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCBkdXBsaWNhdGUga2V5d29yZHMgaW4gaW1wb3J0cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ycnVwdGVkQ29udGVudCA9IGBcbiAgICAgICAgICBleHBvcnQgZGVmYXVsdCBkZWZhdWx0IHZhbHVlO1xuICAgICAgICBgO1xuXG4gICAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGNvcnJ1cHRlZENvbnRlbnQpO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1N5bnRheCBDb3JydXB0aW9uIFNpbXVsYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGRldGVjdCB1bmJhbGFuY2VkIGJyYWNrZXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb3JydXB0ZWRDb250ZW50ID0gYFxuICAgICAgICAgIGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnbWlzc2luZyBjbG9zaW5nIGJyYWNlJztcbiAgICAgICAgYDtcblxuICAgICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShjb3JydXB0ZWRDb250ZW50KTtcblxuICAgICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsndGVzdC1maWxlLnRzJ10pO1xuXG4gICAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCd0ZXN0LWZpbGUudHMnKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBkZXRlY3QgaW5jb21wbGV0ZSBzdGF0ZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb3JydXB0ZWRDb250ZW50ID0gYFxuICAgICAgICAgIGV4cG9ydFxuICAgICAgICAgIGltcG9ydFxuICAgICAgICAgIGZ1bmN0aW9uXG4gICAgICAgICAgY29uc3RcbiAgICAgICAgYDtcblxuICAgICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShjb3JydXB0ZWRDb250ZW50KTtcblxuICAgICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsndGVzdC1maWxlLnRzJ10pO1xuXG4gICAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCd0ZXN0LWZpbGUudHMnKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdUeXBlU2NyaXB0IFN5bnRheCBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBzeW50YXggdXNpbmcgVHlwZVNjcmlwdCBjb21waWxlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnTm8gZXJyb3JzIGZvdW5kJyk7XG5cbiAgICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdChbJ3Rlc3QtZmlsZS50cyddKTtcblxuICAgICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgneWFybiB0c2MgLS1ub0VtaXQgLS1za2lwTGliQ2hlY2sgMj4mMScsIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBkZXRlY3QgVHlwZVNjcmlwdCBzeW50YXggZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgICB0ZXN0LWZpbGUudHMoMTAsNSk6IGVycm9yIFRTMTAwNTogVW5leHBlY3RlZCB0b2tlbiAnZnVuY3Rpb24nXG4gICAgICAgICAgdGVzdC1maWxlLnRzKDE1LDEwKTogZXJyb3IgVFMxMTA5OiBFeHByZXNzaW9uIGV4cGVjdGVkXG4gICAgICAgIGApO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ3Rlc3QtZmlsZS50cycpO1xuICAgICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAucGF0dGVybiA9PT0gJ1RZUEVTQ1JJUFRfU1lOVEFYX0VSUk9SJykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgVHlwZVNjcmlwdCBjb21waWxhdGlvbiBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1R5cGVTY3JpcHQgY29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICAgIGVycm9yLnN0ZG91dCA9ICdVbmV4cGVjdGVkIHRva2VuIGF0IGxpbmUgNSc7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWyd0ZXN0LWZpbGUudHMnXSk7XG5cbiAgICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLnBhdHRlcm4gPT09ICdUWVBFU0NSSVBUX0NPTVBJTEFUSU9OX0VSUk9SJykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlYWwtdGltZSBNb25pdG9yaW5nIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1vbml0b3IgZmlsZXMgaW4gcmVhbC10aW1lIGR1cmluZyBzY3JpcHQgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEZpbGVzID0gWydmaWxlMS50cycsICdmaWxlMi50cyddO1xuXG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnZGV0ZWN0Q29ycnVwdGlvbicpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGV0ZWN0ZWRGaWxlczogW10sXG4gICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJuczogW10sXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuTE9XLFxuICAgICAgICByZWNvbW1lbmRlZEFjdGlvbjogUmVjb3ZlcnlBY3Rpb24uQ09OVElOVUUsXG4gICAgICB9KTtcblxuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RhcnRSZWFsVGltZU1vbml0b3JpbmcodGVzdEZpbGVzLCAxMDAwKTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHRpbWUgdG8gdHJpZ2dlciBtb25pdG9yaW5nXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG5cbiAgICAgIGV4cGVjdChzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh0ZXN0RmlsZXMpO1xuXG4gICAgICBzYWZldHlQcm90b2NvbC5zdG9wUmVhbFRpbWVNb25pdG9yaW5nKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRyaWdnZXIgZW1lcmdlbmN5IHJvbGxiYWNrIG9uIGNyaXRpY2FsIGNvcnJ1cHRpb24gZHVyaW5nIG1vbml0b3JpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RmlsZXMgPSBbJ2ZpbGUxLnRzJ107XG5cbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdkZXRlY3RDb3JydXB0aW9uJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkZXRlY3RlZEZpbGVzOiBbJ2ZpbGUxLnRzJ10sXG4gICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhdHRlcm46ICdDUklUSUNBTF9DT1JSVVBUSU9OJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ3JpdGljYWwgY29ycnVwdGlvbiBkZXRlY3RlZCcsXG4gICAgICAgICAgICBmaWxlczogWydmaWxlMS50cyddLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwsXG4gICAgICAgIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5FTUVSR0VOQ1lfUkVTVE9SRSxcbiAgICAgIH0pO1xuXG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnZW1lcmdlbmN5Um9sbGJhY2snKS5tb2NrUmVzb2x2ZWRWYWx1ZSgpO1xuXG4gICAgICBzYWZldHlQcm90b2NvbC5zdGFydFJlYWxUaW1lTW9uaXRvcmluZyh0ZXN0RmlsZXMsIDEwMDApO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgdGltZSB0byB0cmlnZ2VyIG1vbml0b3JpbmdcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcblxuICAgICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcblxuICAgICAgZXhwZWN0KHNhZmV0eVByb3RvY29sLmVtZXJnZW5jeVJvbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlY29yZCBzYWZldHkgZXZlbnRzIGR1cmluZyByZWFsLXRpbWUgbW9uaXRvcmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RGaWxlcyA9IFsnZmlsZTEudHMnXTtcblxuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2RldGVjdENvcnJ1cHRpb24nKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRldGVjdGVkRmlsZXM6IFsnZmlsZTEudHMnXSxcbiAgICAgICAgY29ycnVwdGlvblBhdHRlcm5zOiBbXSxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5NRURJVU0sXG4gICAgICAgIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5SRVRSWSxcbiAgICAgIH0pO1xuXG4gICAgICBzYWZldHlQcm90b2NvbC5zdGFydFJlYWxUaW1lTW9uaXRvcmluZyh0ZXN0RmlsZXMsIDEwMDApO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgdGltZSB0byB0cmlnZ2VyIG1vbml0b3JpbmdcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcblxuICAgICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09IFNhZmV0eUV2ZW50VHlwZS5DT1JSVVBUSU9OX0RFVEVDVEVEKSkudG9CZSh0cnVlKTtcblxuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RvcFJlYWxUaW1lTW9uaXRvcmluZygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnR2l0IE9wZXJhdGlvbnMgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKGNvbW1hbmQgPT4ge1xuICAgICAgICBjb25zdCBjbWQgPSBjb21tYW5kLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGF0dXMgLS1wb3JjZWxhaW4nKSkgcmV0dXJuICcnO1xuICAgICAgICBpZiAoY21kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggcHVzaCcpKSByZXR1cm4gJyc7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBsaXN0JykpIHJldHVybiAnc3Rhc2hAezB9OiB0ZXN0LXN0YXNoJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXNoIGFwcGx5JykpIHJldHVybiAnJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IGJyYW5jaCAtLXNob3ctY3VycmVudCcpKSByZXR1cm4gJ21haW4nO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGFuZCBtYW5hZ2UgZ2l0IHN0YXNoZXMgdGhyb3VnaG91dCBjYW1wYWlnbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBzdGFzaGVzIGZvciBkaWZmZXJlbnQgcGhhc2VzXG4gICAgICBjb25zdCBzdGFzaDEgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnUGhhc2UgMSBjaGVja3BvaW50JywgJ3BoYXNlMScpO1xuICAgICAgY29uc3Qgc3Rhc2gyID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1BoYXNlIDIgY2hlY2twb2ludCcsICdwaGFzZTInKTtcblxuICAgICAgZXhwZWN0KHN0YXNoMSkudG9NYXRjaCgvXmNhbXBhaWduLXBoYXNlMS1cXGQrLS8pO1xuICAgICAgZXhwZWN0KHN0YXNoMikudG9NYXRjaCgvXmNhbXBhaWduLXBoYXNlMi1cXGQrLS8pO1xuXG4gICAgICBjb25zdCBzdGFzaGVzID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wubGlzdFN0YXNoZXMoKTtcbiAgICAgIGV4cGVjdChzdGFzaGVzLmxlbmd0aCkudG9CZSgyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgc3Rhc2hlcyBieSBwaGFzZSBmb3IgdGFyZ2V0ZWQgcm9sbGJhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHN0YXNoZXMgZm9yIGRpZmZlcmVudCBwaGFzZXNcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdQaGFzZSAxIGNoZWNrcG9pbnQnLCAncGhhc2UxJyk7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnUGhhc2UgMiBjaGVja3BvaW50JywgJ3BoYXNlMicpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ0Fub3RoZXIgUGhhc2UgMSBjaGVja3BvaW50JywgJ3BoYXNlMScpO1xuXG4gICAgICAvLyBBcHBseSBsYXRlc3QgUGhhc2UgMSBzdGFzaFxuICAgICAgY29uc3QgYXBwbGllZFN0YXNoSWQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5hcHBseVN0YXNoQnlQaGFzZSgncGhhc2UxJyk7XG5cbiAgICAgIGV4cGVjdChhcHBsaWVkU3Rhc2hJZCkudG9NYXRjaCgvXmNhbXBhaWduLXBoYXNlMS1cXGQrLS8pO1xuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2dpdCBzdGFzaCBhcHBseScpLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBnaXQgc3RhdGUgYmVmb3JlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2dpdCBzdGF0dXMgLS1wb3JjZWxhaW4nLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZ2l0IG9wZXJhdGlvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbihjb21tYW5kID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQudG9TdHJpbmcoKS5pbmNsdWRlcygnZ2l0IHN0YXNoIHB1c2gnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2l0IHN0YXNoIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBnaXQgc3Rhc2g6IEdpdCBzdGFzaCBmYWlsZWQnLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09IFNhZmV0eUV2ZW50VHlwZS5FTUVSR0VOQ1lfUkVDT1ZFUlkpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3Rhc2ggTWFuYWdlbWVudCBhbmQgQ2xlYW51cCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oY29tbWFuZCA9PiB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGNvbW1hbmQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXR1cyAtLXBvcmNlbGFpbicpKSByZXR1cm4gJyc7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBzdGFzaCBwdXNoJykpIHJldHVybiAnJztcbiAgICAgICAgaWYgKGNtZC5pbmNsdWRlcygnZ2l0IHN0YXNoIGxpc3QnKSkgcmV0dXJuICdzdGFzaEB7MH06IHRlc3Qtc3Rhc2gnO1xuICAgICAgICBpZiAoY21kLmluY2x1ZGVzKCdnaXQgc3Rhc2ggZHJvcCcpKSByZXR1cm4gJyc7XG4gICAgICAgIGlmIChjbWQuaW5jbHVkZXMoJ2dpdCBicmFuY2ggLS1zaG93LWN1cnJlbnQnKSkgcmV0dXJuICdtYWluJztcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFudXAgb2xkIHN0YXNoZXMgYmFzZWQgb24gcmV0ZW50aW9uIHBvbGljeScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBvbGQgc3Rhc2hlc1xuICAgICAgY29uc3Qgb2xkRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICBvbGREYXRlLnNldERhdGUob2xkRGF0ZS5nZXREYXRlKCkgLSAxMCk7IC8vIDEwIGRheXMgb2xkXG5cbiAgICAgIGNvbnN0IHJlY2VudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgcmVjZW50RGF0ZS5zZXREYXRlKHJlY2VudERhdGUuZ2V0RGF0ZSgpIC0gMyk7IC8vIDMgZGF5cyBvbGRcblxuICAgICAgLy8gTWFudWFsbHkgYWRkIHN0YXNoZXMgdG8gc2ltdWxhdGUgYWdlXG4gICAgICBjb25zdCBvbGRTdGFzaCA9IHtcbiAgICAgICAgaWQ6ICdvbGQtc3Rhc2gnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09sZCBzdGFzaCcsXG4gICAgICAgIHRpbWVzdGFtcDogb2xkRGF0ZSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICAgIHJlZjogJ3N0YXNoQHsxfScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZWNlbnRTdGFzaCA9IHtcbiAgICAgICAgaWQ6ICdyZWNlbnQtc3Rhc2gnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1JlY2VudCBzdGFzaCcsXG4gICAgICAgIHRpbWVzdGFtcDogcmVjZW50RGF0ZSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICAgIHJlZjogJ3N0YXNoQHswfScsXG4gICAgICB9O1xuXG4gICAgICAoc2FmZXR5UHJvdG9jb2wgYXMgYW55KS5zdGFzaGVzLnNldCgnb2xkLXN0YXNoJywgb2xkU3Rhc2gpO1xuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIGFueSkuc3Rhc2hlcy5zZXQoJ3JlY2VudC1zdGFzaCcsIHJlY2VudFN0YXNoKTtcblxuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY2xlYW51cE9sZFN0YXNoZXMoKTtcblxuICAgICAgY29uc3Qgc3Rhc2hlcyA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmxpc3RTdGFzaGVzKCk7XG4gICAgICBleHBlY3Qoc3Rhc2hlcy5zb21lKHMgPT4gcy5pZCA9PT0gJ29sZC1zdGFzaCcpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChzdGFzaGVzLnNvbWUocyA9PiBzLmlkID09PSAncmVjZW50LXN0YXNoJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHN0YXNoIHN0YXRpc3RpY3MgZm9yIHJlcG9ydGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBzdGFzaGVzIGZvciBkaWZmZXJlbnQgcGhhc2VzXG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnUGhhc2UgMSBjaGVja3BvaW50JywgJ3BoYXNlMScpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1BoYXNlIDIgY2hlY2twb2ludCcsICdwaGFzZTInKTtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdBbm90aGVyIFBoYXNlIDEgY2hlY2twb2ludCcsICdwaGFzZTEnKTtcblxuICAgICAgY29uc3Qgc3RhdHMgPSBzYWZldHlQcm90b2NvbC5nZXRTdGFzaFN0YXRpc3RpY3MoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UucGhhc2UxKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ5UGhhc2UucGhhc2UyKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdFN0YXNoKS50b0JlSW5zdGFuY2VPZihEYXRlKTtcbiAgICAgIGV4cGVjdChzdGF0cy5uZXdlc3RTdGFzaCkudG9CZUluc3RhbmNlT2YoRGF0ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiB3aXRoIENhbXBhaWduIENvbnRyb2xsZXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbnRlZ3JhdGUgc2FmZXR5IHByb3RvY29scyB3aXRoIHBoYXNlIGV4ZWN1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gbW9ja0NvbmZpZy5waGFzZXNbMF07XG5cbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBleGVjdXRpb24gd2l0aCBzYWZldHkgcHJvdG9jb2xzXG4gICAgICBqZXN0LnNweU9uKGNhbXBhaWduQ29udHJvbGxlciBhcyBhbnksICdjcmVhdGVTYWZldHlDaGVja3BvaW50JykubW9ja1Jlc29sdmVkVmFsdWUoJ2NoZWNrcG9pbnQtMScpO1xuICAgICAgamVzdC5zcHlPbihjYW1wYWlnbkNvbnRyb2xsZXIgYXMgYW55LCAnZ2V0Q3VycmVudE1ldHJpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHR5cGVTY3JpcHRFcnJvcnM6IHsgY3VycmVudDogMCwgdGFyZ2V0OiAwLCByZWR1Y3Rpb246IDg2LCBwZXJjZW50YWdlOiAxMDAgfSxcbiAgICAgICAgbGludGluZ1dhcm5pbmdzOiB7IGN1cnJlbnQ6IDQ1MDYsIHRhcmdldDogMCwgcmVkdWN0aW9uOiAwLCBwZXJjZW50YWdlOiAwIH0sXG4gICAgICAgIGJ1aWxkUGVyZm9ybWFuY2U6IHsgY3VycmVudFRpbWU6IDguNSwgdGFyZ2V0VGltZTogMTAsIGNhY2hlSGl0UmF0ZTogMC44LCBtZW1vcnlVc2FnZTogNDUgfSxcbiAgICAgICAgZW50ZXJwcmlzZVN5c3RlbXM6IHsgY3VycmVudDogMCwgdGFyZ2V0OiAyMDAsIHRyYW5zZm9ybWVkRXhwb3J0czogMCB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbXBhaWduQ29udHJvbGxlci5leGVjdXRlUGhhc2UocGhhc2UpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eUV2ZW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChjYW1wYWlnbkNvbnRyb2xsZXJbJ2NyZWF0ZVNhZmV0eUNoZWNrcG9pbnQnXSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcm9sbGJhY2sgc2NlbmFyaW9zIGR1cmluZyBwaGFzZSBleGVjdXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IG1vY2tDb25maWcucGhhc2VzWzBdO1xuXG4gICAgICAvLyBNb2NrIHZhbGlkYXRpb24gZmFpbHVyZSB0aGF0IHRyaWdnZXJzIHJvbGxiYWNrXG4gICAgICBqZXN0LnNweU9uKGNhbXBhaWduQ29udHJvbGxlciBhcyBhbnksICd2YWxpZGF0ZVBoYXNlUHJvZ3Jlc3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IFsnQ29ycnVwdGlvbiBkZXRlY3RlZCddLFxuICAgICAgICB3YXJuaW5nczogW10sXG4gICAgICB9KTtcblxuICAgICAgamVzdC5zcHlPbihjYW1wYWlnbkNvbnRyb2xsZXIsICdyb2xsYmFja1RvQ2hlY2twb2ludCcpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChjYW1wYWlnbkNvbnRyb2xsZXIuZXhlY3V0ZVBoYXNlKHBoYXNlKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnVG9vbCBleGVjdXRpb24gZmFpbGVkOiBDb3JydXB0aW9uIGRldGVjdGVkJyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChjYW1wYWlnbkNvbnRyb2xsZXIucm9sbGJhY2tUb0NoZWNrcG9pbnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbGUgU3lzdGVtIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbGUgcmVhZCBlcnJvcnMgZHVyaW5nIGNvcnJ1cHRpb24gZGV0ZWN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Blcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ3Byb3RlY3RlZC1maWxlLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbigncHJvdGVjdGVkLWZpbGUudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkhJR0gpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAucGF0dGVybiA9PT0gJ0ZJTEVfUkVBRF9FUlJPUicpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBza2lwIG5vbi1leGlzdGVudCBmaWxlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ25vbi1leGlzdGVudC50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXhlZCBmaWxlIHR5cGVzIGFwcHJvcHJpYXRlbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlcyA9IFsnc2NyaXB0LnRzJywgJ3N0eWxlLmNzcycsICdjb25maWcuanNvbicsICdyZWFkbWUubWQnXTtcblxuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3ZhbGlkIGNvbnRlbnQnKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0SW1wb3J0RXhwb3J0Q29ycnVwdGlvbihmaWxlcyk7XG5cbiAgICAgIC8vIFNob3VsZCBvbmx5IHByb2Nlc3MgVHlwZVNjcmlwdC9KYXZhU2NyaXB0IGZpbGVzXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuTE9XKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhZmV0eSBFdmVudCBUcmFja2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRyYWNrIHNhZmV0eSBldmVudHMgdGhyb3VnaG91dCBpbnRlZ3JhdGlvbiBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgc3Rhc2hcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdUZXN0IHN0YXNoJyk7XG5cbiAgICAgIC8vIERldGVjdCBjb3JydXB0aW9uXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnPDw8PDw8PCBIRUFEXFxuY29uZmxpY3RcXG4+Pj4+Pj4+IGJyYW5jaCcpO1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ3Rlc3QtZmlsZS50cyddKTtcblxuICAgICAgLy8gQXBwbHkgc3Rhc2hcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2goKGF3YWl0IHNhZmV0eVByb3RvY29sLmxpc3RTdGFzaGVzKCkpWzBdLmlkKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gc2FmZXR5UHJvdG9jb2wuZ2V0U2FmZXR5RXZlbnRzKCk7XG5cbiAgICAgIGV4cGVjdChldmVudHMuc29tZShlID0+IGUudHlwZSA9PT0gU2FmZXR5RXZlbnRUeXBlLkNIRUNLUE9JTlRfQ1JFQVRFRCkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09IFNhZmV0eUV2ZW50VHlwZS5DT1JSVVBUSU9OX0RFVEVDVEVEKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChldmVudHMuc29tZShlID0+IGUudHlwZSA9PT0gU2FmZXR5RXZlbnRUeXBlLlJPTExCQUNLX1RSSUdHRVJFRCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGV2ZW50IGhpc3Rvcnkgd2l0aCBwcm9wZXIgc2V2ZXJpdHkgbGV2ZWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR2VuZXJhdGUgZXZlbnRzIG9mIGRpZmZlcmVudCBzZXZlcml0aWVzXG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jcmVhdGVTdGFzaCgnSW5mbyBldmVudCcpOyAvLyBJTkZPXG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCc8PDw8PDw8IEhFQURcXG5jb25mbGljdFxcbj4+Pj4+Pj4gYnJhbmNoJyk7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsndGVzdC1maWxlLnRzJ10pOyAvLyBDUklUSUNBTFxuXG4gICAgICBjb25zdCBldmVudHMgPSBzYWZldHlQcm90b2NvbC5nZXRTYWZldHlFdmVudHMoKTtcbiAgICAgIGNvbnN0IHNldmVyaXRpZXMgPSBldmVudHMubWFwKGUgPT4gZS5zZXZlcml0eSk7XG5cbiAgICAgIGV4cGVjdChzZXZlcml0aWVzKS50b0NvbnRhaW4oU2FmZXR5RXZlbnRTZXZlcml0eS5JTkZPKTtcbiAgICAgIGV4cGVjdChzZXZlcml0aWVzKS50b0NvbnRhaW4oU2FmZXR5RXZlbnRTZXZlcml0eS5DUklUSUNBTCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=