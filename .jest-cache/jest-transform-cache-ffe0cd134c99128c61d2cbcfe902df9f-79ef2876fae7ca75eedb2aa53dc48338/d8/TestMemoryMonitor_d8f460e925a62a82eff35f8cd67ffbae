083ede695ece4407db2642abcddc720e
"use strict";
/**
 * TestMemoryMonitor - Memory usage tracking and management for tests
 *
 * This class provides comprehensive memory monitoring capabilities for test suites,
 * including memory usage tracking, leak detection, and cleanup procedures.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestMemoryMonitor = void 0;
class TestMemoryMonitor {
    constructor(thresholds) {
        this.snapshots = [];
        this.thresholds = {
            warningThreshold: 100,
            errorThreshold: 500,
            leakThreshold: 50,
            ...thresholds,
        };
        this.testStartTime = Date.now();
        this.gcEnabled = typeof global.gc === 'function';
        this.initialMemory = this.takeSnapshot('initial');
        // Enable garbage collection if available
        if (!this.gcEnabled && process.env.NODE_ENV === 'test') {
            console.warn('Garbage collection not available. Run tests with --expose-gc flag for better memory management.');
        }
    }
    /**
     * Take a memory snapshot with optional test name
     */
    takeSnapshot(testName) {
        const memUsage = process.memoryUsage();
        const snapshot = {
            heapUsed: memUsage.heapUsed,
            heapTotal: memUsage.heapTotal,
            external: memUsage.external,
            arrayBuffers: memUsage.arrayBuffers,
            timestamp: Date.now(),
            testName,
        };
        this.snapshots.push(snapshot);
        return snapshot;
    }
    /**
     * Check current memory usage against thresholds
     */
    checkMemoryUsage(testName) {
        const currentSnapshot = this.takeSnapshot(testName);
        const warnings = [];
        const errors = [];
        const heapUsedMB = this.bytesToMB(currentSnapshot.heapUsed);
        const memoryIncreaseMB = this.bytesToMB(currentSnapshot.heapUsed - this.initialMemory.heapUsed);
        // Check against thresholds
        if (heapUsedMB > this.thresholds.errorThreshold) {
            errors.push(`Memory usage (${heapUsedMB.toFixed(2)}MB) exceeds error threshold (${this.thresholds.errorThreshold}MB)`);
        }
        else if (heapUsedMB > this.thresholds.warningThreshold) {
            warnings.push(`Memory usage (${heapUsedMB.toFixed(2)}MB) exceeds warning threshold (${this.thresholds.warningThreshold}MB)`);
        }
        // Check for memory leaks
        if (memoryIncreaseMB > this.thresholds.leakThreshold) {
            warnings.push(`Potential memory leak detected: ${memoryIncreaseMB.toFixed(2)}MB increase since test start`);
        }
        // Log memory usage for debugging
        if (testName && (warnings.length > 0 || errors.length > 0)) {
            console.warn(`Memory check for "${testName}":`, {
                currentUsage: `${heapUsedMB.toFixed(2)}MB`,
                increase: `${memoryIncreaseMB.toFixed(2)}MB`,
                warnings,
                errors,
            });
        }
        return {
            isWithinLimits: errors.length === 0,
            warnings,
            errors,
            currentUsage: currentSnapshot,
        };
    }
    /**
     * Detect potential memory leaks by comparing snapshots
     */
    detectMemoryLeaks() {
        const leakDetails = [];
        for (let i = 1; i < this.snapshots.length; i++) {
            const current = this.snapshots[i];
            const previous = this.snapshots[i - 1];
            const increase = this.bytesToMB(current.heapUsed - previous.heapUsed);
            if (increase > this.thresholds.leakThreshold) {
                leakDetails.push({
                    testName: current.testName,
                    memoryIncrease: increase,
                    timestamp: current.timestamp,
                });
            }
        }
        return {
            hasLeaks: leakDetails.length > 0,
            leakDetails,
        };
    }
    /**
     * Force garbage collection if available
     */
    forceGarbageCollection() {
        if (this.gcEnabled && global.gc) {
            try {
                global.gc();
                return true;
            }
            catch (error) {
                console.warn('Failed to force garbage collection:', error);
                return false;
            }
        }
        return false;
    }
    /**
     * Comprehensive cleanup procedure
     */
    cleanup(testName) {
        const memoryBefore = process.memoryUsage().heapUsed;
        // Force garbage collection
        const gcPerformed = this.forceGarbageCollection();
        // Clear any global test caches
        this.clearTestCaches();
        // Take a snapshot after cleanup
        const memoryAfter = process.memoryUsage().heapUsed;
        const memoryFreed = this.bytesToMB(memoryBefore - memoryAfter);
        if (testName) {
            this.takeSnapshot(`${testName}-cleanup`);
        }
        const cleanupEffective = memoryAfter < memoryBefore;
        if (testName && memoryFreed > 1) {
            console.log(`Cleanup for "${testName}" freed ${memoryFreed.toFixed(2)}MB`);
        }
        return {
            memoryBefore: this.bytesToMB(memoryBefore),
            memoryAfter: this.bytesToMB(memoryAfter),
            gcPerformed,
            cleanupEffective,
        };
    }
    /**
     * Clear global test caches and references
     */
    clearTestCaches() {
        // Clear global test cache if it exists
        if (global.__TEST_CACHE__) {
            if (typeof global.__TEST_CACHE__.clear === 'function') {
                global.__TEST_CACHE__.clear();
            }
            else {
                global.__TEST_CACHE__ = new Map();
            }
        }
        // Clear Jest module cache for test isolation
        if (jest && jest.resetModules) {
            jest.resetModules();
        }
        // Clear any other global test references
        if (global.__TEST_REFS__) {
            global.__TEST_REFS__ = [];
        }
    }
    /**
     * Get memory usage summary
     */
    getMemorySummary() {
        const currentMemory = process.memoryUsage().heapUsed;
        const peakMemory = Math.max(...this.snapshots.map(s => s.heapUsed));
        return {
            initialMemory: this.bytesToMB(this.initialMemory.heapUsed),
            currentMemory: this.bytesToMB(currentMemory),
            peakMemory: this.bytesToMB(peakMemory),
            totalIncrease: this.bytesToMB(currentMemory - this.initialMemory.heapUsed),
            snapshotCount: this.snapshots.length,
            testDuration: Date.now() - this.testStartTime,
        };
    }
    /**
     * Generate detailed memory report
     */
    generateReport() {
        const summary = this.getMemorySummary();
        const leakAnalysis = this.detectMemoryLeaks();
        let report = `
Memory Usage Report
==================
Initial Memory: ${summary.initialMemory.toFixed(2)}MB
Current Memory: ${summary.currentMemory.toFixed(2)}MB
Peak Memory: ${summary.peakMemory.toFixed(2)}MB
Total Increase: ${summary.totalIncrease.toFixed(2)}MB
Test Duration: ${(summary.testDuration / 1000).toFixed(2)}s
Snapshots Taken: ${summary.snapshotCount}

`;
        if (leakAnalysis.hasLeaks) {
            report += `Memory Leaks Detected:\n`;
            leakAnalysis.leakDetails.forEach((leak, index) => {
                report += `  ${index + 1}. ${leak.testName || 'Unknown test'}: +${leak.memoryIncrease.toFixed(2)}MB\n`;
            });
            report += '\n';
        }
        else {
            report += 'No significant memory leaks detected.\n\n';
        }
        // Add recommendations
        if (summary.totalIncrease > this.thresholds.warningThreshold) {
            report += `Recommendations:\n`;
            report += `- Consider reducing test complexity or splitting large test suites\n`;
            report += `- Ensure proper cleanup in afterEach hooks\n`;
            report += `- Use jest.resetModules() to clear module cache\n`;
            if (!this.gcEnabled) {
                report += `- Run tests with --expose-gc flag for better memory management\n`;
            }
        }
        return report;
    }
    /**
     * Convert bytes to megabytes
     */
    bytesToMB(bytes) {
        return bytes / (1024 * 1024);
    }
    /**
     * Static method to create a monitor with default settings
     */
    static createDefault() {
        return new TestMemoryMonitor();
    }
    /**
     * Static method to create a monitor with strict settings for CI
     */
    static createForCI() {
        return new TestMemoryMonitor({
            warningThreshold: 50,
            errorThreshold: 200,
            leakThreshold: 25,
        });
    }
}
exports.TestMemoryMonitor = TestMemoryMonitor;
exports.default = TestMemoryMonitor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9fX3Rlc3RzX18vdXRpbHMvVGVzdE1lbW9yeU1vbml0b3IudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHOzs7QUFpQkgsTUFBYSxpQkFBaUI7SUFPNUIsWUFBWSxVQUFzQztRQUwxQyxjQUFTLEdBQXFCLEVBQUUsQ0FBQztRQU12QyxJQUFJLENBQUMsVUFBVSxHQUFHO1lBQ2hCLGdCQUFnQixFQUFFLEdBQUc7WUFDckIsY0FBYyxFQUFFLEdBQUc7WUFDbkIsYUFBYSxFQUFFLEVBQUU7WUFDakIsR0FBRyxVQUFVO1NBQ2QsQ0FBQztRQUVGLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxNQUFNLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQztRQUNqRCxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbEQseUNBQXlDO1FBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLE1BQU0sRUFBRTtZQUN0RCxPQUFPLENBQUMsSUFBSSxDQUNWLGlHQUFpRyxDQUNsRyxDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxZQUFZLENBQUMsUUFBaUI7UUFDNUIsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sUUFBUSxHQUFtQjtZQUMvQixRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVE7WUFDM0IsU0FBUyxFQUFFLFFBQVEsQ0FBQyxTQUFTO1lBQzdCLFFBQVEsRUFBRSxRQUFRLENBQUMsUUFBUTtZQUMzQixZQUFZLEVBQUUsUUFBUSxDQUFDLFlBQVk7WUFDbkMsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDckIsUUFBUTtTQUNULENBQUM7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aGF0VG9FYXROZXh0L3NyYy9fX3Rlc3RzX18vdXRpbHMvVGVzdE1lbW9yeU1vbml0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0TWVtb3J5TW9uaXRvciAtIE1lbW9yeSB1c2FnZSB0cmFja2luZyBhbmQgbWFuYWdlbWVudCBmb3IgdGVzdHNcbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGNvbXByZWhlbnNpdmUgbWVtb3J5IG1vbml0b3JpbmcgY2FwYWJpbGl0aWVzIGZvciB0ZXN0IHN1aXRlcyxcbiAqIGluY2x1ZGluZyBtZW1vcnkgdXNhZ2UgdHJhY2tpbmcsIGxlYWsgZGV0ZWN0aW9uLCBhbmQgY2xlYW51cCBwcm9jZWR1cmVzLlxuICovXG5cbmludGVyZmFjZSBNZW1vcnlTbmFwc2hvdCB7XG4gIGhlYXBVc2VkOiBudW1iZXI7XG4gIGhlYXBUb3RhbDogbnVtYmVyO1xuICBleHRlcm5hbDogbnVtYmVyO1xuICBhcnJheUJ1ZmZlcnM6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHRlc3ROYW1lPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTWVtb3J5VGhyZXNob2xkcyB7XG4gIHdhcm5pbmdUaHJlc2hvbGQ6IG51bWJlcjsgLy8gTUJcbiAgZXJyb3JUaHJlc2hvbGQ6IG51bWJlcjsgLy8gTUJcbiAgbGVha1RocmVzaG9sZDogbnVtYmVyOyAvLyBNQiBpbmNyZWFzZSBiZXR3ZWVuIHNuYXBzaG90c1xufVxuXG5leHBvcnQgY2xhc3MgVGVzdE1lbW9yeU1vbml0b3Ige1xuICBwcml2YXRlIGluaXRpYWxNZW1vcnk6IE1lbW9yeVNuYXBzaG90O1xuICBwcml2YXRlIHNuYXBzaG90czogTWVtb3J5U25hcHNob3RbXSA9IFtdO1xuICBwcml2YXRlIHRocmVzaG9sZHM6IE1lbW9yeVRocmVzaG9sZHM7XG4gIHByaXZhdGUgdGVzdFN0YXJ0VGltZTogbnVtYmVyO1xuICBwcml2YXRlIGdjRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcih0aHJlc2hvbGRzPzogUGFydGlhbDxNZW1vcnlUaHJlc2hvbGRzPikge1xuICAgIHRoaXMudGhyZXNob2xkcyA9IHtcbiAgICAgIHdhcm5pbmdUaHJlc2hvbGQ6IDEwMCwgLy8gMTAwTUIgd2FybmluZ1xuICAgICAgZXJyb3JUaHJlc2hvbGQ6IDUwMCwgLy8gNTAwTUIgZXJyb3JcbiAgICAgIGxlYWtUaHJlc2hvbGQ6IDUwLCAvLyA1ME1CIGxlYWsgdGhyZXNob2xkXG4gICAgICAuLi50aHJlc2hvbGRzLFxuICAgIH07XG5cbiAgICB0aGlzLnRlc3RTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZ2NFbmFibGVkID0gdHlwZW9mIGdsb2JhbC5nYyA9PT0gJ2Z1bmN0aW9uJztcbiAgICB0aGlzLmluaXRpYWxNZW1vcnkgPSB0aGlzLnRha2VTbmFwc2hvdCgnaW5pdGlhbCcpO1xuXG4gICAgLy8gRW5hYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiBpZiBhdmFpbGFibGVcbiAgICBpZiAoIXRoaXMuZ2NFbmFibGVkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ0dhcmJhZ2UgY29sbGVjdGlvbiBub3QgYXZhaWxhYmxlLiBSdW4gdGVzdHMgd2l0aCAtLWV4cG9zZS1nYyBmbGFnIGZvciBiZXR0ZXIgbWVtb3J5IG1hbmFnZW1lbnQuJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBhIG1lbW9yeSBzbmFwc2hvdCB3aXRoIG9wdGlvbmFsIHRlc3QgbmFtZVxuICAgKi9cbiAgdGFrZVNuYXBzaG90KHRlc3ROYW1lPzogc3RyaW5nKTogTWVtb3J5U25hcHNob3Qge1xuICAgIGNvbnN0IG1lbVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgIGNvbnN0IHNuYXBzaG90OiBNZW1vcnlTbmFwc2hvdCA9IHtcbiAgICAgIGhlYXBVc2VkOiBtZW1Vc2FnZS5oZWFwVXNlZCxcbiAgICAgIGhlYXBUb3RhbDogbWVtVXNhZ2UuaGVhcFRvdGFsLFxuICAgICAgZXh0ZXJuYWw6IG1lbVVzYWdlLmV4dGVybmFsLFxuICAgICAgYXJyYXlCdWZmZXJzOiBtZW1Vc2FnZS5hcnJheUJ1ZmZlcnMsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB0ZXN0TmFtZSxcbiAgICB9O1xuXG4gICAgdGhpcy5zbmFwc2hvdHMucHVzaChzbmFwc2hvdCk7XG4gICAgcmV0dXJuIHNuYXBzaG90O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGN1cnJlbnQgbWVtb3J5IHVzYWdlIGFnYWluc3QgdGhyZXNob2xkc1xuICAgKi9cbiAgY2hlY2tNZW1vcnlVc2FnZSh0ZXN0TmFtZT86IHN0cmluZyk6IHtcbiAgICBpc1dpdGhpbkxpbWl0czogYm9vbGVhbjtcbiAgICB3YXJuaW5nczogc3RyaW5nW107XG4gICAgZXJyb3JzOiBzdHJpbmdbXTtcbiAgICBjdXJyZW50VXNhZ2U6IE1lbW9yeVNuYXBzaG90O1xuICB9IHtcbiAgICBjb25zdCBjdXJyZW50U25hcHNob3QgPSB0aGlzLnRha2VTbmFwc2hvdCh0ZXN0TmFtZSk7XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3QgaGVhcFVzZWRNQiA9IHRoaXMuYnl0ZXNUb01CKGN1cnJlbnRTbmFwc2hvdC5oZWFwVXNlZCk7XG4gICAgY29uc3QgbWVtb3J5SW5jcmVhc2VNQiA9IHRoaXMuYnl0ZXNUb01CKFxuICAgICAgY3VycmVudFNuYXBzaG90LmhlYXBVc2VkIC0gdGhpcy5pbml0aWFsTWVtb3J5LmhlYXBVc2VkXG4gICAgKTtcblxuICAgIC8vIENoZWNrIGFnYWluc3QgdGhyZXNob2xkc1xuICAgIGlmIChoZWFwVXNlZE1CID4gdGhpcy50aHJlc2hvbGRzLmVycm9yVGhyZXNob2xkKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgYE1lbW9yeSB1c2FnZSAoJHtoZWFwVXNlZE1CLnRvRml4ZWQoMil9TUIpIGV4Y2VlZHMgZXJyb3IgdGhyZXNob2xkICgke3RoaXMudGhyZXNob2xkcy5lcnJvclRocmVzaG9sZH1NQilgXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaGVhcFVzZWRNQiA+IHRoaXMudGhyZXNob2xkcy53YXJuaW5nVGhyZXNob2xkKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKFxuICAgICAgICBgTWVtb3J5IHVzYWdlICgke2hlYXBVc2VkTUIudG9GaXhlZCgyKX1NQikgZXhjZWVkcyB3YXJuaW5nIHRocmVzaG9sZCAoJHt0aGlzLnRocmVzaG9sZHMud2FybmluZ1RocmVzaG9sZH1NQilgXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBtZW1vcnkgbGVha3NcbiAgICBpZiAobWVtb3J5SW5jcmVhc2VNQiA+IHRoaXMudGhyZXNob2xkcy5sZWFrVGhyZXNob2xkKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKFxuICAgICAgICBgUG90ZW50aWFsIG1lbW9yeSBsZWFrIGRldGVjdGVkOiAke21lbW9yeUluY3JlYXNlTUIudG9GaXhlZCgyKX1NQiBpbmNyZWFzZSBzaW5jZSB0ZXN0IHN0YXJ0YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBMb2cgbWVtb3J5IHVzYWdlIGZvciBkZWJ1Z2dpbmdcbiAgICBpZiAodGVzdE5hbWUgJiYgKHdhcm5pbmdzLmxlbmd0aCA+IDAgfHwgZXJyb3JzLmxlbmd0aCA+IDApKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1lbW9yeSBjaGVjayBmb3IgXCIke3Rlc3ROYW1lfVwiOmAsIHtcbiAgICAgICAgY3VycmVudFVzYWdlOiBgJHtoZWFwVXNlZE1CLnRvRml4ZWQoMil9TUJgLFxuICAgICAgICBpbmNyZWFzZTogYCR7bWVtb3J5SW5jcmVhc2VNQi50b0ZpeGVkKDIpfU1CYCxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIGVycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1dpdGhpbkxpbWl0czogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgZXJyb3JzLFxuICAgICAgY3VycmVudFVzYWdlOiBjdXJyZW50U25hcHNob3QsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgcG90ZW50aWFsIG1lbW9yeSBsZWFrcyBieSBjb21wYXJpbmcgc25hcHNob3RzXG4gICAqL1xuICBkZXRlY3RNZW1vcnlMZWFrcygpOiB7XG4gICAgaGFzTGVha3M6IGJvb2xlYW47XG4gICAgbGVha0RldGFpbHM6IEFycmF5PHtcbiAgICAgIHRlc3ROYW1lPzogc3RyaW5nO1xuICAgICAgbWVtb3J5SW5jcmVhc2U6IG51bWJlcjtcbiAgICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgIH0+O1xuICB9IHtcbiAgICBjb25zdCBsZWFrRGV0YWlsczogQXJyYXk8e1xuICAgICAgdGVzdE5hbWU/OiBzdHJpbmc7XG4gICAgICBtZW1vcnlJbmNyZWFzZTogbnVtYmVyO1xuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgfT4gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5zbmFwc2hvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnNuYXBzaG90c1tpXTtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5zbmFwc2hvdHNbaSAtIDFdO1xuICAgICAgY29uc3QgaW5jcmVhc2UgPSB0aGlzLmJ5dGVzVG9NQihjdXJyZW50LmhlYXBVc2VkIC0gcHJldmlvdXMuaGVhcFVzZWQpO1xuXG4gICAgICBpZiAoaW5jcmVhc2UgPiB0aGlzLnRocmVzaG9sZHMubGVha1RocmVzaG9sZCkge1xuICAgICAgICBsZWFrRGV0YWlscy5wdXNoKHtcbiAgICAgICAgICB0ZXN0TmFtZTogY3VycmVudC50ZXN0TmFtZSxcbiAgICAgICAgICBtZW1vcnlJbmNyZWFzZTogaW5jcmVhc2UsXG4gICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50LnRpbWVzdGFtcCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0xlYWtzOiBsZWFrRGV0YWlscy5sZW5ndGggPiAwLFxuICAgICAgbGVha0RldGFpbHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAqL1xuICBmb3JjZUdhcmJhZ2VDb2xsZWN0aW9uKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmdjRW5hYmxlZCAmJiBnbG9iYWwuZ2MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbC5nYygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGZvcmNlIGdhcmJhZ2UgY29sbGVjdGlvbjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZWhlbnNpdmUgY2xlYW51cCBwcm9jZWR1cmVcbiAgICovXG4gIGNsZWFudXAodGVzdE5hbWU/OiBzdHJpbmcpOiB7XG4gICAgbWVtb3J5QmVmb3JlOiBudW1iZXI7XG4gICAgbWVtb3J5QWZ0ZXI6IG51bWJlcjtcbiAgICBnY1BlcmZvcm1lZDogYm9vbGVhbjtcbiAgICBjbGVhbnVwRWZmZWN0aXZlOiBib29sZWFuO1xuICB9IHtcbiAgICBjb25zdCBtZW1vcnlCZWZvcmUgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICBjb25zdCBnY1BlcmZvcm1lZCA9IHRoaXMuZm9yY2VHYXJiYWdlQ29sbGVjdGlvbigpO1xuXG4gICAgLy8gQ2xlYXIgYW55IGdsb2JhbCB0ZXN0IGNhY2hlc1xuICAgIHRoaXMuY2xlYXJUZXN0Q2FjaGVzKCk7XG5cbiAgICAvLyBUYWtlIGEgc25hcHNob3QgYWZ0ZXIgY2xlYW51cFxuICAgIGNvbnN0IG1lbW9yeUFmdGVyID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgIGNvbnN0IG1lbW9yeUZyZWVkID0gdGhpcy5ieXRlc1RvTUIobWVtb3J5QmVmb3JlIC0gbWVtb3J5QWZ0ZXIpO1xuXG4gICAgaWYgKHRlc3ROYW1lKSB7XG4gICAgICB0aGlzLnRha2VTbmFwc2hvdChgJHt0ZXN0TmFtZX0tY2xlYW51cGApO1xuICAgIH1cblxuICAgIGNvbnN0IGNsZWFudXBFZmZlY3RpdmUgPSBtZW1vcnlBZnRlciA8IG1lbW9yeUJlZm9yZTtcblxuICAgIGlmICh0ZXN0TmFtZSAmJiBtZW1vcnlGcmVlZCA+IDEpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgQ2xlYW51cCBmb3IgXCIke3Rlc3ROYW1lfVwiIGZyZWVkICR7bWVtb3J5RnJlZWQudG9GaXhlZCgyKX1NQmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lbW9yeUJlZm9yZTogdGhpcy5ieXRlc1RvTUIobWVtb3J5QmVmb3JlKSxcbiAgICAgIG1lbW9yeUFmdGVyOiB0aGlzLmJ5dGVzVG9NQihtZW1vcnlBZnRlciksXG4gICAgICBnY1BlcmZvcm1lZCxcbiAgICAgIGNsZWFudXBFZmZlY3RpdmUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBnbG9iYWwgdGVzdCBjYWNoZXMgYW5kIHJlZmVyZW5jZXNcbiAgICovXG4gIHByaXZhdGUgY2xlYXJUZXN0Q2FjaGVzKCk6IHZvaWQge1xuICAgIC8vIENsZWFyIGdsb2JhbCB0ZXN0IGNhY2hlIGlmIGl0IGV4aXN0c1xuICAgIGlmIChnbG9iYWwuX19URVNUX0NBQ0hFX18pIHtcbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsLl9fVEVTVF9DQUNIRV9fLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGdsb2JhbC5fX1RFU1RfQ0FDSEVfXy5jbGVhcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLl9fVEVTVF9DQUNIRV9fID0gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIEplc3QgbW9kdWxlIGNhY2hlIGZvciB0ZXN0IGlzb2xhdGlvblxuICAgIGlmIChqZXN0ICYmIGplc3QucmVzZXRNb2R1bGVzKSB7XG4gICAgICBqZXN0LnJlc2V0TW9kdWxlcygpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFueSBvdGhlciBnbG9iYWwgdGVzdCByZWZlcmVuY2VzXG4gICAgaWYgKGdsb2JhbC5fX1RFU1RfUkVGU19fKSB7XG4gICAgICBnbG9iYWwuX19URVNUX1JFRlNfXyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbWVtb3J5IHVzYWdlIHN1bW1hcnlcbiAgICovXG4gIGdldE1lbW9yeVN1bW1hcnkoKToge1xuICAgIGluaXRpYWxNZW1vcnk6IG51bWJlcjtcbiAgICBjdXJyZW50TWVtb3J5OiBudW1iZXI7XG4gICAgcGVha01lbW9yeTogbnVtYmVyO1xuICAgIHRvdGFsSW5jcmVhc2U6IG51bWJlcjtcbiAgICBzbmFwc2hvdENvdW50OiBudW1iZXI7XG4gICAgdGVzdER1cmF0aW9uOiBudW1iZXI7XG4gIH0ge1xuICAgIGNvbnN0IGN1cnJlbnRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgY29uc3QgcGVha01lbW9yeSA9IE1hdGgubWF4KC4uLnRoaXMuc25hcHNob3RzLm1hcChzID0+IHMuaGVhcFVzZWQpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsTWVtb3J5OiB0aGlzLmJ5dGVzVG9NQih0aGlzLmluaXRpYWxNZW1vcnkuaGVhcFVzZWQpLFxuICAgICAgY3VycmVudE1lbW9yeTogdGhpcy5ieXRlc1RvTUIoY3VycmVudE1lbW9yeSksXG4gICAgICBwZWFrTWVtb3J5OiB0aGlzLmJ5dGVzVG9NQihwZWFrTWVtb3J5KSxcbiAgICAgIHRvdGFsSW5jcmVhc2U6IHRoaXMuYnl0ZXNUb01CKFxuICAgICAgICBjdXJyZW50TWVtb3J5IC0gdGhpcy5pbml0aWFsTWVtb3J5LmhlYXBVc2VkXG4gICAgICApLFxuICAgICAgc25hcHNob3RDb3VudDogdGhpcy5zbmFwc2hvdHMubGVuZ3RoLFxuICAgICAgdGVzdER1cmF0aW9uOiBEYXRlLm5vdygpIC0gdGhpcy50ZXN0U3RhcnRUaW1lLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZGV0YWlsZWQgbWVtb3J5IHJlcG9ydFxuICAgKi9cbiAgZ2VuZXJhdGVSZXBvcnQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBzdW1tYXJ5ID0gdGhpcy5nZXRNZW1vcnlTdW1tYXJ5KCk7XG4gICAgY29uc3QgbGVha0FuYWx5c2lzID0gdGhpcy5kZXRlY3RNZW1vcnlMZWFrcygpO1xuXG4gICAgbGV0IHJlcG9ydCA9IGBcbk1lbW9yeSBVc2FnZSBSZXBvcnRcbj09PT09PT09PT09PT09PT09PVxuSW5pdGlhbCBNZW1vcnk6ICR7c3VtbWFyeS5pbml0aWFsTWVtb3J5LnRvRml4ZWQoMil9TUJcbkN1cnJlbnQgTWVtb3J5OiAke3N1bW1hcnkuY3VycmVudE1lbW9yeS50b0ZpeGVkKDIpfU1CXG5QZWFrIE1lbW9yeTogJHtzdW1tYXJ5LnBlYWtNZW1vcnkudG9GaXhlZCgyKX1NQlxuVG90YWwgSW5jcmVhc2U6ICR7c3VtbWFyeS50b3RhbEluY3JlYXNlLnRvRml4ZWQoMil9TUJcblRlc3QgRHVyYXRpb246ICR7KHN1bW1hcnkudGVzdER1cmF0aW9uIC8gMTAwMCkudG9GaXhlZCgyKX1zXG5TbmFwc2hvdHMgVGFrZW46ICR7c3VtbWFyeS5zbmFwc2hvdENvdW50fVxuXG5gO1xuXG4gICAgaWYgKGxlYWtBbmFseXNpcy5oYXNMZWFrcykge1xuICAgICAgcmVwb3J0ICs9IGBNZW1vcnkgTGVha3MgRGV0ZWN0ZWQ6XFxuYDtcbiAgICAgIGxlYWtBbmFseXNpcy5sZWFrRGV0YWlscy5mb3JFYWNoKChsZWFrLCBpbmRleCkgPT4ge1xuICAgICAgICByZXBvcnQgKz0gYCAgJHtpbmRleCArIDF9LiAke2xlYWsudGVzdE5hbWUgfHwgJ1Vua25vd24gdGVzdCd9OiArJHtsZWFrLm1lbW9yeUluY3JlYXNlLnRvRml4ZWQoMil9TUJcXG5gO1xuICAgICAgfSk7XG4gICAgICByZXBvcnQgKz0gJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydCArPSAnTm8gc2lnbmlmaWNhbnQgbWVtb3J5IGxlYWtzIGRldGVjdGVkLlxcblxcbic7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlY29tbWVuZGF0aW9uc1xuICAgIGlmIChzdW1tYXJ5LnRvdGFsSW5jcmVhc2UgPiB0aGlzLnRocmVzaG9sZHMud2FybmluZ1RocmVzaG9sZCkge1xuICAgICAgcmVwb3J0ICs9IGBSZWNvbW1lbmRhdGlvbnM6XFxuYDtcbiAgICAgIHJlcG9ydCArPSBgLSBDb25zaWRlciByZWR1Y2luZyB0ZXN0IGNvbXBsZXhpdHkgb3Igc3BsaXR0aW5nIGxhcmdlIHRlc3Qgc3VpdGVzXFxuYDtcbiAgICAgIHJlcG9ydCArPSBgLSBFbnN1cmUgcHJvcGVyIGNsZWFudXAgaW4gYWZ0ZXJFYWNoIGhvb2tzXFxuYDtcbiAgICAgIHJlcG9ydCArPSBgLSBVc2UgamVzdC5yZXNldE1vZHVsZXMoKSB0byBjbGVhciBtb2R1bGUgY2FjaGVcXG5gO1xuICAgICAgaWYgKCF0aGlzLmdjRW5hYmxlZCkge1xuICAgICAgICByZXBvcnQgKz0gYC0gUnVuIHRlc3RzIHdpdGggLS1leHBvc2UtZ2MgZmxhZyBmb3IgYmV0dGVyIG1lbW9yeSBtYW5hZ2VtZW50XFxuYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVwb3J0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYnl0ZXMgdG8gbWVnYWJ5dGVzXG4gICAqL1xuICBwcml2YXRlIGJ5dGVzVG9NQihieXRlczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYnl0ZXMgLyAoMTAyNCAqIDEwMjQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdG8gY3JlYXRlIGEgbW9uaXRvciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVEZWZhdWx0KCk6IFRlc3RNZW1vcnlNb25pdG9yIHtcbiAgICByZXR1cm4gbmV3IFRlc3RNZW1vcnlNb25pdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBtb25pdG9yIHdpdGggc3RyaWN0IHNldHRpbmdzIGZvciBDSVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUZvckNJKCk6IFRlc3RNZW1vcnlNb25pdG9yIHtcbiAgICByZXR1cm4gbmV3IFRlc3RNZW1vcnlNb25pdG9yKHtcbiAgICAgIHdhcm5pbmdUaHJlc2hvbGQ6IDUwLCAvLyBMb3dlciB0aHJlc2hvbGRzIGZvciBDSVxuICAgICAgZXJyb3JUaHJlc2hvbGQ6IDIwMCxcbiAgICAgIGxlYWtUaHJlc2hvbGQ6IDI1LFxuICAgIH0pO1xuICB9XG59XG5cbi8vIEdsb2JhbCB0eXBlIGRlY2xhcmF0aW9uc1xuZGVjbGFyZSBnbG9iYWwge1xuICB2YXIgZ2M6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgdmFyIF9fVEVTVF9DQUNIRV9fOiBNYXA8c3RyaW5nLCBhbnk+IHwgeyBjbGVhcjogKCkgPT4gdm9pZCB9IHwgdW5kZWZpbmVkO1xuICB2YXIgX19URVNUX1JFRlNfXzogYW55W10gfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRlc3RNZW1vcnlNb25pdG9yO1xuIl0sInZlcnNpb24iOjN9