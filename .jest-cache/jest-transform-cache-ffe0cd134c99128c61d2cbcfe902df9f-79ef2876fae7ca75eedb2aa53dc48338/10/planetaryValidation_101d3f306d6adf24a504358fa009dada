b7dc666f3560e8a5adec310004d8ba2a
"use strict";
/**
 * Planetary Data Validation Utilities
 *
 * This module provides comprehensive validation for planetary data integrity,
 * transit date accuracy, and astronomical calculation consistency.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateElementalProperties = exports.runAstronomicalTests = exports.validatePositionConsistency = exports.validateTransitDates = exports.shouldRollback = exports.validatePlanetaryData = void 0;
const reliableAstronomy_1 = require("./reliableAstronomy");
const logger_1 = require("./logger");
// Validation tolerances
const VALIDATION_TOLERANCES = {
    POSITION_DEGREES: 0.1,
    TRANSIT_DAYS: 1,
    TEST_PASS_THRESHOLD: 95,
    API_TIMEOUT_MS: 5000,
};
/**
 * Main validation function for planetary data
 */
async function validatePlanetaryData() {
    const startTime = Date.now();
    const errors = [];
    const warnings = [];
    try {
        logger_1.logger.info('Starting comprehensive planetary data validation');
        // 1. Validate transit dates
        const transitValidation = await validateTransitDates();
        errors.push(...transitValidation.errors);
        warnings.push(...transitValidation.warnings);
        // 2. Check position consistency
        const positionValidation = await validatePositionConsistency();
        errors.push(...positionValidation.errors);
        warnings.push(...positionValidation.warnings);
        // 3. Run astronomical tests
        const testResults = await runAstronomicalTests();
        const testValidation = analyzeTestResults(testResults);
        errors.push(...testValidation.errors);
        warnings.push(...testValidation.warnings);
        // 4. Validate elemental properties consistency
        const elementalValidation = await validateElementalProperties();
        errors.push(...elementalValidation.errors);
        warnings.push(...elementalValidation.warnings);
        const duration = Date.now() - startTime;
        const isValid = errors.filter(e => e.severity === 'CRITICAL' || e.severity === 'HIGH')
            .length === 0;
        const summary = generateValidationSummary(isValid, errors, warnings, duration);
        logger_1.logger.info(`Planetary validation completed in ${duration}ms: ${isValid ? 'PASSED' : 'FAILED'}`);
        return {
            isValid,
            errors,
            warnings,
            summary,
            timestamp: new Date(),
        };
    }
    catch (error) {
        const criticalError = {
            type: 'DATA_CORRUPTION',
            severity: 'CRITICAL',
            message: `Validation process failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            timestamp: new Date(),
        };
        return {
            isValid: false,
            errors: [criticalError],
            warnings,
            summary: 'Critical validation failure - process could not complete',
            timestamp: new Date(),
        };
    }
}
exports.validatePlanetaryData = validatePlanetaryData;
/**
 * Validate transit dates against current astronomical data
 */
async function validateTransitDates() {
    var _a;
    const errors = [];
    const warnings = [];
    try {
        const planets = ['mars', 'venus', 'mercury', 'jupiter', 'saturn'];
        const currentDate = new Date();
        for (const planetName of planets) {
            try {
                // Dynamically import planet data
                const planetModule = await Promise.resolve(`${`../data/planets/${planetName}`}`).then(s => __importStar(require(s)));
                const planetData = planetModule.default;
                if ((_a = planetData === null || planetData === void 0 ? void 0 : planetData.PlanetSpecific) === null || _a === void 0 ? void 0 : _a.TransitDates) {
                    const transitDates = planetData.PlanetSpecific.TransitDates;
                    const validation = validatePlanetTransitDates(planetName, transitDates, currentDate);
                    errors.push(...validation.errors);
                    warnings.push(...validation.warnings);
                }
                else {
                    // This is just a warning, not an error, since not all planets may have transit dates
                    warnings.push({
                        type: 'DATA_OUTDATED',
                        planet: planetName,
                        message: `No transit dates found for ${planetName}`,
                        timestamp: new Date(),
                    });
                }
            }
            catch (error) {
                // Only treat as medium severity since missing transit data is not critical
                warnings.push({
                    type: 'DATA_OUTDATED',
                    planet: planetName,
                    message: `Could not load transit data for ${planetName}: ${error instanceof Error ? error.message : 'Unknown error'}`,
                    timestamp: new Date(),
                });
            }
        }
    }
    catch (error) {
        errors.push({
            type: 'DATA_CORRUPTION',
            severity: 'MEDIUM',
            message: `Transit date validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            timestamp: new Date(),
        });
    }
    return { errors, warnings };
}
exports.validateTransitDates = validateTransitDates;
/**
 * Validate individual planet transit dates
 */
function validatePlanetTransitDates(planetName, transitDates, currentDate) {
    const errors = [];
    const warnings = [];
    try {
        const signs = Object.keys(transitDates);
        for (const sign of signs) {
            const transit = transitDates[sign];
            // Skip complex structures like RetrogradePhases that don't have simple Start/End
            if (!transit || typeof transit !== 'object') {
                continue;
            }
            // Handle different transit data structures
            if (transit.Start && transit.End) {
                // Standard transit format
                const startDate = new Date(transit.Start);
                const endDate = new Date(transit.End);
                // Check date validity
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                    // Only warn for invalid dates, don't treat as high severity
                    warnings.push({
                        type: 'DATA_OUTDATED',
                        planet: planetName,
                        message: `Invalid transit dates for ${planetName} in ${sign}: Start=${transit.Start}, End=${transit.End}`,
                        timestamp: new Date(),
                    });
                    continue;
                }
                // Check logical order
                if (startDate >= endDate) {
                    warnings.push({
                        type: 'DATA_OUTDATED',
                        planet: planetName,
                        message: `Transit start date is after end date for ${planetName} in ${sign}`,
                        timestamp: new Date(),
                    });
                }
                // Check if dates are too far in the past or future
                const daysDiff = Math.abs(currentDate.getTime() - startDate.getTime()) /
                    (1000 * 60 * 60 * 24);
                if (daysDiff > 365 * 2) {
                    // More than 2 years old
                    warnings.push({
                        type: 'DATA_OUTDATED',
                        planet: planetName,
                        message: `Transit data for ${planetName} in ${sign} is ${Math.round(daysDiff)} days old`,
                        timestamp: new Date(),
                    });
                }
            }
            else if (typeof transit === 'object' &&
                Object.keys(transit).length > 0) {
                // Complex structure like RetrogradePhases - validate nested structures
                for (const [key, value] of Object.entries(transit)) {
                    if (value &&
                        typeof value === 'object' &&
                        'Start' in value &&
                        'End' in value) {
                        const nestedTransit = value;
                        const startDate = new Date(nestedTransit.Start);
                        const endDate = new Date(nestedTransit.End);
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                            warnings.push({
                                type: 'DATA_OUTDATED',
                                planet: planetName,
                                message: `Invalid nested transit dates for ${planetName} in ${sign}.${key}`,
                                timestamp: new Date(),
                            });
                        }
                    }
                }
            }
        }
    }
    catch (error) {
        warnings.push({
            type: 'DATA_OUTDATED',
            planet: planetName,
            message: `Error validating transit dates for ${planetName}: ${error instanceof Error ? error.message : 'Unknown error'}`,
            timestamp: new Date(),
        });
    }
    return { errors, warnings };
}
/**
 * Check position consistency between calculated and stored data
 */
async function validatePositionConsistency() {
    const errors = [];
    const warnings = [];
    try {
        // Get current calculated positions
        const currentPositions = await (0, reliableAstronomy_1.getReliablePlanetaryPositions)();
        // Compare with expected ranges based on transit dates
        for (const [planetName, position] of Object.entries(currentPositions)) {
            if (typeof position === 'object' && position !== null) {
                const pos = position;
                if (typeof pos.degree === 'number' &&
                    typeof pos.exactLongitude === 'number') {
                    // Validate degree is within valid range (0-30)
                    if (pos.degree < 0 || pos.degree >= 30) {
                        errors.push({
                            type: 'POSITION_DRIFT',
                            severity: 'HIGH',
                            planet: planetName,
                            actualValue: pos.degree,
                            message: `Invalid degree value for ${planetName}: ${pos.degree} (should be 0-30)`,
                            timestamp: new Date(),
                        });
                    }
                    // Validate longitude is within valid range (0-360)
                    if (pos.exactLongitude < 0 || pos.exactLongitude >= 360) {
                        errors.push({
                            type: 'POSITION_DRIFT',
                            severity: 'HIGH',
                            planet: planetName,
                            actualValue: pos.exactLongitude,
                            message: `Invalid longitude value for ${planetName}: ${pos.exactLongitude} (should be 0-360)`,
                            timestamp: new Date(),
                        });
                    }
                    // Check for reasonable position changes (not too rapid)
                    const positionValidation = await validatePositionChange(planetName, pos);
                    errors.push(...positionValidation.errors);
                    warnings.push(...positionValidation.warnings);
                }
            }
        }
    }
    catch (error) {
        errors.push({
            type: 'API_TIMEOUT',
            severity: 'MEDIUM',
            message: `Position consistency check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            timestamp: new Date(),
        });
    }
    return { errors, warnings };
}
exports.validatePositionConsistency = validatePositionConsistency;
/**
 * Validate position changes are within reasonable bounds
 */
async function validatePositionChange(planetName, currentPosition) {
    const errors = [];
    const warnings = [];
    try {
        // Get expected daily motion for the planet
        const dailyMotion = getPlanetaryDailyMotion(planetName);
        // For now, just validate the position is reasonable
        // In a full implementation, we would compare with previous positions
        // Check if position seems reasonable for the planet
        const expectedSigns = await getExpectedSignsForPlanet(planetName);
        if (expectedSigns.length > 0 &&
            !expectedSigns.includes(currentPosition.sign)) {
            warnings.push({
                type: 'MINOR_DRIFT',
                planet: planetName,
                message: `${planetName} in unexpected sign ${currentPosition.sign}, expected one of: ${expectedSigns.join(', ')}`,
                timestamp: new Date(),
            });
        }
    }
    catch (error) {
        // Non-critical error, just log it
        warnings.push({
            type: 'MINOR_DRIFT',
            planet: planetName,
            message: `Could not validate position change for ${planetName}: ${error instanceof Error ? error.message : 'Unknown error'}`,
            timestamp: new Date(),
        });
    }
    return { errors, warnings };
}
/**
 * Get expected daily motion for a planet (approximate values)
 */
function getPlanetaryDailyMotion(planetName) {
    const dailyMotions = {
        sun: 1.0,
        moon: 13.2,
        mercury: 1.4,
        venus: 1.2,
        mars: 0.5,
        jupiter: 0.08,
        saturn: 0.03,
        uranus: 0.01,
        neptune: 0.006,
        pluto: 0.004,
    };
    return dailyMotions[planetName.toLowerCase()] || 0.1;
}
/**
 * Get expected signs for a planet based on current transit data
 */
async function getExpectedSignsForPlanet(planetName) {
    var _a;
    try {
        const planetModule = await Promise.resolve(`${`../data/planets/${planetName.toLowerCase()}`}`).then(s => __importStar(require(s)));
        const planetData = planetModule.default;
        if ((_a = planetData.PlanetSpecific) === null || _a === void 0 ? void 0 : _a.TransitDates) {
            const currentDate = new Date();
            const transitDates = planetData.PlanetSpecific.TransitDates;
            // Find signs where the planet could currently be
            const possibleSigns = [];
            for (const [sign, dates] of Object.entries(transitDates)) {
                const startDate = new Date(dates.Start);
                const endDate = new Date(dates.End);
                // Add some buffer for date accuracy
                const bufferDays = 7;
                const bufferedStart = new Date(startDate.getTime() - bufferDays * 24 * 60 * 60 * 1000);
                const bufferedEnd = new Date(endDate.getTime() + bufferDays * 24 * 60 * 60 * 1000);
                if (currentDate >= bufferedStart && currentDate <= bufferedEnd) {
                    possibleSigns.push(sign);
                }
            }
            return possibleSigns;
        }
    }
    catch (error) {
        // If we can't load the data, return empty array (no validation)
        return [];
    }
    return [];
}
/**
 * Run comprehensive astronomical calculation tests
 */
async function runAstronomicalTests() {
    const testResults = [];
    // Test 1: Planetary position calculation accuracy
    testResults.push(await testPlanetaryPositionAccuracy());
    // Test 2: Transit date validation
    testResults.push(await testTransitDateValidation());
    // Test 3: Retrograde detection
    testResults.push(await testRetrogradeDetection());
    // Test 4: Lunar node calculation
    testResults.push(await testLunarNodeCalculation());
    // Test 5: API fallback mechanism
    testResults.push(await testApiFallbackMechanism());
    return testResults;
}
exports.runAstronomicalTests = runAstronomicalTests;
/**
 * Test planetary position calculation accuracy
 */
async function testPlanetaryPositionAccuracy() {
    const startTime = Date.now();
    try {
        const positions = await (0, reliableAstronomy_1.getReliablePlanetaryPositions)();
        const requiredPlanets = [
            'sun',
            'moon',
            'mercury',
            'venus',
            'mars',
            'jupiter',
            'saturn',
        ];
        let passedChecks = 0;
        const totalChecks = requiredPlanets.length;
        for (const planet of requiredPlanets) {
            if (positions[planet] && typeof positions[planet] === 'object') {
                const pos = positions[planet];
                if (typeof pos.degree === 'number' &&
                    typeof pos.exactLongitude === 'number' &&
                    pos.sign) {
                    passedChecks++;
                }
            }
        }
        const passed = passedChecks === totalChecks;
        const duration = Date.now() - startTime;
        return {
            testName: 'Planetary Position Accuracy',
            passed,
            duration,
            details: {
                passedChecks,
                totalChecks,
                successRate: (passedChecks / totalChecks) * 100,
            },
        };
    }
    catch (error) {
        return {
            testName: 'Planetary Position Accuracy',
            passed: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}
/**
 * Test transit date validation
 */
async function testTransitDateValidation() {
    var _a;
    const startTime = Date.now();
    try {
        const planets = ['mars', 'venus', 'mercury'];
        let validTransits = 0;
        const totalPlanets = planets.length;
        for (const planet of planets) {
            try {
                const planetModule = await Promise.resolve(`${`../data/planets/${planet}`}`).then(s => __importStar(require(s)));
                const transitDates = (_a = planetModule.default.PlanetSpecific) === null || _a === void 0 ? void 0 : _a.TransitDates;
                if (transitDates && Object.keys(transitDates).length > 0) {
                    validTransits++;
                }
            }
            catch (error) {
                // Planet data not found or invalid
            }
        }
        const passed = validTransits === totalPlanets;
        const duration = Date.now() - startTime;
        return {
            testName: 'Transit Date Validation',
            passed,
            duration,
            details: {
                validTransits,
                totalPlanets,
                successRate: (validTransits / totalPlanets) * 100,
            },
        };
    }
    catch (error) {
        return {
            testName: 'Transit Date Validation',
            passed: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}
/**
 * Test retrograde detection
 */
async function testRetrogradeDetection() {
    const startTime = Date.now();
    try {
        const positions = await (0, reliableAstronomy_1.getReliablePlanetaryPositions)();
        const retrogradeCapablePlanets = [
            'mercury',
            'venus',
            'mars',
            'jupiter',
            'saturn',
            'uranus',
            'neptune',
            'pluto',
        ];
        let validRetrogradeData = 0;
        const totalPlanets = retrogradeCapablePlanets.length;
        for (const planet of retrogradeCapablePlanets) {
            if (positions[planet] && typeof positions[planet] === 'object') {
                const pos = positions[planet];
                if (typeof pos.isRetrograde === 'boolean') {
                    validRetrogradeData++;
                }
            }
        }
        const passed = validRetrogradeData === totalPlanets;
        const duration = Date.now() - startTime;
        return {
            testName: 'Retrograde Detection',
            passed,
            duration,
            details: {
                validRetrogradeData,
                totalPlanets,
                successRate: (validRetrogradeData / totalPlanets) * 100,
            },
        };
    }
    catch (error) {
        return {
            testName: 'Retrograde Detection',
            passed: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}
/**
 * Test lunar node calculation
 */
async function testLunarNodeCalculation() {
    const startTime = Date.now();
    try {
        const positions = await (0, reliableAstronomy_1.getReliablePlanetaryPositions)();
        const northNode = positions.northNode;
        const southNode = positions.southNode;
        let passed = true;
        const details = {};
        // Check north node
        if (!northNode || typeof northNode.degree !== 'number' || !northNode.sign) {
            passed = false;
            details.northNodeError = 'Invalid north node data';
        }
        // Check south node
        if (!southNode || typeof southNode.degree !== 'number' || !southNode.sign) {
            passed = false;
            details.southNodeError = 'Invalid south node data';
        }
        // Check that nodes are opposite (180 degrees apart)
        if (passed && northNode && southNode) {
            const longitudeDiff = Math.abs(northNode.exactLongitude - southNode.exactLongitude);
            const isOpposite = Math.abs(longitudeDiff - 180) < 1; // Within 1 degree tolerance
            if (!isOpposite) {
                passed = false;
                details.oppositionError = `Nodes not opposite: ${longitudeDiff} degrees apart`;
            }
        }
        const duration = Date.now() - startTime;
        return {
            testName: 'Lunar Node Calculation',
            passed,
            duration,
            details,
            error: passed
                ? undefined
                : `Lunar nodes validation failed: ${JSON.stringify(details)}`,
        };
    }
    catch (error) {
        return {
            testName: 'Lunar Node Calculation',
            passed: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}
/**
 * Test API fallback mechanism
 */
async function testApiFallbackMechanism() {
    const startTime = Date.now();
    try {
        // Test that we can get positions even if APIs fail
        // This should fall back to the March 2025 positions
        const positions = await (0, reliableAstronomy_1.getReliablePlanetaryPositions)();
        const requiredPlanets = ['sun', 'moon', 'mercury', 'venus', 'mars'];
        let validPositions = 0;
        for (const planet of requiredPlanets) {
            if (positions[planet] && typeof positions[planet] === 'object') {
                const pos = positions[planet];
                if (pos.sign && typeof pos.degree === 'number') {
                    validPositions++;
                }
            }
        }
        const passed = validPositions === requiredPlanets.length;
        const duration = Date.now() - startTime;
        return {
            testName: 'API Fallback Mechanism',
            passed,
            duration,
            details: {
                validPositions,
                totalRequired: requiredPlanets.length,
                successRate: (validPositions / requiredPlanets.length) * 100,
            },
        };
    }
    catch (error) {
        return {
            testName: 'API Fallback Mechanism',
            passed: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}
/**
 * Validate elemental properties consistency
 */
async function validateElementalProperties() {
    const errors = [];
    const warnings = [];
    try {
        const planets = [
            'sun',
            'moon',
            'mercury',
            'venus',
            'mars',
            'jupiter',
            'saturn',
        ];
        for (const planetName of planets) {
            try {
                const planetModule = await Promise.resolve(`${`../data/planets/${planetName}`}`).then(s => __importStar(require(s)));
                const planetData = planetModule.default;
                // Check elemental properties
                if ((planetData === null || planetData === void 0 ? void 0 : planetData.Elements) && Array.isArray(planetData.Elements)) {
                    const validElements = ['Fire', 'Water', 'Earth', 'Air'];
                    const invalidElements = planetData.Elements.filter((el) => !validElements.includes(el));
                    if (invalidElements.length > 0) {
                        errors.push({
                            type: 'DATA_CORRUPTION',
                            severity: 'MEDIUM',
                            planet: planetName,
                            message: `Invalid elements for ${planetName}: ${invalidElements.join(', ')}`,
                            timestamp: new Date(),
                        });
                    }
                }
                // Check alchemical properties
                if (planetData === null || planetData === void 0 ? void 0 : planetData.Alchemy) {
                    const requiredAlchemical = [
                        'Spirit',
                        'Essence',
                        'Matter',
                        'Substance',
                    ];
                    const missingAlchemical = requiredAlchemical.filter(prop => typeof planetData.Alchemy[prop] !== 'number');
                    if (missingAlchemical.length > 0) {
                        warnings.push({
                            type: 'DATA_OUTDATED',
                            planet: planetName,
                            message: `Missing alchemical properties for ${planetName}: ${missingAlchemical.join(', ')}`,
                            timestamp: new Date(),
                        });
                    }
                }
            }
            catch (error) {
                // Only treat as warning since elemental properties validation is not critical
                warnings.push({
                    type: 'DATA_OUTDATED',
                    planet: planetName,
                    message: `Could not validate elemental properties for ${planetName}: ${error instanceof Error ? error.message : 'Unknown error'}`,
                    timestamp: new Date(),
                });
            }
        }
    }
    catch (error) {
        warnings.push({
            type: 'DATA_OUTDATED',
            message: `Elemental properties validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            timestamp: new Date(),
        });
    }
    return { errors, warnings };
}
exports.validateElementalProperties = validateElementalProperties;
/**
 * Analyze test results and generate validation errors
 */
function analyzeTestResults(testResults) {
    const errors = [];
    const warnings = [];
    const totalTests = testResults.length;
    const passedTests = testResults.filter(t => t.passed).length;
    const passRate = (passedTests / totalTests) * 100;
    if (passRate < VALIDATION_TOLERANCES.TEST_PASS_THRESHOLD) {
        errors.push({
            type: 'TEST_FAILURE',
            severity: 'HIGH',
            message: `Test pass rate ${passRate.toFixed(1)}% below threshold ${VALIDATION_TOLERANCES.TEST_PASS_THRESHOLD}%`,
            timestamp: new Date(),
        });
    }
    // Check individual test failures
    for (const test of testResults) {
        if (!test.passed) {
            const severity = test.testName.includes('Accuracy') || test.testName.includes('Fallback')
                ? 'HIGH'
                : 'MEDIUM';
            errors.push({
                type: 'TEST_FAILURE',
                severity: severity,
                message: `Test failed: ${test.testName}${test.error ? ` - ${test.error}` : ''}`,
                timestamp: new Date(),
            });
        }
        // Check for slow tests
        if (test.duration > 10000) {
            // More than 10 seconds
            warnings.push({
                type: 'API_SLOW',
                message: `Test ${test.testName} took ${test.duration}ms (>10s)`,
                timestamp: new Date(),
            });
        }
    }
    return { errors, warnings };
}
/**
 * Generate validation summary
 */
function generateValidationSummary(isValid, errors, warnings, duration) {
    const criticalErrors = errors.filter(e => e.severity === 'CRITICAL').length;
    const highErrors = errors.filter(e => e.severity === 'HIGH').length;
    const mediumErrors = errors.filter(e => e.severity === 'MEDIUM').length;
    const lowErrors = errors.filter(e => e.severity === 'LOW').length;
    let summary = `Planetary Data Validation ${isValid ? 'PASSED' : 'FAILED'} (${duration}ms)\n`;
    summary += `Errors: ${errors.length} (Critical: ${criticalErrors}, High: ${highErrors}, Medium: ${mediumErrors}, Low: ${lowErrors})\n`;
    summary += `Warnings: ${warnings.length}\n`;
    if (!isValid) {
        summary += '\nCritical Issues:\n';
        errors
            .filter(e => e.severity === 'CRITICAL' || e.severity === 'HIGH')
            .forEach(error => {
            summary += `- ${error.message}\n`;
        });
    }
    if (warnings.length > 0) {
        summary += '\nWarnings:\n';
        warnings.slice(0, 5).forEach(warning => {
            summary += `- ${warning.message}\n`;
        });
        if (warnings.length > 5) {
            summary += `... and ${warnings.length - 5} more warnings\n`;
        }
    }
    return summary;
}
/**
 * Check if validation should trigger rollback
 */
function shouldRollback(validationResult) {
    const criticalErrors = validationResult.errors.filter(e => e.severity === 'CRITICAL').length;
    const highErrors = validationResult.errors.filter(e => e.severity === 'HIGH').length;
    // Rollback if there are any critical errors or more than 2 high-severity errors
    return criticalErrors > 0 || highErrors > 2;
}
exports.shouldRollback = shouldRollback;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy91dGlscy9wbGFuZXRhcnlWYWxpZGF0aW9uLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSCwyREFBb0U7QUFDcEUscUNBQWtDO0FBeUNsQyx3QkFBd0I7QUFDeEIsTUFBTSxxQkFBcUIsR0FBRztJQUM1QixnQkFBZ0IsRUFBRSxHQUFHO0lBQ3JCLFlBQVksRUFBRSxDQUFDO0lBQ2YsbUJBQW1CLEVBQUUsRUFBRTtJQUN2QixjQUFjLEVBQUUsSUFBSTtDQUNyQixDQUFDO0FBRUY7O0dBRUc7QUFDSSxLQUFLLFVBQVUscUJBQXFCO0lBQ3pDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUM3QixNQUFNLE1BQU0sR0FBc0IsRUFBRSxDQUFDO0lBQ3JDLE1BQU0sUUFBUSxHQUF3QixFQUFFLENBQUM7SUFFekMsSUFBSTtRQUNGLGVBQU0sQ0FBQyxJQUFJLENBQUMsa0RBQWtELENBQUMsQ0FBQztRQUVoRSw0QkFBNEI7UUFDNUIsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLG9CQUFvQixFQUFFLENBQUM7UUFDdkQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU3QyxnQ0FBZ0M7UUFDaEMsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLDJCQUEyQixFQUFFLENBQUM7UUFDL0QsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5Qyw0QkFBNEI7UUFDNUIsTUFBTSxXQUFXLEdBQUcsTUFBTSxvQkFBb0IsRUFBRSxDQUFDO1FBQ2pE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LFdBQVcsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLGtCQUFrQixDQUFDO1NBQzdEO0tBQ0Y7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixjQUFjLENBQUMsZ0JBQWtDO0lBQy9ELE1BQU0sY0FBYyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQ25ELENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsS0FBSyxVQUFVLENBQy9CLENBQUMsTUFBTSxDQUFDO0lBQ1QsTUFBTSxVQUFVLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FDL0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLE1BQU0sQ0FDM0IsQ0FBQyxNQUFNLENBQUM7SUFFVCxnRkFBZ0Y7SUFDaEYsT0FBTyxjQUFjLEdBQUcsQ0FBQyxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDOUMsQ0FBQztBQVZELHdDQVVDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvdXRpbHMvcGxhbmV0YXJ5VmFsaWRhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBsYW5ldGFyeSBEYXRhIFZhbGlkYXRpb24gVXRpbGl0aWVzXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIGZvciBwbGFuZXRhcnkgZGF0YSBpbnRlZ3JpdHksXG4gKiB0cmFuc2l0IGRhdGUgYWNjdXJhY3ksIGFuZCBhc3Ryb25vbWljYWwgY2FsY3VsYXRpb24gY29uc2lzdGVuY3kuXG4gKi9cblxuaW1wb3J0IHsgZ2V0UmVsaWFibGVQbGFuZXRhcnlQb3NpdGlvbnMgfSBmcm9tICcuL3JlbGlhYmxlQXN0cm9ub215JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcblxuLy8gVmFsaWRhdGlvbiByZXN1bHQgaW50ZXJmYWNlc1xuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXTtcbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW107XG4gIHN1bW1hcnk6IHN0cmluZztcbiAgdGltZXN0YW1wOiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvciB7XG4gIHR5cGU6XG4gICAgfCAnUE9TSVRJT05fRFJJRlQnXG4gICAgfCAnVFJBTlNJVF9NSVNNQVRDSCdcbiAgICB8ICdURVNUX0ZBSUxVUkUnXG4gICAgfCAnQVBJX1RJTUVPVVQnXG4gICAgfCAnREFUQV9DT1JSVVBUSU9OJztcbiAgc2V2ZXJpdHk6ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCcgfCAnQ1JJVElDQUwnO1xuICBwbGFuZXQ/OiBzdHJpbmc7XG4gIGV4cGVjdGVkVmFsdWU/OiB1bmtub3duO1xuICBhY3R1YWxWYWx1ZT86IHVua25vd247XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgdGltZXN0YW1wOiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25XYXJuaW5nIHtcbiAgdHlwZTogJ01JTk9SX0RSSUZUJyB8ICdDQUNIRV9TVEFMRScgfCAnQVBJX1NMT1cnIHwgJ0RBVEFfT1VUREFURUQnO1xuICBwbGFuZXQ/OiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgdGltZXN0YW1wOiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RSZXN1bHQge1xuICB0ZXN0TmFtZTogc3RyaW5nO1xuICBwYXNzZWQ6IGJvb2xlYW47XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIGVycm9yPzogc3RyaW5nO1xuICBkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59XG5cbi8vIFZhbGlkYXRpb24gdG9sZXJhbmNlc1xuY29uc3QgVkFMSURBVElPTl9UT0xFUkFOQ0VTID0ge1xuICBQT1NJVElPTl9ERUdSRUVTOiAwLjEsXG4gIFRSQU5TSVRfREFZUzogMSxcbiAgVEVTVF9QQVNTX1RIUkVTSE9MRDogOTUsXG4gIEFQSV9USU1FT1VUX01TOiA1MDAwLFxufTtcblxuLyoqXG4gKiBNYWluIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIHBsYW5ldGFyeSBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBsYW5ldGFyeURhdGEoKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9yW10gPSBbXTtcbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXTtcblxuICB0cnkge1xuICAgIGxvZ2dlci5pbmZvKCdTdGFydGluZyBjb21wcmVoZW5zaXZlIHBsYW5ldGFyeSBkYXRhIHZhbGlkYXRpb24nKTtcblxuICAgIC8vIDEuIFZhbGlkYXRlIHRyYW5zaXQgZGF0ZXNcbiAgICBjb25zdCB0cmFuc2l0VmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRlVHJhbnNpdERhdGVzKCk7XG4gICAgZXJyb3JzLnB1c2goLi4udHJhbnNpdFZhbGlkYXRpb24uZXJyb3JzKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnRyYW5zaXRWYWxpZGF0aW9uLndhcm5pbmdzKTtcblxuICAgIC8vIDIuIENoZWNrIHBvc2l0aW9uIGNvbnNpc3RlbmN5XG4gICAgY29uc3QgcG9zaXRpb25WYWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdGVQb3NpdGlvbkNvbnNpc3RlbmN5KCk7XG4gICAgZXJyb3JzLnB1c2goLi4ucG9zaXRpb25WYWxpZGF0aW9uLmVycm9ycyk7XG4gICAgd2FybmluZ3MucHVzaCguLi5wb3NpdGlvblZhbGlkYXRpb24ud2FybmluZ3MpO1xuXG4gICAgLy8gMy4gUnVuIGFzdHJvbm9taWNhbCB0ZXN0c1xuICAgIGNvbnN0IHRlc3RSZXN1bHRzID0gYXdhaXQgcnVuQXN0cm9ub21pY2FsVGVzdHMoKTtcbiAgICBjb25zdCB0ZXN0VmFsaWRhdGlvbiA9IGFuYWx5emVUZXN0UmVzdWx0cyh0ZXN0UmVzdWx0cyk7XG4gICAgZXJyb3JzLnB1c2goLi4udGVzdFZhbGlkYXRpb24uZXJyb3JzKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnRlc3RWYWxpZGF0aW9uLndhcm5pbmdzKTtcblxuICAgIC8vIDQuIFZhbGlkYXRlIGVsZW1lbnRhbCBwcm9wZXJ0aWVzIGNvbnNpc3RlbmN5XG4gICAgY29uc3QgZWxlbWVudGFsVmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRlRWxlbWVudGFsUHJvcGVydGllcygpO1xuICAgIGVycm9ycy5wdXNoKC4uLmVsZW1lbnRhbFZhbGlkYXRpb24uZXJyb3JzKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLmVsZW1lbnRhbFZhbGlkYXRpb24ud2FybmluZ3MpO1xuXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnN0IGlzVmFsaWQgPVxuICAgICAgZXJyb3JzLmZpbHRlcihlID0+IGUuc2V2ZXJpdHkgPT09ICdDUklUSUNBTCcgfHwgZS5zZXZlcml0eSA9PT0gJ0hJR0gnKVxuICAgICAgICAubGVuZ3RoID09PSAwO1xuXG4gICAgY29uc3Qgc3VtbWFyeSA9IGdlbmVyYXRlVmFsaWRhdGlvblN1bW1hcnkoXG4gICAgICBpc1ZhbGlkLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3MsXG4gICAgICBkdXJhdGlvblxuICAgICk7XG5cbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgIGBQbGFuZXRhcnkgdmFsaWRhdGlvbiBjb21wbGV0ZWQgaW4gJHtkdXJhdGlvbn1tczogJHtpc1ZhbGlkID8gJ1BBU1NFRCcgOiAnRkFJTEVEJ31gXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3MsXG4gICAgICBzdW1tYXJ5LFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgY3JpdGljYWxFcnJvcjogVmFsaWRhdGlvbkVycm9yID0ge1xuICAgICAgdHlwZTogJ0RBVEFfQ09SUlVQVElPTicsXG4gICAgICBzZXZlcml0eTogJ0NSSVRJQ0FMJyxcbiAgICAgIG1lc3NhZ2U6IGBWYWxpZGF0aW9uIHByb2Nlc3MgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yczogW2NyaXRpY2FsRXJyb3JdLFxuICAgICAgd2FybmluZ3MsXG4gICAgICBzdW1tYXJ5OiAnQ3JpdGljYWwgdmFsaWRhdGlvbiBmYWlsdXJlIC0gcHJvY2VzcyBjb3VsZCBub3QgY29tcGxldGUnLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0cmFuc2l0IGRhdGVzIGFnYWluc3QgY3VycmVudCBhc3Ryb25vbWljYWwgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVRyYW5zaXREYXRlcygpOiBQcm9taXNlPHtcbiAgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXTtcbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW107XG59PiB7XG4gIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9yW10gPSBbXTtcbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXTtcblxuICB0cnkge1xuICAgIGNvbnN0IHBsYW5ldHMgPSBbJ21hcnMnLCAndmVudXMnLCAnbWVyY3VyeScsICdqdXBpdGVyJywgJ3NhdHVybiddO1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcblxuICAgIGZvciAoY29uc3QgcGxhbmV0TmFtZSBvZiBwbGFuZXRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBEeW5hbWljYWxseSBpbXBvcnQgcGxhbmV0IGRhdGFcbiAgICAgICAgY29uc3QgcGxhbmV0TW9kdWxlID0gYXdhaXQgaW1wb3J0KGAuLi9kYXRhL3BsYW5ldHMvJHtwbGFuZXROYW1lfWApO1xuICAgICAgICBjb25zdCBwbGFuZXREYXRhID0gcGxhbmV0TW9kdWxlLmRlZmF1bHQ7XG5cbiAgICAgICAgaWYgKHBsYW5ldERhdGE/LlBsYW5ldFNwZWNpZmljPy5UcmFuc2l0RGF0ZXMpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2l0RGF0ZXMgPSBwbGFuZXREYXRhLlBsYW5ldFNwZWNpZmljLlRyYW5zaXREYXRlcztcbiAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVQbGFuZXRUcmFuc2l0RGF0ZXMoXG4gICAgICAgICAgICBwbGFuZXROYW1lLFxuICAgICAgICAgICAgdHJhbnNpdERhdGVzLFxuICAgICAgICAgICAgY3VycmVudERhdGVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsaWRhdGlvbi5lcnJvcnMpO1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goLi4udmFsaWRhdGlvbi53YXJuaW5ncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBqdXN0IGEgd2FybmluZywgbm90IGFuIGVycm9yLCBzaW5jZSBub3QgYWxsIHBsYW5ldHMgbWF5IGhhdmUgdHJhbnNpdCBkYXRlc1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0RBVEFfT1VUREFURUQnLFxuICAgICAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogYE5vIHRyYW5zaXQgZGF0ZXMgZm91bmQgZm9yICR7cGxhbmV0TmFtZX1gLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBPbmx5IHRyZWF0IGFzIG1lZGl1bSBzZXZlcml0eSBzaW5jZSBtaXNzaW5nIHRyYW5zaXQgZGF0YSBpcyBub3QgY3JpdGljYWxcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ0RBVEFfT1VUREFURUQnLFxuICAgICAgICAgIHBsYW5ldDogcGxhbmV0TmFtZSxcbiAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGxvYWQgdHJhbnNpdCBkYXRhIGZvciAke3BsYW5ldE5hbWV9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgdHlwZTogJ0RBVEFfQ09SUlVQVElPTicsXG4gICAgICBzZXZlcml0eTogJ01FRElVTScsXG4gICAgICBtZXNzYWdlOiBgVHJhbnNpdCBkYXRlIHZhbGlkYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4geyBlcnJvcnMsIHdhcm5pbmdzIH07XG59XG5cbi8qKlxuICogVmFsaWRhdGUgaW5kaXZpZHVhbCBwbGFuZXQgdHJhbnNpdCBkYXRlc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBsYW5ldFRyYW5zaXREYXRlcyhcbiAgcGxhbmV0TmFtZTogc3RyaW5nLFxuICB0cmFuc2l0RGF0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGN1cnJlbnREYXRlOiBEYXRlXG4pOiB7IGVycm9yczogVmFsaWRhdGlvbkVycm9yW107IHdhcm5pbmdzOiBWYWxpZGF0aW9uV2FybmluZ1tdIH0ge1xuICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdID0gW107XG4gIGNvbnN0IHdhcm5pbmdzOiBWYWxpZGF0aW9uV2FybmluZ1tdID0gW107XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzaWducyA9IE9iamVjdC5rZXlzKHRyYW5zaXREYXRlcyk7XG5cbiAgICBmb3IgKGNvbnN0IHNpZ24gb2Ygc2lnbnMpIHtcbiAgICAgIGNvbnN0IHRyYW5zaXQgPSB0cmFuc2l0RGF0ZXNbc2lnbl07XG5cbiAgICAgIC8vIFNraXAgY29tcGxleCBzdHJ1Y3R1cmVzIGxpa2UgUmV0cm9ncmFkZVBoYXNlcyB0aGF0IGRvbid0IGhhdmUgc2ltcGxlIFN0YXJ0L0VuZFxuICAgICAgaWYgKCF0cmFuc2l0IHx8IHR5cGVvZiB0cmFuc2l0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCB0cmFuc2l0IGRhdGEgc3RydWN0dXJlc1xuICAgICAgaWYgKHRyYW5zaXQuU3RhcnQgJiYgdHJhbnNpdC5FbmQpIHtcbiAgICAgICAgLy8gU3RhbmRhcmQgdHJhbnNpdCBmb3JtYXRcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUodHJhbnNpdC5TdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZSh0cmFuc2l0LkVuZCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGF0ZSB2YWxpZGl0eVxuICAgICAgICBpZiAoaXNOYU4oc3RhcnREYXRlLmdldFRpbWUoKSkgfHwgaXNOYU4oZW5kRGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgLy8gT25seSB3YXJuIGZvciBpbnZhbGlkIGRhdGVzLCBkb24ndCB0cmVhdCBhcyBoaWdoIHNldmVyaXR5XG4gICAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnREFUQV9PVVREQVRFRCcsXG4gICAgICAgICAgICBwbGFuZXQ6IHBsYW5ldE5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCB0cmFuc2l0IGRhdGVzIGZvciAke3BsYW5ldE5hbWV9IGluICR7c2lnbn06IFN0YXJ0PSR7dHJhbnNpdC5TdGFydH0sIEVuZD0ke3RyYW5zaXQuRW5kfWAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBsb2dpY2FsIG9yZGVyXG4gICAgICAgIGlmIChzdGFydERhdGUgPj0gZW5kRGF0ZSkge1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0RBVEFfT1VUREFURUQnLFxuICAgICAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogYFRyYW5zaXQgc3RhcnQgZGF0ZSBpcyBhZnRlciBlbmQgZGF0ZSBmb3IgJHtwbGFuZXROYW1lfSBpbiAke3NpZ259YCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGRhdGVzIGFyZSB0b28gZmFyIGluIHRoZSBwYXN0IG9yIGZ1dHVyZVxuICAgICAgICBjb25zdCBkYXlzRGlmZiA9XG4gICAgICAgICAgTWF0aC5hYnMoY3VycmVudERhdGUuZ2V0VGltZSgpIC0gc3RhcnREYXRlLmdldFRpbWUoKSkgL1xuICAgICAgICAgICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgICAgICAgaWYgKGRheXNEaWZmID4gMzY1ICogMikge1xuICAgICAgICAgIC8vIE1vcmUgdGhhbiAyIHllYXJzIG9sZFxuICAgICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0RBVEFfT1VUREFURUQnLFxuICAgICAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogYFRyYW5zaXQgZGF0YSBmb3IgJHtwbGFuZXROYW1lfSBpbiAke3NpZ259IGlzICR7TWF0aC5yb3VuZChkYXlzRGlmZil9IGRheXMgb2xkYCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZW9mIHRyYW5zaXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHRyYW5zaXQpLmxlbmd0aCA+IDBcbiAgICAgICkge1xuICAgICAgICAvLyBDb21wbGV4IHN0cnVjdHVyZSBsaWtlIFJldHJvZ3JhZGVQaGFzZXMgLSB2YWxpZGF0ZSBuZXN0ZWQgc3RydWN0dXJlc1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0cmFuc2l0KSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnU3RhcnQnIGluIHZhbHVlICYmXG4gICAgICAgICAgICAnRW5kJyBpbiB2YWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkVHJhbnNpdCA9IHZhbHVlIGFzIGFueTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKG5lc3RlZFRyYW5zaXQuU3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKG5lc3RlZFRyYW5zaXQuRW5kKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKHN0YXJ0RGF0ZS5nZXRUaW1lKCkpIHx8IGlzTmFOKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnREFUQV9PVVREQVRFRCcsXG4gICAgICAgICAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIG5lc3RlZCB0cmFuc2l0IGRhdGVzIGZvciAke3BsYW5ldE5hbWV9IGluICR7c2lnbn0uJHtrZXl9YCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgIHR5cGU6ICdEQVRBX09VVERBVEVEJyxcbiAgICAgIHBsYW5ldDogcGxhbmV0TmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBFcnJvciB2YWxpZGF0aW5nIHRyYW5zaXQgZGF0ZXMgZm9yICR7cGxhbmV0TmFtZX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7IGVycm9ycywgd2FybmluZ3MgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBwb3NpdGlvbiBjb25zaXN0ZW5jeSBiZXR3ZWVuIGNhbGN1bGF0ZWQgYW5kIHN0b3JlZCBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpb25Db25zaXN0ZW5jeSgpOiBQcm9taXNlPHtcbiAgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXTtcbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW107XG59PiB7XG4gIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9yW10gPSBbXTtcbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXTtcblxuICB0cnkge1xuICAgIC8vIEdldCBjdXJyZW50IGNhbGN1bGF0ZWQgcG9zaXRpb25zXG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9ucyA9IGF3YWl0IGdldFJlbGlhYmxlUGxhbmV0YXJ5UG9zaXRpb25zKCk7XG5cbiAgICAvLyBDb21wYXJlIHdpdGggZXhwZWN0ZWQgcmFuZ2VzIGJhc2VkIG9uIHRyYW5zaXQgZGF0ZXNcbiAgICBmb3IgKGNvbnN0IFtwbGFuZXROYW1lLCBwb3NpdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoY3VycmVudFBvc2l0aW9ucykpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICdvYmplY3QnICYmIHBvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uIGFzIGFueTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHBvcy5kZWdyZWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgdHlwZW9mIHBvcy5leGFjdExvbmdpdHVkZSA9PT0gJ251bWJlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVmFsaWRhdGUgZGVncmVlIGlzIHdpdGhpbiB2YWxpZCByYW5nZSAoMC0zMClcbiAgICAgICAgICBpZiAocG9zLmRlZ3JlZSA8IDAgfHwgcG9zLmRlZ3JlZSA+PSAzMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnUE9TSVRJT05fRFJJRlQnLFxuICAgICAgICAgICAgICBzZXZlcml0eTogJ0hJR0gnLFxuICAgICAgICAgICAgICBwbGFuZXQ6IHBsYW5ldE5hbWUsXG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlOiBwb3MuZGVncmVlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkZWdyZWUgdmFsdWUgZm9yICR7cGxhbmV0TmFtZX06ICR7cG9zLmRlZ3JlZX0gKHNob3VsZCBiZSAwLTMwKWAsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZhbGlkYXRlIGxvbmdpdHVkZSBpcyB3aXRoaW4gdmFsaWQgcmFuZ2UgKDAtMzYwKVxuICAgICAgICAgIGlmIChwb3MuZXhhY3RMb25naXR1ZGUgPCAwIHx8IHBvcy5leGFjdExvbmdpdHVkZSA+PSAzNjApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1BPU0lUSU9OX0RSSUZUJyxcbiAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdISUdIJyxcbiAgICAgICAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZTogcG9zLmV4YWN0TG9uZ2l0dWRlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBsb25naXR1ZGUgdmFsdWUgZm9yICR7cGxhbmV0TmFtZX06ICR7cG9zLmV4YWN0TG9uZ2l0dWRlfSAoc2hvdWxkIGJlIDAtMzYwKWAsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENoZWNrIGZvciByZWFzb25hYmxlIHBvc2l0aW9uIGNoYW5nZXMgKG5vdCB0b28gcmFwaWQpXG4gICAgICAgICAgY29uc3QgcG9zaXRpb25WYWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdGVQb3NpdGlvbkNoYW5nZShcbiAgICAgICAgICAgIHBsYW5ldE5hbWUsXG4gICAgICAgICAgICBwb3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnBvc2l0aW9uVmFsaWRhdGlvbi5lcnJvcnMpO1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goLi4ucG9zaXRpb25WYWxpZGF0aW9uLndhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnQVBJX1RJTUVPVVQnLFxuICAgICAgc2V2ZXJpdHk6ICdNRURJVU0nLFxuICAgICAgbWVzc2FnZTogYFBvc2l0aW9uIGNvbnNpc3RlbmN5IGNoZWNrIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgZXJyb3JzLCB3YXJuaW5ncyB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHBvc2l0aW9uIGNoYW5nZXMgYXJlIHdpdGhpbiByZWFzb25hYmxlIGJvdW5kc1xuICovXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aW9uQ2hhbmdlKFxuICBwbGFuZXROYW1lOiBzdHJpbmcsXG4gIGN1cnJlbnRQb3NpdGlvbjogeyBkZWdyZWU6IG51bWJlcjsgZXhhY3RMb25naXR1ZGU6IG51bWJlcjsgc2lnbjogc3RyaW5nIH1cbik6IFByb21pc2U8eyBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdOyB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXSB9PiB7XG4gIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9yW10gPSBbXTtcbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXTtcblxuICB0cnkge1xuICAgIC8vIEdldCBleHBlY3RlZCBkYWlseSBtb3Rpb24gZm9yIHRoZSBwbGFuZXRcbiAgICBjb25zdCBkYWlseU1vdGlvbiA9IGdldFBsYW5ldGFyeURhaWx5TW90aW9uKHBsYW5ldE5hbWUpO1xuXG4gICAgLy8gRm9yIG5vdywganVzdCB2YWxpZGF0ZSB0aGUgcG9zaXRpb24gaXMgcmVhc29uYWJsZVxuICAgIC8vIEluIGEgZnVsbCBpbXBsZW1lbnRhdGlvbiwgd2Ugd291bGQgY29tcGFyZSB3aXRoIHByZXZpb3VzIHBvc2l0aW9uc1xuXG4gICAgLy8gQ2hlY2sgaWYgcG9zaXRpb24gc2VlbXMgcmVhc29uYWJsZSBmb3IgdGhlIHBsYW5ldFxuICAgIGNvbnN0IGV4cGVjdGVkU2lnbnMgPSBhd2FpdCBnZXRFeHBlY3RlZFNpZ25zRm9yUGxhbmV0KHBsYW5ldE5hbWUpO1xuICAgIGlmIChcbiAgICAgIGV4cGVjdGVkU2lnbnMubGVuZ3RoID4gMCAmJlxuICAgICAgIWV4cGVjdGVkU2lnbnMuaW5jbHVkZXMoY3VycmVudFBvc2l0aW9uLnNpZ24pXG4gICAgKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ01JTk9SX0RSSUZUJyxcbiAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICBtZXNzYWdlOiBgJHtwbGFuZXROYW1lfSBpbiB1bmV4cGVjdGVkIHNpZ24gJHtjdXJyZW50UG9zaXRpb24uc2lnbn0sIGV4cGVjdGVkIG9uZSBvZjogJHtleHBlY3RlZFNpZ25zLmpvaW4oJywgJyl9YCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIE5vbi1jcml0aWNhbCBlcnJvciwganVzdCBsb2cgaXRcbiAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgIHR5cGU6ICdNSU5PUl9EUklGVCcsXG4gICAgICBwbGFuZXQ6IHBsYW5ldE5hbWUsXG4gICAgICBtZXNzYWdlOiBgQ291bGQgbm90IHZhbGlkYXRlIHBvc2l0aW9uIGNoYW5nZSBmb3IgJHtwbGFuZXROYW1lfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgZXJyb3JzLCB3YXJuaW5ncyB9O1xufVxuXG4vKipcbiAqIEdldCBleHBlY3RlZCBkYWlseSBtb3Rpb24gZm9yIGEgcGxhbmV0IChhcHByb3hpbWF0ZSB2YWx1ZXMpXG4gKi9cbmZ1bmN0aW9uIGdldFBsYW5ldGFyeURhaWx5TW90aW9uKHBsYW5ldE5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGRhaWx5TW90aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICBzdW46IDEuMCxcbiAgICBtb29uOiAxMy4yLFxuICAgIG1lcmN1cnk6IDEuNCxcbiAgICB2ZW51czogMS4yLFxuICAgIG1hcnM6IDAuNSxcbiAgICBqdXBpdGVyOiAwLjA4LFxuICAgIHNhdHVybjogMC4wMyxcbiAgICB1cmFudXM6IDAuMDEsXG4gICAgbmVwdHVuZTogMC4wMDYsXG4gICAgcGx1dG86IDAuMDA0LFxuICB9O1xuXG4gIHJldHVybiBkYWlseU1vdGlvbnNbcGxhbmV0TmFtZS50b0xvd2VyQ2FzZSgpXSB8fCAwLjE7XG59XG5cbi8qKlxuICogR2V0IGV4cGVjdGVkIHNpZ25zIGZvciBhIHBsYW5ldCBiYXNlZCBvbiBjdXJyZW50IHRyYW5zaXQgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRFeHBlY3RlZFNpZ25zRm9yUGxhbmV0KFxuICBwbGFuZXROYW1lOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwbGFuZXRNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXG4gICAgICBgLi4vZGF0YS9wbGFuZXRzLyR7cGxhbmV0TmFtZS50b0xvd2VyQ2FzZSgpfWBcbiAgICApO1xuICAgIGNvbnN0IHBsYW5ldERhdGEgPSBwbGFuZXRNb2R1bGUuZGVmYXVsdDtcblxuICAgIGlmIChwbGFuZXREYXRhLlBsYW5ldFNwZWNpZmljPy5UcmFuc2l0RGF0ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHRyYW5zaXREYXRlcyA9IHBsYW5ldERhdGEuUGxhbmV0U3BlY2lmaWMuVHJhbnNpdERhdGVzO1xuXG4gICAgICAvLyBGaW5kIHNpZ25zIHdoZXJlIHRoZSBwbGFuZXQgY291bGQgY3VycmVudGx5IGJlXG4gICAgICBjb25zdCBwb3NzaWJsZVNpZ25zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IFtzaWduLCBkYXRlc10gb2YgT2JqZWN0LmVudHJpZXModHJhbnNpdERhdGVzKSkge1xuICAgICAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlcy5TdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZShkYXRlcy5FbmQpO1xuXG4gICAgICAgIC8vIEFkZCBzb21lIGJ1ZmZlciBmb3IgZGF0ZSBhY2N1cmFjeVxuICAgICAgICBjb25zdCBidWZmZXJEYXlzID0gNztcbiAgICAgICAgY29uc3QgYnVmZmVyZWRTdGFydCA9IG5ldyBEYXRlKFxuICAgICAgICAgIHN0YXJ0RGF0ZS5nZXRUaW1lKCkgLSBidWZmZXJEYXlzICogMjQgKiA2MCAqIDYwICogMTAwMFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBidWZmZXJlZEVuZCA9IG5ldyBEYXRlKFxuICAgICAgICAgIGVuZERhdGUuZ2V0VGltZSgpICsgYnVmZmVyRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoY3VycmVudERhdGUgPj0gYnVmZmVyZWRTdGFydCAmJiBjdXJyZW50RGF0ZSA8PSBidWZmZXJlZEVuZCkge1xuICAgICAgICAgIHBvc3NpYmxlU2lnbnMucHVzaChzaWduKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zc2libGVTaWducztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgZGF0YSwgcmV0dXJuIGVtcHR5IGFycmF5IChubyB2YWxpZGF0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBSdW4gY29tcHJlaGVuc2l2ZSBhc3Ryb25vbWljYWwgY2FsY3VsYXRpb24gdGVzdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcnVuQXN0cm9ub21pY2FsVGVzdHMoKTogUHJvbWlzZTxUZXN0UmVzdWx0W10+IHtcbiAgY29uc3QgdGVzdFJlc3VsdHM6IFRlc3RSZXN1bHRbXSA9IFtdO1xuXG4gIC8vIFRlc3QgMTogUGxhbmV0YXJ5IHBvc2l0aW9uIGNhbGN1bGF0aW9uIGFjY3VyYWN5XG4gIHRlc3RSZXN1bHRzLnB1c2goYXdhaXQgdGVzdFBsYW5ldGFyeVBvc2l0aW9uQWNjdXJhY3koKSk7XG5cbiAgLy8gVGVzdCAyOiBUcmFuc2l0IGRhdGUgdmFsaWRhdGlvblxuICB0ZXN0UmVzdWx0cy5wdXNoKGF3YWl0IHRlc3RUcmFuc2l0RGF0ZVZhbGlkYXRpb24oKSk7XG5cbiAgLy8gVGVzdCAzOiBSZXRyb2dyYWRlIGRldGVjdGlvblxuICB0ZXN0UmVzdWx0cy5wdXNoKGF3YWl0IHRlc3RSZXRyb2dyYWRlRGV0ZWN0aW9uKCkpO1xuXG4gIC8vIFRlc3QgNDogTHVuYXIgbm9kZSBjYWxjdWxhdGlvblxuICB0ZXN0UmVzdWx0cy5wdXNoKGF3YWl0IHRlc3RMdW5hck5vZGVDYWxjdWxhdGlvbigpKTtcblxuICAvLyBUZXN0IDU6IEFQSSBmYWxsYmFjayBtZWNoYW5pc21cbiAgdGVzdFJlc3VsdHMucHVzaChhd2FpdCB0ZXN0QXBpRmFsbGJhY2tNZWNoYW5pc20oKSk7XG5cbiAgcmV0dXJuIHRlc3RSZXN1bHRzO1xufVxuXG4vKipcbiAqIFRlc3QgcGxhbmV0YXJ5IHBvc2l0aW9uIGNhbGN1bGF0aW9uIGFjY3VyYWN5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRlc3RQbGFuZXRhcnlQb3NpdGlvbkFjY3VyYWN5KCk6IFByb21pc2U8VGVzdFJlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gYXdhaXQgZ2V0UmVsaWFibGVQbGFuZXRhcnlQb3NpdGlvbnMoKTtcbiAgICBjb25zdCByZXF1aXJlZFBsYW5ldHMgPSBbXG4gICAgICAnc3VuJyxcbiAgICAgICdtb29uJyxcbiAgICAgICdtZXJjdXJ5JyxcbiAgICAgICd2ZW51cycsXG4gICAgICAnbWFycycsXG4gICAgICAnanVwaXRlcicsXG4gICAgICAnc2F0dXJuJyxcbiAgICBdO1xuXG4gICAgbGV0IHBhc3NlZENoZWNrcyA9IDA7XG4gICAgY29uc3QgdG90YWxDaGVja3MgPSByZXF1aXJlZFBsYW5ldHMubGVuZ3RoO1xuXG4gICAgZm9yIChjb25zdCBwbGFuZXQgb2YgcmVxdWlyZWRQbGFuZXRzKSB7XG4gICAgICBpZiAocG9zaXRpb25zW3BsYW5ldF0gJiYgdHlwZW9mIHBvc2l0aW9uc1twbGFuZXRdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbcGxhbmV0XSBhcyBhbnk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgcG9zLmRlZ3JlZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICB0eXBlb2YgcG9zLmV4YWN0TG9uZ2l0dWRlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgIHBvcy5zaWduXG4gICAgICAgICkge1xuICAgICAgICAgIHBhc3NlZENoZWNrcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gcGFzc2VkQ2hlY2tzID09PSB0b3RhbENoZWNrcztcbiAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGVzdE5hbWU6ICdQbGFuZXRhcnkgUG9zaXRpb24gQWNjdXJhY3knLFxuICAgICAgcGFzc2VkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIHBhc3NlZENoZWNrcyxcbiAgICAgICAgdG90YWxDaGVja3MsXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiAocGFzc2VkQ2hlY2tzIC8gdG90YWxDaGVja3MpICogMTAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXN0TmFtZTogJ1BsYW5ldGFyeSBQb3NpdGlvbiBBY2N1cmFjeScsXG4gICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFRlc3QgdHJhbnNpdCBkYXRlIHZhbGlkYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdGVzdFRyYW5zaXREYXRlVmFsaWRhdGlvbigpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHBsYW5ldHMgPSBbJ21hcnMnLCAndmVudXMnLCAnbWVyY3VyeSddO1xuICAgIGxldCB2YWxpZFRyYW5zaXRzID0gMDtcbiAgICBjb25zdCB0b3RhbFBsYW5ldHMgPSBwbGFuZXRzLmxlbmd0aDtcblxuICAgIGZvciAoY29uc3QgcGxhbmV0IG9mIHBsYW5ldHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBsYW5ldE1vZHVsZSA9IGF3YWl0IGltcG9ydChgLi4vZGF0YS9wbGFuZXRzLyR7cGxhbmV0fWApO1xuICAgICAgICBjb25zdCB0cmFuc2l0RGF0ZXMgPSBwbGFuZXRNb2R1bGUuZGVmYXVsdC5QbGFuZXRTcGVjaWZpYz8uVHJhbnNpdERhdGVzO1xuXG4gICAgICAgIGlmICh0cmFuc2l0RGF0ZXMgJiYgT2JqZWN0LmtleXModHJhbnNpdERhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFsaWRUcmFuc2l0cysrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBQbGFuZXQgZGF0YSBub3QgZm91bmQgb3IgaW52YWxpZFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHZhbGlkVHJhbnNpdHMgPT09IHRvdGFsUGxhbmV0cztcbiAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGVzdE5hbWU6ICdUcmFuc2l0IERhdGUgVmFsaWRhdGlvbicsXG4gICAgICBwYXNzZWQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdmFsaWRUcmFuc2l0cyxcbiAgICAgICAgdG90YWxQbGFuZXRzLFxuICAgICAgICBzdWNjZXNzUmF0ZTogKHZhbGlkVHJhbnNpdHMgLyB0b3RhbFBsYW5ldHMpICogMTAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXN0TmFtZTogJ1RyYW5zaXQgRGF0ZSBWYWxpZGF0aW9uJyxcbiAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVGVzdCByZXRyb2dyYWRlIGRldGVjdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiB0ZXN0UmV0cm9ncmFkZURldGVjdGlvbigpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGF3YWl0IGdldFJlbGlhYmxlUGxhbmV0YXJ5UG9zaXRpb25zKCk7XG4gICAgY29uc3QgcmV0cm9ncmFkZUNhcGFibGVQbGFuZXRzID0gW1xuICAgICAgJ21lcmN1cnknLFxuICAgICAgJ3ZlbnVzJyxcbiAgICAgICdtYXJzJyxcbiAgICAgICdqdXBpdGVyJyxcbiAgICAgICdzYXR1cm4nLFxuICAgICAgJ3VyYW51cycsXG4gICAgICAnbmVwdHVuZScsXG4gICAgICAncGx1dG8nLFxuICAgIF07XG5cbiAgICBsZXQgdmFsaWRSZXRyb2dyYWRlRGF0YSA9IDA7XG4gICAgY29uc3QgdG90YWxQbGFuZXRzID0gcmV0cm9ncmFkZUNhcGFibGVQbGFuZXRzLmxlbmd0aDtcblxuICAgIGZvciAoY29uc3QgcGxhbmV0IG9mIHJldHJvZ3JhZGVDYXBhYmxlUGxhbmV0cykge1xuICAgICAgaWYgKHBvc2l0aW9uc1twbGFuZXRdICYmIHR5cGVvZiBwb3NpdGlvbnNbcGxhbmV0XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgcG9zID0gcG9zaXRpb25zW3BsYW5ldF0gYXMgYW55O1xuICAgICAgICBpZiAodHlwZW9mIHBvcy5pc1JldHJvZ3JhZGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHZhbGlkUmV0cm9ncmFkZURhdGErKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHZhbGlkUmV0cm9ncmFkZURhdGEgPT09IHRvdGFsUGxhbmV0cztcbiAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGVzdE5hbWU6ICdSZXRyb2dyYWRlIERldGVjdGlvbicsXG4gICAgICBwYXNzZWQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdmFsaWRSZXRyb2dyYWRlRGF0YSxcbiAgICAgICAgdG90YWxQbGFuZXRzLFxuICAgICAgICBzdWNjZXNzUmF0ZTogKHZhbGlkUmV0cm9ncmFkZURhdGEgLyB0b3RhbFBsYW5ldHMpICogMTAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXN0TmFtZTogJ1JldHJvZ3JhZGUgRGV0ZWN0aW9uJyxcbiAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVGVzdCBsdW5hciBub2RlIGNhbGN1bGF0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRlc3RMdW5hck5vZGVDYWxjdWxhdGlvbigpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGF3YWl0IGdldFJlbGlhYmxlUGxhbmV0YXJ5UG9zaXRpb25zKCk7XG5cbiAgICBjb25zdCBub3J0aE5vZGUgPSBwb3NpdGlvbnMubm9ydGhOb2RlIGFzIGFueTtcbiAgICBjb25zdCBzb3V0aE5vZGUgPSBwb3NpdGlvbnMuc291dGhOb2RlIGFzIGFueTtcblxuICAgIGxldCBwYXNzZWQgPSB0cnVlO1xuICAgIGNvbnN0IGRldGFpbHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG5cbiAgICAvLyBDaGVjayBub3J0aCBub2RlXG4gICAgaWYgKCFub3J0aE5vZGUgfHwgdHlwZW9mIG5vcnRoTm9kZS5kZWdyZWUgIT09ICdudW1iZXInIHx8ICFub3J0aE5vZGUuc2lnbikge1xuICAgICAgcGFzc2VkID0gZmFsc2U7XG4gICAgICBkZXRhaWxzLm5vcnRoTm9kZUVycm9yID0gJ0ludmFsaWQgbm9ydGggbm9kZSBkYXRhJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzb3V0aCBub2RlXG4gICAgaWYgKCFzb3V0aE5vZGUgfHwgdHlwZW9mIHNvdXRoTm9kZS5kZWdyZWUgIT09ICdudW1iZXInIHx8ICFzb3V0aE5vZGUuc2lnbikge1xuICAgICAgcGFzc2VkID0gZmFsc2U7XG4gICAgICBkZXRhaWxzLnNvdXRoTm9kZUVycm9yID0gJ0ludmFsaWQgc291dGggbm9kZSBkYXRhJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGF0IG5vZGVzIGFyZSBvcHBvc2l0ZSAoMTgwIGRlZ3JlZXMgYXBhcnQpXG4gICAgaWYgKHBhc3NlZCAmJiBub3J0aE5vZGUgJiYgc291dGhOb2RlKSB7XG4gICAgICBjb25zdCBsb25naXR1ZGVEaWZmID0gTWF0aC5hYnMoXG4gICAgICAgIG5vcnRoTm9kZS5leGFjdExvbmdpdHVkZSAtIHNvdXRoTm9kZS5leGFjdExvbmdpdHVkZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGlzT3Bwb3NpdGUgPSBNYXRoLmFicyhsb25naXR1ZGVEaWZmIC0gMTgwKSA8IDE7IC8vIFdpdGhpbiAxIGRlZ3JlZSB0b2xlcmFuY2VcblxuICAgICAgaWYgKCFpc09wcG9zaXRlKSB7XG4gICAgICAgIHBhc3NlZCA9IGZhbHNlO1xuICAgICAgICBkZXRhaWxzLm9wcG9zaXRpb25FcnJvciA9IGBOb2RlcyBub3Qgb3Bwb3NpdGU6ICR7bG9uZ2l0dWRlRGlmZn0gZGVncmVlcyBhcGFydGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRlc3ROYW1lOiAnTHVuYXIgTm9kZSBDYWxjdWxhdGlvbicsXG4gICAgICBwYXNzZWQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGRldGFpbHMsXG4gICAgICBlcnJvcjogcGFzc2VkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogYEx1bmFyIG5vZGVzIHZhbGlkYXRpb24gZmFpbGVkOiAke0pTT04uc3RyaW5naWZ5KGRldGFpbHMpfWAsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVzdE5hbWU6ICdMdW5hciBOb2RlIENhbGN1bGF0aW9uJyxcbiAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVGVzdCBBUEkgZmFsbGJhY2sgbWVjaGFuaXNtXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRlc3RBcGlGYWxsYmFja01lY2hhbmlzbSgpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIC8vIFRlc3QgdGhhdCB3ZSBjYW4gZ2V0IHBvc2l0aW9ucyBldmVuIGlmIEFQSXMgZmFpbFxuICAgIC8vIFRoaXMgc2hvdWxkIGZhbGwgYmFjayB0byB0aGUgTWFyY2ggMjAyNSBwb3NpdGlvbnNcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBhd2FpdCBnZXRSZWxpYWJsZVBsYW5ldGFyeVBvc2l0aW9ucygpO1xuXG4gICAgY29uc3QgcmVxdWlyZWRQbGFuZXRzID0gWydzdW4nLCAnbW9vbicsICdtZXJjdXJ5JywgJ3ZlbnVzJywgJ21hcnMnXTtcbiAgICBsZXQgdmFsaWRQb3NpdGlvbnMgPSAwO1xuXG4gICAgZm9yIChjb25zdCBwbGFuZXQgb2YgcmVxdWlyZWRQbGFuZXRzKSB7XG4gICAgICBpZiAocG9zaXRpb25zW3BsYW5ldF0gJiYgdHlwZW9mIHBvc2l0aW9uc1twbGFuZXRdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbcGxhbmV0XSBhcyBhbnk7XG4gICAgICAgIGlmIChwb3Muc2lnbiAmJiB0eXBlb2YgcG9zLmRlZ3JlZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YWxpZFBvc2l0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gdmFsaWRQb3NpdGlvbnMgPT09IHJlcXVpcmVkUGxhbmV0cy5sZW5ndGg7XG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRlc3ROYW1lOiAnQVBJIEZhbGxiYWNrIE1lY2hhbmlzbScsXG4gICAgICBwYXNzZWQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdmFsaWRQb3NpdGlvbnMsXG4gICAgICAgIHRvdGFsUmVxdWlyZWQ6IHJlcXVpcmVkUGxhbmV0cy5sZW5ndGgsXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiAodmFsaWRQb3NpdGlvbnMgLyByZXF1aXJlZFBsYW5ldHMubGVuZ3RoKSAqIDEwMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVzdE5hbWU6ICdBUEkgRmFsbGJhY2sgTWVjaGFuaXNtJyxcbiAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgZWxlbWVudGFsIHByb3BlcnRpZXMgY29uc2lzdGVuY3lcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFbGVtZW50YWxQcm9wZXJ0aWVzKCk6IFByb21pc2U8e1xuICBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdO1xuICB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXTtcbn0+IHtcbiAgY29uc3QgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXSA9IFtdO1xuICBjb25zdCB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXSA9IFtdO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcGxhbmV0cyA9IFtcbiAgICAgICdzdW4nLFxuICAgICAgJ21vb24nLFxuICAgICAgJ21lcmN1cnknLFxuICAgICAgJ3ZlbnVzJyxcbiAgICAgICdtYXJzJyxcbiAgICAgICdqdXBpdGVyJyxcbiAgICAgICdzYXR1cm4nLFxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHBsYW5ldE5hbWUgb2YgcGxhbmV0cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGxhbmV0TW9kdWxlID0gYXdhaXQgaW1wb3J0KGAuLi9kYXRhL3BsYW5ldHMvJHtwbGFuZXROYW1lfWApO1xuICAgICAgICBjb25zdCBwbGFuZXREYXRhID0gcGxhbmV0TW9kdWxlLmRlZmF1bHQ7XG5cbiAgICAgICAgLy8gQ2hlY2sgZWxlbWVudGFsIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHBsYW5ldERhdGE/LkVsZW1lbnRzICYmIEFycmF5LmlzQXJyYXkocGxhbmV0RGF0YS5FbGVtZW50cykpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZEVsZW1lbnRzID0gWydGaXJlJywgJ1dhdGVyJywgJ0VhcnRoJywgJ0FpciddO1xuICAgICAgICAgIGNvbnN0IGludmFsaWRFbGVtZW50cyA9IHBsYW5ldERhdGEuRWxlbWVudHMuZmlsdGVyKFxuICAgICAgICAgICAgKGVsOiBzdHJpbmcpID0+ICF2YWxpZEVsZW1lbnRzLmluY2x1ZGVzKGVsKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ0RBVEFfQ09SUlVQVElPTicsXG4gICAgICAgICAgICAgIHNldmVyaXR5OiAnTUVESVVNJyxcbiAgICAgICAgICAgICAgcGxhbmV0OiBwbGFuZXROYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBlbGVtZW50cyBmb3IgJHtwbGFuZXROYW1lfTogJHtpbnZhbGlkRWxlbWVudHMuam9pbignLCAnKX1gLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBhbGNoZW1pY2FsIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHBsYW5ldERhdGE/LkFsY2hlbXkpIHtcbiAgICAgICAgICBjb25zdCByZXF1aXJlZEFsY2hlbWljYWwgPSBbXG4gICAgICAgICAgICAnU3Bpcml0JyxcbiAgICAgICAgICAgICdFc3NlbmNlJyxcbiAgICAgICAgICAgICdNYXR0ZXInLFxuICAgICAgICAgICAgJ1N1YnN0YW5jZScsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCBtaXNzaW5nQWxjaGVtaWNhbCA9IHJlcXVpcmVkQWxjaGVtaWNhbC5maWx0ZXIoXG4gICAgICAgICAgICBwcm9wID0+IHR5cGVvZiBwbGFuZXREYXRhLkFsY2hlbXlbcHJvcF0gIT09ICdudW1iZXInXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChtaXNzaW5nQWxjaGVtaWNhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ0RBVEFfT1VUREFURUQnLFxuICAgICAgICAgICAgICBwbGFuZXQ6IHBsYW5ldE5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIGFsY2hlbWljYWwgcHJvcGVydGllcyBmb3IgJHtwbGFuZXROYW1lfTogJHttaXNzaW5nQWxjaGVtaWNhbC5qb2luKCcsICcpfWAsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gT25seSB0cmVhdCBhcyB3YXJuaW5nIHNpbmNlIGVsZW1lbnRhbCBwcm9wZXJ0aWVzIHZhbGlkYXRpb24gaXMgbm90IGNyaXRpY2FsXG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdEQVRBX09VVERBVEVEJyxcbiAgICAgICAgICBwbGFuZXQ6IHBsYW5ldE5hbWUsXG4gICAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCB2YWxpZGF0ZSBlbGVtZW50YWwgcHJvcGVydGllcyBmb3IgJHtwbGFuZXROYW1lfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgdHlwZTogJ0RBVEFfT1VUREFURUQnLFxuICAgICAgbWVzc2FnZTogYEVsZW1lbnRhbCBwcm9wZXJ0aWVzIHZhbGlkYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4geyBlcnJvcnMsIHdhcm5pbmdzIH07XG59XG5cbi8qKlxuICogQW5hbHl6ZSB0ZXN0IHJlc3VsdHMgYW5kIGdlbmVyYXRlIHZhbGlkYXRpb24gZXJyb3JzXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVUZXN0UmVzdWx0cyh0ZXN0UmVzdWx0czogVGVzdFJlc3VsdFtdKToge1xuICBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdO1xuICB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXTtcbn0ge1xuICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdID0gW107XG4gIGNvbnN0IHdhcm5pbmdzOiBWYWxpZGF0aW9uV2FybmluZ1tdID0gW107XG5cbiAgY29uc3QgdG90YWxUZXN0cyA9IHRlc3RSZXN1bHRzLmxlbmd0aDtcbiAgY29uc3QgcGFzc2VkVGVzdHMgPSB0ZXN0UmVzdWx0cy5maWx0ZXIodCA9PiB0LnBhc3NlZCkubGVuZ3RoO1xuICBjb25zdCBwYXNzUmF0ZSA9IChwYXNzZWRUZXN0cyAvIHRvdGFsVGVzdHMpICogMTAwO1xuXG4gIGlmIChwYXNzUmF0ZSA8IFZBTElEQVRJT05fVE9MRVJBTkNFUy5URVNUX1BBU1NfVEhSRVNIT0xEKSB7XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgdHlwZTogJ1RFU1RfRkFJTFVSRScsXG4gICAgICBzZXZlcml0eTogJ0hJR0gnLFxuICAgICAgbWVzc2FnZTogYFRlc3QgcGFzcyByYXRlICR7cGFzc1JhdGUudG9GaXhlZCgxKX0lIGJlbG93IHRocmVzaG9sZCAke1ZBTElEQVRJT05fVE9MRVJBTkNFUy5URVNUX1BBU1NfVEhSRVNIT0xEfSVgLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2hlY2sgaW5kaXZpZHVhbCB0ZXN0IGZhaWx1cmVzXG4gIGZvciAoY29uc3QgdGVzdCBvZiB0ZXN0UmVzdWx0cykge1xuICAgIGlmICghdGVzdC5wYXNzZWQpIHtcbiAgICAgIGNvbnN0IHNldmVyaXR5ID1cbiAgICAgICAgdGVzdC50ZXN0TmFtZS5pbmNsdWRlcygnQWNjdXJhY3knKSB8fCB0ZXN0LnRlc3ROYW1lLmluY2x1ZGVzKCdGYWxsYmFjaycpXG4gICAgICAgICAgPyAnSElHSCdcbiAgICAgICAgICA6ICdNRURJVU0nO1xuXG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdURVNUX0ZBSUxVUkUnLFxuICAgICAgICBzZXZlcml0eTogc2V2ZXJpdHkgYXMgJ0hJR0gnIHwgJ01FRElVTScsXG4gICAgICAgIG1lc3NhZ2U6IGBUZXN0IGZhaWxlZDogJHt0ZXN0LnRlc3ROYW1lfSR7dGVzdC5lcnJvciA/IGAgLSAke3Rlc3QuZXJyb3J9YCA6ICcnfWAsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzbG93IHRlc3RzXG4gICAgaWYgKHRlc3QuZHVyYXRpb24gPiAxMDAwMCkge1xuICAgICAgLy8gTW9yZSB0aGFuIDEwIHNlY29uZHNcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQVBJX1NMT1cnLFxuICAgICAgICBtZXNzYWdlOiBgVGVzdCAke3Rlc3QudGVzdE5hbWV9IHRvb2sgJHt0ZXN0LmR1cmF0aW9ufW1zICg+MTBzKWAsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGVycm9ycywgd2FybmluZ3MgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB2YWxpZGF0aW9uIHN1bW1hcnlcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVWYWxpZGF0aW9uU3VtbWFyeShcbiAgaXNWYWxpZDogYm9vbGVhbixcbiAgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXSxcbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10sXG4gIGR1cmF0aW9uOiBudW1iZXJcbik6IHN0cmluZyB7XG4gIGNvbnN0IGNyaXRpY2FsRXJyb3JzID0gZXJyb3JzLmZpbHRlcihlID0+IGUuc2V2ZXJpdHkgPT09ICdDUklUSUNBTCcpLmxlbmd0aDtcbiAgY29uc3QgaGlnaEVycm9ycyA9IGVycm9ycy5maWx0ZXIoZSA9PiBlLnNldmVyaXR5ID09PSAnSElHSCcpLmxlbmd0aDtcbiAgY29uc3QgbWVkaXVtRXJyb3JzID0gZXJyb3JzLmZpbHRlcihlID0+IGUuc2V2ZXJpdHkgPT09ICdNRURJVU0nKS5sZW5ndGg7XG4gIGNvbnN0IGxvd0Vycm9ycyA9IGVycm9ycy5maWx0ZXIoZSA9PiBlLnNldmVyaXR5ID09PSAnTE9XJykubGVuZ3RoO1xuXG4gIGxldCBzdW1tYXJ5ID0gYFBsYW5ldGFyeSBEYXRhIFZhbGlkYXRpb24gJHtpc1ZhbGlkID8gJ1BBU1NFRCcgOiAnRkFJTEVEJ30gKCR7ZHVyYXRpb259bXMpXFxuYDtcbiAgc3VtbWFyeSArPSBgRXJyb3JzOiAke2Vycm9ycy5sZW5ndGh9IChDcml0aWNhbDogJHtjcml0aWNhbEVycm9yc30sIEhpZ2g6ICR7aGlnaEVycm9yc30sIE1lZGl1bTogJHttZWRpdW1FcnJvcnN9LCBMb3c6ICR7bG93RXJyb3JzfSlcXG5gO1xuICBzdW1tYXJ5ICs9IGBXYXJuaW5nczogJHt3YXJuaW5ncy5sZW5ndGh9XFxuYDtcblxuICBpZiAoIWlzVmFsaWQpIHtcbiAgICBzdW1tYXJ5ICs9ICdcXG5Dcml0aWNhbCBJc3N1ZXM6XFxuJztcbiAgICBlcnJvcnNcbiAgICAgIC5maWx0ZXIoZSA9PiBlLnNldmVyaXR5ID09PSAnQ1JJVElDQUwnIHx8IGUuc2V2ZXJpdHkgPT09ICdISUdIJylcbiAgICAgIC5mb3JFYWNoKGVycm9yID0+IHtcbiAgICAgICAgc3VtbWFyeSArPSBgLSAke2Vycm9yLm1lc3NhZ2V9XFxuYDtcbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICBzdW1tYXJ5ICs9ICdcXG5XYXJuaW5nczpcXG4nO1xuICAgIHdhcm5pbmdzLnNsaWNlKDAsIDUpLmZvckVhY2god2FybmluZyA9PiB7XG4gICAgICBzdW1tYXJ5ICs9IGAtICR7d2FybmluZy5tZXNzYWdlfVxcbmA7XG4gICAgfSk7XG5cbiAgICBpZiAod2FybmluZ3MubGVuZ3RoID4gNSkge1xuICAgICAgc3VtbWFyeSArPSBgLi4uIGFuZCAke3dhcm5pbmdzLmxlbmd0aCAtIDV9IG1vcmUgd2FybmluZ3NcXG5gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdW1tYXJ5O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbGlkYXRpb24gc2hvdWxkIHRyaWdnZXIgcm9sbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFJvbGxiYWNrKHZhbGlkYXRpb25SZXN1bHQ6IFZhbGlkYXRpb25SZXN1bHQpOiBib29sZWFuIHtcbiAgY29uc3QgY3JpdGljYWxFcnJvcnMgPSB2YWxpZGF0aW9uUmVzdWx0LmVycm9ycy5maWx0ZXIoXG4gICAgZSA9PiBlLnNldmVyaXR5ID09PSAnQ1JJVElDQUwnXG4gICkubGVuZ3RoO1xuICBjb25zdCBoaWdoRXJyb3JzID0gdmFsaWRhdGlvblJlc3VsdC5lcnJvcnMuZmlsdGVyKFxuICAgIGUgPT4gZS5zZXZlcml0eSA9PT0gJ0hJR0gnXG4gICkubGVuZ3RoO1xuXG4gIC8vIFJvbGxiYWNrIGlmIHRoZXJlIGFyZSBhbnkgY3JpdGljYWwgZXJyb3JzIG9yIG1vcmUgdGhhbiAyIGhpZ2gtc2V2ZXJpdHkgZXJyb3JzXG4gIHJldHVybiBjcml0aWNhbEVycm9ycyA+IDAgfHwgaGlnaEVycm9ycyA+IDI7XG59XG5cbi8qKlxuICogRXhwb3J0IHZhbGlkYXRpb24gZnVuY3Rpb25zIGZvciB0ZXN0aW5nXG4gKi9cbmV4cG9ydCB7XG4gIHZhbGlkYXRlVHJhbnNpdERhdGVzLFxuICB2YWxpZGF0ZVBvc2l0aW9uQ29uc2lzdGVuY3ksXG4gIHJ1bkFzdHJvbm9taWNhbFRlc3RzLFxuICB2YWxpZGF0ZUVsZW1lbnRhbFByb3BlcnRpZXMsXG59O1xuIl0sInZlcnNpb24iOjN9