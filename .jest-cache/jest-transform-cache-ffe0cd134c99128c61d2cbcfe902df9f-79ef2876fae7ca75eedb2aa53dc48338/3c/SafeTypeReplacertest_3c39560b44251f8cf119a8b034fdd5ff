91b3bcc67b3408cc13c28225de6b4463
"use strict";
/**
 * SafeTypeReplacer Tests
 * Comprehensive test suite for the Safe Type Replacer system
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock execSync for TypeScript compilation tests
jest.mock('child_process');
// Mock fs for file operations
jest.mock('fs');
// Mock SafetyValidator
jest.mock('../SafetyValidator', () => ({
    SafetyValidator: jest.fn().mockImplementation(() => ({
        calculateSafetyScore: jest.fn().mockReturnValue({
            isValid: true,
            safetyScore: 0.9,
            validationErrors: [],
            warnings: [],
            recommendations: []
        }),
        validateTypeScriptCompilation: jest.fn().mockResolvedValue({
            buildSuccessful: true,
            compilationErrors: [],
            lintingWarnings: [],
            performanceMetrics: { buildTime: 100, memoryUsage: 1000000 }
        }),
        validateBuildAfterBatch: jest.fn().mockResolvedValue({
            buildSuccessful: true,
            compilationErrors: [],
            lintingWarnings: [],
            performanceMetrics: { buildTime: 100, memoryUsage: 1000000 }
        }),
        validateRollbackCapability: jest.fn().mockResolvedValue({
            canRollback: true,
            backupIntegrity: true,
            rollbackErrors: [],
            restorationVerified: true
        }),
        updateSafetyThresholds: jest.fn()
    }))
}));
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const SafeTypeReplacer_1 = require("../SafeTypeReplacer");
const types_1 = require("../types");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('SafeTypeReplacer', () => {
    let replacer;
    let testBackupDir;
    beforeEach(() => {
        jest.clearAllMocks();
        testBackupDir = './.test-backups';
        replacer = new SafeTypeReplacer_1.SafeTypeReplacer(testBackupDir, 0.7, 30000, 3);
        // Mock fs.existsSync to return false for backup directory initially
        mockFs.existsSync.mockImplementation((path) => {
            if (path === testBackupDir)
                return false;
            return true; // Assume other files exist
        });
        // Mock fs.mkdirSync
        mockFs.mkdirSync.mockImplementation(() => undefined);
        // Mock fs.readFileSync and writeFileSync
        mockFs.readFileSync.mockImplementation(() => 'const items: unknown[] = [];');
        mockFs.writeFileSync.mockImplementation(() => undefined);
        // Mock successful TypeScript compilation by default
        mockExecSync.mockImplementation(() => '');
    });
    describe('Constructor and Initialization', () => {
        test('creates backup directory if it does not exist', () => {
            expect(mockFs.mkdirSync).toHaveBeenCalledWith(testBackupDir, { recursive: true });
        });
        test('initializes with default strategies', () => {
            const strategies = replacer.getStrategies();
            expect(strategies).toHaveLength(10);
            expect(strategies[0].priority).toBe(1); // Array type strategy should be first
        });
        test('allows custom configuration', () => {
            const customReplacer = new SafeTypeReplacer_1.SafeTypeReplacer('.custom-backup', 0.8, 60000, 5);
            expect(customReplacer.getBackupDirectory()).toBe('.custom-backup');
        });
    });
    describe('Single Replacement Operations', () => {
        test('successfully replaces array types', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];');
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(1);
            expect(result.failedReplacements).toHaveLength(0);
            expect(result.rollbackPerformed).toBe(false);
        });
        test('handles low safety score rejection', async () => {
            const replacement = {
                original: 'any',
                replacement: 'string',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.3,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.failedReplacements).toHaveLength(1);
            expect(result.compilationErrors[0]).toContain('Safety score');
        });
        test('rolls back on TypeScript compilation failure', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock compilation failure
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type mismatch';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Type mismatch');
        });
        test('handles invalid line numbers', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 999,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];'); // Only 1 line
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Invalid line number');
        });
        test('handles pattern not found in line', async () => {
            const replacement = {
                original: 'string[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];'); // Pattern doesn't match
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Pattern "string[]" not found');
        });
    });
    describe('Batch Processing', () => {
        test('processes multiple replacements successfully', async () => {
            const replacements = [
                {
                    original: 'unknown[]',
                    replacement: 'unknown[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'Record<string, unknown>',
                    replacement: 'Record<string, unknown>',
                    filePath: 'test2.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockImplementation((filePath) => {
                if (filePath.includes('test1.ts'))
                    return 'const items: unknown[] = [];';
                if (filePath.includes('test2.ts'))
                    return 'const data: Record<string, unknown> = {};';
                return 'backup content';
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(2);
            expect(result.failedReplacements).toHaveLength(0);
        });
        test('rolls back all changes on overall compilation failure', async () => {
            const replacements = [
                {
                    original: 'unknown[]',
                    replacement: 'unknown[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                }
            ];
            // Mock overall compilation to fail
            mockExecSync.mockImplementation(() => {
                const error = new Error('Overall compilation failed');
                error.stdout = 'error TS2322: Overall type error';
                throw error;
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Overall type error');
        });
        test('groups replacements by file correctly', async () => {
            const replacements = [
                {
                    original: 'unknown[]',
                    replacement: 'unknown[]',
                    filePath: 'test.ts',
                    lineNumber: 2,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'any',
                    replacement: 'unknown',
                    filePath: 'test.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockReturnValue('const x: unknown = 1;\nconst items: unknown[] = [];');
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(2);
        });
    });
    describe('Safety Score Calculation', () => {
        test('calculates higher scores for array replacements', () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.7,
                validationRequired: true
            };
            // Access private method through any cast for testing
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeGreaterThan(0.7); // Should be boosted for array replacement
        });
        test('calculates lower scores for error handling contexts', () => {
            const replacement = {
                original: 'catch (error: unknown)',
                replacement: 'catch (error: unknown)',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeLessThan(0.8); // Should be reduced for error context
        });
        test('boosts scores for test files', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'test.test.ts',
                lineNumber: 1,
                confidence: 0.7,
                validationRequired: true
            };
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeGreaterThan(0.7); // Should be boosted for test files
        });
    });
    describe('Rollback Verification', () => {
        test('verifies rollback capability successfully', async () => {
            const filePath = 'test.ts';
            const backupPath = 'backup.ts';
            mockFs.readFileSync.mockImplementation((path) => {
                if (path === filePath)
                    return 'modified content';
                if (path === backupPath)
                    return 'original content';
                return '';
            });
            const result = await replacer.verifyRollbackCapability(filePath, backupPath);
            expect(result.success).toBe(true);
        });
        test('detects missing backup file', async () => {
            const filePath = 'test.ts';
            const backupPath = 'missing-backup.ts';
            mockFs.existsSync.mockImplementation((path) => {
                return path !== backupPath; // Backup doesn't exist
            });
            const result = await replacer.verifyRollbackCapability(filePath, backupPath);
            expect(result.success).toBe(false);
            expect(result.error).toContain('Backup file does not exist');
        });
    });
    describe('Strategy Management', () => {
        test('allows adding custom strategies', () => {
            const customStrategy = {
                pattern: /custom_pattern/g,
                replacement: () => 'custom_replacement',
                validator: () => true,
                priority: 0
            };
            replacer.addStrategy(customStrategy);
            const strategies = replacer.getStrategies();
            expect(strategies[0]).toBe(customStrategy); // Should be first due to priority 0
        });
        test('maintains strategy priority order', () => {
            const strategies = replacer.getStrategies();
            for (let i = 1; i < strategies.length; i++) {
                expect(strategies[i].priority).toBeGreaterThanOrEqual(strategies[i - 1].priority);
            }
        });
    });
    describe('Backup Management', () => {
        test('creates backups with timestamp', async () => {
            const filePath = 'test.ts';
            mockFs.readFileSync.mockReturnValue('original content');
            const backupPath = await replacer.createBackup(filePath);
            expect(backupPath).toContain('.test-backups');
            expect(backupPath).toContain('test.ts');
            expect(backupPath).toContain('.backup');
            expect(mockFs.writeFileSync).toHaveBeenCalledWith(backupPath, 'original content', 'utf8');
        });
        test('cleans up old backup files', () => {
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            mockFs.readdirSync.mockReturnValue(['old.backup', 'recent.backup', 'other.txt']);
            mockFs.statSync.mockImplementation((filePath) => {
                if (filePath.includes('old.backup')) {
                    return { mtime: oldDate };
                }
                return { mtime: new Date() }; // Recent file
            });
            replacer.cleanupOldBackups(7); // Keep 7 days
            expect(mockFs.unlinkSync).toHaveBeenCalledWith(path.join(testBackupDir, 'old.backup'));
            expect(mockFs.unlinkSync).not.toHaveBeenCalledWith(path.join(testBackupDir, 'recent.backup'));
        });
    });
    describe('Error Handling and Retries', () => {
        test('handles file system errors gracefully', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock backup creation to fail
            mockFs.writeFileSync.mockImplementation((filePath) => {
                if (filePath.includes('.backup')) {
                    throw new Error('Backup creation failed');
                }
            });
            // Expect the error to be thrown since backup creation is critical
            await expect(replacer.applyReplacement(replacement)).rejects.toThrow('Backup creation failed');
        });
        test('handles compilation errors with rollback', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock compilation to fail
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type error';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Type error');
        });
    });
    describe('TypeScript Compilation Validation', () => {
        test('handles successful compilation', async () => {
            mockExecSync.mockReturnValue('');
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
        test('extracts TypeScript errors from output', async () => {
            const errorOutput = `
        src/test.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/test.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        Found 2 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = errorOutput;
                throw error;
            });
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(false);
            expect(result.errors).toHaveLength(2);
            expect(result.errors[0]).toContain('error TS2322');
            expect(result.errors[1]).toContain('error TS2304');
        });
        test('handles compilation timeout', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('Timeout');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(false);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]).toContain('Timeout');
        });
    });
    describe('Advanced Replacement Strategy Patterns', () => {
        test('infers array element types from context', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: unknown[] = ["hello", "world"];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- High-risk domain requiring flexibility
            const inferredType = replacer.inferArrayElementType(context);
            expect(inferredType).toBe('string');
        });
        test('handles complex nested type inference', () => {
            const complexContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const nested: Record<string, unknown[]> = { items: [1, 2, 3] };',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- High-risk domain requiring flexibility
            const arrayType = replacer.inferArrayElementType(complexContext);
            const recordType = replacer.inferRecordValueType(complexContext);
            expect(arrayType).toBe('number');
            expect(recordType).toBe('number[]');
        });
        test('infers types from usage patterns in surrounding code', () => {
            const usageContext = {
                filePath: 'test.ts',
                lineNumber: 2,
                codeSnippet: 'const data: unknown = getValue();',
                surroundingLines: [
                    'function getValue() { return "test"; }',
                    'console.log(data.toUpperCase());',
                    'const length = data.length;'
                ],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferVariableType(usageContext);
            expect(inferredType).toBe('string');
        });
        test('infers Record value types from object literals', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const config: Record<string, unknown> = { name: "test", count: 42 };',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferRecordValueType(context);
            expect(['string', 'number', 'unknown']).toContain(inferredType);
        });
        test('infers function parameter types from parameter names', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function handleClick(event: unknown) { }',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.COMPONENT,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferFunctionParameterType(context, 'event');
            expect(inferredType).toBe('Event');
        });
        test('infers return types from function context', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function isValid(): any {',
                surroundingLines: ['  return true;'],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferReturnType(context);
            expect(inferredType).toBe('boolean');
        });
        test('detects error handling contexts correctly', () => {
            const errorContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'catch (error: unknown) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const isErrorContext = replacer.isInErrorHandlingContext(errorContext);
            expect(isErrorContext).toBe(true);
        });
        test('detects external API contexts correctly', () => {
            const apiContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const response: unknown = await fetch("/api/data");',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.SERVICE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const isApiContext = replacer.isExternalApiContext(apiContext);
            expect(isApiContext).toBe(true);
        });
        test('applies domain-specific type inference for astrological context', () => {
            const astroContext = {
                filePath: 'astrology.ts',
                lineNumber: 1,
                codeSnippet: 'const planetaryPositions: unknown[] = [];',
                surroundingLines: ['positions.push("mars");'],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.ASTROLOGICAL,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- High-risk domain requiring flexibility
            const inferredType = replacer.inferArrayElementType(astroContext);
            expect(inferredType).toBe('string');
        });
        test('applies domain-specific type inference for recipe context', () => {
            const recipeContext = {
                filePath: 'recipe.ts',
                lineNumber: 1,
                codeSnippet: 'function processIngredient(ingredient: unknown) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.RECIPE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferFunctionParameterType(recipeContext, 'ingredient');
            expect(inferredType).toBe('Ingredient');
        });
        test('handles complex replacement patterns with validation', async () => {
            const mockContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function process(data: unknown): any { return data; }',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const strategies = replacer.getStrategies();
            // Test function parameter strategy
            const paramStrategy = strategies.find(s => s.priority === 4);
            expect(paramStrategy).toBeDefined();
            expect(paramStrategy?.validator(mockContext)).toBe(true);
            // Test return type strategy
            const returnStrategy = strategies.find(s => s.priority === 5);
            expect(returnStrategy).toBeDefined();
            expect(returnStrategy?.validator(mockContext)).toBe(true);
        });
    });
    describe('Comprehensive Error Recovery', () => {
        test('handles partial batch failures with selective rollback', async () => {
            const replacements = [
                {
                    original: 'unknown[]',
                    replacement: 'string[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'any',
                    replacement: 'InvalidType',
                    filePath: 'test2.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockImplementation((filePath) => {
                if (filePath.includes('test1.ts'))
                    return 'const items: unknown[] = [];';
                if (filePath.includes('test2.ts'))
                    return 'const data: unknown = value;';
                return 'backup content';
            });
            // Mock compilation to fail for the second replacement
            let compilationCallCount = 0;
            mockExecSync.mockImplementation(() => {
                compilationCallCount++;
                if (compilationCallCount > 1) {
                    const error = new Error('Compilation failed');
                    error.stdout = 'error TS2304: Cannot find name "InvalidType"';
                    throw error;
                }
                return '';
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2304: Cannot find name "InvalidType"');
        });
        test('handles file system permission errors', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'readonly.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];');
            mockFs.writeFileSync.mockImplementation(() => {
                throw new Error('EACCES: permission denied');
            });
            await expect(replacer.applyReplacement(replacement)).rejects.toThrow('EACCES: permission denied');
        });
        test('handles corrupted backup files', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('.backup')) {
                    throw new Error('Backup file corrupted');
                }
                return 'const items: unknown[] = [];';
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
        });
        test('handles network timeouts during validation', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];');
            // Mock timeout error
            mockExecSync.mockImplementation(() => {
                const error = new Error('Command timed out');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors).toContain('Command timed out');
        });
    });
    describe('Performance and Memory Management', () => {
        test('handles large file processing efficiently', async () => {
            const largeContent = 'const items: unknown[] = [];\n'.repeat(10000);
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'large.ts',
                lineNumber: 5000,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue(largeContent);
            const startTime = Date.now();
            const result = await replacer.applyReplacement(replacement);
            const endTime = Date.now();
            expect(result.success).toBe(true);
            expect(endTime - startTime).toBeLessThan(2000); // Should complete within 2 seconds
        });
        test('manages memory during batch processing', async () => {
            const largeBatch = Array(1000).fill(null).map((_, i) => ({
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: `test${i}.ts`,
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            }));
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];');
            const initialMemory = process.memoryUsage().heapUsed;
            const result = await replacer.processBatch(largeBatch);
            const finalMemory = process.memoryUsage().heapUsed;
            expect(result).toBeDefined();
            // Memory usage shouldn't grow excessively (allow 100MB increase)
            expect(finalMemory - initialMemory).toBeLessThan(100 * 1024 * 1024);
        });
        test('cleans up resources after processing', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];');
            await replacer.applyReplacement(replacement);
            // Verify cleanup was called
            expect(mockFs.writeFileSync).toHaveBeenCalled();
            // Test backup cleanup
            replacer.cleanupOldBackups(0); // Clean all backups
            expect(mockFs.unlinkSync).toHaveBeenCalled();
        });
    });
    describe('Integration with Safety Validator', () => {
        test('integrates with safety validator for comprehensive validation', async () => {
            const replacement = {
                original: 'unknown[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: unknown[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            mockFs.readFileSync.mockReturnValue('const items: unknown[] = [];');
            const result = await replacer.applyReplacement(replacement, context);
            expect(result.success).toBe(true);
        });
        test('respects safety validator recommendations', async () => {
            const lowConfidenceReplacement = {
                original: 'any',
                replacement: 'string',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.3,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(lowConfidenceReplacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Safety score');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly50eXBlc2NyaXB0LWZpeC1iYWNrdXAtMjAyNS0wOC0yNVQyMS0yNy0wMC0xMjZaL3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZVR5cGVSZXBsYWNlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRSCxpREFBaUQ7QUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUczQiw4QkFBOEI7QUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUdoQix1QkFBdUI7QUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNuRCxvQkFBb0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDO1lBQzlDLE9BQU8sRUFBRSxJQUFJO1lBQ2IsV0FBVyxFQUFFLEdBQUc7WUFDaEIsZ0JBQWdCLEVBQUUsRUFBRTtZQUNwQixRQUFRLEVBQUUsRUFBRTtZQUNaLGVBQWUsRUFBRSxFQUFFO1NBQ3BCLENBQUM7UUFDRiw2QkFBNkIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUM7WUFDekQsZUFBZSxFQUFFLElBQUk7WUFDckIsaUJBQWlCLEVBQUUsRUFBRTtZQUNyQixlQUFlLEVBQUUsRUFBRTtZQUNuQixrQkFBa0IsRUFBRSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRTtTQUM3RCxDQUFDO1FBQ0YsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFD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RixDQUFDO1lBRUYsTUFBTSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsOEJBQThCLENBQUMsQ0FBQztZQUVwRSxNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDckUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsMkNBQTJDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDM0QsTUFBTSx3QkFBd0IsR0FBb0I7Z0JBQ2hELFFBQVEsRUFBRSxLQUFLO2dCQUNmLFdBQVcsRUFBRSxRQUFRO2dCQUNyQixRQUFRLEVBQUUsU0FBUztnQkFDbkIsVUFBVSxFQUFFLENBQUM7Z0JBQ2IsVUFBVSxFQUFFLEdBQUc7Z0JBQ2Ysa0JBQWtCLEVBQUUsSUFBSTthQUN6QixDQUFDO1lBRUYsTUFBTSxNQUFNLEdBQUcsTUFBTSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUN6RSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNuQyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvR3JlZ0Nhc3Ryby9EZXNrdG9wL1doYXRUb0VhdE5leHQvLnR5cGVzY3JpcHQtZml4LWJhY2t1cC0yMDI1LTA4LTI1VDIxLTI3LTAwLTEyNlovc3JjL3NlcnZpY2VzL2NhbXBhaWduL3VuaW50ZW50aW9uYWwtYW55LWVsaW1pbmF0aW9uL19fdGVzdHNfXy9TYWZlVHlwZVJlcGxhY2VyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTYWZlVHlwZVJlcGxhY2VyIFRlc3RzXG4gKiBDb21wcmVoZW5zaXZlIHRlc3Qgc3VpdGUgZm9yIHRoZSBTYWZlIFR5cGUgUmVwbGFjZXIgc3lzdGVtXG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBTYWZlVHlwZVJlcGxhY2VyIH0gZnJvbSAnLi4vU2FmZVR5cGVSZXBsYWNlcic7XG5pbXBvcnQgeyBDbGFzc2lmaWNhdGlvbkNvbnRleHQsIENvZGVEb21haW4sIFR5cGVSZXBsYWNlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gTW9jayBleGVjU3luYyBmb3IgVHlwZVNjcmlwdCBjb21waWxhdGlvbiB0ZXN0c1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBtb2NrRXhlY1N5bmMgPSBleGVjU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBleGVjU3luYz47XG5cbi8vIE1vY2sgZnMgZm9yIGZpbGUgb3BlcmF0aW9uc1xuamVzdC5tb2NrKCdmcycpO1xuY29uc3QgbW9ja0ZzID0gZnMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzPjtcblxuLy8gTW9jayBTYWZldHlWYWxpZGF0b3Jcbmplc3QubW9jaygnLi4vU2FmZXR5VmFsaWRhdG9yJywgKCkgPT4gKHtcbiAgU2FmZXR5VmFsaWRhdG9yOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgY2FsY3VsYXRlU2FmZXR5U2NvcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIHNhZmV0eVNjb3JlOiAwLjksXG4gICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW11cbiAgICB9KSxcbiAgICB2YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGJ1aWxkU3VjY2Vzc2Z1bDogdHJ1ZSxcbiAgICAgIGNvbXBpbGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgIGxpbnRpbmdXYXJuaW5nczogW10sXG4gICAgICBwZXJmb3JtYW5jZU1ldHJpY3M6IHsgYnVpbGRUaW1lOiAxMDAsIG1lbW9yeVVzYWdlOiAxMDAwMDAwIH1cbiAgICB9KSxcbiAgICB2YWxpZGF0ZUJ1aWxkQWZ0ZXJCYXRjaDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGJ1aWxkU3VjY2Vzc2Z1bDogdHJ1ZSxcbiAgICAgIGNvbXBpbGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgIGxpbnRpbmdXYXJuaW5nczogW10sXG4gICAgICBwZXJmb3JtYW5jZU1ldHJpY3M6IHsgYnVpbGRUaW1lOiAxMDAsIG1lbW9yeVVzYWdlOiAxMDAwMDAwIH1cbiAgICB9KSxcbiAgICB2YWxpZGF0ZVJvbGxiYWNrQ2FwYWJpbGl0eTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGNhblJvbGxiYWNrOiB0cnVlLFxuICAgICAgYmFja3VwSW50ZWdyaXR5OiB0cnVlLFxuICAgICAgcm9sbGJhY2tFcnJvcnM6IFtdLFxuICAgICAgcmVzdG9yYXRpb25WZXJpZmllZDogdHJ1ZVxuICAgIH0pLFxuICAgIHVwZGF0ZVNhZmV0eVRocmVzaG9sZHM6IGplc3QuZm4oKVxuICB9KSlcbn0pKTtcblxuZGVzY3JpYmUoJ1NhZmVUeXBlUmVwbGFjZXInLCAoKSA9PiB7XG4gIGxldCByZXBsYWNlcjogU2FmZVR5cGVSZXBsYWNlcjtcbiAgbGV0IHRlc3RCYWNrdXBEaXI6IHN0cmluZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICB0ZXN0QmFja3VwRGlyID0gJy4vLnRlc3QtYmFja3Vwcyc7XG4gICAgcmVwbGFjZXIgPSBuZXcgU2FmZVR5cGVSZXBsYWNlcih0ZXN0QmFja3VwRGlyLCAwLjcsIDMwMDAwLCAzKTtcblxuICAgIC8vIE1vY2sgZnMuZXhpc3RzU3luYyB0byByZXR1cm4gZmFsc2UgZm9yIGJhY2t1cCBkaXJlY3RvcnkgaW5pdGlhbGx5XG4gICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICBpZiAocGF0aCA9PT0gdGVzdEJhY2t1cERpcikgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIEFzc3VtZSBvdGhlciBmaWxlcyBleGlzdFxuICAgIH0pO1xuXG4gICAgLy8gTW9jayBmcy5ta2RpclN5bmNcbiAgICBtb2NrRnMubWtkaXJTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB1bmRlZmluZWQgYXMgdW5rbm93bik7XG5cbiAgICAvLyBNb2NrIGZzLnJlYWRGaWxlU3luYyBhbmQgd3JpdGVGaWxlU3luY1xuICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICdjb25zdCBpdGVtczogdW5rbm93bltdID0gW107Jyk7XG4gICAgbW9ja0ZzLndyaXRlRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgVHlwZVNjcmlwdCBjb21waWxhdGlvbiBieSBkZWZhdWx0XG4gICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAnJyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25zdHJ1Y3RvciBhbmQgSW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnY3JlYXRlcyBiYWNrdXAgZGlyZWN0b3J5IGlmIGl0IGRvZXMgbm90IGV4aXN0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KG1vY2tGcy5ta2RpclN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RCYWNrdXBEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5pdGlhbGl6ZXMgd2l0aCBkZWZhdWx0IHN0cmF0ZWdpZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gcmVwbGFjZXIuZ2V0U3RyYXRlZ2llcygpO1xuICAgICAgZXhwZWN0KHN0cmF0ZWdpZXMpLnRvSGF2ZUxlbmd0aCgxMCk7XG4gICAgICBleHBlY3Qoc3RyYXRlZ2llc1swXS5wcmlvcml0eSkudG9CZSgxKTsgLy8gQXJyYXkgdHlwZSBzdHJhdGVneSBzaG91bGQgYmUgZmlyc3RcbiAgICB9KTtcblxuICAgIHRlc3QoJ2FsbG93cyBjdXN0b20gY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbVJlcGxhY2VyID0gbmV3IFNhZmVUeXBlUmVwbGFjZXIoJy5jdXN0b20tYmFja3VwJywgMC44LCA2MDAwMCwgNSk7XG4gICAgICBleHBlY3QoY3VzdG9tUmVwbGFjZXIuZ2V0QmFja3VwRGlyZWN0b3J5KCkpLnRvQmUoJy5jdXN0b20tYmFja3VwJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTaW5nbGUgUmVwbGFjZW1lbnQgT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICB0ZXN0KCdzdWNjZXNzZnVsbHkgcmVwbGFjZXMgYXJyYXkgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ3Vua25vd25bXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBpdGVtczogdW5rbm93bltdID0gW107Jyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWRSZXBsYWNlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZmFpbGVkUmVwbGFjZW1lbnRzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgbG93IHNhZmV0eSBzY29yZSByZWplY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAnc3RyaW5nJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC4zLCAvLyBMb3cgY29uZmlkZW5jZVxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWRSZXBsYWNlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnNbMF0pLnRvQ29udGFpbignU2FmZXR5IHNjb3JlJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyb2xscyBiYWNrIG9uIFR5cGVTY3JpcHQgY29tcGlsYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb21waWxhdGlvbiBmYWlsdXJlXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIHVua25vd247XG4gICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IFR5cGUgbWlzbWF0Y2gnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMyMjogVHlwZSBtaXNtYXRjaCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBpbnZhbGlkIGxpbmUgbnVtYmVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiA5OTksIC8vIEludmFsaWQgbGluZSBudW1iZXJcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBpdGVtczogdW5rbm93bltdID0gW107Jyk7IC8vIE9ubHkgMSBsaW5lXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdJbnZhbGlkIGxpbmUgbnVtYmVyJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIHBhdHRlcm4gbm90IGZvdW5kIGluIGxpbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ3N0cmluZ1tdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiB1bmtub3duW10gPSBbXTsnKTsgLy8gUGF0dGVybiBkb2Vzbid0IG1hdGNoXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdQYXR0ZXJuIFwic3RyaW5nW11cIiBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhdGNoIFByb2Nlc3NpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgncHJvY2Vzc2VzIG11bHRpcGxlIHJlcGxhY2VtZW50cyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudHM6IFR5cGVSZXBsYWNlbWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICd1bmtub3duW10nLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QxLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAnUmVjb3JkPHN0cmluZywgdW5rbm93bj4nLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAnUmVjb3JkPHN0cmluZywgdW5rbm93bj4nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdDIudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZVBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCd0ZXN0MS50cycpKSByZXR1cm4gJ2NvbnN0IGl0ZW1zOiB1bmtub3duW10gPSBbXTsnO1xuICAgICAgICBpZiAoZmlsZVBhdGguaW5jbHVkZXMoJ3Rlc3QyLnRzJykpIHJldHVybiAnY29uc3QgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTsnO1xuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5wcm9jZXNzQmF0Y2gocmVwbGFjZW1lbnRzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkUmVwbGFjZW1lbnRzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmZhaWxlZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncm9sbHMgYmFjayBhbGwgY2hhbmdlcyBvbiBvdmVyYWxsIGNvbXBpbGF0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudHM6IFR5cGVSZXBsYWNlbWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICd1bmtub3duW10nLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QxLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBvdmVyYWxsIGNvbXBpbGF0aW9uIHRvIGZhaWxcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignT3ZlcmFsbCBjb21waWxhdGlvbiBmYWlsZWQnKSBhcyB1bmtub3duO1xuICAgICAgICBlcnJvci5zdGRvdXQgPSAnZXJyb3IgVFMyMzIyOiBPdmVyYWxsIHR5cGUgZXJyb3InO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5wcm9jZXNzQmF0Y2gocmVwbGFjZW1lbnRzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMyMjogT3ZlcmFsbCB0eXBlIGVycm9yJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdncm91cHMgcmVwbGFjZW1lbnRzIGJ5IGZpbGUgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRzOiBUeXBlUmVwbGFjZW1lbnRbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAyLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd24nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCB4OiB1bmtub3duID0gMTtcXG5jb25zdCBpdGVtczogdW5rbm93bltdID0gW107Jyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLnByb2Nlc3NCYXRjaChyZXBsYWNlbWVudHMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWRSZXBsYWNlbWVudHMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhZmV0eSBTY29yZSBDYWxjdWxhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdjYWxjdWxhdGVzIGhpZ2hlciBzY29yZXMgZm9yIGFycmF5IHJlcGxhY2VtZW50cycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjcsXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gQWNjZXNzIHByaXZhdGUgbWV0aG9kIHRocm91Z2ggYW55IGNhc3QgZm9yIHRlc3RpbmdcbiAgICAgIGNvbnN0IHNjb3JlID0gKHJlcGxhY2VyIGFzIHVua25vd24pLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChzY29yZSkudG9CZUdyZWF0ZXJUaGFuKDAuNyk7IC8vIFNob3VsZCBiZSBib29zdGVkIGZvciBhcnJheSByZXBsYWNlbWVudFxuICAgIH0pO1xuXG4gICAgdGVzdCgnY2FsY3VsYXRlcyBsb3dlciBzY29yZXMgZm9yIGVycm9yIGhhbmRsaW5nIGNvbnRleHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdjYXRjaCAoZXJyb3I6IHVua25vd24pJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICdjYXRjaCAoZXJyb3I6IHVua25vd24pJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNjb3JlID0gKHJlcGxhY2VyIGFzIHVua25vd24pLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChzY29yZSkudG9CZUxlc3NUaGFuKDAuOCk7IC8vIFNob3VsZCBiZSByZWR1Y2VkIGZvciBlcnJvciBjb250ZXh0XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdib29zdHMgc2NvcmVzIGZvciB0ZXN0IGZpbGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd24nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuNyxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY29yZSA9IChyZXBsYWNlciBhcyB1bmtub3duKS5jYWxjdWxhdGVTYWZldHlTY29yZShyZXBsYWNlbWVudCk7XG4gICAgICBleHBlY3Qoc2NvcmUpLnRvQmVHcmVhdGVyVGhhbigwLjcpOyAvLyBTaG91bGQgYmUgYm9vc3RlZCBmb3IgdGVzdCBmaWxlc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUm9sbGJhY2sgVmVyaWZpY2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3ZlcmlmaWVzIHJvbGxiYWNrIGNhcGFiaWxpdHkgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSAndGVzdC50cyc7XG4gICAgICBjb25zdCBiYWNrdXBQYXRoID0gJ2JhY2t1cC50cyc7XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSBmaWxlUGF0aCkgcmV0dXJuICdtb2RpZmllZCBjb250ZW50JztcbiAgICAgICAgaWYgKHBhdGggPT09IGJhY2t1cFBhdGgpIHJldHVybiAnb3JpZ2luYWwgY29udGVudCc7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAocmVwbGFjZXIgYXMgdW5rbm93bikudmVyaWZ5Um9sbGJhY2tDYXBhYmlsaXR5KGZpbGVQYXRoLCBiYWNrdXBQYXRoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgbWlzc2luZyBiYWNrdXAgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gJ3Rlc3QudHMnO1xuICAgICAgY29uc3QgYmFja3VwUGF0aCA9ICdtaXNzaW5nLWJhY2t1cC50cyc7XG5cbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogdW5rbm93bikgPT4ge1xuICAgICAgICByZXR1cm4gcGF0aCAhPT0gYmFja3VwUGF0aDsgLy8gQmFja3VwIGRvZXNuJ3QgZXhpc3RcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAocmVwbGFjZXIgYXMgdW5rbm93bikudmVyaWZ5Um9sbGJhY2tDYXBhYmlsaXR5KGZpbGVQYXRoLCBiYWNrdXBQYXRoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oJ0JhY2t1cCBmaWxlIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdHJhdGVneSBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ2FsbG93cyBhZGRpbmcgY3VzdG9tIHN0cmF0ZWdpZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21TdHJhdGVneSA9IHtcbiAgICAgICAgcGF0dGVybjogL2N1c3RvbV9wYXR0ZXJuL2csXG4gICAgICAgIHJlcGxhY2VtZW50OiAoKSA9PiAnY3VzdG9tX3JlcGxhY2VtZW50JyxcbiAgICAgICAgdmFsaWRhdG9yOiAoKSA9PiB0cnVlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfTtcblxuICAgICAgcmVwbGFjZXIuYWRkU3RyYXRlZ3koY3VzdG9tU3RyYXRlZ3kpO1xuICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IHJlcGxhY2VyLmdldFN0cmF0ZWdpZXMoKTtcblxuICAgICAgZXhwZWN0KHN0cmF0ZWdpZXNbMF0pLnRvQmUoY3VzdG9tU3RyYXRlZ3kpOyAvLyBTaG91bGQgYmUgZmlyc3QgZHVlIHRvIHByaW9yaXR5IDBcbiAgICB9KTtcblxuICAgIHRlc3QoJ21haW50YWlucyBzdHJhdGVneSBwcmlvcml0eSBvcmRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSByZXBsYWNlci5nZXRTdHJhdGVnaWVzKCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyYXRlZ2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHBlY3Qoc3RyYXRlZ2llc1tpXS5wcmlvcml0eSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChzdHJhdGVnaWVzW2kgLSAxXS5wcmlvcml0eSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCYWNrdXAgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdjcmVhdGVzIGJhY2t1cHMgd2l0aCB0aW1lc3RhbXAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9ICd0ZXN0LnRzJztcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdvcmlnaW5hbCBjb250ZW50Jyk7XG5cbiAgICAgIGNvbnN0IGJhY2t1cFBhdGggPSBhd2FpdCAocmVwbGFjZXIgYXMgdW5rbm93bikuY3JlYXRlQmFja3VwKGZpbGVQYXRoKTtcblxuICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbignLnRlc3QtYmFja3VwcycpO1xuICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbigndGVzdC50cycpO1xuICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbignLmJhY2t1cCcpO1xuICAgICAgZXhwZWN0KG1vY2tGcy53cml0ZUZpbGVTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYmFja3VwUGF0aCxcbiAgICAgICAgJ29yaWdpbmFsIGNvbnRlbnQnLFxuICAgICAgICAndXRmOCdcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjbGVhbnMgdXAgb2xkIGJhY2t1cCBmaWxlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG9sZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgb2xkRGF0ZS5zZXREYXRlKG9sZERhdGUuZ2V0RGF0ZSgpIC0gMTApOyAvLyAxMCBkYXlzIG9sZFxuXG4gICAgICBtb2NrRnMucmVhZGRpclN5bmMubW9ja1JldHVyblZhbHVlKFsnb2xkLmJhY2t1cCcsICdyZWNlbnQuYmFja3VwJywgJ290aGVyLnR4dCddIGFzIHVua25vd24pO1xuICAgICAgbW9ja0ZzLnN0YXRTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZVBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCdvbGQuYmFja3VwJykpIHtcbiAgICAgICAgICByZXR1cm4geyBtdGltZTogb2xkRGF0ZSB9IGFzIHVua25vd247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbXRpbWU6IG5ldyBEYXRlKCkgfSBhcyB1bmtub3duOyAvLyBSZWNlbnQgZmlsZVxuICAgICAgfSk7XG5cbiAgICAgIHJlcGxhY2VyLmNsZWFudXBPbGRCYWNrdXBzKDcpOyAvLyBLZWVwIDcgZGF5c1xuXG4gICAgICBleHBlY3QobW9ja0ZzLnVubGlua1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBwYXRoLmpvaW4odGVzdEJhY2t1cERpciwgJ29sZC5iYWNrdXAnKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrRnMudW5saW5rU3luYykubm90LnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBwYXRoLmpvaW4odGVzdEJhY2t1cERpciwgJ3JlY2VudC5iYWNrdXAnKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nIGFuZCBSZXRyaWVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2hhbmRsZXMgZmlsZSBzeXN0ZW0gZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ3Vua25vd25bXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgYmFja3VwIGNyZWF0aW9uIHRvIGZhaWxcbiAgICAgIG1vY2tGcy53cml0ZUZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZVBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2t1cCBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4cGVjdCB0aGUgZXJyb3IgdG8gYmUgdGhyb3duIHNpbmNlIGJhY2t1cCBjcmVhdGlvbiBpcyBjcml0aWNhbFxuICAgICAgYXdhaXQgZXhwZWN0KHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpKS5yZWplY3RzLnRvVGhyb3coJ0JhY2t1cCBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY29tcGlsYXRpb24gZXJyb3JzIHdpdGggcm9sbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ3Vua25vd25bXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgY29tcGlsYXRpb24gdG8gZmFpbFxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDb21waWxhdGlvbiBmYWlsZWQnKSBhcyB1bmtub3duO1xuICAgICAgICBlcnJvci5zdGRvdXQgPSAnZXJyb3IgVFMyMzIyOiBUeXBlIGVycm9yJztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9ycykudG9Db250YWluKCdlcnJvciBUUzIzMjI6IFR5cGUgZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1R5cGVTY3JpcHQgQ29tcGlsYXRpb24gVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdoYW5kbGVzIHN1Y2Nlc3NmdWwgY29tcGlsYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKHJlcGxhY2VyIGFzIHVua25vd24pLnZhbGlkYXRlVHlwZVNjcmlwdENvbXBpbGF0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdleHRyYWN0cyBUeXBlU2NyaXB0IGVycm9ycyBmcm9tIG91dHB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yT3V0cHV0ID0gYFxuICAgICAgICBzcmMvdGVzdC50cygxMCw1KTogZXJyb3IgVFMyMzIyOiBUeXBlICdzdHJpbmcnIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHR5cGUgJ251bWJlcicuXG4gICAgICAgIHNyYy90ZXN0LnRzKDE1LDEwKTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd1bmtub3duVmFyaWFibGUnLlxuICAgICAgICBGb3VuZCAyIGVycm9ycy5cbiAgICAgIGA7XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgdW5rbm93bjtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gZXJyb3JPdXRwdXQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChyZXBsYWNlciBhcyB1bmtub3duKS52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzBdKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMyMicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnNbMV0pLnRvQ29udGFpbignZXJyb3IgVFMyMzA0Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGNvbXBpbGF0aW9uIHRpbWVvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1RpbWVvdXQnKSBhcyB1bmtub3duO1xuICAgICAgICBlcnJvci5jb2RlID0gJ1RJTUVPVVQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAocmVwbGFjZXIgYXMgdW5rbm93bikudmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yc1swXSkudG9Db250YWluKCdUaW1lb3V0Jyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBZHZhbmNlZCBSZXBsYWNlbWVudCBTdHJhdGVneSBQYXR0ZXJucycsICgpID0+IHtcbiAgICB0ZXN0KCdpbmZlcnMgYXJyYXkgZWxlbWVudCB0eXBlcyBmcm9tIGNvbnRleHQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgaXRlbXM6IHVua25vd25bXSA9IFtcImhlbGxvXCIsIFwid29ybGRcIl07JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gSGlnaC1yaXNrIGRvbWFpbiByZXF1aXJpbmcgZmxleGliaWxpdHlcbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyQXJyYXlFbGVtZW50VHlwZShjb250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ3N0cmluZycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb21wbGV4IG5lc3RlZCB0eXBlIGluZmVyZW5jZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBsZXhDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgbmVzdGVkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duW10+ID0geyBpdGVtczogWzEsIDIsIDNdIH07JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gSGlnaC1yaXNrIGRvbWFpbiByZXF1aXJpbmcgZmxleGliaWxpdHlcbiAgICAgIGNvbnN0IGFycmF5VHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyQXJyYXlFbGVtZW50VHlwZShjb21wbGV4Q29udGV4dCk7XG4gICAgICBjb25zdCByZWNvcmRUeXBlID0gKHJlcGxhY2VyIGFzIHVua25vd24pLmluZmVyUmVjb3JkVmFsdWVUeXBlKGNvbXBsZXhDb250ZXh0KTtcblxuICAgICAgZXhwZWN0KGFycmF5VHlwZSkudG9CZSgnbnVtYmVyJyk7XG4gICAgICBleHBlY3QocmVjb3JkVHlwZSkudG9CZSgnbnVtYmVyW10nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2luZmVycyB0eXBlcyBmcm9tIHVzYWdlIHBhdHRlcm5zIGluIHN1cnJvdW5kaW5nIGNvZGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1c2FnZUNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMixcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBkYXRhOiB1bmtub3duID0gZ2V0VmFsdWUoKTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXG4gICAgICAgICAgJ2Z1bmN0aW9uIGdldFZhbHVlKCkgeyByZXR1cm4gXCJ0ZXN0XCI7IH0nLFxuICAgICAgICAgICdjb25zb2xlLmxvZyhkYXRhLnRvVXBwZXJDYXNlKCkpOycsXG4gICAgICAgICAgJ2NvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOydcbiAgICAgICAgXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgdW5rbm93bikuaW5mZXJWYXJpYWJsZVR5cGUodXNhZ2VDb250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ3N0cmluZycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5mZXJzIFJlY29yZCB2YWx1ZSB0eXBlcyBmcm9tIG9iamVjdCBsaXRlcmFscycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBjb25maWc6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0geyBuYW1lOiBcInRlc3RcIiwgY291bnQ6IDQyIH07JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaW5mZXJyZWRUeXBlID0gKHJlcGxhY2VyIGFzIHVua25vd24pLmluZmVyUmVjb3JkVmFsdWVUeXBlKGNvbnRleHQpO1xuICAgICAgZXhwZWN0KFsnc3RyaW5nJywgJ251bWJlcicsICd1bmtub3duJ10pLnRvQ29udGFpbihpbmZlcnJlZFR5cGUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5mZXJzIGZ1bmN0aW9uIHBhcmFtZXRlciB0eXBlcyBmcm9tIHBhcmFtZXRlciBuYW1lcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudDogdW5rbm93bikgeyB9JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uQ09NUE9ORU5ULFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgdW5rbm93bikuaW5mZXJGdW5jdGlvblBhcmFtZXRlclR5cGUoY29udGV4dCwgJ2V2ZW50Jyk7XG4gICAgICBleHBlY3QoaW5mZXJyZWRUeXBlKS50b0JlKCdFdmVudCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5mZXJzIHJldHVybiB0eXBlcyBmcm9tIGZ1bmN0aW9uIGNvbnRleHQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnZnVuY3Rpb24gaXNWYWxpZCgpOiBhbnkgeycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFsnICByZXR1cm4gdHJ1ZTsnXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgdW5rbm93bikuaW5mZXJSZXR1cm5UeXBlKGNvbnRleHQpO1xuICAgICAgZXhwZWN0KGluZmVycmVkVHlwZSkudG9CZSgnYm9vbGVhbicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGV0ZWN0cyBlcnJvciBoYW5kbGluZyBjb250ZXh0cyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvckNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjYXRjaCAoZXJyb3I6IHVua25vd24pIHsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpc0Vycm9yQ29udGV4dCA9IChyZXBsYWNlciBhcyB1bmtub3duKS5pc0luRXJyb3JIYW5kbGluZ0NvbnRleHQoZXJyb3JDb250ZXh0KTtcbiAgICAgIGV4cGVjdChpc0Vycm9yQ29udGV4dCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgZXh0ZXJuYWwgQVBJIGNvbnRleHRzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGFwaUNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCByZXNwb25zZTogdW5rbm93biA9IGF3YWl0IGZldGNoKFwiL2FwaS9kYXRhXCIpOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlNFUlZJQ0UsXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGlzQXBpQ29udGV4dCA9IChyZXBsYWNlciBhcyB1bmtub3duKS5pc0V4dGVybmFsQXBpQ29udGV4dChhcGlDb250ZXh0KTtcbiAgICAgIGV4cGVjdChpc0FwaUNvbnRleHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdhcHBsaWVzIGRvbWFpbi1zcGVjaWZpYyB0eXBlIGluZmVyZW5jZSBmb3IgYXN0cm9sb2dpY2FsIGNvbnRleHQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBhc3Ryb0NvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICdhc3Ryb2xvZ3kudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IHBsYW5ldGFyeVBvc2l0aW9uczogdW5rbm93bltdID0gW107JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogWydwb3NpdGlvbnMucHVzaChcIm1hcnNcIik7J10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uQVNUUk9MT0dJQ0FMLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBIaWdoLXJpc2sgZG9tYWluIHJlcXVpcmluZyBmbGV4aWJpbGl0eVxuICAgICAgY29uc3QgaW5mZXJyZWRUeXBlID0gKHJlcGxhY2VyIGFzIGFueSkuaW5mZXJBcnJheUVsZW1lbnRUeXBlKGFzdHJvQ29udGV4dCk7XG4gICAgICBleHBlY3QoaW5mZXJyZWRUeXBlKS50b0JlKCdzdHJpbmcnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2FwcGxpZXMgZG9tYWluLXNwZWNpZmljIHR5cGUgaW5mZXJlbmNlIGZvciByZWNpcGUgY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlY2lwZUNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICdyZWNpcGUudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2Z1bmN0aW9uIHByb2Nlc3NJbmdyZWRpZW50KGluZ3JlZGllbnQ6IHVua25vd24pIHsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5SRUNJUEUsXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyB1bmtub3duKS5pbmZlckZ1bmN0aW9uUGFyYW1ldGVyVHlwZShyZWNpcGVDb250ZXh0LCAnaW5ncmVkaWVudCcpO1xuICAgICAgZXhwZWN0KGluZmVycmVkVHlwZSkudG9CZSgnSW5ncmVkaWVudCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb21wbGV4IHJlcGxhY2VtZW50IHBhdHRlcm5zIHdpdGggdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnZnVuY3Rpb24gcHJvY2VzcyhkYXRhOiB1bmtub3duKTogYW55IHsgcmV0dXJuIGRhdGE7IH0nLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gcmVwbGFjZXIuZ2V0U3RyYXRlZ2llcygpO1xuXG4gICAgICAvLyBUZXN0IGZ1bmN0aW9uIHBhcmFtZXRlciBzdHJhdGVneVxuICAgICAgY29uc3QgcGFyYW1TdHJhdGVneSA9IHN0cmF0ZWdpZXMuZmluZChzID0+IHMucHJpb3JpdHkgPT09IDQpO1xuICAgICAgZXhwZWN0KHBhcmFtU3RyYXRlZ3kpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocGFyYW1TdHJhdGVneT8udmFsaWRhdG9yKG1vY2tDb250ZXh0KSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gVGVzdCByZXR1cm4gdHlwZSBzdHJhdGVneVxuICAgICAgY29uc3QgcmV0dXJuU3RyYXRlZ3kgPSBzdHJhdGVnaWVzLmZpbmQocyA9PiBzLnByaW9yaXR5ID09PSA1KTtcbiAgICAgIGV4cGVjdChyZXR1cm5TdHJhdGVneSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXR1cm5TdHJhdGVneT8udmFsaWRhdG9yKG1vY2tDb250ZXh0KSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXByZWhlbnNpdmUgRXJyb3IgUmVjb3ZlcnknLCAoKSA9PiB7XG4gICAgdGVzdCgnaGFuZGxlcyBwYXJ0aWFsIGJhdGNoIGZhaWx1cmVzIHdpdGggc2VsZWN0aXZlIHJvbGxiYWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRzOiBUeXBlUmVwbGFjZW1lbnRbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3N0cmluZ1tdJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QxLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ0ludmFsaWRUeXBlJywgLy8gVGhpcyBzaG91bGQgY2F1c2UgY29tcGlsYXRpb24gZXJyb3JcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QyLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGZpbGVQYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChmaWxlUGF0aC5pbmNsdWRlcygndGVzdDEudHMnKSkgcmV0dXJuICdjb25zdCBpdGVtczogdW5rbm93bltdID0gW107JztcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCd0ZXN0Mi50cycpKSByZXR1cm4gJ2NvbnN0IGRhdGE6IHVua25vd24gPSB2YWx1ZTsnO1xuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGNvbXBpbGF0aW9uIHRvIGZhaWwgZm9yIHRoZSBzZWNvbmQgcmVwbGFjZW1lbnRcbiAgICAgIGxldCBjb21waWxhdGlvbkNhbGxDb3VudCA9IDA7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29tcGlsYXRpb25DYWxsQ291bnQrKztcbiAgICAgICAgaWYgKGNvbXBpbGF0aW9uQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDb21waWxhdGlvbiBmYWlsZWQnKSBhcyB1bmtub3duO1xuICAgICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgXCJJbnZhbGlkVHlwZVwiJztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKHJlcGxhY2VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9ycykudG9Db250YWluKCdlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgXCJJbnZhbGlkVHlwZVwiJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGZpbGUgc3lzdGVtIHBlcm1pc3Npb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICd1bmtub3duW10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAncmVhZG9ubHkudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiB1bmtub3duW10gPSBbXTsnKTtcbiAgICAgIG1vY2tGcy53cml0ZUZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRUFDQ0VTOiBwZXJtaXNzaW9uIGRlbmllZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChyZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KSkucmVqZWN0cy50b1Rocm93KCdFQUNDRVM6IHBlcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGNvcnJ1cHRlZCBiYWNrdXAgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ3Vua25vd25bXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2t1cCBmaWxlIGNvcnJ1cHRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnY29uc3QgaXRlbXM6IHVua25vd25bXSA9IFtdOyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBuZXR3b3JrIHRpbWVvdXRzIGR1cmluZyB2YWxpZGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICd1bmtub3duW10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IHVua25vd25bXSA9IFtdOycpO1xuXG4gICAgICAvLyBNb2NrIHRpbWVvdXQgZXJyb3JcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tbWFuZCB0aW1lZCBvdXQnKSBhcyB1bmtub3duO1xuICAgICAgICBlcnJvci5jb2RlID0gJ1RJTUVPVVQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0NvbnRhaW4oJ0NvbW1hbmQgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBhbmQgTWVtb3J5IE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnaGFuZGxlcyBsYXJnZSBmaWxlIHByb2Nlc3NpbmcgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZUNvbnRlbnQgPSAnY29uc3QgaXRlbXM6IHVua25vd25bXSA9IFtdO1xcbicucmVwZWF0KDEwMDAwKTtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ2xhcmdlLnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogNTAwMCxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGxhcmdlQ29udGVudCk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDIwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDIgc2Vjb25kc1xuICAgIH0pO1xuXG4gICAgdGVzdCgnbWFuYWdlcyBtZW1vcnkgZHVyaW5nIGJhdGNoIHByb2Nlc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZUJhdGNoOiBUeXBlUmVwbGFjZW1lbnRbXSA9IEFycmF5KDEwMDApLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICBvcmlnaW5hbDogJ3Vua25vd25bXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6IGB0ZXN0JHtpfS50c2AsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBpdGVtczogdW5rbm93bltdID0gW107Jyk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5wcm9jZXNzQmF0Y2gobGFyZ2VCYXRjaCk7XG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIC8vIE1lbW9yeSB1c2FnZSBzaG91bGRuJ3QgZ3JvdyBleGNlc3NpdmVseSAoYWxsb3cgMTAwTUIgaW5jcmVhc2UpXG4gICAgICBleHBlY3QoZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5KS50b0JlTGVzc1RoYW4oMTAwICogMTAyNCAqIDEwMjQpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnY2xlYW5zIHVwIHJlc291cmNlcyBhZnRlciBwcm9jZXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICd1bmtub3duW10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IHVua25vd25bXSA9IFtdOycpO1xuXG4gICAgICBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgLy8gVmVyaWZ5IGNsZWFudXAgd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tGcy53cml0ZUZpbGVTeW5jKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIC8vIFRlc3QgYmFja3VwIGNsZWFudXBcbiAgICAgIHJlcGxhY2VyLmNsZWFudXBPbGRCYWNrdXBzKDApOyAvLyBDbGVhbiBhbGwgYmFja3Vwc1xuICAgICAgZXhwZWN0KG1vY2tGcy51bmxpbmtTeW5jKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiB3aXRoIFNhZmV0eSBWYWxpZGF0b3InLCAoKSA9PiB7XG4gICAgdGVzdCgnaW50ZWdyYXRlcyB3aXRoIHNhZmV0eSB2YWxpZGF0b3IgZm9yIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAndW5rbm93bltdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IGl0ZW1zOiB1bmtub3duW10gPSBbXTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IHVua25vd25bXSA9IFtdOycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50LCBjb250ZXh0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Jlc3BlY3RzIHNhZmV0eSB2YWxpZGF0b3IgcmVjb21tZW5kYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG93Q29uZmlkZW5jZVJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICdzdHJpbmcnLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjMsIC8vIFZlcnkgbG93IGNvbmZpZGVuY2VcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KGxvd0NvbmZpZGVuY2VSZXBsYWNlbWVudCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdTYWZldHkgc2NvcmUnKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==