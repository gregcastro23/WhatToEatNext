298a8bf8d8f9fda46bae83e6702940dc
"use strict";
/**
 * AutomatedLintingFixer Tests
 *
 * Comprehensive test suite for the automated linting fixer with safety protocols
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock external dependencies
jest.mock('child_process');
jest.mock('fs');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const AutomatedLintingFixer_1 = require("../AutomatedLintingFixer");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('AutomatedLintingFixer', () => {
    let fixer;
    let mockCategorizedErrors;
    let mockLintingIssues;
    beforeEach(() => {
        jest.clearAllMocks();
        // Setup default mocks
        mockExecSync.mockReturnValue('');
        mockFs.readFileSync.mockReturnValue('const unusedVar = "test";\nconsole.log("hello");');
        mockFs.writeFileSync.mockImplementation(() => { });
        mockFs.existsSync.mockReturnValue(true);
        // Create fixer instance
        fixer = new AutomatedLintingFixer_1.AutomatedLintingFixer('/test/workspace', {
            enableRollback: true,
            validateBeforeFix: true,
            validateAfterFix: true,
            maxFailuresBeforeStop: 3,
        });
        // Setup mock linting issues
        mockLintingIssues = [
            {
                id: 'test-1',
                file: 'src/test.ts',
                line: 1,
                column: 7,
                rule: '@typescript-eslint/no-unused-vars',
                message: "'unusedVar' is defined but never used",
                severity: 'warning',
                category: { primary: 'typescript', secondary: 'no-unused-vars', priority: 2 },
                autoFixable: true,
                resolutionStrategy: {
                    type: 'auto-fix',
                    confidence: 0.8,
                    riskLevel: 'low',
                    requiredValidation: [],
                    estimatedEffort: 1,
                    dependencies: [],
                },
            },
            {
                id: 'test-2',
                file: 'src/imports.ts',
                line: 1,
                column: 1,
                rule: 'import/order',
                message: 'Import order is incorrect',
                severity: 'warning',
                category: { primary: 'import', secondary: 'order', priority: 3 },
                autoFixable: true,
                resolutionStrategy: {
                    type: 'auto-fix',
                    confidence: 0.9,
                    riskLevel: 'low',
                    requiredValidation: [],
                    estimatedEffort: 0.5,
                    dependencies: [],
                },
            },
        ];
        mockCategorizedErrors = {
            total: mockLintingIssues.length,
            errors: 0,
            warnings: mockLintingIssues.length,
            byCategory: {
                typescript: [mockLintingIssues[0]],
                import: [mockLintingIssues[1]],
            },
            byPriority: {
                2: [mockLintingIssues[0]],
                3: [mockLintingIssues[1]],
            },
            byFile: {
                'src/test.ts': [mockLintingIssues[0]],
                'src/imports.ts': [mockLintingIssues[1]],
            },
            autoFixable: mockLintingIssues,
            requiresManualReview: [],
        };
    });
    describe('applyAutomatedFixes', () => {
        it('should successfully apply automated fixes with default options', async () => {
            // Mock successful validation
            mockExecSync
                .mockReturnValueOnce('') // build
                .mockReturnValueOnce('') // type-check
                .mockReturnValueOnce('') // lint
                .mockReturnValueOnce('stash@{0}: automated-linting-fixes') // git stash
                .mockReturnValueOnce('') // eslint fix file 1
                .mockReturnValueOnce('') // eslint fix file 2
                .mockReturnValueOnce('') // final build
                .mockReturnValueOnce('') // final type-check
                .mockReturnValueOnce(''); // final lint
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors);
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(2);
            expect(result.failedIssues).toBe(0);
            expect(result.processedFiles).toHaveLength(2);
            expect(result.rollbackInfo).toBeDefined();
        });
        it('should handle batch processing with custom batch size', async () => {
            const batchOptions = {
                batchSize: 1,
                validateAfterEachBatch: true,
            };
            // Mock successful operations
            mockExecSync.mockReturnValue('');
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors, batchOptions);
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(2);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('eslint --config'), expect.any(Object));
        });
        it('should perform rollback on validation failure', async () => {
            // Mock validation failure after first batch
            mockExecSync
                .mockReturnValueOnce('') // initial build
                .mockReturnValueOnce('') // initial type-check
                .mockReturnValueOnce('') // initial lint
                .mockReturnValueOnce('stash@{0}: automated-linting-fixes') // git stash
                .mockReturnValueOnce('') // eslint fix
                .mockImplementationOnce(() => {
                throw new Error('Build failed');
            }) // build validation fails
                .mockReturnValueOnce(''); // rollback
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors, {
                batchSize: 1,
                validateAfterEachBatch: true,
            });
            expect(result.metrics.rollbacksPerformed).toBe(1);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash pop'), expect.any(Object));
        });
        it('should skip preserved files', async () => {
            const preservedIssue = {
                ...mockLintingIssues[0],
                file: 'src/calculations/astrological.ts',
            };
            const categorizedWithPreserved = {
                ...mockCategorizedErrors,
                autoFixable: [preservedIssue],
            };
            mockExecSync.mockReturnValue('');
            const result = await fixer.applyAutomatedFixes(categorizedWithPreserved);
            expect(result.fixedIssues).toBe(0);
            expect(result.processedFiles).toHaveLength(0);
        });
        it('should handle dry run mode', async () => {
            mockExecSync.mockReturnValue('');
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors, {
                dryRun: true,
            });
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(2);
            // Should not actually run eslint fix commands in dry run
            expect(mockExecSync).not.toHaveBeenCalledWith(expect.stringContaining('eslint --config'), expect.any(Object));
        });
        it('should stop after max failures', async () => {
            // Mock failures
            mockExecSync
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('stash@{0}') // git stash
                .mockImplementationOnce(() => {
                throw new Error('Fix failed');
            }) // first fix fails
                .mockImplementationOnce(() => {
                throw new Error('Build failed');
            }) // validation fails
                .mockReturnValueOnce('') // rollback
                .mockImplementationOnce(() => {
                throw new Error('Fix failed');
            }) // second fix fails
                .mockImplementationOnce(() => {
                throw new Error('Build failed');
            }) // validation fails
                .mockReturnValueOnce('') // rollback
                .mockImplementationOnce(() => {
                throw new Error('Fix failed');
            }); // third fix fails
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors, {
                batchSize: 1,
                continueOnError: true,
            });
            expect(result.success).toBe(false);
            expect(result.metrics.rollbacksPerformed).toBeGreaterThan(0);
        });
    });
    describe('handleUnusedVariables', () => {
        it('should prefix unused variables with underscore', async () => {
            const unusedVarIssues = [mockLintingIssues[0]];
            const result = await fixer.handleUnusedVariables(unusedVarIssues, {
                prefixWithUnderscore: true,
                removeCompletely: false,
            });
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(1);
            expect(mockFs.writeFileSync).toHaveBeenCalledWith(expect.stringContaining('src/test.ts'), expect.stringContaining('_unusedVar'));
        });
        it('should skip domain files when configured', async () => {
            const domainIssue = {
                ...mockLintingIssues[0],
                file: 'src/calculations/planetary.ts',
                domainContext: {
                    isAstrologicalCalculation: true,
                    isCampaignSystem: false,
                    isTestFile: false,
                    isScriptFile: false,
                    requiresSpecialHandling: true,
                },
            };
            const result = await fixer.handleUnusedVariables([domainIssue], {
                skipDomainFiles: true,
            });
            expect(result.fixedIssues).toBe(0);
            expect(mockFs.writeFileSync).not.toHaveBeenCalled();
        });
        it('should skip test files when configured', async () => {
            const testIssue = {
                ...mockLintingIssues[0],
                file: 'src/test.spec.ts',
                domainContext: {
                    isAstrologicalCalculation: false,
                    isCampaignSystem: false,
                    isTestFile: true,
                    isScriptFile: false,
                    requiresSpecialHandling: true,
                },
            };
            const result = await fixer.handleUnusedVariables([testIssue], {
                skipTestFiles: true,
            });
            expect(result.fixedIssues).toBe(0);
            expect(mockFs.writeFileSync).not.toHaveBeenCalled();
        });
        it('should handle file read/write errors gracefully', async () => {
            mockFs.readFileSync.mockImplementationOnce(() => {
                throw new Error('File read error');
            });
            const result = await fixer.handleUnusedVariables([mockLintingIssues[0]]);
            expect(result.success).toBe(false);
            expect(result.failedIssues).toBe(1);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0].severity).toBe('error');
        });
    });
    describe('optimizeImports', () => {
        it('should optimize import statements successfully', async () => {
            const importIssues = [mockLintingIssues[1]];
            mockExecSync.mockReturnValue('');
            const result = await fixer.optimizeImports(importIssues, {
                removeDuplicates: true,
                organizeImports: true,
                sortImports: true,
            });
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(1);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('eslint --config'), expect.any(Object));
        });
        it('should group issues by file for batch processing', async () => {
            const multipleImportIssues = [
                mockLintingIssues[1],
                {
                    ...mockLintingIssues[1],
                    id: 'test-3',
                    rule: 'import/newline-after-import',
                },
            ];
            mockExecSync.mockReturnValue('');
            const result = await fixer.optimizeImports(multipleImportIssues);
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(2);
            expect(result.processedFiles).toHaveLength(1); // Same file, so only one processed
        });
        it('should handle eslint command failures', async () => {
            mockExecSync.mockImplementationOnce(() => {
                throw new Error('ESLint command failed');
            });
            const result = await fixer.optimizeImports([mockLintingIssues[1]]);
            expect(result.success).toBe(false);
            expect(result.failedIssues).toBe(1);
            expect(result.errors).toHaveLength(1);
        });
    });
    describe('improveTypeAnnotations', () => {
        it('should improve simple type annotations', async () => {
            const typeIssue = {
                ...mockLintingIssues[0],
                rule: '@typescript-eslint/no-explicit-any',
                message: "'any' type should be replaced with specific type in parameter",
                autoFixable: true,
            };
            mockExecSync.mockReturnValue('');
            const result = await fixer.improveTypeAnnotations([typeIssue], {
                maxComplexity: 'simple',
                inferFromUsage: true,
            });
            expect(result.success).toBe(true);
            expect(result.fixedIssues).toBe(1);
        });
        it('should skip complex type issues when configured for simple only', async () => {
            const complexTypeIssue = {
                ...mockLintingIssues[0],
                rule: '@typescript-eslint/no-explicit-any',
                message: "'any' type in complex generic constraint",
                autoFixable: false,
            };
            const result = await fixer.improveTypeAnnotations([complexTypeIssue], {
                maxComplexity: 'simple',
            });
            expect(result.fixedIssues).toBe(0);
        });
        it('should preserve explicit any in specified patterns', async () => {
            const astroTypeIssue = {
                ...mockLintingIssues[0],
                file: 'src/calculations/planetary.ts',
                rule: '@typescript-eslint/no-explicit-any',
            };
            const result = await fixer.improveTypeAnnotations([astroTypeIssue], {
                preserveExplicitAny: ['**/calculations/**'],
            });
            expect(result.fixedIssues).toBe(0);
        });
    });
    describe('validateFixes', () => {
        it('should run comprehensive validation successfully', async () => {
            mockExecSync
                .mockReturnValueOnce('') // build
                .mockReturnValueOnce('') // type-check
                .mockReturnValueOnce('') // lint
                .mockReturnValueOnce(''); // test
            const results = await fixer.validateFixes();
            expect(results).toHaveLength(4);
            expect(results.every(r => r.success)).toBe(true);
            expect(results.map(r => r.type)).toEqual(['build', 'type-check', 'lint', 'test']);
        });
        it('should handle validation failures gracefully', async () => {
            mockExecSync
                .mockImplementationOnce(() => {
                throw new Error('Build failed');
            })
                .mockReturnValueOnce('') // type-check
                .mockReturnValueOnce('') // lint
                .mockReturnValueOnce(''); // test
            const results = await fixer.validateFixes();
            expect(results[0].success).toBe(false);
            expect(results[0].type).toBe('build');
            expect(results[0].details).toContain('Build failed');
        });
        it('should skip test validation if no jest config exists', async () => {
            mockFs.existsSync.mockReturnValue(false);
            mockExecSync
                .mockReturnValueOnce('') // build
                .mockReturnValueOnce('') // type-check
                .mockReturnValueOnce(''); // lint
            const results = await fixer.validateFixes();
            expect(results).toHaveLength(3);
            expect(results.map(r => r.type)).not.toContain('test');
        });
    });
    describe('performRollback', () => {
        it('should perform rollback successfully', async () => {
            // First create a backup
            mockExecSync
                .mockReturnValueOnce('') // git add and stash
                .mockReturnValueOnce('stash@{0}: automated-linting-fixes-test'); // git stash list
            await fixer.applyAutomatedFixes(mockCategorizedErrors, { createBackups: true });
            // Then perform rollback
            mockExecSync.mockReturnValueOnce(''); // git stash pop
            const rollbackSuccess = await fixer.performRollback();
            expect(rollbackSuccess).toBe(true);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash pop'), expect.any(Object));
        });
        it('should handle rollback failure gracefully', async () => {
            // Create backup first
            mockExecSync.mockReturnValueOnce('').mockReturnValueOnce('stash@{0}: test');
            await fixer.applyAutomatedFixes(mockCategorizedErrors, { createBackups: true });
            // Mock rollback failure
            mockExecSync.mockImplementationOnce(() => {
                throw new Error('Rollback failed');
            });
            const rollbackSuccess = await fixer.performRollback();
            expect(rollbackSuccess).toBe(false);
        });
        it('should return false when no rollback info available', async () => {
            const rollbackSuccess = await fixer.performRollback();
            expect(rollbackSuccess).toBe(false);
        });
    });
    describe('Safety Protocols', () => {
        it('should respect safety protocols configuration', () => {
            const strictSafetyProtocols = {
                enableRollback: true,
                validateBeforeFix: true,
                validateAfterFix: true,
                maxFailuresBeforeStop: 1,
                requireManualApproval: true,
                preservePatterns: ['**/critical/**'],
            };
            const strictFixer = new AutomatedLintingFixer_1.AutomatedLintingFixer('/test', strictSafetyProtocols);
            expect(strictFixer).toBeDefined();
        });
        it('should preserve files matching safety patterns', async () => {
            const criticalIssue = {
                ...mockLintingIssues[0],
                file: 'src/calculations/critical-astro.ts',
            };
            const result = await fixer.applyAutomatedFixes({
                ...mockCategorizedErrors,
                autoFixable: [criticalIssue],
            });
            expect(result.fixedIssues).toBe(0);
        });
        it('should skip high-risk issues', async () => {
            const highRiskIssue = {
                ...mockLintingIssues[0],
                resolutionStrategy: {
                    ...mockLintingIssues[0].resolutionStrategy,
                    riskLevel: 'high',
                },
            };
            const result = await fixer.applyAutomatedFixes({
                ...mockCategorizedErrors,
                autoFixable: [highRiskIssue],
            });
            expect(result.fixedIssues).toBe(0);
        });
        it('should skip low-confidence fixes', async () => {
            const lowConfidenceIssue = {
                ...mockLintingIssues[0],
                resolutionStrategy: {
                    ...mockLintingIssues[0].resolutionStrategy,
                    confidence: 0.3,
                },
            };
            const result = await fixer.applyAutomatedFixes({
                ...mockCategorizedErrors,
                autoFixable: [lowConfidenceIssue],
            });
            expect(result.fixedIssues).toBe(0);
        });
    });
    describe('Error Handling', () => {
        it('should collect and report errors properly', async () => {
            mockExecSync
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('stash@{0}') // backup
                .mockImplementationOnce(() => {
                throw new Error('Fix command failed');
            });
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0].severity).toBe('error');
            expect(result.errors[0].message).toContain('batch');
        });
        it('should perform emergency rollback on critical failure', async () => {
            mockExecSync
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('') // initial validation
                .mockReturnValueOnce('stash@{0}') // backup
                .mockImplementationOnce(() => {
                throw new Error('Critical system failure');
            })
                .mockReturnValueOnce(''); // emergency rollback
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors);
            expect(result.success).toBe(false);
            expect(result.metrics.rollbacksPerformed).toBe(1);
            expect(result.errors.some(e => e.severity === 'critical')).toBe(true);
        });
    });
    describe('Metrics Collection', () => {
        it('should collect comprehensive metrics', async () => {
            mockExecSync.mockReturnValue('');
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors);
            expect(result.metrics).toBeDefined();
            expect(result.metrics.startTime).toBeInstanceOf(Date);
            expect(result.metrics.endTime).toBeInstanceOf(Date);
            expect(result.metrics.totalTime).toBeGreaterThan(0);
            expect(result.metrics.filesProcessed).toBe(2);
            expect(result.metrics.issuesAttempted).toBe(2);
            expect(result.metrics.issuesFixed).toBe(2);
            expect(result.metrics.issuesFailed).toBe(0);
        });
        it('should track rollback metrics', async () => {
            mockExecSync
                .mockReturnValueOnce('') // validation
                .mockReturnValueOnce('') // validation
                .mockReturnValueOnce('') // validation
                .mockReturnValueOnce('stash@{0}') // backup
                .mockReturnValueOnce('') // fix
                .mockImplementationOnce(() => {
                throw new Error('Validation failed');
            }) // validation fails
                .mockReturnValueOnce(''); // rollback
            const result = await fixer.applyAutomatedFixes(mockCategorizedErrors, {
                validateAfterEachBatch: true,
            });
            expect(result.metrics.rollbacksPerformed).toBe(1);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL3NlcnZpY2VzL2xpbnRpbmcvX190ZXN0c19fL0F1dG9tYXRlZExpbnRpbmdGaXhlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYUgsNkJBQTZCO0FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQWJoQixpREFBeUM7QUFDekMsdUNBQXlCO0FBRXpCLG9FQUtrQztBQU9sQyxNQUFNLFlBQVksR0FBRyx3QkFBZ0QsQ0FBQztBQUN0RSxNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBRTVDLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7SUFDckMsSUFBSSxLQUE0QixDQUFDO0lBQ2pDLElBQUkscUJBQXdDLENBQUM7SUFDN0MsSUFBSSxpQkFBaUMsQ0FBQztJQUV0QyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXJCLHNCQUFzQjtRQUN0QixZQUFZLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLGtEQUFrRCxDQUFDLENBQUM7UUFDeEYsTUFBTSxDQUFDLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUMsQ0FBQztRQUNsRCxNQUFNLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV4Qyx3QkFBd0I7UUFDeEIsS0FBSyxHQUFHLElBQUksNkNBQXFCLENBQUMsaUJBQWlCLEVBQUU7WUFDbkQsY0FBYyxFQUFFLElBQUk7WUFDcEIsaUJBQWlCLEVBQUUsSUFBSTtZQUN2Qixn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QUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9iYWNrdXBzL2ZpcnN0LXdhdmUtMjAyNS0wOC0xMVQwNS0xOS0yNi04MTNaL3NyYy9zZXJ2aWNlcy9saW50aW5nL19fdGVzdHNfXy9BdXRvbWF0ZWRMaW50aW5nRml4ZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF1dG9tYXRlZExpbnRpbmdGaXhlciBUZXN0c1xuICpcbiAqIENvbXByZWhlbnNpdmUgdGVzdCBzdWl0ZSBmb3IgdGhlIGF1dG9tYXRlZCBsaW50aW5nIGZpeGVyIHdpdGggc2FmZXR5IHByb3RvY29sc1xuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB7XG4gIEF1dG9tYXRlZExpbnRpbmdGaXhlcixcbiAgQXV0b21hdGVkRml4UmVzdWx0LFxuICBCYXRjaFByb2Nlc3NpbmdPcHRpb25zLFxuICBTYWZldHlQcm90b2NvbHMsXG59IGZyb20gJy4uL0F1dG9tYXRlZExpbnRpbmdGaXhlcic7XG5pbXBvcnQgeyBMaW50aW5nSXNzdWUsIENhdGVnb3JpemVkRXJyb3JzIH0gZnJvbSAnLi4vTGludGluZ0Vycm9yQW5hbHl6ZXInO1xuXG4vLyBNb2NrIGV4dGVybmFsIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJyk7XG5qZXN0Lm1vY2soJ2ZzJyk7XG5cbmNvbnN0IG1vY2tFeGVjU3luYyA9IGV4ZWNTeW5jIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGV4ZWNTeW5jPjtcbmNvbnN0IG1vY2tGcyA9IGZzIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBmcz47XG5cbmRlc2NyaWJlKCdBdXRvbWF0ZWRMaW50aW5nRml4ZXInLCAoKSA9PiB7XG4gIGxldCBmaXhlcjogQXV0b21hdGVkTGludGluZ0ZpeGVyO1xuICBsZXQgbW9ja0NhdGVnb3JpemVkRXJyb3JzOiBDYXRlZ29yaXplZEVycm9ycztcbiAgbGV0IG1vY2tMaW50aW5nSXNzdWVzOiBMaW50aW5nSXNzdWVbXTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcblxuICAgIC8vIFNldHVwIGRlZmF1bHQgbW9ja3NcbiAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcbiAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgdW51c2VkVmFyID0gXCJ0ZXN0XCI7XFxuY29uc29sZS5sb2coXCJoZWxsb1wiKTsnKTtcbiAgICBtb2NrRnMud3JpdGVGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgIC8vIENyZWF0ZSBmaXhlciBpbnN0YW5jZVxuICAgIGZpeGVyID0gbmV3IEF1dG9tYXRlZExpbnRpbmdGaXhlcignL3Rlc3Qvd29ya3NwYWNlJywge1xuICAgICAgZW5hYmxlUm9sbGJhY2s6IHRydWUsXG4gICAgICB2YWxpZGF0ZUJlZm9yZUZpeDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlQWZ0ZXJGaXg6IHRydWUsXG4gICAgICBtYXhGYWlsdXJlc0JlZm9yZVN0b3A6IDMsXG4gICAgfSk7XG5cbiAgICAvLyBTZXR1cCBtb2NrIGxpbnRpbmcgaXNzdWVzXG4gICAgbW9ja0xpbnRpbmdJc3N1ZXMgPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAndGVzdC0xJyxcbiAgICAgICAgZmlsZTogJ3NyYy90ZXN0LnRzJyxcbiAgICAgICAgbGluZTogMSxcbiAgICAgICAgY29sdW1uOiA3LFxuICAgICAgICBydWxlOiAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyxcbiAgICAgICAgbWVzc2FnZTogXCIndW51c2VkVmFyJyBpcyBkZWZpbmVkIGJ1dCBuZXZlciB1c2VkXCIsXG4gICAgICAgIHNldmVyaXR5OiAnd2FybmluZycsXG4gICAgICAgIGNhdGVnb3J5OiB7IHByaW1hcnk6ICd0eXBlc2NyaXB0Jywgc2Vjb25kYXJ5OiAnbm8tdW51c2VkLXZhcnMnLCBwcmlvcml0eTogMiB9LFxuICAgICAgICBhdXRvRml4YWJsZTogdHJ1ZSxcbiAgICAgICAgcmVzb2x1dGlvblN0cmF0ZWd5OiB7XG4gICAgICAgICAgdHlwZTogJ2F1dG8tZml4JyxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgcmlza0xldmVsOiAnbG93JyxcbiAgICAgICAgICByZXF1aXJlZFZhbGlkYXRpb246IFtdLFxuICAgICAgICAgIGVzdGltYXRlZEVmZm9ydDogMSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICd0ZXN0LTInLFxuICAgICAgICBmaWxlOiAnc3JjL2ltcG9ydHMudHMnLFxuICAgICAgICBsaW5lOiAxLFxuICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgIHJ1bGU6ICdpbXBvcnQvb3JkZXInLFxuICAgICAgICBtZXNzYWdlOiAnSW1wb3J0IG9yZGVyIGlzIGluY29ycmVjdCcsXG4gICAgICAgIHNldmVyaXR5OiAnd2FybmluZycsXG4gICAgICAgIGNhdGVnb3J5OiB7IHByaW1hcnk6ICdpbXBvcnQnLCBzZWNvbmRhcnk6ICdvcmRlcicsIHByaW9yaXR5OiAzIH0sXG4gICAgICAgIGF1dG9GaXhhYmxlOiB0cnVlLFxuICAgICAgICByZXNvbHV0aW9uU3RyYXRlZ3k6IHtcbiAgICAgICAgICB0eXBlOiAnYXV0by1maXgnLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICByaXNrTGV2ZWw6ICdsb3cnLFxuICAgICAgICAgIHJlcXVpcmVkVmFsaWRhdGlvbjogW10sXG4gICAgICAgICAgZXN0aW1hdGVkRWZmb3J0OiAwLjUsXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIG1vY2tDYXRlZ29yaXplZEVycm9ycyA9IHtcbiAgICAgIHRvdGFsOiBtb2NrTGludGluZ0lzc3Vlcy5sZW5ndGgsXG4gICAgICBlcnJvcnM6IDAsXG4gICAgICB3YXJuaW5nczogbW9ja0xpbnRpbmdJc3N1ZXMubGVuZ3RoLFxuICAgICAgYnlDYXRlZ29yeToge1xuICAgICAgICB0eXBlc2NyaXB0OiBbbW9ja0xpbnRpbmdJc3N1ZXNbMF1dLFxuICAgICAgICBpbXBvcnQ6IFttb2NrTGludGluZ0lzc3Vlc1sxXV0sXG4gICAgICB9LFxuICAgICAgYnlQcmlvcml0eToge1xuICAgICAgICAyOiBbbW9ja0xpbnRpbmdJc3N1ZXNbMF1dLFxuICAgICAgICAzOiBbbW9ja0xpbnRpbmdJc3N1ZXNbMV1dLFxuICAgICAgfSxcbiAgICAgIGJ5RmlsZToge1xuICAgICAgICAnc3JjL3Rlc3QudHMnOiBbbW9ja0xpbnRpbmdJc3N1ZXNbMF1dLFxuICAgICAgICAnc3JjL2ltcG9ydHMudHMnOiBbbW9ja0xpbnRpbmdJc3N1ZXNbMV1dLFxuICAgICAgfSxcbiAgICAgIGF1dG9GaXhhYmxlOiBtb2NrTGludGluZ0lzc3VlcyxcbiAgICAgIHJlcXVpcmVzTWFudWFsUmV2aWV3OiBbXSxcbiAgICB9O1xuICB9KTtcblxuICBkZXNjcmliZSgnYXBwbHlBdXRvbWF0ZWRGaXhlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSBhcHBseSBhdXRvbWF0ZWQgZml4ZXMgd2l0aCBkZWZhdWx0IG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvblxuICAgICAgbW9ja0V4ZWNTeW5jXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBidWlsZFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gdHlwZS1jaGVja1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gbGludFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnc3Rhc2hAezB9OiBhdXRvbWF0ZWQtbGludGluZy1maXhlcycpIC8vIGdpdCBzdGFzaFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gZXNsaW50IGZpeCBmaWxlIDFcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGVzbGludCBmaXggZmlsZSAyXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBmaW5hbCBidWlsZFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gZmluYWwgdHlwZS1jaGVja1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJyk7IC8vIGZpbmFsIGxpbnRcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIuYXBwbHlBdXRvbWF0ZWRGaXhlcyhtb2NrQ2F0ZWdvcml6ZWRFcnJvcnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWRJc3N1ZXMpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnByb2Nlc3NlZEZpbGVzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrSW5mbykudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJhdGNoIHByb2Nlc3Npbmcgd2l0aCBjdXN0b20gYmF0Y2ggc2l6ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoT3B0aW9uczogUGFydGlhbDxCYXRjaFByb2Nlc3NpbmdPcHRpb25zPiA9IHtcbiAgICAgICAgYmF0Y2hTaXplOiAxLFxuICAgICAgICB2YWxpZGF0ZUFmdGVyRWFjaEJhdGNoOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIG9wZXJhdGlvbnNcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKG1vY2tDYXRlZ29yaXplZEVycm9ycywgYmF0Y2hPcHRpb25zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5maXhlZElzc3VlcykudG9CZSgyKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdlc2xpbnQgLS1jb25maWcnKSwgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGVyZm9ybSByb2xsYmFjayBvbiB2YWxpZGF0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRpb24gZmFpbHVyZSBhZnRlciBmaXJzdCBiYXRjaFxuICAgICAgbW9ja0V4ZWNTeW5jXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBpbml0aWFsIGJ1aWxkXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBpbml0aWFsIHR5cGUtY2hlY2tcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGluaXRpYWwgbGludFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnc3Rhc2hAezB9OiBhdXRvbWF0ZWQtbGludGluZy1maXhlcycpIC8vIGdpdCBzdGFzaFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gZXNsaW50IGZpeFxuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWlsZCBmYWlsZWQnKTtcbiAgICAgICAgfSkgLy8gYnVpbGQgdmFsaWRhdGlvbiBmYWlsc1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJyk7IC8vIHJvbGxiYWNrXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLmFwcGx5QXV0b21hdGVkRml4ZXMobW9ja0NhdGVnb3JpemVkRXJyb3JzLCB7XG4gICAgICAgIGJhdGNoU2l6ZTogMSxcbiAgICAgICAgdmFsaWRhdGVBZnRlckVhY2hCYXRjaDogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0Lm1ldHJpY3Mucm9sbGJhY2tzUGVyZm9ybWVkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2dpdCBzdGFzaCBwb3AnKSwgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCBwcmVzZXJ2ZWQgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVzZXJ2ZWRJc3N1ZTogTGludGluZ0lzc3VlID0ge1xuICAgICAgICAuLi5tb2NrTGludGluZ0lzc3Vlc1swXSxcbiAgICAgICAgZmlsZTogJ3NyYy9jYWxjdWxhdGlvbnMvYXN0cm9sb2dpY2FsLnRzJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhdGVnb3JpemVkV2l0aFByZXNlcnZlZDogQ2F0ZWdvcml6ZWRFcnJvcnMgPSB7XG4gICAgICAgIC4uLm1vY2tDYXRlZ29yaXplZEVycm9ycyxcbiAgICAgICAgYXV0b0ZpeGFibGU6IFtwcmVzZXJ2ZWRJc3N1ZV0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIuYXBwbHlBdXRvbWF0ZWRGaXhlcyhjYXRlZ29yaXplZFdpdGhQcmVzZXJ2ZWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzZWRGaWxlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZHJ5IHJ1biBtb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLmFwcGx5QXV0b21hdGVkRml4ZXMobW9ja0NhdGVnb3JpemVkRXJyb3JzLCB7XG4gICAgICAgIGRyeVJ1bjogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDIpO1xuICAgICAgLy8gU2hvdWxkIG5vdCBhY3R1YWxseSBydW4gZXNsaW50IGZpeCBjb21tYW5kcyBpbiBkcnkgcnVuXG4gICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2VzbGludCAtLWNvbmZpZycpLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIGFmdGVyIG1heCBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZmFpbHVyZXNcbiAgICAgIG1vY2tFeGVjU3luY1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gaW5pdGlhbCB2YWxpZGF0aW9uXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBpbml0aWFsIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGluaXRpYWwgdmFsaWRhdGlvblxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnc3Rhc2hAezB9JykgLy8gZ2l0IHN0YXNoXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpeCBmYWlsZWQnKTtcbiAgICAgICAgfSkgLy8gZmlyc3QgZml4IGZhaWxzXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1aWxkIGZhaWxlZCcpO1xuICAgICAgICB9KSAvLyB2YWxpZGF0aW9uIGZhaWxzXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyByb2xsYmFja1xuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXggZmFpbGVkJyk7XG4gICAgICAgIH0pIC8vIHNlY29uZCBmaXggZmFpbHNcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnVpbGQgZmFpbGVkJyk7XG4gICAgICAgIH0pIC8vIHZhbGlkYXRpb24gZmFpbHNcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIHJvbGxiYWNrXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpeCBmYWlsZWQnKTtcbiAgICAgICAgfSk7IC8vIHRoaXJkIGZpeCBmYWlsc1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKG1vY2tDYXRlZ29yaXplZEVycm9ycywge1xuICAgICAgICBiYXRjaFNpemU6IDEsXG4gICAgICAgIGNvbnRpbnVlT25FcnJvcjogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzLnJvbGxiYWNrc1BlcmZvcm1lZCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaGFuZGxlVW51c2VkVmFyaWFibGVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJlZml4IHVudXNlZCB2YXJpYWJsZXMgd2l0aCB1bmRlcnNjb3JlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdW51c2VkVmFySXNzdWVzID0gW21vY2tMaW50aW5nSXNzdWVzWzBdXTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIuaGFuZGxlVW51c2VkVmFyaWFibGVzKHVudXNlZFZhcklzc3Vlcywge1xuICAgICAgICBwcmVmaXhXaXRoVW5kZXJzY29yZTogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlQ29tcGxldGVseTogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5maXhlZElzc3VlcykudG9CZSgxKTtcbiAgICAgIGV4cGVjdChtb2NrRnMud3JpdGVGaWxlU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzcmMvdGVzdC50cycpLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnX3VudXNlZFZhcicpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCBkb21haW4gZmlsZXMgd2hlbiBjb25maWd1cmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZG9tYWluSXNzdWU6IExpbnRpbmdJc3N1ZSA9IHtcbiAgICAgICAgLi4ubW9ja0xpbnRpbmdJc3N1ZXNbMF0sXG4gICAgICAgIGZpbGU6ICdzcmMvY2FsY3VsYXRpb25zL3BsYW5ldGFyeS50cycsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBpc0FzdHJvbG9naWNhbENhbGN1bGF0aW9uOiB0cnVlLFxuICAgICAgICAgIGlzQ2FtcGFpZ25TeXN0ZW06IGZhbHNlLFxuICAgICAgICAgIGlzVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICAgIGlzU2NyaXB0RmlsZTogZmFsc2UsXG4gICAgICAgICAgcmVxdWlyZXNTcGVjaWFsSGFuZGxpbmc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5oYW5kbGVVbnVzZWRWYXJpYWJsZXMoW2RvbWFpbklzc3VlXSwge1xuICAgICAgICBza2lwRG9tYWluRmlsZXM6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maXhlZElzc3VlcykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChtb2NrRnMud3JpdGVGaWxlU3luYykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCB0ZXN0IGZpbGVzIHdoZW4gY29uZmlndXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RJc3N1ZTogTGludGluZ0lzc3VlID0ge1xuICAgICAgICAuLi5tb2NrTGludGluZ0lzc3Vlc1swXSxcbiAgICAgICAgZmlsZTogJ3NyYy90ZXN0LnNwZWMudHMnLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgaXNBc3Ryb2xvZ2ljYWxDYWxjdWxhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaXNDYW1wYWlnblN5c3RlbTogZmFsc2UsXG4gICAgICAgICAgaXNUZXN0RmlsZTogdHJ1ZSxcbiAgICAgICAgICBpc1NjcmlwdEZpbGU6IGZhbHNlLFxuICAgICAgICAgIHJlcXVpcmVzU3BlY2lhbEhhbmRsaW5nOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIuaGFuZGxlVW51c2VkVmFyaWFibGVzKFt0ZXN0SXNzdWVdLCB7XG4gICAgICAgIHNraXBUZXN0RmlsZXM6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maXhlZElzc3VlcykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChtb2NrRnMud3JpdGVGaWxlU3luYykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbGUgcmVhZC93cml0ZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSByZWFkIGVycm9yJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIuaGFuZGxlVW51c2VkVmFyaWFibGVzKFttb2NrTGludGluZ0lzc3Vlc1swXV0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWRJc3N1ZXMpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnNbMF0uc2V2ZXJpdHkpLnRvQmUoJ2Vycm9yJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdvcHRpbWl6ZUltcG9ydHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBvcHRpbWl6ZSBpbXBvcnQgc3RhdGVtZW50cyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJc3N1ZXMgPSBbbW9ja0xpbnRpbmdJc3N1ZXNbMV1dO1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLm9wdGltaXplSW1wb3J0cyhpbXBvcnRJc3N1ZXMsIHtcbiAgICAgICAgcmVtb3ZlRHVwbGljYXRlczogdHJ1ZSxcbiAgICAgICAgb3JnYW5pemVJbXBvcnRzOiB0cnVlLFxuICAgICAgICBzb3J0SW1wb3J0czogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2VzbGludCAtLWNvbmZpZycpLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBncm91cCBpc3N1ZXMgYnkgZmlsZSBmb3IgYmF0Y2ggcHJvY2Vzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG11bHRpcGxlSW1wb3J0SXNzdWVzID0gW1xuICAgICAgICBtb2NrTGludGluZ0lzc3Vlc1sxXSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm1vY2tMaW50aW5nSXNzdWVzWzFdLFxuICAgICAgICAgIGlkOiAndGVzdC0zJyxcbiAgICAgICAgICBydWxlOiAnaW1wb3J0L25ld2xpbmUtYWZ0ZXItaW1wb3J0JyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5vcHRpbWl6ZUltcG9ydHMobXVsdGlwbGVJbXBvcnRJc3N1ZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzZWRGaWxlcykudG9IYXZlTGVuZ3RoKDEpOyAvLyBTYW1lIGZpbGUsIHNvIG9ubHkgb25lIHByb2Nlc3NlZFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXNsaW50IGNvbW1hbmQgZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRVNMaW50IGNvbW1hbmQgZmFpbGVkJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIub3B0aW1pemVJbXBvcnRzKFttb2NrTGludGluZ0lzc3Vlc1sxXV0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWRJc3N1ZXMpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaW1wcm92ZVR5cGVBbm5vdGF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGltcHJvdmUgc2ltcGxlIHR5cGUgYW5ub3RhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0eXBlSXNzdWU6IExpbnRpbmdJc3N1ZSA9IHtcbiAgICAgICAgLi4ubW9ja0xpbnRpbmdJc3N1ZXNbMF0sXG4gICAgICAgIHJ1bGU6ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55JyxcbiAgICAgICAgbWVzc2FnZTogXCInYW55JyB0eXBlIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHNwZWNpZmljIHR5cGUgaW4gcGFyYW1ldGVyXCIsXG4gICAgICAgIGF1dG9GaXhhYmxlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLmltcHJvdmVUeXBlQW5ub3RhdGlvbnMoW3R5cGVJc3N1ZV0sIHtcbiAgICAgICAgbWF4Q29tcGxleGl0eTogJ3NpbXBsZScsXG4gICAgICAgIGluZmVyRnJvbVVzYWdlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZml4ZWRJc3N1ZXMpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgY29tcGxleCB0eXBlIGlzc3VlcyB3aGVuIGNvbmZpZ3VyZWQgZm9yIHNpbXBsZSBvbmx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcGxleFR5cGVJc3N1ZTogTGludGluZ0lzc3VlID0ge1xuICAgICAgICAuLi5tb2NrTGludGluZ0lzc3Vlc1swXSxcbiAgICAgICAgcnVsZTogJ0B0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnknLFxuICAgICAgICBtZXNzYWdlOiBcIidhbnknIHR5cGUgaW4gY29tcGxleCBnZW5lcmljIGNvbnN0cmFpbnRcIixcbiAgICAgICAgYXV0b0ZpeGFibGU6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZml4ZXIuaW1wcm92ZVR5cGVBbm5vdGF0aW9ucyhbY29tcGxleFR5cGVJc3N1ZV0sIHtcbiAgICAgICAgbWF4Q29tcGxleGl0eTogJ3NpbXBsZScsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maXhlZElzc3VlcykudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJlc2VydmUgZXhwbGljaXQgYW55IGluIHNwZWNpZmllZCBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFzdHJvVHlwZUlzc3VlOiBMaW50aW5nSXNzdWUgPSB7XG4gICAgICAgIC4uLm1vY2tMaW50aW5nSXNzdWVzWzBdLFxuICAgICAgICBmaWxlOiAnc3JjL2NhbGN1bGF0aW9ucy9wbGFuZXRhcnkudHMnLFxuICAgICAgICBydWxlOiAnQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5pbXByb3ZlVHlwZUFubm90YXRpb25zKFthc3Ryb1R5cGVJc3N1ZV0sIHtcbiAgICAgICAgcHJlc2VydmVFeHBsaWNpdEFueTogWycqKi9jYWxjdWxhdGlvbnMvKionXSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVGaXhlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJ1biBjb21wcmVoZW5zaXZlIHZhbGlkYXRpb24gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBidWlsZFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gdHlwZS1jaGVja1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gbGludFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJyk7IC8vIHRlc3RcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGZpeGVyLnZhbGlkYXRlRml4ZXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KHIgPT4gci5zdWNjZXNzKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLm1hcChyID0+IHIudHlwZSkpLnRvRXF1YWwoWydidWlsZCcsICd0eXBlLWNoZWNrJywgJ2xpbnQnLCAndGVzdCddKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZmFpbHVyZXMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luY1xuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWlsZCBmYWlsZWQnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIHR5cGUtY2hlY2tcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGxpbnRcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpOyAvLyB0ZXN0XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBmaXhlci52YWxpZGF0ZUZpeGVzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzWzBdLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdHNbMF0udHlwZSkudG9CZSgnYnVpbGQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzWzBdLmRldGFpbHMpLnRvQ29udGFpbignQnVpbGQgZmFpbGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgdGVzdCB2YWxpZGF0aW9uIGlmIG5vIGplc3QgY29uZmlnIGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG4gICAgICBtb2NrRXhlY1N5bmNcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGJ1aWxkXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyB0eXBlLWNoZWNrXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKTsgLy8gbGludFxuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZml4ZXIudmFsaWRhdGVGaXhlcygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KHJlc3VsdHMubWFwKHIgPT4gci50eXBlKSkubm90LnRvQ29udGFpbigndGVzdCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGVyZm9ybVJvbGxiYWNrJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcGVyZm9ybSByb2xsYmFjayBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBGaXJzdCBjcmVhdGUgYSBiYWNrdXBcbiAgICAgIG1vY2tFeGVjU3luY1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gZ2l0IGFkZCBhbmQgc3Rhc2hcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJ3N0YXNoQHswfTogYXV0b21hdGVkLWxpbnRpbmctZml4ZXMtdGVzdCcpOyAvLyBnaXQgc3Rhc2ggbGlzdFxuXG4gICAgICBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKG1vY2tDYXRlZ29yaXplZEVycm9ycywgeyBjcmVhdGVCYWNrdXBzOiB0cnVlIH0pO1xuXG4gICAgICAvLyBUaGVuIHBlcmZvcm0gcm9sbGJhY2tcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKTsgLy8gZ2l0IHN0YXNoIHBvcFxuXG4gICAgICBjb25zdCByb2xsYmFja1N1Y2Nlc3MgPSBhd2FpdCBmaXhlci5wZXJmb3JtUm9sbGJhY2soKTtcblxuICAgICAgZXhwZWN0KHJvbGxiYWNrU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdnaXQgc3Rhc2ggcG9wJyksIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByb2xsYmFjayBmYWlsdXJlIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYmFja3VwIGZpcnN0XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlT25jZSgnJykubW9ja1JldHVyblZhbHVlT25jZSgnc3Rhc2hAezB9OiB0ZXN0Jyk7XG5cbiAgICAgIGF3YWl0IGZpeGVyLmFwcGx5QXV0b21hdGVkRml4ZXMobW9ja0NhdGVnb3JpemVkRXJyb3JzLCB7IGNyZWF0ZUJhY2t1cHM6IHRydWUgfSk7XG5cbiAgICAgIC8vIE1vY2sgcm9sbGJhY2sgZmFpbHVyZVxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvbGxiYWNrIGZhaWxlZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJvbGxiYWNrU3VjY2VzcyA9IGF3YWl0IGZpeGVyLnBlcmZvcm1Sb2xsYmFjaygpO1xuXG4gICAgICBleHBlY3Qocm9sbGJhY2tTdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gbm8gcm9sbGJhY2sgaW5mbyBhdmFpbGFibGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByb2xsYmFja1N1Y2Nlc3MgPSBhd2FpdCBmaXhlci5wZXJmb3JtUm9sbGJhY2soKTtcbiAgICAgIGV4cGVjdChyb2xsYmFja1N1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FmZXR5IFByb3RvY29scycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlc3BlY3Qgc2FmZXR5IHByb3RvY29scyBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RyaWN0U2FmZXR5UHJvdG9jb2xzOiBTYWZldHlQcm90b2NvbHMgPSB7XG4gICAgICAgIGVuYWJsZVJvbGxiYWNrOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZUJlZm9yZUZpeDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVBZnRlckZpeDogdHJ1ZSxcbiAgICAgICAgbWF4RmFpbHVyZXNCZWZvcmVTdG9wOiAxLFxuICAgICAgICByZXF1aXJlTWFudWFsQXBwcm92YWw6IHRydWUsXG4gICAgICAgIHByZXNlcnZlUGF0dGVybnM6IFsnKiovY3JpdGljYWwvKionXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0cmljdEZpeGVyID0gbmV3IEF1dG9tYXRlZExpbnRpbmdGaXhlcignL3Rlc3QnLCBzdHJpY3RTYWZldHlQcm90b2NvbHMpO1xuICAgICAgZXhwZWN0KHN0cmljdEZpeGVyKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBmaWxlcyBtYXRjaGluZyBzYWZldHkgcGF0dGVybnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjcml0aWNhbElzc3VlOiBMaW50aW5nSXNzdWUgPSB7XG4gICAgICAgIC4uLm1vY2tMaW50aW5nSXNzdWVzWzBdLFxuICAgICAgICBmaWxlOiAnc3JjL2NhbGN1bGF0aW9ucy9jcml0aWNhbC1hc3Ryby50cycsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKHtcbiAgICAgICAgLi4ubW9ja0NhdGVnb3JpemVkRXJyb3JzLFxuICAgICAgICBhdXRvRml4YWJsZTogW2NyaXRpY2FsSXNzdWVdLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZml4ZWRJc3N1ZXMpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgaGlnaC1yaXNrIGlzc3VlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZ2hSaXNrSXNzdWU6IExpbnRpbmdJc3N1ZSA9IHtcbiAgICAgICAgLi4ubW9ja0xpbnRpbmdJc3N1ZXNbMF0sXG4gICAgICAgIHJlc29sdXRpb25TdHJhdGVneToge1xuICAgICAgICAgIC4uLm1vY2tMaW50aW5nSXNzdWVzWzBdLnJlc29sdXRpb25TdHJhdGVneSxcbiAgICAgICAgICByaXNrTGV2ZWw6ICdoaWdoJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLmFwcGx5QXV0b21hdGVkRml4ZXMoe1xuICAgICAgICAuLi5tb2NrQ2F0ZWdvcml6ZWRFcnJvcnMsXG4gICAgICAgIGF1dG9GaXhhYmxlOiBbaGlnaFJpc2tJc3N1ZV0sXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maXhlZElzc3VlcykudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCBsb3ctY29uZmlkZW5jZSBmaXhlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvd0NvbmZpZGVuY2VJc3N1ZTogTGludGluZ0lzc3VlID0ge1xuICAgICAgICAuLi5tb2NrTGludGluZ0lzc3Vlc1swXSxcbiAgICAgICAgcmVzb2x1dGlvblN0cmF0ZWd5OiB7XG4gICAgICAgICAgLi4ubW9ja0xpbnRpbmdJc3N1ZXNbMF0ucmVzb2x1dGlvblN0cmF0ZWd5LFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuMyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLmFwcGx5QXV0b21hdGVkRml4ZXMoe1xuICAgICAgICAuLi5tb2NrQ2F0ZWdvcml6ZWRFcnJvcnMsXG4gICAgICAgIGF1dG9GaXhhYmxlOiBbbG93Q29uZmlkZW5jZUlzc3VlXSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpeGVkSXNzdWVzKS50b0JlKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb2xsZWN0IGFuZCByZXBvcnQgZXJyb3JzIHByb3Blcmx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBpbml0aWFsIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGluaXRpYWwgdmFsaWRhdGlvblxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gaW5pdGlhbCB2YWxpZGF0aW9uXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCdzdGFzaEB7MH0nKSAvLyBiYWNrdXBcbiAgICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRml4IGNvbW1hbmQgZmFpbGVkJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKG1vY2tDYXRlZ29yaXplZEVycm9ycyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yc1swXS5zZXZlcml0eSkudG9CZSgnZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzBdLm1lc3NhZ2UpLnRvQ29udGFpbignYmF0Y2gnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGVyZm9ybSBlbWVyZ2VuY3kgcm9sbGJhY2sgb24gY3JpdGljYWwgZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luY1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gaW5pdGlhbCB2YWxpZGF0aW9uXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBpbml0aWFsIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGluaXRpYWwgdmFsaWRhdGlvblxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnc3Rhc2hAezB9JykgLy8gYmFja3VwXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyaXRpY2FsIHN5c3RlbSBmYWlsdXJlJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKTsgLy8gZW1lcmdlbmN5IHJvbGxiYWNrXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpeGVyLmFwcGx5QXV0b21hdGVkRml4ZXMobW9ja0NhdGVnb3JpemVkRXJyb3JzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcy5yb2xsYmFja3NQZXJmb3JtZWQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycy5zb21lKGUgPT4gZS5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZXRyaWNzIENvbGxlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb2xsZWN0IGNvbXByZWhlbnNpdmUgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKG1vY2tDYXRlZ29yaXplZEVycm9ycyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcy5zdGFydFRpbWUpLnRvQmVJbnN0YW5jZU9mKERhdGUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzLmVuZFRpbWUpLnRvQmVJbnN0YW5jZU9mKERhdGUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzLnRvdGFsVGltZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzLmZpbGVzUHJvY2Vzc2VkKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzLmlzc3Vlc0F0dGVtcHRlZCkudG9CZSgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcy5pc3N1ZXNGaXhlZCkudG9CZSgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcy5pc3N1ZXNGYWlsZWQpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRyYWNrIHJvbGxiYWNrIG1ldHJpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmNcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIHZhbGlkYXRpb25cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJ3N0YXNoQHswfScpIC8vIGJhY2t1cFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gZml4XG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH0pIC8vIHZhbGlkYXRpb24gZmFpbHNcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpOyAvLyByb2xsYmFja1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXhlci5hcHBseUF1dG9tYXRlZEZpeGVzKG1vY2tDYXRlZ29yaXplZEVycm9ycywge1xuICAgICAgICB2YWxpZGF0ZUFmdGVyRWFjaEJhdGNoOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcy5yb2xsYmFja3NQZXJmb3JtZWQpLnRvQmUoMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=