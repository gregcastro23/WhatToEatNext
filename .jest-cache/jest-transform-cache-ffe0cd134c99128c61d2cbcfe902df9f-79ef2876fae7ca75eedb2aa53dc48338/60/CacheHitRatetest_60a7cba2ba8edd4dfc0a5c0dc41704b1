28f1efbb8f15df65d34492b45b677bcd
"use strict";
/**
 * Performance Tests for Cache Hit Rate Validation
 * Perfect Codebase Campaign - Cache Performance Testing
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ProgressTracker_1 = require("../../ProgressTracker");
const CampaignController_1 = require("../../CampaignController");
const campaign_1 = require("../../../../types/campaign");
describe('Cache Hit Rate Performance Tests', () => {
    let progressTracker;
    let campaignController;
    let mockConfig;
    beforeEach(() => {
        const safetySettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7
        };
        mockConfig = {
            phases: [{
                    id: 'cache-test-phase',
                    name: 'Cache Test Phase',
                    description: 'Phase for cache testing',
                    tools: [{
                            scriptPath: 'scripts/cache/test-script.js',
                            parameters: { enableCache: true },
                            batchSize: 50,
                            safetyLevel: campaign_1.SafetyLevel.MEDIUM
                        }],
                    successCriteria: { buildTime: 10 },
                    safetyCheckpoints: []
                }],
            safetySettings,
            progressTargets: { typeScriptErrors: 0, lintingWarnings: 0, buildTime: 10, enterpriseSystems: 200 },
            toolConfiguration: {
                enhancedErrorFixer: 'scripts/typescript-fixes/fix-typescript-errors-enhanced-v3.js',
                explicitAnyFixer: 'scripts/typescript-fixes/fix-explicit-any-systematic.js',
                unusedVariablesFixer: 'scripts/typescript-fixes/fix-unused-variables-enhanced.js',
                consoleStatementFixer: 'scripts/lint-fixes/fix-console-statements-only.js'
            }
        };
        progressTracker = new ProgressTracker_1.ProgressTracker();
        campaignController = new CampaignController_1.CampaignController(mockConfig);
        // Reset mocks
        jest.clearAllMocks();
    });
    describe('Cache Hit Rate Monitoring', () => {
        it('should validate cache hit rate above 80% target', async () => {
            // Mock excellent cache performance
            jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(0.85);
            const cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.85);
            expect(cacheHitRate).toBeGreaterThanOrEqual(0.8); // Above 80% target
            expect(cacheHitRate).toBeLessThanOrEqual(1.0); // Cannot exceed 100%
        });
        it('should detect poor cache performance', async () => {
            // Mock poor cache performance
            jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(0.65);
            const cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.65);
            expect(cacheHitRate).toBeLessThan(0.8); // Below 80% target
        });
        it('should handle cache measurement errors gracefully', async () => {
            // Mock cache measurement error
            jest.spyOn(progressTracker, 'getCacheHitRate').mockRejectedValue(new Error('Cache measurement failed'));
            const cacheHitRate = await progressTracker.getCacheHitRate().catch(() => 0);
            expect(cacheHitRate).toBe(0); // Error handling returns 0
        });
        it('should track cache performance trends over time', async () => {
            const cacheReadings = [];
            let callCount = 0;
            // Mock improving cache performance over time
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                callCount++;
                // Simulate cache warming up - performance improves over time
                const baseRate = 0.6;
                const improvement = Math.min(0.3, callCount * 0.05); // Max 30% improvement
                return Math.min(0.95, baseRate + improvement); // Cap at 95%
            });
            // Collect multiple cache hit rate readings
            for (let i = 0; i < 10; i++) {
                const cacheHitRate = await progressTracker.getCacheHitRate();
                cacheReadings.push(cacheHitRate);
            }
            expect(cacheReadings.length).toBe(10);
            expect(cacheReadings.every(rate => rate >= 0 && rate <= 1)).toBe(true);
            // Cache performance should improve over time
            const firstReading = cacheReadings[0];
            const lastReading = cacheReadings[cacheReadings.length - 1];
            expect(lastReading).toBeGreaterThanOrEqual(firstReading);
            expect(lastReading).toBeGreaterThanOrEqual(0.8); // Should reach target
        });
    });
    describe('Cache Performance Optimization', () => {
        it('should validate 3-tier caching system performance', async () => {
            // Mock 3-tier cache system with different hit rates
            const cacheHitRates = {
                l1Cache: 0.9,
                l2Cache: 0.7,
                l3Cache: 0.5 // 50% L3 cache hit rate (disk/network)
            };
            // Calculate overall cache hit rate
            const overallHitRate = cacheHitRates.l1Cache * 0.6 + // L1 handles 60% of requests
                cacheHitRates.l2Cache * 0.3 + // L2 handles 30% of requests
                cacheHitRates.l3Cache * 0.1; // L3 handles 10% of requests
            jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(overallHitRate);
            const cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBeCloseTo(0.81, 2); // Should be ~81%
            expect(cacheHitRate).toBeGreaterThan(0.8); // Above target
        });
        it('should detect cache invalidation impact', async () => {
            let cacheInvalidated = false;
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                // Simulate cache invalidation impact
                return cacheInvalidated ? 0.3 : 0.85; // Dramatic drop after invalidation
            });
            // Before cache invalidation
            let cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.85);
            // Simulate cache invalidation
            cacheInvalidated = true;
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.3);
            expect(cacheHitRate).toBeLessThan(0.8); // Below target after invalidation
        });
        it('should validate cache warming strategies', async () => {
            const warmupReadings = [];
            let warmupStep = 0;
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                warmupStep++;
                // Simulate cache warming - exponential improvement
                const maxRate = 0.9;
                const warmupRate = maxRate * (1 - Math.exp(-warmupStep * 0.3));
                return Math.min(maxRate, warmupRate);
            });
            // Simulate cache warming process
            for (let i = 0; i < 8; i++) {
                const cacheHitRate = await progressTracker.getCacheHitRate();
                warmupReadings.push(cacheHitRate);
            }
            expect(warmupReadings.length).toBe(8);
            // Cache should warm up progressively
            expect(warmupReadings[0]).toBeLessThan(0.3); // Cold start
            expect(warmupReadings[warmupReadings.length - 1]).toBeGreaterThan(0.8); // Warmed up
            // Each reading should be better than or equal to the previous
            for (let i = 1; i < warmupReadings.length; i++) {
                expect(warmupReadings[i]).toBeGreaterThanOrEqual(warmupReadings[i - 1]);
            }
        });
        it('should handle cache size optimization', async () => {
            // Mock different cache sizes and their hit rates
            const cacheSizeTests = [
                { size: '10MB', hitRate: 0.6 },
                { size: '50MB', hitRate: 0.8 },
                { size: '100MB', hitRate: 0.9 },
                { size: '200MB', hitRate: 0.92 } // Very large cache (diminishing returns)
            ];
            for (const test of cacheSizeTests) {
                jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(test.hitRate);
                const cacheHitRate = await progressTracker.getCacheHitRate();
                expect(cacheHitRate).toBe(test.hitRate);
                // Larger caches should generally have better hit rates
                if (test.size === '100MB') {
                    expect(cacheHitRate).toBeGreaterThan(0.8); // Should exceed target
                }
            }
        });
    });
    describe('Cache Performance Under Load', () => {
        it('should maintain cache performance under concurrent access', async () => {
            let concurrentRequests = 0;
            const maxConcurrentRequests = 10;
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                concurrentRequests++;
                // Simulate cache performance degradation under high load
                const loadFactor = Math.min(1, concurrentRequests / maxConcurrentRequests);
                const baseRate = 0.85;
                const degradation = loadFactor * 0.1; // Up to 10% degradation under full load
                setTimeout(() => concurrentRequests--, 100); // Simulate request completion
                return Math.max(0.7, baseRate - degradation); // Minimum 70% hit rate
            });
            // Simulate concurrent cache access
            const promises = Array.from({ length: 15 }, () => progressTracker.getCacheHitRate());
            const results = await Promise.all(promises);
            expect(results.length).toBe(15);
            expect(results.every(rate => rate >= 0.7)).toBe(true); // All should be above minimum
            // Average should still be reasonable
            const averageHitRate = results.reduce((sum, rate) => sum + rate, 0) / results.length;
            expect(averageHitRate).toBeGreaterThan(0.75);
        });
        it('should handle cache thrashing scenarios', async () => {
            let thrashingActive = false;
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                if (thrashingActive) {
                    // Simulate cache thrashing - very poor hit rate
                    return 0.2 + Math.random() * 0.2; // 20-40% hit rate
                }
                else {
                    // Normal cache performance
                    return 0.8 + Math.random() * 0.1; // 80-90% hit rate
                }
            });
            // Normal operation
            let cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBeGreaterThan(0.8);
            // Simulate cache thrashing
            thrashingActive = true;
            const thrashingReadings = [];
            for (let i = 0; i < 5; i++) {
                cacheHitRate = await progressTracker.getCacheHitRate();
                thrashingReadings.push(cacheHitRate);
            }
            // All readings during thrashing should be poor
            expect(thrashingReadings.every(rate => rate < 0.5)).toBe(true);
            // Recovery from thrashing
            thrashingActive = false;
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBeGreaterThan(0.8); // Should recover
        });
        it('should validate cache performance during campaign execution', async () => {
            const phase = mockConfig.phases[0];
            let executionStep = 0;
            // Mock cache performance during different execution phases
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                executionStep++;
                // Simulate cache performance during campaign execution
                if (executionStep <= 2) {
                    return 0.6; // Initial cold cache
                }
                else if (executionStep <= 5) {
                    return 0.75; // Cache warming up
                }
                else {
                    return 0.85; // Optimal cache performance
                }
            });
            // Mock campaign execution with cache monitoring
            jest.spyOn(campaignController, 'getCurrentMetrics').mockImplementation(async () => {
                const cacheHitRate = await progressTracker.getCacheHitRate();
                return {
                    typeScriptErrors: { current: 86, target: 0, reduction: 0, percentage: 0 },
                    lintingWarnings: { current: 4506, target: 0, reduction: 0, percentage: 0 },
                    buildPerformance: { currentTime: 8.5, targetTime: 10, cacheHitRate, memoryUsage: 45 },
                    enterpriseSystems: { current: 0, target: 200, transformedExports: 0 }
                };
            });
            const result = await campaignController.executePhase(phase);
            expect(result.success).toBe(true);
            // Final cache hit rate should be optimal
            const finalCacheHitRate = await progressTracker.getCacheHitRate();
            expect(finalCacheHitRate).toBe(0.85);
            expect(finalCacheHitRate).toBeGreaterThan(0.8);
        });
    });
    describe('Cache Performance Benchmarks', () => {
        it('should benchmark cache lookup performance', async () => {
            const lookupTimes = [];
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                const startTime = Date.now();
                // Simulate cache lookup time
                const lookupDelay = 5 + Math.random() * 10; // 5-15ms lookup time
                const endTime = startTime + lookupDelay;
                while (Date.now() < endTime) {
                    // Busy wait to simulate lookup
                }
                lookupTimes.push(Date.now() - startTime);
                return 0.85; // Good hit rate
            });
            // Perform multiple cache lookups
            for (let i = 0; i < 10; i++) {
                await progressTracker.getCacheHitRate();
            }
            expect(lookupTimes.length).toBe(10);
            expect(lookupTimes.every(time => time > 0)).toBe(true);
            // Average lookup time should be reasonable
            const averageLookupTime = lookupTimes.reduce((sum, time) => sum + time, 0) / lookupTimes.length;
            expect(averageLookupTime).toBeLessThan(50); // Should be under 50ms
        });
        it('should validate cache efficiency across different data sizes', async () => {
            const dataSizeTests = [
                { size: 'small', hitRate: 0.95, lookupTime: 5 },
                { size: 'medium', hitRate: 0.85, lookupTime: 10 },
                { size: 'large', hitRate: 0.8, lookupTime: 15 },
                { size: 'xlarge', hitRate: 0.75, lookupTime: 25 }
            ];
            for (const test of dataSizeTests) {
                jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                    // Simulate lookup time based on data size
                    const delay = test.lookupTime;
                    const endTime = Date.now() + delay;
                    while (Date.now() < endTime) {
                        // Busy wait
                    }
                    return test.hitRate;
                });
                const startTime = Date.now();
                const cacheHitRate = await progressTracker.getCacheHitRate();
                const lookupTime = Date.now() - startTime;
                expect(cacheHitRate).toBe(test.hitRate);
                expect(lookupTime).toBeGreaterThanOrEqual(test.lookupTime);
                // Even large data should maintain reasonable performance
                if (test.size === 'large') {
                    expect(cacheHitRate).toBeGreaterThanOrEqual(0.8);
                    expect(lookupTime).toBeLessThan(50);
                }
            }
        });
        it('should benchmark cache invalidation performance', async () => {
            let cacheVersion = 1;
            const invalidationTimes = [];
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                // Simulate cache invalidation impact
                const currentVersion = cacheVersion;
                if (currentVersion === 1) {
                    return 0.85; // Good hit rate before invalidation
                }
                else {
                    // Simulate cache rebuilding after invalidation
                    const rebuildProgress = Math.min(1, (Date.now() % 1000) / 1000);
                    return 0.3 + (0.55 * rebuildProgress); // 30% to 85% recovery
                }
            });
            // Measure performance before invalidation
            const beforeInvalidation = await progressTracker.getCacheHitRate();
            expect(beforeInvalidation).toBe(0.85);
            // Simulate cache invalidation
            const invalidationStart = Date.now();
            cacheVersion = 2;
            // Measure recovery time
            let recoveryComplete = false;
            while (!recoveryComplete && (Date.now() - invalidationStart) < 2000) {
                const currentHitRate = await progressTracker.getCacheHitRate();
                if (currentHitRate >= 0.8) {
                    recoveryComplete = true;
                    invalidationTimes.push(Date.now() - invalidationStart);
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            // Cache should recover within reasonable time
            expect(recoveryComplete).toBe(true);
            if (invalidationTimes.length > 0) {
                expect(invalidationTimes[0]).toBeLessThan(2000); // Should recover within 2 seconds
            }
        });
    });
    describe('Cache Configuration Optimization', () => {
        it('should validate optimal cache configuration', async () => {
            const cacheConfigs = [
                { name: 'minimal', hitRate: 0.6, memoryUsage: 20 },
                { name: 'balanced', hitRate: 0.8, memoryUsage: 35 },
                { name: 'aggressive', hitRate: 0.9, memoryUsage: 48 },
                { name: 'maximum', hitRate: 0.92, memoryUsage: 55 } // Exceeds memory target
            ];
            for (const config of cacheConfigs) {
                jest.spyOn(progressTracker, 'getCacheHitRate').mockResolvedValue(config.hitRate);
                jest.spyOn(progressTracker, 'getMemoryUsage').mockResolvedValue(config.memoryUsage);
                const cacheHitRate = await progressTracker.getCacheHitRate();
                const memoryUsage = await progressTracker.getMemoryUsage();
                expect(cacheHitRate).toBe(config.hitRate);
                expect(memoryUsage).toBe(config.memoryUsage);
                // Balanced configuration should be optimal
                if (config.name === 'balanced') {
                    expect(cacheHitRate).toBeGreaterThanOrEqual(0.8); // Meets target
                    expect(memoryUsage).toBeLessThan(50); // Under memory limit
                }
                // Maximum configuration exceeds memory limit
                if (config.name === 'maximum') {
                    expect(memoryUsage).toBeGreaterThan(50); // Exceeds memory target
                }
            }
        });
        it('should handle cache configuration changes dynamically', async () => {
            let currentConfig = 'default';
            jest.spyOn(progressTracker, 'getCacheHitRate').mockImplementation(async () => {
                switch (currentConfig) {
                    case 'default':
                        return 0.75;
                    case 'optimized':
                        return 0.85;
                    case 'high-performance':
                        return 0.9;
                    default:
                        return 0.7;
                }
            });
            // Test default configuration
            let cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.75);
            // Switch to optimized configuration
            currentConfig = 'optimized';
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.85);
            expect(cacheHitRate).toBeGreaterThan(0.8); // Meets target
            // Switch to high-performance configuration
            currentConfig = 'high-performance';
            cacheHitRate = await progressTracker.getCacheHitRate();
            expect(cacheHitRate).toBe(0.9);
            expect(cacheHitRate).toBeGreaterThan(0.85); // Exceeds target
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9fX3Rlc3RzX18vcGVyZm9ybWFuY2UvQ2FjaGVIaXRSYXRlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7QUFFSCwyREFBd0Q7QUFDeEQsaUVBQThEO0FBQzlELHlEQUlvQztBQUVwQyxRQUFRLENBQUMsa0NBQWtDLEVBQUUsR0FBRyxFQUFFO0lBQ2hELElBQUksZUFBZ0MsQ0FBQztJQUNyQyxJQUFJLGtCQUFzQyxDQUFDO0lBQzNDLElBQUksVUFBMEIsQ0FBQztJQUUvQixVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsTUFBTSxjQUFjLEdBQW1CO1lBQ3JDLGdCQUFnQixFQUFFLEVBQUU7WUFDcEIsd0JBQXdCLEVBQUUsQ0FBQztZQUMzQix1QkFBdUIsRUFBRSxFQUFFO1lBQzNCLDBCQUEwQixFQUFFLElBQUk7WUFDaEMsd0JBQXdCLEVBQUUsSUFBSTtZQUM5QixrQkFBa0IsRUFBRSxDQUFDO1NBQ3RCLENBQUM7UUFFRixVQUFVLEdBQUc7WUFDWCxNQUFNLEVBQUUsQ0FBQztvQkFDUCxFQUFFLEVBQUUsa0JBQWtCO29CQUN0QixJQUFJLEVBQUUsa0JBQWtCO29CQUN4QixXQUFXLEVBQUUseUJBQXlCO29CQUN0QyxLQUFLLEVBQUUsQ0FBQzs0QkFDTixVQUFVLEVBQUUsOEJBQThCOzRCQUMxQyxVQUFVLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFOzRCQUNqQyxTQUFTLEVBQUUsRUFBRTs0QkFDYixXQUFXLEVBQUUsc0JBQVcsQ0FBQyxNQUFNO3lCQUNoQyxDQUFDO29CQUNGLGVBQWUsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUU7b0JBQ2xDLGlCQUFpQixFQUFFLEVBQUU7aUJBQ3RCLENBQUM7WUFDRixjQUFjO1lBQ2QsZUFBZSxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLGVBQWUsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLEVB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SyxTQUFTO3dCQUNaLE9BQU8sSUFBSSxDQUFDO29CQUNkLEtBQUssV0FBVzt3QkFDZCxPQUFPLElBQUksQ0FBQztvQkFDZCxLQUFLLGtCQUFrQjt3QkFDckIsT0FBTyxHQUFHLENBQUM7b0JBQ2I7d0JBQ0UsT0FBTyxHQUFHLENBQUM7aUJBQ2Q7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILDZCQUE2QjtZQUM3QixJQUFJLFlBQVksR0FBRyxNQUFNLGVBQWUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUMzRCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWhDLG9DQUFvQztZQUNwQyxhQUFhLEdBQUcsV0FBVyxDQUFDO1lBQzVCLFlBQVksR0FBRyxNQUFNLGVBQWUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN2RCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxlQUFlO1lBRTFELDJDQUEyQztZQUMzQyxhQUFhLEdBQUcsa0JBQWtCLENBQUM7WUFDbkMsWUFBWSxHQUFHLE1BQU0sZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0IsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLGlCQUFpQjtRQUMvRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi9fX3Rlc3RzX18vcGVyZm9ybWFuY2UvQ2FjaGVIaXRSYXRlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBUZXN0cyBmb3IgQ2FjaGUgSGl0IFJhdGUgVmFsaWRhdGlvblxuICogUGVyZmVjdCBDb2RlYmFzZSBDYW1wYWlnbiAtIENhY2hlIFBlcmZvcm1hbmNlIFRlc3RpbmdcbiAqL1xuXG5pbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuLi8uLi9Qcm9ncmVzc1RyYWNrZXInO1xuaW1wb3J0IHsgQ2FtcGFpZ25Db250cm9sbGVyIH0gZnJvbSAnLi4vLi4vQ2FtcGFpZ25Db250cm9sbGVyJztcbmltcG9ydCB7XG4gIENhbXBhaWduQ29uZmlnLFxuICBTYWZldHlTZXR0aW5ncyxcbiAgU2FmZXR5TGV2ZWxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vdHlwZXMvY2FtcGFpZ24nO1xuXG5kZXNjcmliZSgnQ2FjaGUgSGl0IFJhdGUgUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBwcm9ncmVzc1RyYWNrZXI6IFByb2dyZXNzVHJhY2tlcjtcbiAgbGV0IGNhbXBhaWduQ29udHJvbGxlcjogQ2FtcGFpZ25Db250cm9sbGVyO1xuICBsZXQgbW9ja0NvbmZpZzogQ2FtcGFpZ25Db25maWc7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY29uc3Qgc2FmZXR5U2V0dGluZ3M6IFNhZmV0eVNldHRpbmdzID0ge1xuICAgICAgbWF4RmlsZXNQZXJCYXRjaDogMjUsXG4gICAgICBidWlsZFZhbGlkYXRpb25GcmVxdWVuY3k6IDUsXG4gICAgICB0ZXN0VmFsaWRhdGlvbkZyZXF1ZW5jeTogMTAsXG4gICAgICBjb3JydXB0aW9uRGV0ZWN0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgICAgIGF1dG9tYXRpY1JvbGxiYWNrRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHN0YXNoUmV0ZW50aW9uRGF5czogN1xuICAgIH07XG5cbiAgICBtb2NrQ29uZmlnID0ge1xuICAgICAgcGhhc2VzOiBbe1xuICAgICAgICBpZDogJ2NhY2hlLXRlc3QtcGhhc2UnLFxuICAgICAgICBuYW1lOiAnQ2FjaGUgVGVzdCBQaGFzZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUGhhc2UgZm9yIGNhY2hlIHRlc3RpbmcnLFxuICAgICAgICB0b29sczogW3tcbiAgICAgICAgICBzY3JpcHRQYXRoOiAnc2NyaXB0cy9jYWNoZS90ZXN0LXNjcmlwdC5qcycsXG4gICAgICAgICAgcGFyYW1ldGVyczogeyBlbmFibGVDYWNoZTogdHJ1ZSB9LFxuICAgICAgICAgIGJhdGNoU2l6ZTogNTAsXG4gICAgICAgICAgc2FmZXR5TGV2ZWw6IFNhZmV0eUxldmVsLk1FRElVTVxuICAgICAgICB9XSxcbiAgICAgICAgc3VjY2Vzc0NyaXRlcmlhOiB7IGJ1aWxkVGltZTogMTAgfSxcbiAgICAgICAgc2FmZXR5Q2hlY2twb2ludHM6IFtdXG4gICAgICB9XSxcbiAgICAgIHNhZmV0eVNldHRpbmdzLFxuICAgICAgcHJvZ3Jlc3NUYXJnZXRzOiB7IHR5cGVTY3JpcHRFcnJvcnM6IDAsIGxpbnRpbmdXYXJuaW5nczogMCwgYnVpbGRUaW1lOiAxMCwgZW50ZXJwcmlzZVN5c3RlbXM6IDIwMCB9LFxuICAgICAgdG9vbENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgZW5oYW5jZWRFcnJvckZpeGVyOiAnc2NyaXB0cy90eXBlc2NyaXB0LWZpeGVzL2ZpeC10eXBlc2NyaXB0LWVycm9ycy1lbmhhbmNlZC12My5qcycsXG4gICAgICAgIGV4cGxpY2l0QW55Rml4ZXI6ICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LWV4cGxpY2l0LWFueS1zeXN0ZW1hdGljLmpzJyxcbiAgICAgICAgdW51c2VkVmFyaWFibGVzRml4ZXI6ICdzY3JpcHRzL3R5cGVzY3JpcHQtZml4ZXMvZml4LXVudXNlZC12YXJpYWJsZXMtZW5oYW5jZWQuanMnLFxuICAgICAgICBjb25zb2xlU3RhdGVtZW50Rml4ZXI6ICdzY3JpcHRzL2xpbnQtZml4ZXMvZml4LWNvbnNvbGUtc3RhdGVtZW50cy1vbmx5LmpzJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9ncmVzc1RyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKCk7XG4gICAgY2FtcGFpZ25Db250cm9sbGVyID0gbmV3IENhbXBhaWduQ29udHJvbGxlcihtb2NrQ29uZmlnKTtcblxuICAgIC8vIFJlc2V0IG1vY2tzXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYWNoZSBIaXQgUmF0ZSBNb25pdG9yaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY2FjaGUgaGl0IHJhdGUgYWJvdmUgODAlIHRhcmdldCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZXhjZWxsZW50IGNhY2hlIHBlcmZvcm1hbmNlXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tSZXNvbHZlZFZhbHVlKDAuODUpO1xuXG4gICAgICBjb25zdCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG5cbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmUoMC44NSk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDAuOCk7IC8vIEFib3ZlIDgwJSB0YXJnZXRcbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMS4wKTsgLy8gQ2Fubm90IGV4Y2VlZCAxMDAlXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBwb29yIGNhY2hlIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBwb29yIGNhY2hlIHBlcmZvcm1hbmNlXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tSZXNvbHZlZFZhbHVlKDAuNjUpO1xuXG4gICAgICBjb25zdCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG5cbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmUoMC42NSk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlTGVzc1RoYW4oMC44KTsgLy8gQmVsb3cgODAlIHRhcmdldFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgbWVhc3VyZW1lbnQgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGNhY2hlIG1lYXN1cmVtZW50IGVycm9yXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoJ0NhY2hlIG1lYXN1cmVtZW50IGZhaWxlZCcpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCkuY2F0Y2goKCkgPT4gMCk7XG5cbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmUoMCk7IC8vIEVycm9yIGhhbmRsaW5nIHJldHVybnMgMFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmFjayBjYWNoZSBwZXJmb3JtYW5jZSB0cmVuZHMgb3ZlciB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGVSZWFkaW5nczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuXG4gICAgICAvLyBNb2NrIGltcHJvdmluZyBjYWNoZSBwZXJmb3JtYW5jZSBvdmVyIHRpbWVcbiAgICAgIGplc3Quc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJykubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIHdhcm1pbmcgdXAgLSBwZXJmb3JtYW5jZSBpbXByb3ZlcyBvdmVyIHRpbWVcbiAgICAgICAgY29uc3QgYmFzZVJhdGUgPSAwLjY7XG4gICAgICAgIGNvbnN0IGltcHJvdmVtZW50ID0gTWF0aC5taW4oMC4zLCBjYWxsQ291bnQgKiAwLjA1KTsgLy8gTWF4IDMwJSBpbXByb3ZlbWVudFxuICAgICAgICByZXR1cm4gTWF0aC5taW4oMC45NSwgYmFzZVJhdGUgKyBpbXByb3ZlbWVudCk7IC8vIENhcCBhdCA5NSVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDb2xsZWN0IG11bHRpcGxlIGNhY2hlIGhpdCByYXRlIHJlYWRpbmdzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICBjYWNoZVJlYWRpbmdzLnB1c2goY2FjaGVIaXRSYXRlKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KGNhY2hlUmVhZGluZ3MubGVuZ3RoKS50b0JlKDEwKTtcbiAgICAgIGV4cGVjdChjYWNoZVJlYWRpbmdzLmV2ZXJ5KHJhdGUgPT4gcmF0ZSA+PSAwICYmIHJhdGUgPD0gMSkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIENhY2hlIHBlcmZvcm1hbmNlIHNob3VsZCBpbXByb3ZlIG92ZXIgdGltZVxuICAgICAgY29uc3QgZmlyc3RSZWFkaW5nID0gY2FjaGVSZWFkaW5nc1swXTtcbiAgICAgIGNvbnN0IGxhc3RSZWFkaW5nID0gY2FjaGVSZWFkaW5nc1tjYWNoZVJlYWRpbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgZXhwZWN0KGxhc3RSZWFkaW5nKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGZpcnN0UmVhZGluZyk7XG4gICAgICBleHBlY3QobGFzdFJlYWRpbmcpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMC44KTsgLy8gU2hvdWxkIHJlYWNoIHRhcmdldFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgUGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgMy10aWVyIGNhY2hpbmcgc3lzdGVtIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayAzLXRpZXIgY2FjaGUgc3lzdGVtIHdpdGggZGlmZmVyZW50IGhpdCByYXRlc1xuICAgICAgY29uc3QgY2FjaGVIaXRSYXRlcyA9IHtcbiAgICAgICAgbDFDYWNoZTogMC45LCAgLy8gOTAlIEwxIGNhY2hlIGhpdCByYXRlXG4gICAgICAgIGwyQ2FjaGU6IDAuNywgIC8vIDcwJSBMMiBjYWNoZSBoaXQgcmF0ZVxuICAgICAgICBsM0NhY2hlOiAwLjUgICAvLyA1MCUgTDMgY2FjaGUgaGl0IHJhdGUgKGRpc2svbmV0d29yaylcbiAgICAgIH07XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBvdmVyYWxsIGNhY2hlIGhpdCByYXRlXG4gICAgICBjb25zdCBvdmVyYWxsSGl0UmF0ZSA9IFxuICAgICAgICBjYWNoZUhpdFJhdGVzLmwxQ2FjaGUgKiAwLjYgKyAgLy8gTDEgaGFuZGxlcyA2MCUgb2YgcmVxdWVzdHNcbiAgICAgICAgY2FjaGVIaXRSYXRlcy5sMkNhY2hlICogMC4zICsgIC8vIEwyIGhhbmRsZXMgMzAlIG9mIHJlcXVlc3RzXG4gICAgICAgIGNhY2hlSGl0UmF0ZXMubDNDYWNoZSAqIDAuMTsgICAvLyBMMyBoYW5kbGVzIDEwJSBvZiByZXF1ZXN0c1xuXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tSZXNvbHZlZFZhbHVlKG92ZXJhbGxIaXRSYXRlKTtcblxuICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuXG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlQ2xvc2VUbygwLjgxLCAyKTsgLy8gU2hvdWxkIGJlIH44MSVcbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpOyAvLyBBYm92ZSB0YXJnZXRcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGNhY2hlIGludmFsaWRhdGlvbiBpbXBhY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY2FjaGVJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIGludmFsaWRhdGlvbiBpbXBhY3RcbiAgICAgICAgcmV0dXJuIGNhY2hlSW52YWxpZGF0ZWQgPyAwLjMgOiAwLjg1OyAvLyBEcmFtYXRpYyBkcm9wIGFmdGVyIGludmFsaWRhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIC8vIEJlZm9yZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICAgIGxldCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuODUpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICAgIGNhY2hlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSgwLjMpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUxlc3NUaGFuKDAuOCk7IC8vIEJlbG93IHRhcmdldCBhZnRlciBpbnZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY2FjaGUgd2FybWluZyBzdHJhdGVnaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd2FybXVwUmVhZGluZ3M6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgd2FybXVwU3RlcCA9IDA7XG5cbiAgICAgIGplc3Quc3B5T24ocHJvZ3Jlc3NUcmFja2VyLCAnZ2V0Q2FjaGVIaXRSYXRlJykubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgd2FybXVwU3RlcCsrO1xuICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSB3YXJtaW5nIC0gZXhwb25lbnRpYWwgaW1wcm92ZW1lbnRcbiAgICAgICAgY29uc3QgbWF4UmF0ZSA9IDAuOTtcbiAgICAgICAgY29uc3Qgd2FybXVwUmF0ZSA9IG1heFJhdGUgKiAoMSAtIE1hdGguZXhwKC13YXJtdXBTdGVwICogMC4zKSk7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtYXhSYXRlLCB3YXJtdXBSYXRlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjYWNoZSB3YXJtaW5nIHByb2Nlc3NcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgICAgd2FybXVwUmVhZGluZ3MucHVzaChjYWNoZUhpdFJhdGUpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3Qod2FybXVwUmVhZGluZ3MubGVuZ3RoKS50b0JlKDgpO1xuXG4gICAgICAvLyBDYWNoZSBzaG91bGQgd2FybSB1cCBwcm9ncmVzc2l2ZWx5XG4gICAgICBleHBlY3Qod2FybXVwUmVhZGluZ3NbMF0pLnRvQmVMZXNzVGhhbigwLjMpOyAvLyBDb2xkIHN0YXJ0XG4gICAgICBleHBlY3Qod2FybXVwUmVhZGluZ3Nbd2FybXVwUmVhZGluZ3MubGVuZ3RoIC0gMV0pLnRvQmVHcmVhdGVyVGhhbigwLjgpOyAvLyBXYXJtZWQgdXBcblxuICAgICAgLy8gRWFjaCByZWFkaW5nIHNob3VsZCBiZSBiZXR0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgcHJldmlvdXNcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2FybXVwUmVhZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0KHdhcm11cFJlYWRpbmdzW2ldKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKHdhcm11cFJlYWRpbmdzW2kgLSAxXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYWNoZSBzaXplIG9wdGltaXphdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZGlmZmVyZW50IGNhY2hlIHNpemVzIGFuZCB0aGVpciBoaXQgcmF0ZXNcbiAgICAgIGNvbnN0IGNhY2hlU2l6ZVRlc3RzID0gW1xuICAgICAgICB7IHNpemU6ICcxME1CJywgaGl0UmF0ZTogMC42IH0sICAgLy8gU21hbGwgY2FjaGVcbiAgICAgICAgeyBzaXplOiAnNTBNQicsIGhpdFJhdGU6IDAuOCB9LCAgIC8vIE1lZGl1bSBjYWNoZVxuICAgICAgICB7IHNpemU6ICcxMDBNQicsIGhpdFJhdGU6IDAuOSB9LCAgLy8gTGFyZ2UgY2FjaGVcbiAgICAgICAgeyBzaXplOiAnMjAwTUInLCBoaXRSYXRlOiAwLjkyIH0gIC8vIFZlcnkgbGFyZ2UgY2FjaGUgKGRpbWluaXNoaW5nIHJldHVybnMpXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgY2FjaGVTaXplVGVzdHMpIHtcbiAgICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0ZXN0LmhpdFJhdGUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKHRlc3QuaGl0UmF0ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMYXJnZXIgY2FjaGVzIHNob3VsZCBnZW5lcmFsbHkgaGF2ZSBiZXR0ZXIgaGl0IHJhdGVzXG4gICAgICAgIGlmICh0ZXN0LnNpemUgPT09ICcxMDBNQicpIHtcbiAgICAgICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTsgLy8gU2hvdWxkIGV4Y2VlZCB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgUGVyZm9ybWFuY2UgVW5kZXIgTG9hZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGNhY2hlIHBlcmZvcm1hbmNlIHVuZGVyIGNvbmN1cnJlbnQgYWNjZXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGNvbmN1cnJlbnRSZXF1ZXN0cyA9IDA7XG4gICAgICBjb25zdCBtYXhDb25jdXJyZW50UmVxdWVzdHMgPSAxMDtcblxuICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25jdXJyZW50UmVxdWVzdHMrKztcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIHVuZGVyIGhpZ2ggbG9hZFxuICAgICAgICBjb25zdCBsb2FkRmFjdG9yID0gTWF0aC5taW4oMSwgY29uY3VycmVudFJlcXVlc3RzIC8gbWF4Q29uY3VycmVudFJlcXVlc3RzKTtcbiAgICAgICAgY29uc3QgYmFzZVJhdGUgPSAwLjg1O1xuICAgICAgICBjb25zdCBkZWdyYWRhdGlvbiA9IGxvYWRGYWN0b3IgKiAwLjE7IC8vIFVwIHRvIDEwJSBkZWdyYWRhdGlvbiB1bmRlciBmdWxsIGxvYWRcbiAgICAgICAgXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29uY3VycmVudFJlcXVlc3RzLS0sIDEwMCk7IC8vIFNpbXVsYXRlIHJlcXVlc3QgY29tcGxldGlvblxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAuNywgYmFzZVJhdGUgLSBkZWdyYWRhdGlvbik7IC8vIE1pbmltdW0gNzAlIGhpdCByYXRlXG4gICAgICB9KTtcblxuICAgICAgLy8gU2ltdWxhdGUgY29uY3VycmVudCBjYWNoZSBhY2Nlc3NcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTUgfSwgKCkgPT4gXG4gICAgICAgIHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlKDE1KTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KHJhdGUgPT4gcmF0ZSA+PSAwLjcpKS50b0JlKHRydWUpOyAvLyBBbGwgc2hvdWxkIGJlIGFib3ZlIG1pbmltdW1cbiAgICAgIFxuICAgICAgLy8gQXZlcmFnZSBzaG91bGQgc3RpbGwgYmUgcmVhc29uYWJsZVxuICAgICAgY29uc3QgYXZlcmFnZUhpdFJhdGUgPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByYXRlKSA9PiBzdW0gKyByYXRlLCAwKSAvIHJlc3VsdHMubGVuZ3RoO1xuICAgICAgZXhwZWN0KGF2ZXJhZ2VIaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC43NSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYWNoZSB0aHJhc2hpbmcgc2NlbmFyaW9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHRocmFzaGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aHJhc2hpbmdBY3RpdmUpIHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSB0aHJhc2hpbmcgLSB2ZXJ5IHBvb3IgaGl0IHJhdGVcbiAgICAgICAgICByZXR1cm4gMC4yICsgTWF0aC5yYW5kb20oKSAqIDAuMjsgLy8gMjAtNDAlIGhpdCByYXRlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9ybWFsIGNhY2hlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgcmV0dXJuIDAuOCArIE1hdGgucmFuZG9tKCkgKiAwLjE7IC8vIDgwLTkwJSBoaXQgcmF0ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gTm9ybWFsIG9wZXJhdGlvblxuICAgICAgbGV0IGNhY2hlSGl0UmF0ZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRDYWNoZUhpdFJhdGUoKTtcbiAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjYWNoZSB0aHJhc2hpbmdcbiAgICAgIHRocmFzaGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICBjb25zdCB0aHJhc2hpbmdSZWFkaW5nczogbnVtYmVyW10gPSBbXTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICB0aHJhc2hpbmdSZWFkaW5ncy5wdXNoKGNhY2hlSGl0UmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCByZWFkaW5ncyBkdXJpbmcgdGhyYXNoaW5nIHNob3VsZCBiZSBwb29yXG4gICAgICBleHBlY3QodGhyYXNoaW5nUmVhZGluZ3MuZXZlcnkocmF0ZSA9PiByYXRlIDwgMC41KSkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gUmVjb3ZlcnkgZnJvbSB0aHJhc2hpbmdcbiAgICAgIHRocmFzaGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDAuOCk7IC8vIFNob3VsZCByZWNvdmVyXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNhY2hlIHBlcmZvcm1hbmNlIGR1cmluZyBjYW1wYWlnbiBleGVjdXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IG1vY2tDb25maWcucGhhc2VzWzBdO1xuICAgICAgbGV0IGV4ZWN1dGlvblN0ZXAgPSAwO1xuXG4gICAgICAvLyBNb2NrIGNhY2hlIHBlcmZvcm1hbmNlIGR1cmluZyBkaWZmZXJlbnQgZXhlY3V0aW9uIHBoYXNlc1xuICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBleGVjdXRpb25TdGVwKys7XG4gICAgICAgIFxuICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSBwZXJmb3JtYW5jZSBkdXJpbmcgY2FtcGFpZ24gZXhlY3V0aW9uXG4gICAgICAgIGlmIChleGVjdXRpb25TdGVwIDw9IDIpIHtcbiAgICAgICAgICByZXR1cm4gMC42OyAvLyBJbml0aWFsIGNvbGQgY2FjaGVcbiAgICAgICAgfSBlbHNlIGlmIChleGVjdXRpb25TdGVwIDw9IDUpIHtcbiAgICAgICAgICByZXR1cm4gMC43NTsgLy8gQ2FjaGUgd2FybWluZyB1cFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwLjg1OyAvLyBPcHRpbWFsIGNhY2hlIHBlcmZvcm1hbmNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGNhbXBhaWduIGV4ZWN1dGlvbiB3aXRoIGNhY2hlIG1vbml0b3JpbmdcbiAgICAgIGplc3Quc3B5T24oY2FtcGFpZ25Db250cm9sbGVyIGFzIGFueSwgJ2dldEN1cnJlbnRNZXRyaWNzJykubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGVTY3JpcHRFcnJvcnM6IHsgY3VycmVudDogODYsIHRhcmdldDogMCwgcmVkdWN0aW9uOiAwLCBwZXJjZW50YWdlOiAwIH0sXG4gICAgICAgICAgbGludGluZ1dhcm5pbmdzOiB7IGN1cnJlbnQ6IDQ1MDYsIHRhcmdldDogMCwgcmVkdWN0aW9uOiAwLCBwZXJjZW50YWdlOiAwIH0sXG4gICAgICAgICAgYnVpbGRQZXJmb3JtYW5jZTogeyBjdXJyZW50VGltZTogOC41LCB0YXJnZXRUaW1lOiAxMCwgY2FjaGVIaXRSYXRlLCBtZW1vcnlVc2FnZTogNDUgfSxcbiAgICAgICAgICBlbnRlcnByaXNlU3lzdGVtczogeyBjdXJyZW50OiAwLCB0YXJnZXQ6IDIwMCwgdHJhbnNmb3JtZWRFeHBvcnRzOiAwIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYW1wYWlnbkNvbnRyb2xsZXIuZXhlY3V0ZVBoYXNlKHBoYXNlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBGaW5hbCBjYWNoZSBoaXQgcmF0ZSBzaG91bGQgYmUgb3B0aW1hbFxuICAgICAgY29uc3QgZmluYWxDYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoZmluYWxDYWNoZUhpdFJhdGUpLnRvQmUoMC44NSk7XG4gICAgICBleHBlY3QoZmluYWxDYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgUGVyZm9ybWFuY2UgQmVuY2htYXJrcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGJlbmNobWFyayBjYWNoZSBsb29rdXAgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb29rdXBUaW1lczogbnVtYmVyW10gPSBbXTtcbiAgICAgIFxuICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRDYWNoZUhpdFJhdGUnKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgbG9va3VwIHRpbWVcbiAgICAgICAgY29uc3QgbG9va3VwRGVsYXkgPSA1ICsgTWF0aC5yYW5kb20oKSAqIDEwOyAvLyA1LTE1bXMgbG9va3VwIHRpbWVcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGxvb2t1cERlbGF5O1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBCdXN5IHdhaXQgdG8gc2ltdWxhdGUgbG9va3VwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxvb2t1cFRpbWVzLnB1c2goRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSk7XG4gICAgICAgIHJldHVybiAwLjg1OyAvLyBHb29kIGhpdCByYXRlXG4gICAgICB9KTtcblxuICAgICAgLy8gUGVyZm9ybSBtdWx0aXBsZSBjYWNoZSBsb29rdXBzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QobG9va3VwVGltZXMubGVuZ3RoKS50b0JlKDEwKTtcbiAgICAgIGV4cGVjdChsb29rdXBUaW1lcy5ldmVyeSh0aW1lID0+IHRpbWUgPiAwKSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gQXZlcmFnZSBsb29rdXAgdGltZSBzaG91bGQgYmUgcmVhc29uYWJsZVxuICAgICAgY29uc3QgYXZlcmFnZUxvb2t1cFRpbWUgPSBsb29rdXBUaW1lcy5yZWR1Y2UoKHN1bSwgdGltZSkgPT4gc3VtICsgdGltZSwgMCkgLyBsb29rdXBUaW1lcy5sZW5ndGg7XG4gICAgICBleHBlY3QoYXZlcmFnZUxvb2t1cFRpbWUpLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBiZSB1bmRlciA1MG1zXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNhY2hlIGVmZmljaWVuY3kgYWNyb3NzIGRpZmZlcmVudCBkYXRhIHNpemVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YVNpemVUZXN0cyA9IFtcbiAgICAgICAgeyBzaXplOiAnc21hbGwnLCBoaXRSYXRlOiAwLjk1LCBsb29rdXBUaW1lOiA1IH0sXG4gICAgICAgIHsgc2l6ZTogJ21lZGl1bScsIGhpdFJhdGU6IDAuODUsIGxvb2t1cFRpbWU6IDEwIH0sXG4gICAgICAgIHsgc2l6ZTogJ2xhcmdlJywgaGl0UmF0ZTogMC44LCBsb29rdXBUaW1lOiAxNSB9LFxuICAgICAgICB7IHNpemU6ICd4bGFyZ2UnLCBoaXRSYXRlOiAwLjc1LCBsb29rdXBUaW1lOiAyNSB9XG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgZGF0YVNpemVUZXN0cykge1xuICAgICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgbG9va3VwIHRpbWUgYmFzZWQgb24gZGF0YSBzaXplXG4gICAgICAgICAgY29uc3QgZGVsYXkgPSB0ZXN0Lmxvb2t1cFRpbWU7XG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCkgKyBkZWxheTtcbiAgICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgICAgIC8vIEJ1c3kgd2FpdFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGVzdC5oaXRSYXRlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmUodGVzdC5oaXRSYXRlKTtcbiAgICAgICAgZXhwZWN0KGxvb2t1cFRpbWUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwodGVzdC5sb29rdXBUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW4gbGFyZ2UgZGF0YSBzaG91bGQgbWFpbnRhaW4gcmVhc29uYWJsZSBwZXJmb3JtYW5jZVxuICAgICAgICBpZiAodGVzdC5zaXplID09PSAnbGFyZ2UnKSB7XG4gICAgICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjgpO1xuICAgICAgICAgIGV4cGVjdChsb29rdXBUaW1lKS50b0JlTGVzc1RoYW4oNTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGJlbmNobWFyayBjYWNoZSBpbnZhbGlkYXRpb24gcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY2FjaGVWZXJzaW9uID0gMTtcbiAgICAgIGNvbnN0IGludmFsaWRhdGlvblRpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIGludmFsaWRhdGlvbiBpbXBhY3RcbiAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSBjYWNoZVZlcnNpb247XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VycmVudFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gMC44NTsgLy8gR29vZCBoaXQgcmF0ZSBiZWZvcmUgaW52YWxpZGF0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgY2FjaGUgcmVidWlsZGluZyBhZnRlciBpbnZhbGlkYXRpb25cbiAgICAgICAgICBjb25zdCByZWJ1aWxkUHJvZ3Jlc3MgPSBNYXRoLm1pbigxLCAoRGF0ZS5ub3coKSAlIDEwMDApIC8gMTAwMCk7XG4gICAgICAgICAgcmV0dXJuIDAuMyArICgwLjU1ICogcmVidWlsZFByb2dyZXNzKTsgLy8gMzAlIHRvIDg1JSByZWNvdmVyeVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gTWVhc3VyZSBwZXJmb3JtYW5jZSBiZWZvcmUgaW52YWxpZGF0aW9uXG4gICAgICBjb25zdCBiZWZvcmVJbnZhbGlkYXRpb24gPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoYmVmb3JlSW52YWxpZGF0aW9uKS50b0JlKDAuODUpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBjYWNoZSBpbnZhbGlkYXRpb25cbiAgICAgIGNvbnN0IGludmFsaWRhdGlvblN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNhY2hlVmVyc2lvbiA9IDI7XG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgcmVjb3ZlcnkgdGltZVxuICAgICAgbGV0IHJlY292ZXJ5Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHdoaWxlICghcmVjb3ZlcnlDb21wbGV0ZSAmJiAoRGF0ZS5ub3coKSAtIGludmFsaWRhdGlvblN0YXJ0KSA8IDIwMDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudEhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICAgIGlmIChjdXJyZW50SGl0UmF0ZSA+PSAwLjgpIHtcbiAgICAgICAgICByZWNvdmVyeUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBpbnZhbGlkYXRpb25UaW1lcy5wdXNoKERhdGUubm93KCkgLSBpbnZhbGlkYXRpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWNoZSBzaG91bGQgcmVjb3ZlciB3aXRoaW4gcmVhc29uYWJsZSB0aW1lXG4gICAgICBleHBlY3QocmVjb3ZlcnlDb21wbGV0ZSkudG9CZSh0cnVlKTtcbiAgICAgIGlmIChpbnZhbGlkYXRpb25UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV4cGVjdChpbnZhbGlkYXRpb25UaW1lc1swXSkudG9CZUxlc3NUaGFuKDIwMDApOyAvLyBTaG91bGQgcmVjb3ZlciB3aXRoaW4gMiBzZWNvbmRzXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYWNoZSBDb25maWd1cmF0aW9uIE9wdGltaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIG9wdGltYWwgY2FjaGUgY29uZmlndXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlQ29uZmlncyA9IFtcbiAgICAgICAgeyBuYW1lOiAnbWluaW1hbCcsIGhpdFJhdGU6IDAuNiwgbWVtb3J5VXNhZ2U6IDIwIH0sXG4gICAgICAgIHsgbmFtZTogJ2JhbGFuY2VkJywgaGl0UmF0ZTogMC44LCBtZW1vcnlVc2FnZTogMzUgfSxcbiAgICAgICAgeyBuYW1lOiAnYWdncmVzc2l2ZScsIGhpdFJhdGU6IDAuOSwgbWVtb3J5VXNhZ2U6IDQ4IH0sXG4gICAgICAgIHsgbmFtZTogJ21heGltdW0nLCBoaXRSYXRlOiAwLjkyLCBtZW1vcnlVc2FnZTogNTUgfSAvLyBFeGNlZWRzIG1lbW9yeSB0YXJnZXRcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNhY2hlQ29uZmlncykge1xuICAgICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tSZXNvbHZlZFZhbHVlKGNvbmZpZy5oaXRSYXRlKTtcbiAgICAgICAgamVzdC5zcHlPbihwcm9ncmVzc1RyYWNrZXIsICdnZXRNZW1vcnlVc2FnZScpLm1vY2tSZXNvbHZlZFZhbHVlKGNvbmZpZy5tZW1vcnlVc2FnZSk7XG5cbiAgICAgICAgY29uc3QgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IGF3YWl0IHByb2dyZXNzVHJhY2tlci5nZXRNZW1vcnlVc2FnZSgpO1xuXG4gICAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmUoY29uZmlnLmhpdFJhdGUpO1xuICAgICAgICBleHBlY3QobWVtb3J5VXNhZ2UpLnRvQmUoY29uZmlnLm1lbW9yeVVzYWdlKTtcblxuICAgICAgICAvLyBCYWxhbmNlZCBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBvcHRpbWFsXG4gICAgICAgIGlmIChjb25maWcubmFtZSA9PT0gJ2JhbGFuY2VkJykge1xuICAgICAgICAgIGV4cGVjdChjYWNoZUhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMC44KTsgLy8gTWVldHMgdGFyZ2V0XG4gICAgICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlKS50b0JlTGVzc1RoYW4oNTApOyAvLyBVbmRlciBtZW1vcnkgbGltaXRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1heGltdW0gY29uZmlndXJhdGlvbiBleGNlZWRzIG1lbW9yeSBsaW1pdFxuICAgICAgICBpZiAoY29uZmlnLm5hbWUgPT09ICdtYXhpbXVtJykge1xuICAgICAgICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZUdyZWF0ZXJUaGFuKDUwKTsgLy8gRXhjZWVkcyBtZW1vcnkgdGFyZ2V0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyBkeW5hbWljYWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBjdXJyZW50Q29uZmlnID0gJ2RlZmF1bHQnO1xuICAgICAgXG4gICAgICBqZXN0LnNweU9uKHByb2dyZXNzVHJhY2tlciwgJ2dldENhY2hlSGl0UmF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY3VycmVudENvbmZpZykge1xuICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICAgICAgcmV0dXJuIDAuNzU7XG4gICAgICAgICAgY2FzZSAnb3B0aW1pemVkJzpcbiAgICAgICAgICAgIHJldHVybiAwLjg1O1xuICAgICAgICAgIGNhc2UgJ2hpZ2gtcGVyZm9ybWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIDAuOTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAuNztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRlc3QgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICBsZXQgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSgwLjc1KTtcblxuICAgICAgLy8gU3dpdGNoIHRvIG9wdGltaXplZCBjb25maWd1cmF0aW9uXG4gICAgICBjdXJyZW50Q29uZmlnID0gJ29wdGltaXplZCc7XG4gICAgICBjYWNoZUhpdFJhdGUgPSBhd2FpdCBwcm9ncmVzc1RyYWNrZXIuZ2V0Q2FjaGVIaXRSYXRlKCk7XG4gICAgICBleHBlY3QoY2FjaGVIaXRSYXRlKS50b0JlKDAuODUpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDAuOCk7IC8vIE1lZXRzIHRhcmdldFxuXG4gICAgICAvLyBTd2l0Y2ggdG8gaGlnaC1wZXJmb3JtYW5jZSBjb25maWd1cmF0aW9uXG4gICAgICBjdXJyZW50Q29uZmlnID0gJ2hpZ2gtcGVyZm9ybWFuY2UnO1xuICAgICAgY2FjaGVIaXRSYXRlID0gYXdhaXQgcHJvZ3Jlc3NUcmFja2VyLmdldENhY2hlSGl0UmF0ZSgpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZSgwLjkpO1xuICAgICAgZXhwZWN0KGNhY2hlSGl0UmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDAuODUpOyAvLyBFeGNlZWRzIHRhcmdldFxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==