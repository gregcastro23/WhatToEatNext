ebc055f081318a9f8cde47eb57a39505
"use strict";
/**
 * Tests for ProgressiveImprovementEngine
 * Validates batch processing orchestration and realistic target management
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('fs');
jest.mock('child_process');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const ProgressiveImprovementEngine_1 = require("../ProgressiveImprovementEngine");
const mockFs = fs;
const mockExecSync = child_process_1.execSync;
describe('ProgressiveImprovementEngine', () => {
    let engine;
    let mockConfig;
    beforeEach(() => {
        engine = new ProgressiveImprovementEngine_1.ProgressiveImprovementEngine();
        mockConfig = {
            maxFilesPerBatch: 10,
            targetReductionPercentage: 15,
            confidenceThreshold: 0.8,
            enableDomainAnalysis: true,
            enableDocumentation: true,
            safetyLevel: 'MODERATE',
            validationFrequency: 5
        };
        // Reset mocks
        jest.clearAllMocks();
    });
    describe('Batch Processing Orchestration', () => {
        test('should initialize with adaptive configuration', () => {
            const config = engine.getAdaptiveConfig();
            expect(config.maxFilesPerBatch).toBe(15); // Default value
            expect(config.targetReductionPercentage).toBe(15);
            expect(config.confidenceThreshold).toBe(0.8);
            expect(config.safetyLevel).toBe('MODERATE');
        });
        test('should adapt batch size based on safety scores', async () => {
            // Mock file system operations
            mockExecSync.mockReturnValue('src/test1.ts\nsrc/test2.ts\n');
            mockFs.readFileSync.mockReturnValue('const data: any = {};');
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readdirSync.mockReturnValue([]);
            // Mock TypeScript error count (no errors)
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1; // grep exit code for no matches
                    throw error;
                }
                return 'src/test1.ts\nsrc/test2.ts\n';
            });
            // Execute multiple batches to trigger adaptation
            const batch1 = await engine.executeBatch(mockConfig);
            const batch2 = await engine.executeBatch(mockConfig);
            expect(batch1.batchNumber).toBe(1);
            expect(batch2.batchNumber).toBe(2);
            const history = engine.getBatchHistory();
            expect(history).toHaveLength(2);
        });
        test('should create safety checkpoints during execution', async () => {
            // Mock successful execution
            mockExecSync.mockReturnValue('');
            mockFs.readFileSync.mockReturnValue('const data: any = {};');
            const batch = await engine.executeBatch(mockConfig);
            expect(batch.safetyScore).toBeGreaterThanOrEqual(0);
            expect(batch.executionTime).toBeGreaterThan(0);
        });
        test('should track progress metrics accurately', async () => {
            const progress = await engine.getProgressMetrics();
            expect(progress).toHaveProperty('totalAnyTypes');
            expect(progress).toHaveProperty('reductionPercentage');
            expect(progress).toHaveProperty('batchesCompleted');
            expect(progress).toHaveProperty('averageSuccessRate');
        });
    });
    describe('Realistic Target Management', () => {
        test('should set realistic targets based on file analysis', async () => {
            // Mock file analysis
            mockExecSync.mockReturnValue('src/test1.ts\nsrc/test2.ts\nsrc/test3.test.ts\n');
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.toString().includes('test')) {
                    return 'const mockData: any = {};'; // Test file
                }
                return 'const items: any[] = []; const config: Record<string, unknown> = {};';
            });
            const targetInfo = await engine.setRealisticTargets();
            expect(targetInfo.recommendedTarget).toBeGreaterThan(0);
            expect(targetInfo.recommendedTarget).toBeLessThanOrEqual(25);
            expect(targetInfo.reasoning).toBeInstanceOf(Array);
            expect(targetInfo.reasoning.length).toBeGreaterThan(0);
            expect(targetInfo.milestones).toHaveLength(4);
            // Verify milestones are progressive
            for (let i = 1; i < targetInfo.milestones.length; i++) {
                expect(targetInfo.milestones[i].percentage).toBeGreaterThan(targetInfo.milestones[i - 1].percentage);
            }
        });
        test('should monitor progress with milestone tracking', async () => {
            mockExecSync.mockReturnValue('src/test1.ts\n');
            mockFs.readFileSync.mockReturnValue('const data: any = {};');
            const monitoring = await engine.monitorProgress();
            expect(monitoring.currentProgress).toBeDefined();
            expect(monitoring.milestoneStatus).toBeInstanceOf(Array);
            expect(monitoring.recommendations).toBeInstanceOf(Array);
            expect(typeof monitoring.needsManualIntervention).toBe('boolean');
        });
        test('should analyze success rate and adapt strategy', () => {
            const analysis = engine.analyzeSuccessRateAndAdapt();
            expect(analysis.currentSuccessRate).toBeGreaterThanOrEqual(0);
            expect(analysis.currentSuccessRate).toBeLessThanOrEqual(1);
            expect(['improving', 'declining', 'stable']).toContain(analysis.trend);
            expect(analysis.adaptations).toBeInstanceOf(Array);
        });
        test('should recommend manual intervention when needed', async () => {
            // Simulate low success rate scenario by mocking batch history
            const lowSuccessBatch = {
                batchNumber: 1,
                filesProcessed: 5,
                anyTypesAnalyzed: 10,
                replacementsAttempted: 10,
                replacementsSuccessful: 1,
                compilationErrors: 0,
                rollbacksPerformed: 0,
                executionTime: 1000,
                safetyScore: 0.6 // Low safety score
            };
            // Add multiple low-success batches to history
            for (let i = 0; i < 5; i++) {
                engine.batchHistory.push({ ...lowSuccessBatch, batchNumber: i + 1 });
            }
            mockExecSync.mockReturnValue('src/test1.ts\n');
            mockFs.readFileSync.mockReturnValue('const data: any = {};');
            const monitoring = await engine.monitorProgress();
            expect(monitoring.needsManualIntervention).toBe(true);
            expect(monitoring.recommendations.some(r => r.includes('manual review') || r.includes('documentation'))).toBe(true);
        });
        test('should adjust targets based on historical performance', async () => {
            // Add successful batch history
            const successfulBatch = {
                batchNumber: 1,
                filesProcessed: 10,
                anyTypesAnalyzed: 20,
                replacementsAttempted: 15,
                replacementsSuccessful: 12,
                compilationErrors: 0,
                rollbacksPerformed: 0,
                executionTime: 2000,
                safetyScore: 0.95
            };
            engine.batchHistory.push(successfulBatch);
            mockExecSync.mockReturnValue('src/test1.ts\nsrc/test2.ts\n');
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            const targetInfo = await engine.setRealisticTargets();
            // Should increase target due to high success rate
            expect(targetInfo.reasoning.some(r => r.includes('High historical success rate'))).toBe(true);
        });
    });
    describe('Strategy Adaptation', () => {
        test('should reduce batch size when safety score is low', () => {
            const initialConfig = engine.getAdaptiveConfig();
            const initialBatchSize = initialConfig.maxFilesPerBatch;
            // Add low safety score batches
            const lowSafetyBatch = {
                batchNumber: 1,
                filesProcessed: 5,
                anyTypesAnalyzed: 10,
                replacementsAttempted: 8,
                replacementsSuccessful: 3,
                compilationErrors: 2,
                rollbacksPerformed: 1,
                executionTime: 1500,
                safetyScore: 0.5 // Low safety score
            };
            for (let i = 0; i < 3; i++) {
                engine.batchHistory.push({ ...lowSafetyBatch, batchNumber: i + 1 });
            }
            // Trigger adaptation
            engine.adaptStrategy();
            const adaptedConfig = engine.getAdaptiveConfig();
            expect(adaptedConfig.maxFilesPerBatch).toBeLessThan(initialBatchSize);
            expect(adaptedConfig.confidenceThreshold).toBeGreaterThan(initialConfig.confidenceThreshold);
        });
        test('should increase batch size when performance is good', () => {
            const initialConfig = engine.getAdaptiveConfig();
            const initialBatchSize = initialConfig.maxFilesPerBatch;
            // Add high performance batches
            const highPerformanceBatch = {
                batchNumber: 1,
                filesProcessed: 10,
                anyTypesAnalyzed: 20,
                replacementsAttempted: 18,
                replacementsSuccessful: 16,
                compilationErrors: 0,
                rollbacksPerformed: 0,
                executionTime: 1000,
                safetyScore: 0.95
            };
            for (let i = 0; i < 3; i++) {
                engine.batchHistory.push({ ...highPerformanceBatch, batchNumber: i + 1 });
            }
            // Trigger adaptation
            engine.adaptStrategy();
            const adaptedConfig = engine.getAdaptiveConfig();
            expect(adaptedConfig.maxFilesPerBatch).toBeGreaterThanOrEqual(initialBatchSize);
        });
    });
    describe('Full Campaign Execution', () => {
        test('should execute full campaign with progress tracking', async () => {
            // Mock minimal file system for quick test
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return ''; // No files to process
            });
            const result = await engine.executeFullCampaign(mockConfig);
            expect(result).toHaveProperty('totalAnyTypesAnalyzed');
            expect(result).toHaveProperty('reductionAchieved');
            expect(result).toHaveProperty('safetyEvents');
            expect(result.safetyEvents).toBeInstanceOf(Array);
        });
        test('should handle campaign with realistic file processing', async () => {
            // Mock realistic file discovery and processing
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return 'src/test1.ts\nsrc/test2.ts\nsrc/test3.ts\n';
                }
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('test1.ts'))
                    return 'const items: any[] = [];';
                if (path.includes('test2.ts'))
                    return 'const data: Record<string, unknown> = {};';
                if (path.includes('test3.ts'))
                    return 'function test(param: unknown) { return param; }';
                return 'backup content';
            });
            const result = await engine.executeFullCampaign({
                ...mockConfig,
                maxFilesPerBatch: 2,
                targetReductionPercentage: 10
            });
            expect(result.totalAnyTypesAnalyzed).toBeGreaterThan(0);
            expect(result.reductionAchieved).toBeGreaterThanOrEqual(0);
        });
        test('should handle campaign interruption gracefully', async () => {
            // Mock scenario where campaign needs to stop due to safety concerns
            let batchCount = 0;
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return 'src/test1.ts\nsrc/test2.ts\n';
                }
                if (command.includes('grep -c "error TS"')) {
                    batchCount++;
                    if (batchCount > 2) {
                        // Simulate increasing errors after a few batches
                        return '10'; // Return error count as string
                    }
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            mockFs.readFileSync.mockReturnValue('const data: any = complexOperation();');
            const result = await engine.executeFullCampaign({
                ...mockConfig,
                maxFilesPerBatch: 1,
                targetReductionPercentage: 50 // High target to test interruption
            });
            expect(result.safetyEvents.length).toBeGreaterThan(0);
            expect(result.safetyEvents.some(event => event.type === 'LOW_SAFETY_SCORE')).toBe(true);
        });
    });
    describe('Advanced Batch Processing Scenarios', () => {
        test('should handle mixed file types in single batch', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return 'src/component.tsx\nsrc/service.ts\nsrc/test.test.ts\n';
                }
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('component.tsx'))
                    return 'const props: any = {};';
                if (path.includes('service.ts'))
                    return 'const response: any = await fetch("/api");';
                if (path.includes('test.test.ts'))
                    return 'const mockData: any = jest.fn();';
                return 'backup content';
            });
            const batch = await engine.executeBatch({
                ...mockConfig,
                maxFilesPerBatch: 3
            });
            expect(batch.filesProcessed).toBe(3);
            expect(batch.anyTypesAnalyzed).toBe(3);
        });
        test('should adapt to compilation errors during batch', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return 'src/problematic.ts\n';
                }
                if (command.includes('grep -c "error TS"')) {
                    // Simulate compilation errors appearing
                    return '5';
                }
                return '';
            });
            mockFs.readFileSync.mockReturnValue('const data: any = getValue();');
            const batch = await engine.executeBatch(mockConfig);
            expect(batch.compilationErrors).toBe(5);
            expect(batch.safetyScore).toBeLessThan(1.0);
        });
        test('should handle file system errors during batch processing', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return 'src/inaccessible.ts\n';
                }
                return '';
            });
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('ENOENT: file not found');
            });
            const batch = await engine.executeBatch(mockConfig);
            expect(batch.filesProcessed).toBe(0);
            expect(batch.rollbacksPerformed).toBeGreaterThan(0);
        });
    });
    describe('Realistic Target Management Edge Cases', () => {
        test('should handle codebase with no any types', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            const targetInfo = await engine.setRealisticTargets();
            expect(targetInfo.recommendedTarget).toBeGreaterThan(0);
            expect(targetInfo.reasoning).toContain('analysis of 0 files');
        });
        test('should handle codebase with only test files', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return 'src/test1.test.ts\nsrc/test2.spec.ts\n';
                }
                return '';
            });
            mockFs.readFileSync.mockReturnValue('const mockData: any = {};');
            const targetInfo = await engine.setRealisticTargets();
            expect(targetInfo.reasoning.some(r => r.includes('test files'))).toBe(true);
            expect(targetInfo.recommendedTarget).toBeLessThan(15); // Should be reduced due to test files
        });
        test('should handle extremely complex codebase', async () => {
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return Array(100).fill(null).map((_, i) => `src/complex${i}.ts`).join('\n');
                }
                return '';
            });
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('complex')) {
                    return 'function complex(param: unknown): any { return param as unknown; }';
                }
                return 'backup content';
            });
            const targetInfo = await engine.setRealisticTargets();
            expect(targetInfo.recommendedTarget).toBeGreaterThan(0);
            expect(targetInfo.milestones).toHaveLength(4);
            expect(targetInfo.reasoning.length).toBeGreaterThan(0);
        });
    });
    describe('Progress Monitoring Edge Cases', () => {
        test('should detect stagnation and recommend intervention', async () => {
            // Add multiple low-progress batches to simulate stagnation
            const stagnantBatch = {
                batchNumber: 1,
                filesProcessed: 5,
                anyTypesAnalyzed: 10,
                replacementsAttempted: 8,
                replacementsSuccessful: 0,
                compilationErrors: 0,
                rollbacksPerformed: 0,
                executionTime: 1000,
                safetyScore: 0.8
            };
            for (let i = 0; i < 5; i++) {
                engine.batchHistory.push({ ...stagnantBatch, batchNumber: i + 1 });
            }
            mockExecSync.mockReturnValue('src/test1.ts\n');
            mockFs.readFileSync.mockReturnValue('const data: any = {};');
            const monitoring = await engine.monitorProgress();
            expect(monitoring.needsManualIntervention).toBe(true);
            expect(monitoring.recommendations.some(r => r.includes('stagnated') || r.includes('manual'))).toBe(true);
        });
        test('should provide strategic recommendations based on progress', async () => {
            mockExecSync.mockReturnValue('src/test1.ts\n');
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            // Test early stage recommendations
            const earlyMonitoring = await engine.monitorProgress();
            expect(earlyMonitoring.recommendations.some(r => r.includes('array types') || r.includes('quick wins'))).toBe(true);
            // Simulate progress to mid-stage
            const progressBatch = {
                batchNumber: 1,
                filesProcessed: 10,
                anyTypesAnalyzed: 20,
                replacementsAttempted: 15,
                replacementsSuccessful: 12,
                compilationErrors: 0,
                rollbacksPerformed: 0,
                executionTime: 2000,
                safetyScore: 0.9
            };
            engine.batchHistory.push(progressBatch);
            const midMonitoring = await engine.monitorProgress();
            expect(midMonitoring.recommendations.some(r => r.includes('Record') || r.includes('domain-specific'))).toBe(true);
        });
    });
    describe('Memory and Performance Under Load', () => {
        test('should handle memory pressure gracefully', async () => {
            // Simulate memory pressure scenario
            const originalMemoryUsage = process.memoryUsage;
            process.memoryUsage = jest.fn().mockReturnValue({
                rss: 500 * 1024 * 1024,
                heapUsed: 400 * 1024 * 1024,
                heapTotal: 450 * 1024 * 1024,
                external: 10 * 1024 * 1024,
                arrayBuffers: 5 * 1024 * 1024
            });
            mockExecSync.mockReturnValue('src/test1.ts\n');
            mockFs.readFileSync.mockReturnValue('const data: any = {};');
            const batch = await engine.executeBatch(mockConfig);
            expect(batch).toBeDefined();
            expect(batch.executionTime).toBeGreaterThan(0);
            // Restore original function
            process.memoryUsage = originalMemoryUsage;
        });
        test('should maintain performance with large batch history', async () => {
            // Add large batch history
            for (let i = 0; i < 1000; i++) {
                engine.batchHistory.push({
                    batchNumber: i + 1,
                    filesProcessed: 5,
                    anyTypesAnalyzed: 10,
                    replacementsAttempted: 8,
                    replacementsSuccessful: 6,
                    compilationErrors: 0,
                    rollbacksPerformed: 0,
                    executionTime: 1000,
                    safetyScore: 0.9
                });
            }
            const startTime = Date.now();
            const analysis = engine.analyzeSuccessRateAndAdapt();
            const endTime = Date.now();
            expect(analysis).toBeDefined();
            expect(endTime - startTime).toBeLessThan(1000); // Should complete within 1 second
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vUHJvZ3Jlc3NpdmVJbXByb3ZlbWVudEVuZ2luZS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPSCxvQkFBb0I7QUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBUDNCLGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFDekIsa0ZBQStFO0FBTy9FLE1BQU0sTUFBTSxHQUFHLEVBQTRCLENBQUM7QUFDNUMsTUFBTSxZQUFZLEdBQUcsd0JBQWdELENBQUM7QUFFdEUsUUFBUSxDQUFDLDhCQUE4QixFQUFFLEdBQUcsRUFBRTtJQUM1QyxJQUFJLE1BQW9DLENBQUM7SUFDekMsSUFBSSxVQUFrQyxDQUFDO0lBRXZDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxNQUFNLEdBQUcsSUFBSSwyREFBNEIsRUFBRSxDQUFDO1FBQzVDLFVBQVUsR0FBRztZQUNYLGdCQUFnQixFQUFFLEVBQUU7WUFDcEIseUJBQXlCLEVBQUUsRUFBRTtZQUM3QixtQkFBbUIsRUFBRSxHQUFHO1lBQ3hCLG9CQUFvQixFQUFFLElBQUk7WUFDMUIsbUJBQW1CLEVBQUUsSUFBSTtZQUN6QixXQUFXLEVBQUUsVUFBVTtZQUN2QixtQkFBbUIsRUFBRSxDQUFDO1NBQ3ZCLENBQUM7UUFFRixjQUFjO1FBQ2QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLGdDQUFnQyxFQUFFLEdBQUcsRUFBRTtRQUM5QyxJQUFJLENBQUMsK0NBQStDLEVBQUUsR0FBRyxFQUFFO1lBQ3pELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIs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YXRUb0VhdE5leHQvc3JjL3NlcnZpY2VzL2NhbXBhaWduL3VuaW50ZW50aW9uYWwtYW55LWVsaW1pbmF0aW9uL19fdGVzdHNfXy9Qcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0cyBmb3IgUHJvZ3Jlc3NpdmVJbXByb3ZlbWVudEVuZ2luZVxuICogVmFsaWRhdGVzIGJhdGNoIHByb2Nlc3Npbmcgb3JjaGVzdHJhdGlvbiBhbmQgcmVhbGlzdGljIHRhcmdldCBtYW5hZ2VtZW50XG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IFByb2dyZXNzaXZlSW1wcm92ZW1lbnRFbmdpbmUgfSBmcm9tICcuLi9Qcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lJztcbmltcG9ydCB7IFVuaW50ZW50aW9uYWxBbnlDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ2ZzJyk7XG5qZXN0Lm1vY2soJ2NoaWxkX3Byb2Nlc3MnKTtcblxuY29uc3QgbW9ja0ZzID0gZnMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzPjtcbmNvbnN0IG1vY2tFeGVjU3luYyA9IGV4ZWNTeW5jIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGV4ZWNTeW5jPjtcblxuZGVzY3JpYmUoJ1Byb2dyZXNzaXZlSW1wcm92ZW1lbnRFbmdpbmUnLCAoKSA9PiB7XG4gIGxldCBlbmdpbmU6IFByb2dyZXNzaXZlSW1wcm92ZW1lbnRFbmdpbmU7XG4gIGxldCBtb2NrQ29uZmlnOiBVbmludGVudGlvbmFsQW55Q29uZmlnO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGVuZ2luZSA9IG5ldyBQcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lKCk7XG4gICAgbW9ja0NvbmZpZyA9IHtcbiAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDEwLFxuICAgICAgdGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZTogMTUsXG4gICAgICBjb25maWRlbmNlVGhyZXNob2xkOiAwLjgsXG4gICAgICBlbmFibGVEb21haW5BbmFseXNpczogdHJ1ZSxcbiAgICAgIGVuYWJsZURvY3VtZW50YXRpb246IHRydWUsXG4gICAgICBzYWZldHlMZXZlbDogJ01PREVSQVRFJyxcbiAgICAgIHZhbGlkYXRpb25GcmVxdWVuY3k6IDVcbiAgICB9O1xuXG4gICAgLy8gUmVzZXQgbW9ja3NcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhdGNoIFByb2Nlc3NpbmcgT3JjaGVzdHJhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGFkYXB0aXZlIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSBlbmdpbmUuZ2V0QWRhcHRpdmVDb25maWcoKTtcblxuICAgICAgZXhwZWN0KGNvbmZpZy5tYXhGaWxlc1BlckJhdGNoKS50b0JlKDE1KTsgLy8gRGVmYXVsdCB2YWx1ZVxuICAgICAgZXhwZWN0KGNvbmZpZy50YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlKS50b0JlKDE1KTtcbiAgICAgIGV4cGVjdChjb25maWcuY29uZmlkZW5jZVRocmVzaG9sZCkudG9CZSgwLjgpO1xuICAgICAgZXhwZWN0KGNvbmZpZy5zYWZldHlMZXZlbCkudG9CZSgnTU9ERVJBVEUnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhZGFwdCBiYXRjaCBzaXplIGJhc2VkIG9uIHNhZmV0eSBzY29yZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGZpbGUgc3lzdGVtIG9wZXJhdGlvbnNcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3NyYy90ZXN0MS50c1xcbnNyYy90ZXN0Mi50c1xcbicpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhdGE6IGFueSA9IHt9OycpO1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZzLnJlYWRkaXJTeW5jLm1vY2tSZXR1cm5WYWx1ZShbXSk7XG5cbiAgICAgIC8vIE1vY2sgVHlwZVNjcmlwdCBlcnJvciBjb3VudCAobm8gZXJyb3JzKVxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtYyBcImVycm9yIFRTXCInKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBtYXRjaGVzJykgYXMgdW5rbm93bjtcbiAgICAgICAgICBlcnJvci5zdGF0dXMgPSAxOyAvLyBncmVwIGV4aXQgY29kZSBmb3Igbm8gbWF0Y2hlc1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnc3JjL3Rlc3QxLnRzXFxuc3JjL3Rlc3QyLnRzXFxuJztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIG11bHRpcGxlIGJhdGNoZXMgdG8gdHJpZ2dlciBhZGFwdGF0aW9uXG4gICAgICBjb25zdCBiYXRjaDEgPSBhd2FpdCBlbmdpbmUuZXhlY3V0ZUJhdGNoKG1vY2tDb25maWcpO1xuICAgICAgY29uc3QgYmF0Y2gyID0gYXdhaXQgZW5naW5lLmV4ZWN1dGVCYXRjaChtb2NrQ29uZmlnKTtcblxuICAgICAgZXhwZWN0KGJhdGNoMS5iYXRjaE51bWJlcikudG9CZSgxKTtcbiAgICAgIGV4cGVjdChiYXRjaDIuYmF0Y2hOdW1iZXIpLnRvQmUoMik7XG5cbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBlbmdpbmUuZ2V0QmF0Y2hIaXN0b3J5KCk7XG4gICAgICBleHBlY3QoaGlzdG9yeSkudG9IYXZlTGVuZ3RoKDIpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGNyZWF0ZSBzYWZldHkgY2hlY2twb2ludHMgZHVyaW5nIGV4ZWN1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBleGVjdXRpb25cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhdGE6IGFueSA9IHt9OycpO1xuXG4gICAgICBjb25zdCBiYXRjaCA9IGF3YWl0IGVuZ2luZS5leGVjdXRlQmF0Y2gobW9ja0NvbmZpZyk7XG5cbiAgICAgIGV4cGVjdChiYXRjaC5zYWZldHlTY29yZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChiYXRjaC5leGVjdXRpb25UaW1lKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdHJhY2sgcHJvZ3Jlc3MgbWV0cmljcyBhY2N1cmF0ZWx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBhd2FpdCBlbmdpbmUuZ2V0UHJvZ3Jlc3NNZXRyaWNzKCk7XG5cbiAgICAgIGV4cGVjdChwcm9ncmVzcykudG9IYXZlUHJvcGVydHkoJ3RvdGFsQW55VHlwZXMnKTtcbiAgICAgIGV4cGVjdChwcm9ncmVzcykudG9IYXZlUHJvcGVydHkoJ3JlZHVjdGlvblBlcmNlbnRhZ2UnKTtcbiAgICAgIGV4cGVjdChwcm9ncmVzcykudG9IYXZlUHJvcGVydHkoJ2JhdGNoZXNDb21wbGV0ZWQnKTtcbiAgICAgIGV4cGVjdChwcm9ncmVzcykudG9IYXZlUHJvcGVydHkoJ2F2ZXJhZ2VTdWNjZXNzUmF0ZScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVhbGlzdGljIFRhcmdldCBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBzZXQgcmVhbGlzdGljIHRhcmdldHMgYmFzZWQgb24gZmlsZSBhbmFseXNpcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZmlsZSBhbmFseXNpc1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnc3JjL3Rlc3QxLnRzXFxuc3JjL3Rlc3QyLnRzXFxuc3JjL3Rlc3QzLnRlc3QudHNcXG4nKTtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChwYXRoLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ3Rlc3QnKSkge1xuICAgICAgICAgIHJldHVybiAnY29uc3QgbW9ja0RhdGE6IGFueSA9IHt9Oyc7IC8vIFRlc3QgZmlsZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107IGNvbnN0IGNvbmZpZzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTsnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRhcmdldEluZm8gPSBhd2FpdCBlbmdpbmUuc2V0UmVhbGlzdGljVGFyZ2V0cygpO1xuXG4gICAgICBleHBlY3QodGFyZ2V0SW5mby5yZWNvbW1lbmRlZFRhcmdldCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHRhcmdldEluZm8ucmVjb21tZW5kZWRUYXJnZXQpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMjUpO1xuICAgICAgZXhwZWN0KHRhcmdldEluZm8ucmVhc29uaW5nKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgICBleHBlY3QodGFyZ2V0SW5mby5yZWFzb25pbmcubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QodGFyZ2V0SW5mby5taWxlc3RvbmVzKS50b0hhdmVMZW5ndGgoNCk7XG5cbiAgICAgIC8vIFZlcmlmeSBtaWxlc3RvbmVzIGFyZSBwcm9ncmVzc2l2ZVxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0YXJnZXRJbmZvLm1pbGVzdG9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0KHRhcmdldEluZm8ubWlsZXN0b25lc1tpXS5wZXJjZW50YWdlKS50b0JlR3JlYXRlclRoYW4oXG4gICAgICAgICAgdGFyZ2V0SW5mby5taWxlc3RvbmVzW2kgLSAxXS5wZXJjZW50YWdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbW9uaXRvciBwcm9ncmVzcyB3aXRoIG1pbGVzdG9uZSB0cmFja2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3NyYy90ZXN0MS50c1xcbicpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhdGE6IGFueSA9IHt9OycpO1xuXG4gICAgICBjb25zdCBtb25pdG9yaW5nID0gYXdhaXQgZW5naW5lLm1vbml0b3JQcm9ncmVzcygpO1xuXG4gICAgICBleHBlY3QobW9uaXRvcmluZy5jdXJyZW50UHJvZ3Jlc3MpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobW9uaXRvcmluZy5taWxlc3RvbmVTdGF0dXMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgIGV4cGVjdChtb25pdG9yaW5nLnJlY29tbWVuZGF0aW9ucykudG9CZUluc3RhbmNlT2YoQXJyYXkpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBtb25pdG9yaW5nLm5lZWRzTWFudWFsSW50ZXJ2ZW50aW9uKS50b0JlKCdib29sZWFuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYW5hbHl6ZSBzdWNjZXNzIHJhdGUgYW5kIGFkYXB0IHN0cmF0ZWd5JywgKCkgPT4ge1xuICAgICAgY29uc3QgYW5hbHlzaXMgPSBlbmdpbmUuYW5hbHl6ZVN1Y2Nlc3NSYXRlQW5kQWRhcHQoKTtcblxuICAgICAgZXhwZWN0KGFuYWx5c2lzLmN1cnJlbnRTdWNjZXNzUmF0ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChhbmFseXNpcy5jdXJyZW50U3VjY2Vzc1JhdGUpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgICBleHBlY3QoWydpbXByb3ZpbmcnLCAnZGVjbGluaW5nJywgJ3N0YWJsZSddKS50b0NvbnRhaW4oYW5hbHlzaXMudHJlbmQpO1xuICAgICAgZXhwZWN0KGFuYWx5c2lzLmFkYXB0YXRpb25zKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVjb21tZW5kIG1hbnVhbCBpbnRlcnZlbnRpb24gd2hlbiBuZWVkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTaW11bGF0ZSBsb3cgc3VjY2VzcyByYXRlIHNjZW5hcmlvIGJ5IG1vY2tpbmcgYmF0Y2ggaGlzdG9yeVxuICAgICAgY29uc3QgbG93U3VjY2Vzc0JhdGNoID0ge1xuICAgICAgICBiYXRjaE51bWJlcjogMSxcbiAgICAgICAgZmlsZXNQcm9jZXNzZWQ6IDUsXG4gICAgICAgIGFueVR5cGVzQW5hbHl6ZWQ6IDEwLFxuICAgICAgICByZXBsYWNlbWVudHNBdHRlbXB0ZWQ6IDEwLFxuICAgICAgICByZXBsYWNlbWVudHNTdWNjZXNzZnVsOiAxLCAvLyBWZXJ5IGxvdyBzdWNjZXNzIHJhdGVcbiAgICAgICAgY29tcGlsYXRpb25FcnJvcnM6IDAsXG4gICAgICAgIHJvbGxiYWNrc1BlcmZvcm1lZDogMCxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogMTAwMCxcbiAgICAgICAgc2FmZXR5U2NvcmU6IDAuNiAvLyBMb3cgc2FmZXR5IHNjb3JlXG4gICAgICB9O1xuXG4gICAgICAvLyBBZGQgbXVsdGlwbGUgbG93LXN1Y2Nlc3MgYmF0Y2hlcyB0byBoaXN0b3J5XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAoZW5naW5lIGFzIHVua25vd24pLmJhdGNoSGlzdG9yeS5wdXNoKHsgLi4ubG93U3VjY2Vzc0JhdGNoLCBiYXRjaE51bWJlcjogaSArIDEgfSk7XG4gICAgICB9XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3NyYy90ZXN0MS50c1xcbicpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhdGE6IGFueSA9IHt9OycpO1xuXG4gICAgICBjb25zdCBtb25pdG9yaW5nID0gYXdhaXQgZW5naW5lLm1vbml0b3JQcm9ncmVzcygpO1xuXG4gICAgICBleHBlY3QobW9uaXRvcmluZy5uZWVkc01hbnVhbEludGVydmVudGlvbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb25pdG9yaW5nLnJlY29tbWVuZGF0aW9ucy5zb21lKHIgPT5cbiAgICAgICAgci5pbmNsdWRlcygnbWFudWFsIHJldmlldycpIHx8IHIuaW5jbHVkZXMoJ2RvY3VtZW50YXRpb24nKVxuICAgICAgKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhZGp1c3QgdGFyZ2V0cyBiYXNlZCBvbiBoaXN0b3JpY2FsIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIHN1Y2Nlc3NmdWwgYmF0Y2ggaGlzdG9yeVxuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bEJhdGNoID0ge1xuICAgICAgICBiYXRjaE51bWJlcjogMSxcbiAgICAgICAgZmlsZXNQcm9jZXNzZWQ6IDEwLFxuICAgICAgICBhbnlUeXBlc0FuYWx5emVkOiAyMCxcbiAgICAgICAgcmVwbGFjZW1lbnRzQXR0ZW1wdGVkOiAxNSxcbiAgICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bDogMTIsIC8vIEhpZ2ggc3VjY2VzcyByYXRlXG4gICAgICAgIGNvbXBpbGF0aW9uRXJyb3JzOiAwLFxuICAgICAgICByb2xsYmFja3NQZXJmb3JtZWQ6IDAsXG4gICAgICAgIGV4ZWN1dGlvblRpbWU6IDIwMDAsXG4gICAgICAgIHNhZmV0eVNjb3JlOiAwLjk1XG4gICAgICB9O1xuXG4gICAgICAoZW5naW5lIGFzIHVua25vd24pLmJhdGNoSGlzdG9yeS5wdXNoKHN1Y2Nlc3NmdWxCYXRjaCk7XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3NyYy90ZXN0MS50c1xcbnNyYy90ZXN0Mi50c1xcbicpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuXG4gICAgICBjb25zdCB0YXJnZXRJbmZvID0gYXdhaXQgZW5naW5lLnNldFJlYWxpc3RpY1RhcmdldHMoKTtcblxuICAgICAgLy8gU2hvdWxkIGluY3JlYXNlIHRhcmdldCBkdWUgdG8gaGlnaCBzdWNjZXNzIHJhdGVcbiAgICAgIGV4cGVjdCh0YXJnZXRJbmZvLnJlYXNvbmluZy5zb21lKHIgPT5cbiAgICAgICAgci5pbmNsdWRlcygnSGlnaCBoaXN0b3JpY2FsIHN1Y2Nlc3MgcmF0ZScpXG4gICAgICApKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RyYXRlZ3kgQWRhcHRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmVkdWNlIGJhdGNoIHNpemUgd2hlbiBzYWZldHkgc2NvcmUgaXMgbG93JywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbENvbmZpZyA9IGVuZ2luZS5nZXRBZGFwdGl2ZUNvbmZpZygpO1xuICAgICAgY29uc3QgaW5pdGlhbEJhdGNoU2l6ZSA9IGluaXRpYWxDb25maWcubWF4RmlsZXNQZXJCYXRjaDtcblxuICAgICAgLy8gQWRkIGxvdyBzYWZldHkgc2NvcmUgYmF0Y2hlc1xuICAgICAgY29uc3QgbG93U2FmZXR5QmF0Y2ggPSB7XG4gICAgICAgIGJhdGNoTnVtYmVyOiAxLFxuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogNSxcbiAgICAgICAgYW55VHlwZXNBbmFseXplZDogMTAsXG4gICAgICAgIHJlcGxhY2VtZW50c0F0dGVtcHRlZDogOCxcbiAgICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bDogMyxcbiAgICAgICAgY29tcGlsYXRpb25FcnJvcnM6IDIsXG4gICAgICAgIHJvbGxiYWNrc1BlcmZvcm1lZDogMSxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogMTUwMCxcbiAgICAgICAgc2FmZXR5U2NvcmU6IDAuNSAvLyBMb3cgc2FmZXR5IHNjb3JlXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAoZW5naW5lIGFzIHVua25vd24pLmJhdGNoSGlzdG9yeS5wdXNoKHsgLi4ubG93U2FmZXR5QmF0Y2gsIGJhdGNoTnVtYmVyOiBpICsgMSB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlciBhZGFwdGF0aW9uXG4gICAgICAoZW5naW5lIGFzIHVua25vd24pLmFkYXB0U3RyYXRlZ3koKTtcblxuICAgICAgY29uc3QgYWRhcHRlZENvbmZpZyA9IGVuZ2luZS5nZXRBZGFwdGl2ZUNvbmZpZygpO1xuICAgICAgZXhwZWN0KGFkYXB0ZWRDb25maWcubWF4RmlsZXNQZXJCYXRjaCkudG9CZUxlc3NUaGFuKGluaXRpYWxCYXRjaFNpemUpO1xuICAgICAgZXhwZWN0KGFkYXB0ZWRDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZCkudG9CZUdyZWF0ZXJUaGFuKGluaXRpYWxDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaW5jcmVhc2UgYmF0Y2ggc2l6ZSB3aGVuIHBlcmZvcm1hbmNlIGlzIGdvb2QnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsQ29uZmlnID0gZW5naW5lLmdldEFkYXB0aXZlQ29uZmlnKCk7XG4gICAgICBjb25zdCBpbml0aWFsQmF0Y2hTaXplID0gaW5pdGlhbENvbmZpZy5tYXhGaWxlc1BlckJhdGNoO1xuXG4gICAgICAvLyBBZGQgaGlnaCBwZXJmb3JtYW5jZSBiYXRjaGVzXG4gICAgICBjb25zdCBoaWdoUGVyZm9ybWFuY2VCYXRjaCA9IHtcbiAgICAgICAgYmF0Y2hOdW1iZXI6IDEsXG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiAxMCxcbiAgICAgICAgYW55VHlwZXNBbmFseXplZDogMjAsXG4gICAgICAgIHJlcGxhY2VtZW50c0F0dGVtcHRlZDogMTgsXG4gICAgICAgIHJlcGxhY2VtZW50c1N1Y2Nlc3NmdWw6IDE2LFxuICAgICAgICBjb21waWxhdGlvbkVycm9yczogMCxcbiAgICAgICAgcm9sbGJhY2tzUGVyZm9ybWVkOiAwLFxuICAgICAgICBleGVjdXRpb25UaW1lOiAxMDAwLFxuICAgICAgICBzYWZldHlTY29yZTogMC45NVxuICAgICAgfTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgKGVuZ2luZSBhcyB1bmtub3duKS5iYXRjaEhpc3RvcnkucHVzaCh7IC4uLmhpZ2hQZXJmb3JtYW5jZUJhdGNoLCBiYXRjaE51bWJlcjogaSArIDEgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYWRhcHRhdGlvblxuICAgICAgKGVuZ2luZSBhcyB1bmtub3duKS5hZGFwdFN0cmF0ZWd5KCk7XG5cbiAgICAgIGNvbnN0IGFkYXB0ZWRDb25maWcgPSBlbmdpbmUuZ2V0QWRhcHRpdmVDb25maWcoKTtcbiAgICAgIGV4cGVjdChhZGFwdGVkQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2gpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoaW5pdGlhbEJhdGNoU2l6ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGdWxsIENhbXBhaWduIEV4ZWN1dGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgZXhlY3V0ZSBmdWxsIGNhbXBhaWduIHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIG1pbmltYWwgZmlsZSBzeXN0ZW0gZm9yIHF1aWNrIHRlc3RcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLWMgXCJlcnJvciBUU1wiJykpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTm8gbWF0Y2hlcycpIGFzIHVua25vd247XG4gICAgICAgICAgZXJyb3Iuc3RhdHVzID0gMTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7IC8vIE5vIGZpbGVzIHRvIHByb2Nlc3NcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmdpbmUuZXhlY3V0ZUZ1bGxDYW1wYWlnbihtb2NrQ29uZmlnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ3RvdGFsQW55VHlwZXNBbmFseXplZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ3JlZHVjdGlvbkFjaGlldmVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnc2FmZXR5RXZlbnRzJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eUV2ZW50cykudG9CZUluc3RhbmNlT2YoQXJyYXkpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBjYW1wYWlnbiB3aXRoIHJlYWxpc3RpYyBmaWxlIHByb2Nlc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHJlYWxpc3RpYyBmaWxlIGRpc2NvdmVyeSBhbmQgcHJvY2Vzc2luZ1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtciAtbCcpKSB7XG4gICAgICAgICAgcmV0dXJuICdzcmMvdGVzdDEudHNcXG5zcmMvdGVzdDIudHNcXG5zcmMvdGVzdDMudHNcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdncmVwIC1jIFwiZXJyb3IgVFNcIicpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIG1hdGNoZXMnKSBhcyB1bmtub3duO1xuICAgICAgICAgIGVycm9yLnN0YXR1cyA9IDE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCd0ZXN0MS50cycpKSByZXR1cm4gJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOyc7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCd0ZXN0Mi50cycpKSByZXR1cm4gJ2NvbnN0IGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307JztcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ3Rlc3QzLnRzJykpIHJldHVybiAnZnVuY3Rpb24gdGVzdChwYXJhbTogdW5rbm93bikgeyByZXR1cm4gcGFyYW07IH0nO1xuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmdpbmUuZXhlY3V0ZUZ1bGxDYW1wYWlnbih7XG4gICAgICAgIC4uLm1vY2tDb25maWcsXG4gICAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDIsXG4gICAgICAgIHRhcmdldFJlZHVjdGlvblBlcmNlbnRhZ2U6IDEwXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC50b3RhbEFueVR5cGVzQW5hbHl6ZWQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucmVkdWN0aW9uQWNoaWV2ZWQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGNhbXBhaWduIGludGVycnVwdGlvbiBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBzY2VuYXJpbyB3aGVyZSBjYW1wYWlnbiBuZWVkcyB0byBzdG9wIGR1ZSB0byBzYWZldHkgY29uY2VybnNcbiAgICAgIGxldCBiYXRjaENvdW50ID0gMDtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLXIgLWwnKSkge1xuICAgICAgICAgIHJldHVybiAnc3JjL3Rlc3QxLnRzXFxuc3JjL3Rlc3QyLnRzXFxuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtYyBcImVycm9yIFRTXCInKSkge1xuICAgICAgICAgIGJhdGNoQ291bnQrKztcbiAgICAgICAgICBpZiAoYmF0Y2hDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIGluY3JlYXNpbmcgZXJyb3JzIGFmdGVyIGEgZmV3IGJhdGNoZXNcbiAgICAgICAgICAgIHJldHVybiAnMTAnOyAvLyBSZXR1cm4gZXJyb3IgY291bnQgYXMgc3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBtYXRjaGVzJykgYXMgdW5rbm93bjtcbiAgICAgICAgICBlcnJvci5zdGF0dXMgPSAxO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgZGF0YTogYW55ID0gY29tcGxleE9wZXJhdGlvbigpOycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmdpbmUuZXhlY3V0ZUZ1bGxDYW1wYWlnbih7XG4gICAgICAgIC4uLm1vY2tDb25maWcsXG4gICAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDEsXG4gICAgICAgIHRhcmdldFJlZHVjdGlvblBlcmNlbnRhZ2U6IDUwIC8vIEhpZ2ggdGFyZ2V0IHRvIHRlc3QgaW50ZXJydXB0aW9uXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zYWZldHlFdmVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eUV2ZW50cy5zb21lKGV2ZW50ID0+IGV2ZW50LnR5cGUgPT09ICdMT1dfU0FGRVRZX1NDT1JFJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBZHZhbmNlZCBCYXRjaCBQcm9jZXNzaW5nIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG1peGVkIGZpbGUgdHlwZXMgaW4gc2luZ2xlIGJhdGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtciAtbCcpKSB7XG4gICAgICAgICAgcmV0dXJuICdzcmMvY29tcG9uZW50LnRzeFxcbnNyYy9zZXJ2aWNlLnRzXFxuc3JjL3Rlc3QudGVzdC50c1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLWMgXCJlcnJvciBUU1wiJykpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTm8gbWF0Y2hlcycpIGFzIHVua25vd247XG4gICAgICAgICAgZXJyb3Iuc3RhdHVzID0gMTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ2NvbXBvbmVudC50c3gnKSkgcmV0dXJuICdjb25zdCBwcm9wczogYW55ID0ge307JztcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ3NlcnZpY2UudHMnKSkgcmV0dXJuICdjb25zdCByZXNwb25zZTogYW55ID0gYXdhaXQgZmV0Y2goXCIvYXBpXCIpOyc7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCd0ZXN0LnRlc3QudHMnKSkgcmV0dXJuICdjb25zdCBtb2NrRGF0YTogYW55ID0gamVzdC5mbigpOyc7XG4gICAgICAgIHJldHVybiAnYmFja3VwIGNvbnRlbnQnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgZW5naW5lLmV4ZWN1dGVCYXRjaCh7XG4gICAgICAgIC4uLm1vY2tDb25maWcsXG4gICAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDNcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoYmF0Y2guZmlsZXNQcm9jZXNzZWQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QoYmF0Y2guYW55VHlwZXNBbmFseXplZCkudG9CZSgzKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhZGFwdCB0byBjb21waWxhdGlvbiBlcnJvcnMgZHVyaW5nIGJhdGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtciAtbCcpKSB7XG4gICAgICAgICAgcmV0dXJuICdzcmMvcHJvYmxlbWF0aWMudHNcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdncmVwIC1jIFwiZXJyb3IgVFNcIicpKSB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgY29tcGlsYXRpb24gZXJyb3JzIGFwcGVhcmluZ1xuICAgICAgICAgIHJldHVybiAnNSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBkYXRhOiBhbnkgPSBnZXRWYWx1ZSgpOycpO1xuXG4gICAgICBjb25zdCBiYXRjaCA9IGF3YWl0IGVuZ2luZS5leGVjdXRlQmF0Y2gobW9ja0NvbmZpZyk7XG5cbiAgICAgIGV4cGVjdChiYXRjaC5jb21waWxhdGlvbkVycm9ycykudG9CZSg1KTtcbiAgICAgIGV4cGVjdChiYXRjaC5zYWZldHlTY29yZSkudG9CZUxlc3NUaGFuKDEuMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGZpbGUgc3lzdGVtIGVycm9ycyBkdXJpbmcgYmF0Y2ggcHJvY2Vzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLXIgLWwnKSkge1xuICAgICAgICAgIHJldHVybiAnc3JjL2luYWNjZXNzaWJsZS50c1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFTk9FTlQ6IGZpbGUgbm90IGZvdW5kJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCBlbmdpbmUuZXhlY3V0ZUJhdGNoKG1vY2tDb25maWcpO1xuXG4gICAgICBleHBlY3QoYmF0Y2guZmlsZXNQcm9jZXNzZWQpLnRvQmUoMCk7XG4gICAgICBleHBlY3QoYmF0Y2gucm9sbGJhY2tzUGVyZm9ybWVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWFsaXN0aWMgVGFyZ2V0IE1hbmFnZW1lbnQgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGNvZGViYXNlIHdpdGggbm8gYW55IHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtciAtbCcpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIG1hdGNoZXMnKSBhcyB1bmtub3duO1xuICAgICAgICAgIGVycm9yLnN0YXR1cyA9IDE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRhcmdldEluZm8gPSBhd2FpdCBlbmdpbmUuc2V0UmVhbGlzdGljVGFyZ2V0cygpO1xuXG4gICAgICBleHBlY3QodGFyZ2V0SW5mby5yZWNvbW1lbmRlZFRhcmdldCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHRhcmdldEluZm8ucmVhc29uaW5nKS50b0NvbnRhaW4oJ2FuYWx5c2lzIG9mIDAgZmlsZXMnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgY29kZWJhc2Ugd2l0aCBvbmx5IHRlc3QgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kKSA9PiB7XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdncmVwIC1yIC1sJykpIHtcbiAgICAgICAgICByZXR1cm4gJ3NyYy90ZXN0MS50ZXN0LnRzXFxuc3JjL3Rlc3QyLnNwZWMudHNcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgbW9ja0RhdGE6IGFueSA9IHt9OycpO1xuXG4gICAgICBjb25zdCB0YXJnZXRJbmZvID0gYXdhaXQgZW5naW5lLnNldFJlYWxpc3RpY1RhcmdldHMoKTtcblxuICAgICAgZXhwZWN0KHRhcmdldEluZm8ucmVhc29uaW5nLnNvbWUociA9PiByLmluY2x1ZGVzKCd0ZXN0IGZpbGVzJykpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHRhcmdldEluZm8ucmVjb21tZW5kZWRUYXJnZXQpLnRvQmVMZXNzVGhhbigxNSk7IC8vIFNob3VsZCBiZSByZWR1Y2VkIGR1ZSB0byB0ZXN0IGZpbGVzXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGV4dHJlbWVseSBjb21wbGV4IGNvZGViYXNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtciAtbCcpKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5KDEwMCkuZmlsbChudWxsKS5tYXAoKF8sIGkpID0+IGBzcmMvY29tcGxleCR7aX0udHNgKS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ2NvbXBsZXgnKSkge1xuICAgICAgICAgIHJldHVybiAnZnVuY3Rpb24gY29tcGxleChwYXJhbTogdW5rbm93bik6IGFueSB7IHJldHVybiBwYXJhbSBhcyB1bmtub3duOyB9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0YXJnZXRJbmZvID0gYXdhaXQgZW5naW5lLnNldFJlYWxpc3RpY1RhcmdldHMoKTtcblxuICAgICAgZXhwZWN0KHRhcmdldEluZm8ucmVjb21tZW5kZWRUYXJnZXQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdCh0YXJnZXRJbmZvLm1pbGVzdG9uZXMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICAgIGV4cGVjdCh0YXJnZXRJbmZvLnJlYXNvbmluZy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb2dyZXNzIE1vbml0b3JpbmcgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgZGV0ZWN0IHN0YWduYXRpb24gYW5kIHJlY29tbWVuZCBpbnRlcnZlbnRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgbXVsdGlwbGUgbG93LXByb2dyZXNzIGJhdGNoZXMgdG8gc2ltdWxhdGUgc3RhZ25hdGlvblxuICAgICAgY29uc3Qgc3RhZ25hbnRCYXRjaCA9IHtcbiAgICAgICAgYmF0Y2hOdW1iZXI6IDEsXG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiA1LFxuICAgICAgICBhbnlUeXBlc0FuYWx5emVkOiAxMCxcbiAgICAgICAgcmVwbGFjZW1lbnRzQXR0ZW1wdGVkOiA4LFxuICAgICAgICByZXBsYWNlbWVudHNTdWNjZXNzZnVsOiAwLCAvLyBObyBzdWNjZXNzZnVsIHJlcGxhY2VtZW50c1xuICAgICAgICBjb21waWxhdGlvbkVycm9yczogMCxcbiAgICAgICAgcm9sbGJhY2tzUGVyZm9ybWVkOiAwLFxuICAgICAgICBleGVjdXRpb25UaW1lOiAxMDAwLFxuICAgICAgICBzYWZldHlTY29yZTogMC44XG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAoZW5naW5lIGFzIHVua25vd24pLmJhdGNoSGlzdG9yeS5wdXNoKHsgLi4uc3RhZ25hbnRCYXRjaCwgYmF0Y2hOdW1iZXI6IGkgKyAxIH0pO1xuICAgICAgfVxuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKCdzcmMvdGVzdDEudHNcXG4nKTtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBkYXRhOiBhbnkgPSB7fTsnKTtcblxuICAgICAgY29uc3QgbW9uaXRvcmluZyA9IGF3YWl0IGVuZ2luZS5tb25pdG9yUHJvZ3Jlc3MoKTtcblxuICAgICAgZXhwZWN0KG1vbml0b3JpbmcubmVlZHNNYW51YWxJbnRlcnZlbnRpb24pLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9uaXRvcmluZy5yZWNvbW1lbmRhdGlvbnMuc29tZShyID0+XG4gICAgICAgIHIuaW5jbHVkZXMoJ3N0YWduYXRlZCcpIHx8IHIuaW5jbHVkZXMoJ21hbnVhbCcpXG4gICAgICApKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgc3RyYXRlZ2ljIHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBwcm9ncmVzcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJ3NyYy90ZXN0MS50c1xcbicpO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuXG4gICAgICAvLyBUZXN0IGVhcmx5IHN0YWdlIHJlY29tbWVuZGF0aW9uc1xuICAgICAgY29uc3QgZWFybHlNb25pdG9yaW5nID0gYXdhaXQgZW5naW5lLm1vbml0b3JQcm9ncmVzcygpO1xuICAgICAgZXhwZWN0KGVhcmx5TW9uaXRvcmluZy5yZWNvbW1lbmRhdGlvbnMuc29tZShyID0+XG4gICAgICAgIHIuaW5jbHVkZXMoJ2FycmF5IHR5cGVzJykgfHwgci5pbmNsdWRlcygncXVpY2sgd2lucycpXG4gICAgICApKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBwcm9ncmVzcyB0byBtaWQtc3RhZ2VcbiAgICAgIGNvbnN0IHByb2dyZXNzQmF0Y2ggPSB7XG4gICAgICAgIGJhdGNoTnVtYmVyOiAxLFxuICAgICAgICBmaWxlc1Byb2Nlc3NlZDogMTAsXG4gICAgICAgIGFueVR5cGVzQW5hbHl6ZWQ6IDIwLFxuICAgICAgICByZXBsYWNlbWVudHNBdHRlbXB0ZWQ6IDE1LFxuICAgICAgICByZXBsYWNlbWVudHNTdWNjZXNzZnVsOiAxMixcbiAgICAgICAgY29tcGlsYXRpb25FcnJvcnM6IDAsXG4gICAgICAgIHJvbGxiYWNrc1BlcmZvcm1lZDogMCxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogMjAwMCxcbiAgICAgICAgc2FmZXR5U2NvcmU6IDAuOVxuICAgICAgfTtcblxuICAgICAgKGVuZ2luZSBhcyB1bmtub3duKS5iYXRjaEhpc3RvcnkucHVzaChwcm9ncmVzc0JhdGNoKTtcblxuICAgICAgY29uc3QgbWlkTW9uaXRvcmluZyA9IGF3YWl0IGVuZ2luZS5tb25pdG9yUHJvZ3Jlc3MoKTtcbiAgICAgIGV4cGVjdChtaWRNb25pdG9yaW5nLnJlY29tbWVuZGF0aW9ucy5zb21lKHIgPT5cbiAgICAgICAgci5pbmNsdWRlcygnUmVjb3JkJykgfHwgci5pbmNsdWRlcygnZG9tYWluLXNwZWNpZmljJylcbiAgICAgICkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgYW5kIFBlcmZvcm1hbmNlIFVuZGVyIExvYWQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtZW1vcnkgcHJlc3N1cmUgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIG1lbW9yeSBwcmVzc3VyZSBzY2VuYXJpb1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2U7XG4gICAgICBwcm9jZXNzLm1lbW9yeVVzYWdlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHJzczogNTAwICogMTAyNCAqIDEwMjQsIC8vIDUwME1CXG4gICAgICAgIGhlYXBVc2VkOiA0MDAgKiAxMDI0ICogMTAyNCwgLy8gNDAwTUJcbiAgICAgICAgaGVhcFRvdGFsOiA0NTAgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgZXh0ZXJuYWw6IDEwICogMTAyNCAqIDEwMjQsXG4gICAgICAgIGFycmF5QnVmZmVyczogNSAqIDEwMjQgKiAxMDI0XG4gICAgICB9KTtcblxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnc3JjL3Rlc3QxLnRzXFxuJyk7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgZGF0YTogYW55ID0ge307Jyk7XG5cbiAgICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgZW5naW5lLmV4ZWN1dGVCYXRjaChtb2NrQ29uZmlnKTtcblxuICAgICAgZXhwZWN0KGJhdGNoKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGJhdGNoLmV4ZWN1dGlvblRpbWUpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgcHJvY2Vzcy5tZW1vcnlVc2FnZSA9IG9yaWdpbmFsTWVtb3J5VXNhZ2U7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbWFpbnRhaW4gcGVyZm9ybWFuY2Ugd2l0aCBsYXJnZSBiYXRjaCBoaXN0b3J5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIGxhcmdlIGJhdGNoIGhpc3RvcnlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIChlbmdpbmUgYXMgdW5rbm93bikuYmF0Y2hIaXN0b3J5LnB1c2goe1xuICAgICAgICAgIGJhdGNoTnVtYmVyOiBpICsgMSxcbiAgICAgICAgICBmaWxlc1Byb2Nlc3NlZDogNSxcbiAgICAgICAgICBhbnlUeXBlc0FuYWx5emVkOiAxMCxcbiAgICAgICAgICByZXBsYWNlbWVudHNBdHRlbXB0ZWQ6IDgsXG4gICAgICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bDogNixcbiAgICAgICAgICBjb21waWxhdGlvbkVycm9yczogMCxcbiAgICAgICAgICByb2xsYmFja3NQZXJmb3JtZWQ6IDAsXG4gICAgICAgICAgZXhlY3V0aW9uVGltZTogMTAwMCxcbiAgICAgICAgICBzYWZldHlTY29yZTogMC45XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgYW5hbHlzaXMgPSBlbmdpbmUuYW5hbHl6ZVN1Y2Nlc3NSYXRlQW5kQWRhcHQoKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QoYW5hbHlzaXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDEwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDEgc2Vjb25kXG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=