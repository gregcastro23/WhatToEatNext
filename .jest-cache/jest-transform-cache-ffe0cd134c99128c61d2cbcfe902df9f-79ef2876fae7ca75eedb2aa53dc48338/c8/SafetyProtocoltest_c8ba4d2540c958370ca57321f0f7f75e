7e072982a6cc44a32bc591190a089cf6
"use strict";
/**
 * Unit Tests for SafetyProtocol
 * Perfect Codebase Campaign - Safety Protocol Testing
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('child_process');
jest.mock('fs');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const campaign_1 = require("../../../types/campaign");
const SafetyProtocol_1 = require("../SafetyProtocol");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('SafetyProtocol', () => {
    let safetyProtocol;
    let mockSettings;
    beforeEach(() => {
        mockSettings = {
            maxFilesPerBatch: 25,
            buildValidationFrequency: 5,
            testValidationFrequency: 10,
            corruptionDetectionEnabled: true,
            automaticRollbackEnabled: true,
            stashRetentionDays: 7,
        };
        safetyProtocol = new SafetyProtocol_1.SafetyProtocol(mockSettings);
        // Reset mocks
        jest.clearAllMocks();
        // Default mock implementations
        mockExecSync.mockReturnValue('');
        mockFs.existsSync.mockReturnValue(true);
        mockFs.readFileSync.mockReturnValue('valid content');
    });
    describe('Constructor', () => {
        it('should initialize with provided settings', () => {
            expect(safetyProtocol).toBeInstanceOf(SafetyProtocol_1.SafetyProtocol);
        });
        it('should initialize empty stashes map', () => {
            const stashes = safetyProtocol.stashes;
            expect(stashes.size).toBe(0);
        });
        it('should initialize empty safety events array', () => {
            const events = safetyProtocol.safetyEvents;
            expect(events).toEqual([]);
        });
    });
    describe('createStash', () => {
        beforeEach(() => {
            // Mock git commands
            mockExecSync
                .mockReturnValueOnce('') // git status validation
                .mockReturnValueOnce('') // git stash push
                .mockReturnValueOnce('stash@{0}: campaign-1-2023-01-01T00-00-00-000Z: Test stash') // git stash list
                .mockReturnValueOnce('main'); // git branch --show-current
        });
        it('should create git stash with descriptive name', async () => {
            const stashId = await safetyProtocol.createStash('Test stash', 'phase1');
            expect(stashId).toMatch(/^campaign-phase1-\d+-/);
            expect(mockExecSync).toHaveBeenCalledWith(expect.stringContaining('git stash push -u -m'), expect.any(Object));
        });
        it('should store stash information', async () => {
            const stashId = await safetyProtocol.createStash('Test stash');
            const stashes = safetyProtocol.stashes;
            expect(stashes.has(stashId)).toBe(true);
            const stash = stashes.get(stashId);
            expect(stash.description).toContain('Test stash');
            expect(stash.ref).toBe('stash@{0}');
        });
        it('should record safety event for stash creation', async () => {
            await safetyProtocol.createStash('Test stash');
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.CHECKPOINT_CREATED);
            expect(events[0].description).toContain('Git stash created');
        });
        it('should handle git validation failure', async () => {
            // Mock git validation failure
            jest
                .spyOn(safetyProtocol, 'validateGitState')
                .mockResolvedValue({
                success: false,
                errors: ['Not a git repository'],
                warnings: [],
            });
            await expect(safetyProtocol.createStash('Test stash')).rejects.toThrow('Git validation failed: Not a git repository');
        });
        it('should handle git stash creation failure', async () => {
            mockExecSync.mockImplementationOnce(() => { throw new Error('Git stash failed'); });
            await expect(safetyProtocol.createStash('Test stash')).rejects.toThrow('Failed to create git stash: Git stash failed');
        });
    });
    describe('applyStash', () => {
        let mockStash;
        beforeEach(() => {
            mockStash = {
                id: 'test-stash-1',
                description: 'Test stash description',
                timestamp: new Date(),
                branch: 'main',
                ref: 'stash@{0}',
            };
            // Add stash to internal map
            safetyProtocol.stashes.set('test-stash-1', mockStash);
            // Mock git validation
            jest
                .spyOn(safetyProtocol, 'validateGitState')
                .mockResolvedValue({
                success: true,
                errors: [],
                warnings: [],
            });
        });
        it('should apply stash successfully', async () => {
            await safetyProtocol.applyStash('test-stash-1');
            expect(mockExecSync).toHaveBeenCalledWith('git stash apply stash@{0}', expect.any(Object));
        });
        it('should record safety event for stash application', async () => {
            await safetyProtocol.applyStash('test-stash-1');
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.ROLLBACK_TRIGGERED);
            expect(events[0].description).toContain('Git stash applied: test-stash-1');
        });
        it('should validate git state after application when requested', async () => {
            await safetyProtocol.applyStash('test-stash-1', true);
            expect(safetyProtocol['validateGitState']).toHaveBeenCalled();
        });
        it('should handle non-existent stash', async () => {
            await expect(safetyProtocol.applyStash('non-existent')).rejects.toThrow('Stash not found: non-existent');
        });
        it('should handle git stash apply failure', async () => {
            mockExecSync.mockImplementationOnce(() => { throw new Error('Git stash apply failed'); });
            await expect(safetyProtocol.applyStash('test-stash-1')).rejects.toThrow('Failed to apply git stash test-stash-1: Git stash apply failed');
        });
    });
    describe('autoApplyLatestStash', () => {
        beforeEach(() => {
            // Add multiple stashes with different timestamps
            const stash1 = {
                id: 'stash-1',
                description: 'First stash',
                timestamp: new Date('2023-01-01'),
                branch: 'main',
                ref: 'stash@{1}',
            };
            const stash2 = {
                id: 'stash-2',
                description: 'Latest stash',
                timestamp: new Date('2023-01-02'),
                branch: 'main',
                ref: 'stash@{0}',
            };
            const stashMap = safetyProtocol.stashes;
            stashMap.set('stash-1', stash1);
            stashMap.set('stash-2', stash2);
            jest.spyOn(safetyProtocol, 'applyStash').mockResolvedValue();
        });
        it('should apply the most recent stash', async () => {
            const appliedStashId = await safetyProtocol.autoApplyLatestStash();
            expect(appliedStashId).toBe('stash-2');
            expect(safetyProtocol.applyStash).toHaveBeenCalledWith('stash-2');
        });
        it('should handle no available stashes', async () => {
            safetyProtocol.stashes.clear();
            await expect(safetyProtocol.autoApplyLatestStash()).rejects.toThrow('No stashes available for automatic rollback');
        });
    });
    describe('detectCorruption', () => {
        const mockFiles = ['file1.ts', 'file2.ts', 'file3.ts'];
        beforeEach(() => {
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue('valid content');
        });
        it('should detect no corruption in valid files', async () => {
            const report = await safetyProtocol.detectCorruption(mockFiles);
            expect(report.detectedFiles).toEqual([]);
            expect(report.corruptionPatterns).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
            expect(report.recommendedAction).toBe(campaign_1.RecoveryAction.CONTINUE);
        });
        it('should detect git merge conflict markers', async () => {
            mockFs.readFileSync.mockReturnValue(`
        function test() {
        <<<<<<< HEAD
          return 'version 1';
        =======
          return 'version 2';
        >>>>>>> branch
        }
      `);
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.CRITICAL);
            expect(report.recommendedAction).toBe(campaign_1.RecoveryAction.EMERGENCY_RESTORE);
        });
        it('should detect corrupted import statements', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import @/types from './types';
        import @/services from './services';
      `);
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.description.includes('Corrupted type import'))).toBe(true);
        });
        it('should detect syntax corruption', async () => {
            mockFs.readFileSync.mockReturnValueOnce('invalid syntax without closing brace');
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should handle file read errors', async () => {
            mockFs.readFileSync.mockImplementation(() => {
                throw new Error('Permission denied');
            });
            const report = await safetyProtocol.detectCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.pattern === 'FILE_READ_ERROR')).toBe(true);
        });
        it('should skip non-existent files', async () => {
            mockFs.existsSync.mockReturnValue(false);
            const report = await safetyProtocol.detectCorruption(['non-existent.ts']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
        it('should record safety event when corruption is detected', async () => {
            mockFs.readFileSync.mockReturnValue('<<<<<<< HEAD\nconflict\n>>>>>>> branch');
            await safetyProtocol.detectCorruption(['file1.ts']);
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.CORRUPTION_DETECTED);
        });
    });
    describe('detectImportExportCorruption', () => {
        beforeEach(() => {
            mockFs.existsSync.mockReturnValue(true);
        });
        it('should detect empty import statements', async () => {
            mockFs.readFileSync.mockReturnValue(`
import something, { a, b } from './module';
        export { };
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.corruptionPatterns.some(p => p.description.includes('Empty import'))).toBe(true);
            expect(report.corruptionPatterns.some(p => p.description.includes('Empty export'))).toBe(true);
        });
        it('should detect import from undefined module', async () => {
            mockFs.readFileSync.mockReturnValue(`
        import something from "undefined";
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.description.includes('Import from undefined'))).toBe(true);
        });
        it('should detect duplicate from clauses', async () => {
            mockFs.readFileSync.mockReturnValue(`
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should detect double commas in destructuring', async () => {
            mockFs.readFileSync.mockReturnValue(`
        export { x,, y };
      `);
            const report = await safetyProtocol.detectImportExportCorruption(['file1.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should skip non-JavaScript/TypeScript files', async () => {
            const report = await safetyProtocol.detectImportExportCorruption(['file1.txt', 'file2.md']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
    });
    describe('validateSyntaxWithTypeScript', () => {
        it('should validate syntax using TypeScript compiler', async () => {
            mockExecSync.mockReturnValue('No errors found');
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.ts', 'file2.ts']);
            expect(mockExecSync).toHaveBeenCalledWith('yarn tsc --noEmit --skipLibCheck 2>&1', expect.any(Object));
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
        it('should detect TypeScript syntax errors', async () => {
            mockExecSync.mockReturnValue(`
        file1.ts(10,5): error TS1005: Unexpected token 'function'
        file2.ts(15,10): error TS1109: Expression expected
      `);
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.ts', 'file2.ts']);
            expect(report.detectedFiles).toContain('file1.ts');
            expect(report.detectedFiles).toContain('file2.ts');
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
        });
        it('should handle TypeScript compilation errors', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('TypeScript compilation failed');
                error.stdout = 'Unexpected token at line 5';
                throw error;
            });
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.ts']);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.HIGH);
            expect(report.corruptionPatterns.some(p => p.pattern === 'TYPESCRIPT_COMPILATION_ERROR')).toBe(true);
        });
        it('should skip non-TypeScript files', async () => {
            const report = await safetyProtocol.validateSyntaxWithTypeScript(['file1.js', 'file2.txt']);
            expect(report.detectedFiles).toEqual([]);
            expect(report.severity).toBe(campaign_1.CorruptionSeverity.LOW);
        });
    });
    describe('emergencyRollback', () => {
        beforeEach(() => {
            const stash = {
                id: 'emergency-stash',
                description: 'Emergency stash',
                timestamp: new Date(),
                branch: 'main',
                ref: 'stash@{0}',
            };
            safetyProtocol.stashes.set('emergency-stash', stash);
            jest.spyOn(safetyProtocol, 'applyStash').mockResolvedValue();
        });
        it('should apply the most recent stash for emergency rollback', async () => {
            await safetyProtocol.emergencyRollback();
            expect(safetyProtocol.applyStash).toHaveBeenCalledWith('emergency-stash');
        });
        it('should record safety event for emergency rollback', async () => {
            await safetyProtocol.emergencyRollback();
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBe(1);
            expect(events[0].type).toBe(campaign_1.SafetyEventType.EMERGENCY_RECOVERY);
            expect(events[0].description).toContain('Emergency rollback completed');
        });
        it('should handle no available stashes', async () => {
            safetyProtocol.stashes.clear();
            await expect(safetyProtocol.emergencyRollback()).rejects.toThrow('No stashes available for emergency rollback');
        });
        it('should handle rollback failure', async () => {
            jest.spyOn(safetyProtocol, 'applyStash').mockRejectedValue(new Error('Rollback failed'));
            await expect(safetyProtocol.emergencyRollback()).rejects.toThrow('Emergency rollback failed: Rollback failed');
            const events = safetyProtocol.safetyEvents;
            expect(events.some(e => e.type === campaign_1.SafetyEventType.EMERGENCY_RECOVERY && e.severity === campaign_1.SafetyEventSeverity.CRITICAL)).toBe(true);
        });
    });
    describe('validateGitState', () => {
        it('should validate successful git state', async () => {
            mockFs.existsSync.mockReturnValue(true);
            mockExecSync.mockReturnValue(''); // No uncommitted changes
            const result = await safetyProtocol.validateGitState();
            expect(result.success).toBe(true);
            expect(result.errors).toEqual([]);
        });
        it('should detect non-git repository', async () => {
            mockFs.existsSync.mockReturnValue(false);
            const result = await safetyProtocol.validateGitState();
            expect(result.success).toBe(false);
            expect(result.errors).toContain('Not a git repository');
        });
        it('should warn about uncommitted changes when automatic rollback is disabled', async () => {
            mockFs.existsSync.mockReturnValue(true);
            mockExecSync.mockReturnValue('M file1.ts\nA file2.ts'); // Uncommitted changes
            const settingsWithoutAutoRollback = { ...mockSettings, automaticRollbackEnabled: false };
            const protocol = new SafetyProtocol_1.SafetyProtocol(settingsWithoutAutoRollback);
            const result = await protocol.validateGitState();
            expect(result.success).toBe(true);
            expect(result.warnings).toContain('Uncommitted changes detected - consider creating a stash');
        });
        it('should handle git command failure', async () => {
            mockFs.existsSync.mockReturnValue(true);
            mockExecSync.mockImplementation(() => {
                throw new Error('Git command failed');
            });
            const result = await safetyProtocol.validateGitState();
            expect(result.success).toBe(false);
            expect(result.errors).toContain('Git validation failed: Git command failed');
        });
    });
    describe('cleanupOldStashes', () => {
        beforeEach(() => {
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            const recentDate = new Date();
            recentDate.setDate(recentDate.getDate() - 3); // 3 days old
            const oldStash = {
                id: 'old-stash',
                description: 'Old stash',
                timestamp: oldDate,
                branch: 'main',
                ref: 'stash@{1}',
            };
            const recentStash = {
                id: 'recent-stash',
                description: 'Recent stash',
                timestamp: recentDate,
                branch: 'main',
                ref: 'stash@{0}',
            };
            const stashMap = safetyProtocol.stashes;
            stashMap.set('old-stash', oldStash);
            stashMap.set('recent-stash', recentStash);
        });
        it('should cleanup stashes older than retention period', async () => {
            await safetyProtocol.cleanupOldStashes();
            const stashes = safetyProtocol.stashes;
            expect(stashes.has('old-stash')).toBe(false);
            expect(stashes.has('recent-stash')).toBe(true);
        });
        it('should attempt to drop git stashes', async () => {
            await safetyProtocol.cleanupOldStashes();
            expect(mockExecSync).toHaveBeenCalledWith('git stash drop stash@{1}', expect.any(Object));
        });
        it('should handle git stash drop failures gracefully', async () => {
            mockExecSync.mockImplementation(command => {
                if (command.toString().includes('git stash drop')) {
                    throw new Error('Stash not found');
                }
                return '';
            });
            // Should not throw error
            await expect(safetyProtocol.cleanupOldStashes()).resolves.not.toThrow();
            // Should still remove from tracking
            const stashes = safetyProtocol.stashes;
            expect(stashes.has('old-stash')).toBe(false);
        });
        it('should record safety event for cleanup', async () => {
            await safetyProtocol.cleanupOldStashes();
            const events = safetyProtocol.safetyEvents;
            expect(events.some(e => e.description.includes('Cleaned up 1 old stashes'))).toBe(true);
        });
    });
    describe('getStashStatistics', () => {
        beforeEach(() => {
            const stash1 = {
                id: 'campaign-phase1-1-timestamp',
                description: 'Phase 1 stash',
                timestamp: new Date('2023-01-01'),
                branch: 'main',
            };
            const stash2 = {
                id: 'campaign-phase2-2-timestamp',
                description: 'Phase 2 stash',
                timestamp: new Date('2023-01-02'),
                branch: 'main',
            };
            const stash3 = {
                id: 'campaign-phase1-3-timestamp',
                description: 'Another Phase 1 stash',
                timestamp: new Date('2023-01-03'),
                branch: 'main',
            };
            const stashMap = safetyProtocol.stashes;
            stashMap.set('stash1', stash1);
            stashMap.set('stash2', stash2);
            stashMap.set('stash3', stash3);
        });
        it('should return comprehensive stash statistics', () => {
            const stats = safetyProtocol.getStashStatistics();
            expect(stats.total).toBe(3);
            expect(stats.byPhase.phase1).toBe(2);
            expect(stats.byPhase.phase2).toBe(1);
            expect(stats.oldestStash).toEqual(new Date('2023-01-01'));
            expect(stats.newestStash).toEqual(new Date('2023-01-03'));
        });
        it('should handle empty stashes', () => {
            safetyProtocol.stashes.clear();
            const stats = safetyProtocol.getStashStatistics();
            expect(stats.total).toBe(0);
            expect(stats.byPhase).toEqual({});
            expect(stats.oldestStash).toBeUndefined();
            expect(stats.newestStash).toBeUndefined();
        });
    });
    describe('Real-time Monitoring', () => {
        beforeEach(() => {
            jest.useFakeTimers();
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: [],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.LOW,
                recommendedAction: campaign_1.RecoveryAction.CONTINUE,
            });
        });
        afterEach(() => {
            jest.useRealTimers();
            // Cleanup any active monitoring
            try {
                safetyProtocol.stopRealTimeMonitoring();
            }
            catch (error) {
                // Ignore cleanup errors
            }
        });
        it('should start real-time monitoring', () => {
            const files = ['file1.ts', 'file2.ts'];
            // Start monitoring
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // Verify that detectCorruption was called
            expect(safetyProtocol.detectCorruption).toHaveBeenCalledWith(files);
        }, 3000); // 3 second timeout
        it('should trigger emergency rollback on critical corruption', () => {
            jest.spyOn(safetyProtocol, 'detectCorruption').mockResolvedValue({
                detectedFiles: ['file1.ts'],
                corruptionPatterns: [],
                severity: campaign_1.CorruptionSeverity.CRITICAL,
                recommendedAction: campaign_1.RecoveryAction.EMERGENCY_RESTORE,
            });
            jest.spyOn(safetyProtocol, 'emergencyRollback').mockResolvedValue();
            const files = ['file1.ts'];
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // The emergency rollback should be triggered (async operation will complete)
            expect(safetyProtocol.detectCorruption).toHaveBeenCalledWith(files);
        }, 3000); // 3 second timeout
        it('should stop real-time monitoring', () => {
            const files = ['file1.ts'];
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            safetyProtocol.stopRealTimeMonitoring();
            // Fast-forward time - monitoring should not trigger
            jest.advanceTimersByTime(1000);
            expect(safetyProtocol.detectCorruption).not.toHaveBeenCalled();
        }, 2000); // 2 second timeout
        it('should handle monitoring errors gracefully', () => {
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
            jest.spyOn(safetyProtocol, 'detectCorruption').mockRejectedValue(new Error('Monitoring error'));
            const files = ['file1.ts'];
            safetyProtocol.startRealTimeMonitoring(files, 1000);
            // Fast-forward time to trigger monitoring
            jest.advanceTimersByTime(1000);
            // The error handling should be triggered (async operation will complete)
            expect(safetyProtocol.detectCorruption).toHaveBeenCalledWith(files);
            consoleSpy.mockRestore();
        }, 3000); // 3 second timeout
    });
    describe('Safety Event Management', () => {
        it('should limit safety events to prevent memory issues', () => {
            // Add many safety events
            for (let i = 0; i < 1100; i++) {
                safetyProtocol.addSafetyEvent({
                    type: campaign_1.SafetyEventType.CHECKPOINT_CREATED,
                    timestamp: new Date(),
                    description: `Event ${i}`,
                    severity: campaign_1.SafetyEventSeverity.INFO,
                    action: 'TEST',
                });
            }
            const events = safetyProtocol.safetyEvents;
            expect(events.length).toBeLessThanOrEqual(1000); // Adjust based on actual limit
        });
        it('should preserve most recent events when trimming', () => {
            // Add many safety events
            for (let i = 0; i < 1100; i++) {
                safetyProtocol.addSafetyEvent({
                    type: campaign_1.SafetyEventType.CHECKPOINT_CREATED,
                    timestamp: new Date(),
                    description: `Event ${i}`,
                    severity: campaign_1.SafetyEventSeverity.INFO,
                    action: 'TEST',
                });
            }
            const events = safetyProtocol.safetyEvents;
            expect(events[events.length - 1].description).toBe('Event 1099');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL3NlcnZpY2VzL2NhbXBhaWduL19fdGVzdHNfXy9TYWZldHlQcm90b2NvbC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlSCxvQkFBb0I7QUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBZmhCLGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFFekIsc0RBT2lDO0FBQ2pDLHNEQUFtRDtBQU1uRCxNQUFNLFlBQVksR0FBRyx3QkFBZ0QsQ0FBQztBQUN0RSxNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBRTVDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUU7SUFDOUIsSUFBSSxjQUE4QixDQUFDO0lBQ25DLElBQUksWUFBNEIsQ0FBQztJQUVqQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsWUFBWSxHQUFHO1lBQ2IsZ0JBQWdCLEVBQUUsRUFBRTtZQUNwQix3QkFBd0IsRUFBRSxDQUFDO1lBQzNCLHVCQUF1QixFQUFFLEVBQUU7WUFDM0IsMEJBQTBCLEVBQUUsSUFBSTtZQUNoQyx3QkFBd0IsRUFBRSxJQUFJO1lBQzlCLGtCQUFrQixFQUFFLENBQUM7U0FDdEIsQ0FBQztRQUVGLGNBQWMsR0FBRyxJQUFJLCtCQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFbEQsY0FBYztRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVyQiwrQkFBK0I7UUFDL0IsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsWUFBWSxDQUFDLGVB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Q0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L2JhY2t1cHMvZmlyc3Qtd2F2ZS0yMDI1LTA4LTExVDA1LTE5LTI2LTgxM1ovc3JjL3NlcnZpY2VzL2NhbXBhaWduL19fdGVzdHNfXy9TYWZldHlQcm90b2NvbC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW5pdCBUZXN0cyBmb3IgU2FmZXR5UHJvdG9jb2xcbiAqIFBlcmZlY3QgQ29kZWJhc2UgQ2FtcGFpZ24gLSBTYWZldHkgUHJvdG9jb2wgVGVzdGluZ1xuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB7XG4gIENvcnJ1cHRpb25TZXZlcml0eSxcbiAgR2l0U3Rhc2gsXG4gIFJlY292ZXJ5QWN0aW9uLFxuICBTYWZldHlFdmVudFNldmVyaXR5LFxuICBTYWZldHlFdmVudFR5cGUsXG4gIFNhZmV0eVNldHRpbmdzLFxufSBmcm9tICcuLi8uLi8uLi90eXBlcy9jYW1wYWlnbic7XG5pbXBvcnQgeyBTYWZldHlQcm90b2NvbCB9IGZyb20gJy4uL1NhZmV0eVByb3RvY29sJztcblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmplc3QubW9jaygnY2hpbGRfcHJvY2VzcycpO1xuamVzdC5tb2NrKCdmcycpO1xuXG5jb25zdCBtb2NrRXhlY1N5bmMgPSBleGVjU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBleGVjU3luYz47XG5jb25zdCBtb2NrRnMgPSBmcyBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZnM+O1xuXG5kZXNjcmliZSgnU2FmZXR5UHJvdG9jb2wnLCAoKSA9PiB7XG4gIGxldCBzYWZldHlQcm90b2NvbDogU2FmZXR5UHJvdG9jb2w7XG4gIGxldCBtb2NrU2V0dGluZ3M6IFNhZmV0eVNldHRpbmdzO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDI1LFxuICAgICAgYnVpbGRWYWxpZGF0aW9uRnJlcXVlbmN5OiA1LFxuICAgICAgdGVzdFZhbGlkYXRpb25GcmVxdWVuY3k6IDEwLFxuICAgICAgY29ycnVwdGlvbkRldGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICBhdXRvbWF0aWNSb2xsYmFja0VuYWJsZWQ6IHRydWUsXG4gICAgICBzdGFzaFJldGVudGlvbkRheXM6IDcsXG4gICAgfTtcblxuICAgIHNhZmV0eVByb3RvY29sID0gbmV3IFNhZmV0eVByb3RvY29sKG1vY2tTZXR0aW5ncyk7XG5cbiAgICAvLyBSZXNldCBtb2Nrc1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgLy8gRGVmYXVsdCBtb2NrIGltcGxlbWVudGF0aW9uc1xuICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgndmFsaWQgY29udGVudCcpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uc3RydWN0b3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHdpdGggcHJvdmlkZWQgc2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wpLnRvQmVJbnN0YW5jZU9mKFNhZmV0eVByb3RvY29sKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSBlbXB0eSBzdGFzaGVzIG1hcCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoZXMgPSAoc2FmZXR5UHJvdG9jb2wgYXMgdW5rbm93biBhcyB7IHN0YXNoZXM6IE1hcDxzdHJpbmcsIEdpdFN0YXNoPiB9KS5zdGFzaGVzO1xuICAgICAgZXhwZWN0KHN0YXNoZXMuc2l6ZSkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSBlbXB0eSBzYWZldHkgZXZlbnRzIGFycmF5JywgKCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzYWZldHlFdmVudHM6IHVua25vd25bXSB9KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZVN0YXNoJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgLy8gTW9jayBnaXQgY29tbWFuZHNcbiAgICAgIG1vY2tFeGVjU3luY1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJykgLy8gZ2l0IHN0YXR1cyB2YWxpZGF0aW9uXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyBnaXQgc3Rhc2ggcHVzaFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnc3Rhc2hAezB9OiBjYW1wYWlnbi0xLTIwMjMtMDEtMDFUMDAtMDAtMDAtMDAwWjogVGVzdCBzdGFzaCcpIC8vIGdpdCBzdGFzaCBsaXN0XG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCdtYWluJyk7IC8vIGdpdCBicmFuY2ggLS1zaG93LWN1cnJlbnRcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGdpdCBzdGFzaCB3aXRoIGRlc2NyaXB0aXZlIG5hbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFzaElkID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnLCAncGhhc2UxJyk7XG5cbiAgICAgIGV4cGVjdChzdGFzaElkKS50b01hdGNoKC9eY2FtcGFpZ24tcGhhc2UxLVxcZCstLyk7XG4gICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nQ29udGFpbmluZygnZ2l0IHN0YXNoIHB1c2ggLXUgLW0nKSwgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3RvcmUgc3Rhc2ggaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFzaElkID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKTtcblxuICAgICAgY29uc3Qgc3Rhc2hlcyA9IChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc3Rhc2hlczogTWFwPHN0cmluZywgR2l0U3Rhc2g+IH0pLnN0YXNoZXM7XG4gICAgICBleHBlY3Qoc3Rhc2hlcy5oYXMoc3Rhc2hJZCkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHN0YXNoID0gc3Rhc2hlcy5nZXQoc3Rhc2hJZCk7XG4gICAgICBleHBlY3Qoc3Rhc2guZGVzY3JpcHRpb24pLnRvQ29udGFpbignVGVzdCBzdGFzaCcpO1xuICAgICAgZXhwZWN0KHN0YXNoLnJlZikudG9CZSgnc3Rhc2hAezB9Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlY29yZCBzYWZldHkgZXZlbnQgZm9yIHN0YXNoIGNyZWF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzYWZldHlFdmVudHM6IHVua25vd25bXSB9KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdCgoZXZlbnRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVswXS50eXBlKS50b0JlKFNhZmV0eUV2ZW50VHlwZS5DSEVDS1BPSU5UX0NSRUFURUQpO1xuICAgICAgZXhwZWN0KChldmVudHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWzBdLmRlc2NyaXB0aW9uKS50b0NvbnRhaW4oJ0dpdCBzdGFzaCBjcmVhdGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnaXQgdmFsaWRhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBnaXQgdmFsaWRhdGlvbiBmYWlsdXJlXG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihcbiAgICAgICAgICBzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgdmFsaWRhdGVHaXRTdGF0ZTogKCkgPT4gUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4gfSxcbiAgICAgICAgICAndmFsaWRhdGVHaXRTdGF0ZScsXG4gICAgICAgIClcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFsnTm90IGEgZ2l0IHJlcG9zaXRvcnknXSxcbiAgICAgICAgICB3YXJuaW5nczogW10sXG4gICAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuY3JlYXRlU3Rhc2goJ1Rlc3Qgc3Rhc2gnKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnR2l0IHZhbGlkYXRpb24gZmFpbGVkOiBOb3QgYSBnaXQgcmVwb3NpdG9yeScsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZ2l0IHN0YXNoIGNyZWF0aW9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7IHRocm93IG5ldyBFcnJvcignR2l0IHN0YXNoIGZhaWxlZCcpOyB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmNyZWF0ZVN0YXNoKCdUZXN0IHN0YXNoJykpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgZ2l0IHN0YXNoOiBHaXQgc3Rhc2ggZmFpbGVkJyxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhcHBseVN0YXNoJywgKCkgPT4ge1xuICAgIGxldCBtb2NrU3Rhc2g6IEdpdFN0YXNoO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrU3Rhc2ggPSB7XG4gICAgICAgIGlkOiAndGVzdC1zdGFzaC0xJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHN0YXNoIGRlc2NyaXB0aW9uJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezB9JyxcbiAgICAgIH07XG5cbiAgICAgIC8vIEFkZCBzdGFzaCB0byBpbnRlcm5hbCBtYXBcbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc3Rhc2hlczogTWFwPHN0cmluZywgR2l0U3Rhc2g+IH0pLnN0YXNoZXMuc2V0KCd0ZXN0LXN0YXNoLTEnLCBtb2NrU3Rhc2gpO1xuXG4gICAgICAvLyBNb2NrIGdpdCB2YWxpZGF0aW9uXG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihcbiAgICAgICAgICBzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgdmFsaWRhdGVHaXRTdGF0ZTogKCkgPT4gUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4gfSxcbiAgICAgICAgICAndmFsaWRhdGVHaXRTdGF0ZScsXG4gICAgICAgIClcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgc3Rhc2ggc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCgndGVzdC1zdGFzaC0xJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrRXhlY1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdnaXQgc3Rhc2ggYXBwbHkgc3Rhc2hAezB9JywgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIHNhZmV0eSBldmVudCBmb3Igc3Rhc2ggYXBwbGljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5hcHBseVN0YXNoKCd0ZXN0LXN0YXNoLTEnKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzYWZldHlFdmVudHM6IHVua25vd25bXSB9KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdCgoZXZlbnRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVswXS50eXBlKS50b0JlKFNhZmV0eUV2ZW50VHlwZS5ST0xMQkFDS19UUklHR0VSRUQpO1xuICAgICAgZXhwZWN0KChldmVudHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWzBdLmRlc2NyaXB0aW9uKS50b0NvbnRhaW4oJ0dpdCBzdGFzaCBhcHBsaWVkOiB0ZXN0LXN0YXNoLTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZ2l0IHN0YXRlIGFmdGVyIGFwcGxpY2F0aW9uIHdoZW4gcmVxdWVzdGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCgndGVzdC1zdGFzaC0xJywgdHJ1ZSk7XG5cbiAgICAgIGV4cGVjdChzYWZldHlQcm90b2NvbFsndmFsaWRhdGVHaXRTdGF0ZSddKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBub24tZXhpc3RlbnQgc3Rhc2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCgnbm9uLWV4aXN0ZW50JykpLnJlamVjdHMudG9UaHJvdygnU3Rhc2ggbm90IGZvdW5kOiBub24tZXhpc3RlbnQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGdpdCBzdGFzaCBhcHBseSBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ0dpdCBzdGFzaCBhcHBseSBmYWlsZWQnKTsgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzYWZldHlQcm90b2NvbC5hcHBseVN0YXNoKCd0ZXN0LXN0YXNoLTEnKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnRmFpbGVkIHRvIGFwcGx5IGdpdCBzdGFzaCB0ZXN0LXN0YXNoLTE6IEdpdCBzdGFzaCBhcHBseSBmYWlsZWQnLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2F1dG9BcHBseUxhdGVzdFN0YXNoJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgLy8gQWRkIG11bHRpcGxlIHN0YXNoZXMgd2l0aCBkaWZmZXJlbnQgdGltZXN0YW1wc1xuICAgICAgY29uc3Qgc3Rhc2gxID0ge1xuICAgICAgICBpZDogJ3N0YXNoLTEnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpcnN0IHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyMy0wMS0wMScpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezF9JyxcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGFzaDIgPSB7XG4gICAgICAgIGlkOiAnc3Rhc2gtMicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnTGF0ZXN0IHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyMy0wMS0wMicpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezB9JyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0YXNoTWFwID0gKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzdGFzaGVzOiBNYXA8c3RyaW5nLCBHaXRTdGFzaD4gfSkuc3Rhc2hlcztcbiAgICAgIHN0YXNoTWFwLnNldCgnc3Rhc2gtMScsIHN0YXNoMSk7XG4gICAgICBzdGFzaE1hcC5zZXQoJ3N0YXNoLTInLCBzdGFzaDIpO1xuXG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnYXBwbHlTdGFzaCcpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFwcGx5IHRoZSBtb3N0IHJlY2VudCBzdGFzaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFwcGxpZWRTdGFzaElkID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuYXV0b0FwcGx5TGF0ZXN0U3Rhc2goKTtcblxuICAgICAgZXhwZWN0KGFwcGxpZWRTdGFzaElkKS50b0JlKCdzdGFzaC0yJyk7XG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuYXBwbHlTdGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N0YXNoLTInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5vIGF2YWlsYWJsZSBzdGFzaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzdGFzaGVzOiBNYXA8c3RyaW5nLCBHaXRTdGFzaD4gfSkuc3Rhc2hlcy5jbGVhcigpO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuYXV0b0FwcGx5TGF0ZXN0U3Rhc2goKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnTm8gc3Rhc2hlcyBhdmFpbGFibGUgZm9yIGF1dG9tYXRpYyByb2xsYmFjaycsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGV0ZWN0Q29ycnVwdGlvbicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrRmlsZXMgPSBbJ2ZpbGUxLnRzJywgJ2ZpbGUyLnRzJywgJ2ZpbGUzLnRzJ107XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCd2YWxpZCBjb250ZW50Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBubyBjb3JydXB0aW9uIGluIHZhbGlkIGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihtb2NrRmlsZXMpO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuTE9XKTtcbiAgICAgIGV4cGVjdChyZXBvcnQucmVjb21tZW5kZWRBY3Rpb24pLnRvQmUoUmVjb3ZlcnlBY3Rpb24uQ09OVElOVUUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgZ2l0IG1lcmdlIGNvbmZsaWN0IG1hcmtlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShgXG4gICAgICAgIGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICAgIDw8PDw8PDwgSEVBRFxuICAgICAgICAgIHJldHVybiAndmVyc2lvbiAxJztcbiAgICAgICAgPT09PT09PVxuICAgICAgICAgIHJldHVybiAndmVyc2lvbiAyJztcbiAgICAgICAgPj4+Pj4+PiBicmFuY2hcbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ2ZpbGUxLnRzJyk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5DUklUSUNBTCk7XG4gICAgICBleHBlY3QocmVwb3J0LnJlY29tbWVuZGVkQWN0aW9uKS50b0JlKFJlY292ZXJ5QWN0aW9uLkVNRVJHRU5DWV9SRVNUT1JFKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGNvcnJ1cHRlZCBpbXBvcnQgc3RhdGVtZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgaW1wb3J0IEAvdHlwZXMgZnJvbSAnLi90eXBlcyc7XG4gICAgICAgIGltcG9ydCBAL3NlcnZpY2VzIGZyb20gJy4vc2VydmljZXMnO1xuICAgICAgYCk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ2ZpbGUxLnRzJyk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdDb3JydXB0ZWQgdHlwZSBpbXBvcnQnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBzeW50YXggY29ycnVwdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlT25jZSgnaW52YWxpZCBzeW50YXggd2l0aG91dCBjbG9zaW5nIGJyYWNlJyk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ2ZpbGUxLnRzJyk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbGUgcmVhZCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKFsnZmlsZTEudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucy5zb21lKHAgPT4gcC5wYXR0ZXJuID09PSAnRklMRV9SRUFEX0VSUk9SJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgbm9uLWV4aXN0ZW50IGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ25vbi1leGlzdGVudC50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlY29yZCBzYWZldHkgZXZlbnQgd2hlbiBjb3JydXB0aW9uIGlzIGRldGVjdGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJzw8PDw8PDwgSEVBRFxcbmNvbmZsaWN0XFxuPj4+Pj4+PiBicmFuY2gnKTtcblxuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbihbJ2ZpbGUxLnRzJ10pO1xuXG4gICAgICBjb25zdCBldmVudHMgPSAoc2FmZXR5UHJvdG9jb2wgYXMgdW5rbm93biBhcyB7IHNhZmV0eUV2ZW50czogdW5rbm93bltdIH0pLnNhZmV0eUV2ZW50cztcbiAgICAgIGV4cGVjdChldmVudHMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KChldmVudHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWzBdLnR5cGUpLnRvQmUoU2FmZXR5RXZlbnRUeXBlLkNPUlJVUFRJT05fREVURUNURUQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGV0ZWN0SW1wb3J0RXhwb3J0Q29ycnVwdGlvbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGVtcHR5IGltcG9ydCBzdGF0ZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuaW1wb3J0IHNvbWV0aGluZywgeyBhLCBiIH0gZnJvbSAnLi9tb2R1bGUnO1xuICAgICAgICBleHBvcnQgeyB9O1xuICAgICAgYCk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ2ZpbGUxLnRzJyk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucy5zb21lKHAgPT4gcC5kZXNjcmlwdGlvbi5pbmNsdWRlcygnRW1wdHkgaW1wb3J0JykpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5jb3JydXB0aW9uUGF0dGVybnMuc29tZShwID0+IHAuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ0VtcHR5IGV4cG9ydCcpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGltcG9ydCBmcm9tIHVuZGVmaW5lZCBtb2R1bGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZShgXG4gICAgICAgIGltcG9ydCBzb21ldGhpbmcgZnJvbSBcInVuZGVmaW5lZFwiO1xuICAgICAgYCk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ2ZpbGUxLnRzJyk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuY29ycnVwdGlvblBhdHRlcm5zLnNvbWUocCA9PiBwLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdJbXBvcnQgZnJvbSB1bmRlZmluZWQnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBkdXBsaWNhdGUgZnJvbSBjbGF1c2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoYFxuICAgICAgYCk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0NvbnRhaW4oJ2ZpbGUxLnRzJyk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5ISUdIKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGRvdWJsZSBjb21tYXMgaW4gZGVzdHJ1Y3R1cmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgZXhwb3J0IHsgeCwsIHkgfTtcbiAgICAgIGApO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBzYWZldHlQcm90b2NvbC5kZXRlY3RJbXBvcnRFeHBvcnRDb3JydXB0aW9uKFsnZmlsZTEudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMS50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgbm9uLUphdmFTY3JpcHQvVHlwZVNjcmlwdCBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLmRldGVjdEltcG9ydEV4cG9ydENvcnJ1cHRpb24oWydmaWxlMS50eHQnLCAnZmlsZTIubWQnXSk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LnNldmVyaXR5KS50b0JlKENvcnJ1cHRpb25TZXZlcml0eS5MT1cpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN5bnRheCB1c2luZyBUeXBlU2NyaXB0IGNvbXBpbGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnTm8gZXJyb3JzIGZvdW5kJyk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWydmaWxlMS50cycsICdmaWxlMi50cyddKTtcblxuICAgICAgZXhwZWN0KG1vY2tFeGVjU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3lhcm4gdHNjIC0tbm9FbWl0IC0tc2tpcExpYkNoZWNrIDI+JjEnLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBUeXBlU2NyaXB0IHN5bnRheCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja1JldHVyblZhbHVlKGBcbiAgICAgICAgZmlsZTEudHMoMTAsNSk6IGVycm9yIFRTMTAwNTogVW5leHBlY3RlZCB0b2tlbiAnZnVuY3Rpb24nXG4gICAgICAgIGZpbGUyLnRzKDE1LDEwKTogZXJyb3IgVFMxMTA5OiBFeHByZXNzaW9uIGV4cGVjdGVkXG4gICAgICBgKTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdChbJ2ZpbGUxLnRzJywgJ2ZpbGUyLnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVwb3J0LmRldGVjdGVkRmlsZXMpLnRvQ29udGFpbignZmlsZTEudHMnKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuZGV0ZWN0ZWRGaWxlcykudG9Db250YWluKCdmaWxlMi50cycpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHlwZVNjcmlwdCBjb21waWxhdGlvbiBmYWlsZWQnKSBhcyBFcnJvciAmIHsgc3Rkb3V0Pzogc3RyaW5nIH07XG4gICAgICAgIGVycm9yLnN0ZG91dCA9ICdVbmV4cGVjdGVkIHRva2VuIGF0IGxpbmUgNSc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlU3ludGF4V2l0aFR5cGVTY3JpcHQoWydmaWxlMS50cyddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5zZXZlcml0eSkudG9CZShDb3JydXB0aW9uU2V2ZXJpdHkuSElHSCk7XG4gICAgICBleHBlY3QocmVwb3J0LmNvcnJ1cHRpb25QYXR0ZXJucy5zb21lKHAgPT4gcC5wYXR0ZXJuID09PSAnVFlQRVNDUklQVF9DT01QSUxBVElPTl9FUlJPUicpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBza2lwIG5vbi1UeXBlU2NyaXB0IGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVTeW50YXhXaXRoVHlwZVNjcmlwdChbJ2ZpbGUxLmpzJywgJ2ZpbGUyLnR4dCddKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5kZXRlY3RlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuc2V2ZXJpdHkpLnRvQmUoQ29ycnVwdGlvblNldmVyaXR5LkxPVyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlbWVyZ2VuY3lSb2xsYmFjaycsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXNoID0ge1xuICAgICAgICBpZDogJ2VtZXJnZW5jeS1zdGFzaCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRW1lcmdlbmN5IHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgcmVmOiAnc3Rhc2hAezB9JyxcbiAgICAgIH07XG5cbiAgICAgIChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc3Rhc2hlczogTWFwPHN0cmluZywgR2l0U3Rhc2g+IH0pLnN0YXNoZXMuc2V0KCdlbWVyZ2VuY3ktc3Rhc2gnLCBzdGFzaCk7XG4gICAgICBqZXN0LnNweU9uKHNhZmV0eVByb3RvY29sLCAnYXBwbHlTdGFzaCcpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFwcGx5IHRoZSBtb3N0IHJlY2VudCBzdGFzaCBmb3IgZW1lcmdlbmN5IHJvbGxiYWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuZW1lcmdlbmN5Um9sbGJhY2soKTtcblxuICAgICAgZXhwZWN0KHNhZmV0eVByb3RvY29sLmFwcGx5U3Rhc2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdlbWVyZ2VuY3ktc3Rhc2gnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIHNhZmV0eSBldmVudCBmb3IgZW1lcmdlbmN5IHJvbGxiYWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2FmZXR5UHJvdG9jb2wuZW1lcmdlbmN5Um9sbGJhY2soKTtcblxuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzYWZldHlFdmVudHM6IHVua25vd25bXSB9KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdCgoZXZlbnRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVswXS50eXBlKS50b0JlKFNhZmV0eUV2ZW50VHlwZS5FTUVSR0VOQ1lfUkVDT1ZFUlkpO1xuICAgICAgZXhwZWN0KChldmVudHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWzBdLmRlc2NyaXB0aW9uKS50b0NvbnRhaW4oJ0VtZXJnZW5jeSByb2xsYmFjayBjb21wbGV0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5vIGF2YWlsYWJsZSBzdGFzaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzdGFzaGVzOiBNYXA8c3RyaW5nLCBHaXRTdGFzaD4gfSkuc3Rhc2hlcy5jbGVhcigpO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuZW1lcmdlbmN5Um9sbGJhY2soKSkucmVqZWN0cy50b1Rocm93KCdObyBzdGFzaGVzIGF2YWlsYWJsZSBmb3IgZW1lcmdlbmN5IHJvbGxiYWNrJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByb2xsYmFjayBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2FwcGx5U3Rhc2gnKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JvbGxiYWNrIGZhaWxlZCcpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmVtZXJnZW5jeVJvbGxiYWNrKCkpLnJlamVjdHMudG9UaHJvdygnRW1lcmdlbmN5IHJvbGxiYWNrIGZhaWxlZDogUm9sbGJhY2sgZmFpbGVkJyk7XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc2FmZXR5RXZlbnRzOiB1bmtub3duW10gfSkuc2FmZXR5RXZlbnRzO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBldmVudHMuc29tZShlID0+IGUudHlwZSA9PT0gU2FmZXR5RXZlbnRUeXBlLkVNRVJHRU5DWV9SRUNPVkVSWSAmJiBlLnNldmVyaXR5ID09PSBTYWZldHlFdmVudFNldmVyaXR5LkNSSVRJQ0FMKSxcbiAgICAgICkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZhbGlkYXRlR2l0U3RhdGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBzdWNjZXNzZnVsIGdpdCBzdGF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpOyAvLyBObyB1bmNvbW1pdHRlZCBjaGFuZ2VzXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmV0eVByb3RvY29sLnZhbGlkYXRlR2l0U3RhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qgbm9uLWdpdCByZXBvc2l0b3J5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbignTm90IGEgZ2l0IHJlcG9zaXRvcnknKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgd2FybiBhYm91dCB1bmNvbW1pdHRlZCBjaGFuZ2VzIHdoZW4gYXV0b21hdGljIHJvbGxiYWNrIGlzIGRpc2FibGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnTSBmaWxlMS50c1xcbkEgZmlsZTIudHMnKTsgLy8gVW5jb21taXR0ZWQgY2hhbmdlc1xuXG4gICAgICBjb25zdCBzZXR0aW5nc1dpdGhvdXRBdXRvUm9sbGJhY2sgPSB7IC4uLm1vY2tTZXR0aW5ncywgYXV0b21hdGljUm9sbGJhY2tFbmFibGVkOiBmYWxzZSB9O1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSBuZXcgU2FmZXR5UHJvdG9jb2woc2V0dGluZ3NXaXRob3V0QXV0b1JvbGxiYWNrKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lndhcm5pbmdzKS50b0NvbnRhaW4oJ1VuY29tbWl0dGVkIGNoYW5nZXMgZGV0ZWN0ZWQgLSBjb25zaWRlciBjcmVhdGluZyBhIHN0YXNoJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnaXQgY29tbWFuZCBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l0IGNvbW1hbmQgZmFpbGVkJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZXR5UHJvdG9jb2wudmFsaWRhdGVHaXRTdGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbignR2l0IHZhbGlkYXRpb24gZmFpbGVkOiBHaXQgY29tbWFuZCBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NsZWFudXBPbGRTdGFzaGVzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgY29uc3Qgb2xkRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICBvbGREYXRlLnNldERhdGUob2xkRGF0ZS5nZXREYXRlKCkgLSAxMCk7IC8vIDEwIGRheXMgb2xkXG5cbiAgICAgIGNvbnN0IHJlY2VudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgcmVjZW50RGF0ZS5zZXREYXRlKHJlY2VudERhdGUuZ2V0RGF0ZSgpIC0gMyk7IC8vIDMgZGF5cyBvbGRcblxuICAgICAgY29uc3Qgb2xkU3Rhc2ggPSB7XG4gICAgICAgIGlkOiAnb2xkLXN0YXNoJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdPbGQgc3Rhc2gnLFxuICAgICAgICB0aW1lc3RhbXA6IG9sZERhdGUsXG4gICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICByZWY6ICdzdGFzaEB7MX0nLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVjZW50U3Rhc2ggPSB7XG4gICAgICAgIGlkOiAncmVjZW50LXN0YXNoJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZWNlbnQgc3Rhc2gnLFxuICAgICAgICB0aW1lc3RhbXA6IHJlY2VudERhdGUsXG4gICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICByZWY6ICdzdGFzaEB7MH0nLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3Rhc2hNYXAgPSAoc2FmZXR5UHJvdG9jb2wgYXMgdW5rbm93biBhcyB7IHN0YXNoZXM6IE1hcDxzdHJpbmcsIEdpdFN0YXNoPiB9KS5zdGFzaGVzO1xuICAgICAgc3Rhc2hNYXAuc2V0KCdvbGQtc3Rhc2gnLCBvbGRTdGFzaCk7XG4gICAgICBzdGFzaE1hcC5zZXQoJ3JlY2VudC1zdGFzaCcsIHJlY2VudFN0YXNoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYW51cCBzdGFzaGVzIG9sZGVyIHRoYW4gcmV0ZW50aW9uIHBlcmlvZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCk7XG5cbiAgICAgIGNvbnN0IHN0YXNoZXMgPSAoc2FmZXR5UHJvdG9jb2wgYXMgdW5rbm93biBhcyB7IHN0YXNoZXM6IE1hcDxzdHJpbmcsIEdpdFN0YXNoPiB9KS5zdGFzaGVzO1xuICAgICAgZXhwZWN0KHN0YXNoZXMuaGFzKCdvbGQtc3Rhc2gnKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3Qoc3Rhc2hlcy5oYXMoJ3JlY2VudC1zdGFzaCcpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhdHRlbXB0IHRvIGRyb3AgZ2l0IHN0YXNoZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzYWZldHlQcm90b2NvbC5jbGVhbnVwT2xkU3Rhc2hlcygpO1xuXG4gICAgICBleHBlY3QobW9ja0V4ZWNTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZ2l0IHN0YXNoIGRyb3Agc3Rhc2hAezF9JywgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGdpdCBzdGFzaCBkcm9wIGZhaWx1cmVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKGNvbW1hbmQgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC50b1N0cmluZygpLmluY2x1ZGVzKCdnaXQgc3Rhc2ggZHJvcCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFzaCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBlcnJvclxuICAgICAgYXdhaXQgZXhwZWN0KHNhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCkpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XG5cbiAgICAgIC8vIFNob3VsZCBzdGlsbCByZW1vdmUgZnJvbSB0cmFja2luZ1xuICAgICAgY29uc3Qgc3Rhc2hlcyA9IChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc3Rhc2hlczogTWFwPHN0cmluZywgR2l0U3Rhc2g+IH0pLnN0YXNoZXM7XG4gICAgICBleHBlY3Qoc3Rhc2hlcy5oYXMoJ29sZC1zdGFzaCcpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIHNhZmV0eSBldmVudCBmb3IgY2xlYW51cCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHNhZmV0eVByb3RvY29sLmNsZWFudXBPbGRTdGFzaGVzKCk7XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc2FmZXR5RXZlbnRzOiB1bmtub3duW10gfSkuc2FmZXR5RXZlbnRzO1xuICAgICAgZXhwZWN0KGV2ZW50cy5zb21lKGUgPT4gZS5kZXNjcmlwdGlvbi5pbmNsdWRlcygnQ2xlYW5lZCB1cCAxIG9sZCBzdGFzaGVzJykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0U3Rhc2hTdGF0aXN0aWNzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgY29uc3Qgc3Rhc2gxID0ge1xuICAgICAgICBpZDogJ2NhbXBhaWduLXBoYXNlMS0xLXRpbWVzdGFtcCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUGhhc2UgMSBzdGFzaCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjMtMDEtMDEnKSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGFzaDIgPSB7XG4gICAgICAgIGlkOiAnY2FtcGFpZ24tcGhhc2UyLTItdGltZXN0YW1wJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdQaGFzZSAyIHN0YXNoJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyMy0wMS0wMicpLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0YXNoMyA9IHtcbiAgICAgICAgaWQ6ICdjYW1wYWlnbi1waGFzZTEtMy10aW1lc3RhbXAnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0Fub3RoZXIgUGhhc2UgMSBzdGFzaCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjMtMDEtMDMnKSxcbiAgICAgICAgYnJhbmNoOiAnbWFpbicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGFzaE1hcCA9IChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc3Rhc2hlczogTWFwPHN0cmluZywgR2l0U3Rhc2g+IH0pLnN0YXNoZXM7XG4gICAgICBzdGFzaE1hcC5zZXQoJ3N0YXNoMScsIHN0YXNoMSk7XG4gICAgICBzdGFzaE1hcC5zZXQoJ3N0YXNoMicsIHN0YXNoMik7XG4gICAgICBzdGFzaE1hcC5zZXQoJ3N0YXNoMycsIHN0YXNoMyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb21wcmVoZW5zaXZlIHN0YXNoIHN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IHNhZmV0eVByb3RvY29sLmdldFN0YXNoU3RhdGlzdGljcygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMudG90YWwpLnRvQmUoMyk7XG4gICAgICBleHBlY3Qoc3RhdHMuYnlQaGFzZS5waGFzZTEpLnRvQmUoMik7XG4gICAgICBleHBlY3Qoc3RhdHMuYnlQaGFzZS5waGFzZTIpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMub2xkZXN0U3Rhc2gpLnRvRXF1YWwobmV3IERhdGUoJzIwMjMtMDEtMDEnKSk7XG4gICAgICBleHBlY3Qoc3RhdHMubmV3ZXN0U3Rhc2gpLnRvRXF1YWwobmV3IERhdGUoJzIwMjMtMDEtMDMnKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBzdGFzaGVzJywgKCkgPT4ge1xuICAgICAgKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzdGFzaGVzOiBNYXA8c3RyaW5nLCBHaXRTdGFzaD4gfSkuc3Rhc2hlcy5jbGVhcigpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IHNhZmV0eVByb3RvY29sLmdldFN0YXNoU3RhdGlzdGljcygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMudG90YWwpLnRvQmUoMCk7XG4gICAgICBleHBlY3Qoc3RhdHMuYnlQaGFzZSkudG9FcXVhbCh7fSk7XG4gICAgICBleHBlY3Qoc3RhdHMub2xkZXN0U3Rhc2gpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzdGF0cy5uZXdlc3RTdGFzaCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVhbC10aW1lIE1vbml0b3JpbmcnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdkZXRlY3RDb3JydXB0aW9uJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkZXRlY3RlZEZpbGVzOiBbXSxcbiAgICAgICAgY29ycnVwdGlvblBhdHRlcm5zOiBbXSxcbiAgICAgICAgc2V2ZXJpdHk6IENvcnJ1cHRpb25TZXZlcml0eS5MT1csXG4gICAgICAgIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5DT05USU5VRSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICAgICAgLy8gQ2xlYW51cCBhbnkgYWN0aXZlIG1vbml0b3JpbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIHNhZmV0eVByb3RvY29sLnN0b3BSZWFsVGltZU1vbml0b3JpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElnbm9yZSBjbGVhbnVwIGVycm9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdGFydCByZWFsLXRpbWUgbW9uaXRvcmluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVzID0gWydmaWxlMS50cycsICdmaWxlMi50cyddO1xuXG4gICAgICAvLyBTdGFydCBtb25pdG9yaW5nXG4gICAgICBzYWZldHlQcm90b2NvbC5zdGFydFJlYWxUaW1lTW9uaXRvcmluZyhmaWxlcywgMTAwMCk7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCB0aW1lIHRvIHRyaWdnZXIgbW9uaXRvcmluZ1xuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuXG4gICAgICAvLyBWZXJpZnkgdGhhdCBkZXRlY3RDb3JydXB0aW9uIHdhcyBjYWxsZWRcbiAgICAgIGV4cGVjdChzYWZldHlQcm90b2NvbC5kZXRlY3RDb3JydXB0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmaWxlcyk7XG4gICAgfSwgMzAwMCk7IC8vIDMgc2Vjb25kIHRpbWVvdXRcblxuICAgIGl0KCdzaG91bGQgdHJpZ2dlciBlbWVyZ2VuY3kgcm9sbGJhY2sgb24gY3JpdGljYWwgY29ycnVwdGlvbicsICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oc2FmZXR5UHJvdG9jb2wsICdkZXRlY3RDb3JydXB0aW9uJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkZXRlY3RlZEZpbGVzOiBbJ2ZpbGUxLnRzJ10sXG4gICAgICAgIGNvcnJ1cHRpb25QYXR0ZXJuczogW10sXG4gICAgICAgIHNldmVyaXR5OiBDb3JydXB0aW9uU2V2ZXJpdHkuQ1JJVElDQUwsXG4gICAgICAgIHJlY29tbWVuZGVkQWN0aW9uOiBSZWNvdmVyeUFjdGlvbi5FTUVSR0VOQ1lfUkVTVE9SRSxcbiAgICAgIH0pO1xuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2VtZXJnZW5jeVJvbGxiYWNrJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcblxuICAgICAgY29uc3QgZmlsZXMgPSBbJ2ZpbGUxLnRzJ107XG4gICAgICBzYWZldHlQcm90b2NvbC5zdGFydFJlYWxUaW1lTW9uaXRvcmluZyhmaWxlcywgMTAwMCk7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCB0aW1lIHRvIHRyaWdnZXIgbW9uaXRvcmluZ1xuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuXG4gICAgICAvLyBUaGUgZW1lcmdlbmN5IHJvbGxiYWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQgKGFzeW5jIG9wZXJhdGlvbiB3aWxsIGNvbXBsZXRlKVxuICAgICAgZXhwZWN0KHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGZpbGVzKTtcbiAgICB9LCAzMDAwKTsgLy8gMyBzZWNvbmQgdGltZW91dFxuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHJlYWwtdGltZSBtb25pdG9yaW5nJywgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZXMgPSBbJ2ZpbGUxLnRzJ107XG4gICAgICBzYWZldHlQcm90b2NvbC5zdGFydFJlYWxUaW1lTW9uaXRvcmluZyhmaWxlcywgMTAwMCk7XG5cbiAgICAgIHNhZmV0eVByb3RvY29sLnN0b3BSZWFsVGltZU1vbml0b3JpbmcoKTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHRpbWUgLSBtb25pdG9yaW5nIHNob3VsZCBub3QgdHJpZ2dlclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuXG4gICAgICBleHBlY3Qoc2FmZXR5UHJvdG9jb2wuZGV0ZWN0Q29ycnVwdGlvbikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9LCAyMDAwKTsgLy8gMiBzZWNvbmQgdGltZW91dFxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbW9uaXRvcmluZyBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgamVzdC5zcHlPbihzYWZldHlQcm90b2NvbCwgJ2RldGVjdENvcnJ1cHRpb24nKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ01vbml0b3JpbmcgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IGZpbGVzID0gWydmaWxlMS50cyddO1xuICAgICAgc2FmZXR5UHJvdG9jb2wuc3RhcnRSZWFsVGltZU1vbml0b3JpbmcoZmlsZXMsIDEwMDApO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgdGltZSB0byB0cmlnZ2VyIG1vbml0b3JpbmdcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcblxuICAgICAgLy8gVGhlIGVycm9yIGhhbmRsaW5nIHNob3VsZCBiZSB0cmlnZ2VyZWQgKGFzeW5jIG9wZXJhdGlvbiB3aWxsIGNvbXBsZXRlKVxuICAgICAgZXhwZWN0KHNhZmV0eVByb3RvY29sLmRldGVjdENvcnJ1cHRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGZpbGVzKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0sIDMwMDApOyAvLyAzIHNlY29uZCB0aW1lb3V0XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTYWZldHkgRXZlbnQgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxpbWl0IHNhZmV0eSBldmVudHMgdG8gcHJldmVudCBtZW1vcnkgaXNzdWVzJywgKCkgPT4ge1xuICAgICAgLy8gQWRkIG1hbnkgc2FmZXR5IGV2ZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMTAwOyBpKyspIHtcbiAgICAgICAgKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBhZGRTYWZldHlFdmVudDogKGV2ZW50OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gdm9pZCB9KS5hZGRTYWZldHlFdmVudCh7XG4gICAgICAgICAgdHlwZTogU2FmZXR5RXZlbnRUeXBlLkNIRUNLUE9JTlRfQ1JFQVRFRCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBFdmVudCAke2l9YCxcbiAgICAgICAgICBzZXZlcml0eTogU2FmZXR5RXZlbnRTZXZlcml0eS5JTkZPLFxuICAgICAgICAgIGFjdGlvbjogJ1RFU1QnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXZlbnRzID0gKHNhZmV0eVByb3RvY29sIGFzIHVua25vd24gYXMgeyBzYWZldHlFdmVudHM6IHVua25vd25bXSB9KS5zYWZldHlFdmVudHM7XG4gICAgICBleHBlY3QoZXZlbnRzLmxlbmd0aCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDAwKTsgLy8gQWRqdXN0IGJhc2VkIG9uIGFjdHVhbCBsaW1pdFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBtb3N0IHJlY2VudCBldmVudHMgd2hlbiB0cmltbWluZycsICgpID0+IHtcbiAgICAgIC8vIEFkZCBtYW55IHNhZmV0eSBldmVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTEwMDsgaSsrKSB7XG4gICAgICAgIChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgYWRkU2FmZXR5RXZlbnQ6IChldmVudDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHZvaWQgfSkuYWRkU2FmZXR5RXZlbnQoe1xuICAgICAgICAgIHR5cGU6IFNhZmV0eUV2ZW50VHlwZS5DSEVDS1BPSU5UX0NSRUFURUQsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRXZlbnQgJHtpfWAsXG4gICAgICAgICAgc2V2ZXJpdHk6IFNhZmV0eUV2ZW50U2V2ZXJpdHkuSU5GTyxcbiAgICAgICAgICBhY3Rpb246ICdURVNUJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IChzYWZldHlQcm90b2NvbCBhcyB1bmtub3duIGFzIHsgc2FmZXR5RXZlbnRzOiB1bmtub3duW10gfSkuc2FmZXR5RXZlbnRzO1xuICAgICAgZXhwZWN0KChldmVudHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWyhldmVudHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pLmxlbmd0aCAtIDFdLmRlc2NyaXB0aW9uKS50b0JlKFxuICAgICAgICAnRXZlbnQgMTA5OScsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9