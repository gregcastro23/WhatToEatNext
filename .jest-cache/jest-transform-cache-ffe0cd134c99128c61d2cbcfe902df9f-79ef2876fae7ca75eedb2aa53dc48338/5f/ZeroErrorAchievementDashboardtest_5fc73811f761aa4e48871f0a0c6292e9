e75651ca1079cbda0db6f2bdf946c901
"use strict";
/**
 * Zero-Error Achievement Dashboard Tests
 *
 * Comprehensive test suite for the zero-error monitoring and
 * achievement tracking system.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const ZeroErrorAchievementDashboard_1 = require("../../services/linting/ZeroErrorAchievementDashboard");
// Mock external dependencies
void jest.mock('child_process');
void jest.mock('fs');
const mockExecSync = child_process_1.execSync;
const mockWriteFileSync = fs_1.writeFileSync;
const mockReadFileSync = fs_1.readFileSync;
const mockExistsSync = fs_1.existsSync;
const mockMkdirSync = fs_1.mkdirSync;
describe('ZeroErrorAchievementDashboard', () => {
    let dashboard;
    let mockMetrics;
    beforeEach(() => {
        void jest.clearAllMocks();
        // Mock file system operations
        void mockExistsSync.mockReturnValue(true);
        void mockReadFileSync.mockReturnValue('[]');
        void mockWriteFileSync.mockImplementation(() => { });
        void mockMkdirSync.mockImplementation(() => '');
        // Mock successful command execution
        void mockExecSync.mockReturnValue('');
        // Create mock metrics
        mockMetrics = {
            timestamp: new Date(),
            totalIssues: 1500,
            errors: 50,
            warnings: 1450,
            parserErrors: 0,
            explicitAnyErrors: 150,
            importOrderIssues: 200,
            unusedVariables: 300,
            reactHooksIssues: 100,
            consoleStatements: 50,
            domainSpecificIssues: {
                astrologicalCalculations: 25,
                campaignSystem: 15,
                testFiles: 10,
            },
            performanceMetrics: {
                lintingDuration: 25000,
                cacheHitRate: 0.75,
                memoryUsage: 256,
                filesProcessed: 500,
            },
            qualityScore: 85,
            regressionDetected: false,
        };
        dashboard = new ZeroErrorAchievementDashboard_1.ZeroErrorAchievementDashboard();
    });
    afterEach(() => {
        void jest.restoreAllMocks();
    });
    describe('Dashboard Generation', () => {
        test('should generate comprehensive dashboard successfully', async () => {
            // Mock validation dashboard result
            const mockValidationResult = {
                passed: true,
                metrics: mockMetrics,
                alerts: [],
                recommendations: ['Continue systematic improvement'],
                regressionAnalysis: {
                    detected: false,
                    affectedMetrics: [],
                    severity: 'minor',
                    recommendations: [],
                    historicalComparison: {
                        current: 1500,
                        previous: 1600,
                        change: -100,
                        changePercentage: -6.25,
                    },
                },
            };
            // Mock the validation dashboard
            void jest
                .spyOn(dashboard['validationDashboard'], 'runComprehensiveValidation')
                .mockResolvedValue(mockValidationResult);
            await dashboard.generateDashboard();
            // Verify dashboard report was generated
            expect(mockWriteFileSync).toHaveBeenCalledWith(expect.stringContaining('zero-error-achievement-dashboard.md'), expect.stringContaining('# ðŸŽ¯ Zero-Error Achievement Dashboard'), 'utf8');
            // Verify JSON data was generated
            expect(mockWriteFileSync).toHaveBeenCalledWith(expect.stringContaining('zero-error-achievement-dashboard.json'), expect.stringContaining('"timestamp"'), undefined);
        });
        test('should handle dashboard generation errors gracefully', async () => {
            // Mock validation dashboard failure
            void jest
                .spyOn(dashboard['validationDashboard'], 'runComprehensiveValidation')
                .mockRejectedValue(new Error('Validation failed'));
            await expect(dashboard.generateDashboard()).rejects.toThrow('Validation failed');
        });
        test('should generate targets with correct progress calculations', async () => {
            const mockValidationResult = {
                passed: true,
                metrics: mockMetrics,
                alerts: [],
                recommendations: [],
                regressionAnalysis: {
                    detected: false,
                    affectedMetrics: [],
                    severity: 'minor',
                    recommendations: [],
                    historicalComparison: {
                        current: 1500,
                        previous: 1600,
                        change: -100,
                        changePercentage: -6.25,
                    },
                },
            };
            void jest
                .spyOn(dashboard['validationDashboard'], 'runComprehensiveValidation')
                .mockResolvedValue(mockValidationResult);
            await dashboard.generateDashboard();
            // Verify targets file was written
            const targetsCall = mockWriteFileSync.mock.calls.find(call => call[0].includes('zero-error-targets.json'));
            expect(targetsCall).toBeDefined();
            const targetsData = JSON.parse(targetsCall[1]);
            expect(targetsData).toBeInstanceOf(Array);
            expect(targetsData.length).toBeGreaterThan(0);
            // Check parser errors target
            const parserErrorsTarget = targetsData.find(t => t.metric === 'parserErrors');
            expect(parserErrorsTarget).toBeDefined();
            expect(parserErrorsTarget.currentValue).toBe(0);
            expect(parserErrorsTarget.targetValue).toBe(0);
            expect(parserErrorsTarget.progress).toBe(100); // Already achieved
            expect(parserErrorsTarget.priority).toBe('critical');
        });
    });
    describe('Real-Time Monitoring', () => {
        test('should detect significant changes in metrics', async () => {
            const previousMetrics = { ...mockMetrics, totalIssues: 1000 };
            const currentMetrics = { ...mockMetrics, totalIssues: 1500 };
            const changes = dashboard['detectSignificantChanges'](previousMetrics, currentMetrics);
            expect(changes).toContain(expect.stringContaining('Total Issues increased'));
            expect(changes[0]).toMatch(/50\.0%/); // 50% increase
        }, 5000); // 5 second timeout
        test('should identify critical issues correctly', () => {
            const criticalMetrics = {
                ...mockMetrics,
                parserErrors: 5,
                explicitAnyErrors: 250,
                qualityScore: 45,
                performanceMetrics: {
                    ...mockMetrics.performanceMetrics,
                    lintingDuration: 75000,
                },
            };
            const criticalIssues = dashboard['identifyCriticalIssues'](criticalMetrics);
            expect(criticalIssues).toContain(expect.stringContaining('5 parser errors'));
            expect(criticalIssues).toContain(expect.stringContaining('250 explicit any errors'));
            expect(criticalIssues).toContain(expect.stringContaining('Quality score 45'));
            expect(criticalIssues).toContain(expect.stringContaining('75000ms'));
        }, 3000); // 3 second timeout
        test('should handle real-time monitoring updates efficiently', async () => {
            const startTime = Date.now();
            // Simulate rapid metric updates
            for (let i = 0; i < 10; i++) {
                const updatedMetrics = { ...mockMetrics, totalIssues: 1000 + i * 10 };
                dashboard['detectSignificantChanges'](mockMetrics, updatedMetrics);
            }
            const duration = Date.now() - startTime;
            // Should handle updates quickly
            expect(duration).toBeLessThan(1000); // Under 1 second
        }, 5000); // 5 second timeout
        test('should validate monitoring consistency', async () => {
            const testMetrics = { ...mockMetrics, totalIssues: 500 };
            // Run the same detection multiple times
            const results = [];
            for (let i = 0; i < 5; i++) {
                const changes = dashboard['detectSignificantChanges'](mockMetrics, testMetrics);
                void results.push(changes.length);
            }
            // Results should be consistent
            const allSame = results.every(count => count === results[0]);
            expect(allSame).toBe(true);
        }, 3000); // 3 second timeout
        test('should update real-time status correctly', async () => {
            dashboard['updateRealTimeStatus'](mockMetrics);
            const statusCall = mockWriteFileSync.mock.calls.find(call => call[0].includes('zero-error-achievement-status.json'));
            expect(statusCall).toBeDefined();
            const statusData = JSON.parse(statusCall[1]);
            expect(statusData.qualityScore).toBe(85);
            expect(statusData.totalIssues).toBe(1500);
            expect(statusData.parserErrors).toBe(0);
            expect(statusData.status).toBe('good'); // Quality score 85 = good
        });
    });
    describe('Trend Analysis', () => {
        test('should calculate trends correctly with sufficient data', async () => {
            // Mock metrics history with trend data
            const historyData = [
                { ...mockMetrics, totalIssues: 2000, timestamp: new Date('2025-01-01') },
                { ...mockMetrics, totalIssues: 1800, timestamp: new Date('2025-01-02') },
                { ...mockMetrics, totalIssues: 1600, timestamp: new Date('2025-01-03') },
                { ...mockMetrics, totalIssues: 1500, timestamp: new Date('2025-01-04') },
            ];
            void mockReadFileSync.mockReturnValueOnce(JSON.stringify(historyData));
            const trends = await dashboard['analyzeTrends'](mockMetrics);
            expect(trends).toBeInstanceOf(Array);
            expect(trends.length).toBeGreaterThan(0);
            const totalIssuesTrend = trends.find(t => t.metric === 'totalIssues');
            expect(totalIssuesTrend).toBeDefined();
            if (totalIssuesTrend) {
                expect(totalIssuesTrend.trend).toBe('improving'); // Decreasing issues = improving
                expect(totalIssuesTrend.velocity).toBeLessThan(0); // Negative velocity = decreasing
            }
        });
        test('should handle insufficient data for trend analysis', async () => {
            // Mock insufficient history data
            const historyData = [mockMetrics];
            void mockReadFileSync.mockReturnValueOnce(JSON.stringify(historyData));
            const trends = await dashboard['analyzeTrends'](mockMetrics);
            expect(trends).toEqual([]); // No trends with insufficient data
        });
        test('should project future values correctly', () => {
            const velocity = -10; // Improving by 10 issues per day
            const currentValue = 1500;
            const projection = dashboard['projectFuture'](velocity, currentValue);
            expect(projection.sevenDays).toBe(1430); // 1500 - (10 * 7);
            expect(projection.thirtyDays).toBe(1200); // 1500 - (10 * 30);
            expect(projection.ninetyDays).toBe(600); // 1500 - (10 * 90)
        });
    });
    describe('Quality Gates', () => {
        test('should evaluate quality gates correctly', async () => {
            const gates = await dashboard['checkQualityGates'](mockMetrics);
            expect(gates).toBeInstanceOf(Array);
            expect(gates.length).toBeGreaterThan(0);
            // Check parser errors gate (should pass with 0 errors)
            const parserGate = gates.find(g => g.name === 'parser-errors');
            expect(parserGate).toBeDefined();
            if (parserGate) {
                expect(parserGate.status).toBe('passing');
            }
            // Check explicit any gate (should warn with 150 errors)
            const anyGate = gates.find(g => g.name === 'explicit-any');
            expect(anyGate).toBeDefined();
            if (anyGate) {
                expect(anyGate.status).toBe('warning'); // 150 > 100 but <= 150
            }
            // Check quality score gate (should pass with 85)
            const qualityGate = gates.find(g => g.id === 'quality-score-minimum');
            expect(qualityGate).toBeDefined();
            if (qualityGate) {
                expect(qualityGate.status).toBe('passing'); // 85 >= 80
            }
        });
        test('should identify failing quality gates', async () => {
            const failingMetrics = {
                ...mockMetrics,
                parserErrors: 3,
                explicitAnyErrors: 200,
                qualityScore: 65,
            };
            const gates = await dashboard['checkQualityGates'](failingMetrics);
            const parserGate = gates.find(g => g.name === 'parser-errors');
            if (parserGate) {
                expect(parserGate.status).toBe('failing');
            }
            const anyGate = gates.find(g => g.name === 'explicit-any');
            if (anyGate) {
                expect(anyGate.status).toBe('failing'); // 200 > 150
            }
            const qualityGate = gates.find(g => g.id === 'quality-score-minimum');
            if (qualityGate) {
                expect(qualityGate.status).toBe('warning'); // 65 < 80 but >= 70
            }
        });
    });
    describe('Target Management', () => {
        test('should calculate progress correctly for different metric types', () => {
            // Quality score progress (higher is better)
            const qualityProgress = dashboard['calculateProgress'](85, 95, 'qualityScore');
            expect(qualityProgress).toBeCloseTo(89.47, 1); // (85/95) * 100
            // Error count progress (lower is better)
            const errorProgress = dashboard['calculateProgress'](150, 0, 'explicitAnyErrors');
            expect(errorProgress).toBeGreaterThan(0);
            expect(errorProgress).toBeLessThan(100);
        });
        test('should estimate completion dates based on progress', () => {
            const deadline = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
            const completion = dashboard['estimateCompletion'](150, 0, deadline);
            expect(completion).toBeInstanceOf(Date);
            expect(completion.getTime()).toBeGreaterThan(Date.now());
            expect(completion.getTime()).toBeLessThanOrEqual(deadline.getTime());
        });
        test('should update targets with current metrics', async () => {
            const mockValidationResult = {
                passed: true,
                metrics: mockMetrics,
                alerts: [],
                recommendations: [],
                regressionAnalysis: {
                    detected: false,
                    affectedMetrics: [],
                    severity: 'minor',
                    recommendations: [],
                    historicalComparison: {
                        current: 1500,
                        previous: 1600,
                        change: -100,
                        changePercentage: -6.25,
                    },
                },
            };
            void jest
                .spyOn(dashboard['validationDashboard'], 'runComprehensiveValidation')
                .mockResolvedValue(mockValidationResult);
            const targets = await dashboard['updateTargets'](mockMetrics);
            expect(targets).toBeInstanceOf(Array);
            expect(targets.length).toBeGreaterThan(0);
            // Verify all targets have required properties
            for (const target of targets) {
                expect(target).toHaveProperty('metric');
                expect(target).toHaveProperty('currentValue');
                expect(target).toHaveProperty('targetValue');
                expect(target).toHaveProperty('progress');
                expect(target).toHaveProperty('priority');
                expect(target).toHaveProperty('strategy');
                expect(target.progress).toBeGreaterThanOrEqual(0);
                expect(target.progress).toBeLessThanOrEqual(100);
            }
        });
    });
    describe('Maintenance Procedures', () => {
        test('should initialize maintenance procedures correctly', () => {
            const procedures = dashboard['maintenanceProcedures'];
            expect(procedures.size).toBeGreaterThan(0);
            expect(procedures.has('daily-health-check')).toBe(true);
            expect(procedures.has('weekly-cache-optimization')).toBe(true);
            expect(procedures.has('monthly-metrics-cleanup')).toBe(true);
            const dailyCheck = procedures.get('daily-health-check');
            expect(dailyCheck).toBeDefined();
            if (dailyCheck) {
                expect(dailyCheck.frequency).toBe('daily');
                expect(dailyCheck.automated).toBe(true);
                expect(typeof dailyCheck.procedure).toBe('function');
            }
        });
        test('should calculate next run times correctly', () => {
            const baseDate = new Date('2025-01-15T10:00:00Z');
            const nextDaily = dashboard['calculateNextRun'](baseDate, 'daily');
            expect(nextDaily.getDate()).toBe(16); // Next day
            const nextWeekly = dashboard['calculateNextRun'](baseDate, 'weekly');
            expect(nextWeekly.getDate()).toBe(22); // 7 days later
            const nextMonthly = dashboard['calculateNextRun'](baseDate, 'monthly');
            expect(nextMonthly.getMonth()).toBe(1); // February (0-indexed)
            const nextQuarterly = dashboard['calculateNextRun'](baseDate, 'quarterly');
            expect(nextQuarterly.getMonth()).toBe(3); // April (0-indexed)
        });
        test('should run scheduled maintenance procedures', async () => {
            // Mock successful command execution for maintenance
            mockExecSync.mockReturnValue('0'); // Success exit code
            const results = await dashboard['runScheduledMaintenance']();
            // Should run procedures that are due
            expect(results).toBeInstanceOf(Map);
            // Verify maintenance procedures were updated
            const dailyCheck = dashboard['maintenanceProcedures'].get('daily-health-check');
            if (dailyCheck && results.has('daily-health-check')) {
                expect(dailyCheck.lastRun).toBeInstanceOf(Date);
                expect(dailyCheck.nextRun).toBeInstanceOf(Date);
                if (dailyCheck.nextRun && dailyCheck.lastRun) {
                    expect(dailyCheck.nextRun.getTime()).toBeGreaterThan(dailyCheck.lastRun.getTime());
                }
            }
        });
    });
    describe('Report Generation', () => {
        test('should generate comprehensive markdown report', async () => {
            const mockData = {
                validationResult: {
                    passed: true,
                    metrics: mockMetrics,
                    alerts: [],
                    recommendations: ['Continue improvement'],
                    regressionAnalysis: {
                        detected: false,
                        affectedMetrics: [],
                        severity: 'minor',
                        recommendations: [],
                        historicalComparison: {
                            current: 1500,
                            previous: 1600,
                            change: -100,
                            changePercentage: -6.25,
                        },
                    },
                },
                trendAnalysis: [],
                targets: [],
                qualityGates: [],
                maintenanceResults: new Map(),
                generationTime: 1500,
            };
            dashboard['generateComprehensiveReport'](mockData);
            // Verify markdown report was generated
            const markdownCall = mockWriteFileSync.mock.calls.find(call => call[0].includes('.md'));
            expect(markdownCall).toBeDefined();
            expect(markdownCall[1]).toContain('# ðŸŽ¯ Zero-Error Achievement Dashboard');
            expect(markdownCall[1]).toContain('Quality Score: 85/100');
            expect(markdownCall[1]).toContain('Total Issues: 1500');
        });
        test('should generate JSON report with structured data', async () => {
            const mockData = {
                validationResult: {
                    passed: true,
                    metrics: mockMetrics,
                    alerts: [],
                    recommendations: [],
                    regressionAnalysis: {
                        detected: false,
                        affectedMetrics: [],
                        severity: 'minor',
                        recommendations: [],
                        historicalComparison: {
                            current: 1500,
                            previous: 1600,
                            change: -100,
                            changePercentage: -6.25,
                        },
                    },
                },
                trendAnalysis: [],
                targets: [],
                qualityGates: [],
                maintenanceResults: new Map(),
                generationTime: 1500,
            };
            dashboard['generateComprehensiveReport'](mockData);
            // Verify JSON report was generated
            const jsonCall = mockWriteFileSync.mock.calls.find(call => call[0].includes('.json'));
            expect(jsonCall).toBeDefined();
            const jsonData = JSON.parse(jsonCall[1]);
            expect(jsonData).toHaveProperty('timestamp');
            expect(jsonData).toHaveProperty('generationTime', 1500);
            expect(jsonData).toHaveProperty('summary');
            expect(jsonData).toHaveProperty('metrics');
            expect(jsonData.summary).toHaveProperty('qualityScore', 85);
        });
    });
    describe('Helper Methods', () => {
        test('should get metric values correctly from nested objects', () => {
            const value1 = dashboard['getMetricValue'](mockMetrics, 'totalIssues');
            expect(value1).toBe(1500);
            const value2 = dashboard['getMetricValue'](mockMetrics, 'performanceMetrics.lintingDuration');
            expect(value2).toBe(25000);
            const value3 = dashboard['getMetricValue'](mockMetrics, 'domainSpecificIssues.astrologicalCalculations');
            expect(value3).toBe(25);
            const value4 = dashboard['getMetricValue'](mockMetrics, 'nonexistent.path');
            expect(value4).toBe(0);
        });
        test('should calculate overall progress correctly', () => {
            const targets = [
                { progress: 100, metric: 'parserErrors' },
                { progress: 75, metric: 'explicitAnyErrors' },
                { progress: 50, metric: 'totalIssues' },
                { progress: 85, metric: 'qualityScore' },
            ];
            const overallProgress = dashboard['calculateOverallProgress'](targets);
            expect(overallProgress).toBe(78); // (100 + 75 + 50 + 85) / 4 = 77.5, rounded to 78
        });
        test('should get overall status correctly', () => {
            const mockValidationResult = {
                passed: true,
                metrics: mockMetrics,
                alerts: [],
                recommendations: [],
                regressionAnalysis: {
                    detected: false,
                    affectedMetrics: [],
                    severity: 'minor',
                    recommendations: [],
                    historicalComparison: {
                        current: 1500,
                        previous: 1600,
                        change: -100,
                        changePercentage: -6.25,
                    },
                },
            };
            const passingGates = [
                { status: 'passing', blocksDeployment: true },
                { status: 'passing', blocksDeployment: false },
            ];
            const status1 = dashboard['getOverallStatus'](mockValidationResult, passingGates);
            expect(status1).toBe('ðŸ‘ GOOD'); // Quality score 85 = good
            const failingGates = [{ status: 'failing', blocksDeployment: true }];
            const status2 = dashboard['getOverallStatus'](mockValidationResult, failingGates);
            expect(status2).toBe('ðŸš¨ CRITICAL'); // Failing deployment-blocking gate = critical
        });
    });
    describe('Error Handling', () => {
        test('should handle file system errors gracefully', async () => {
            mockReadFileSync.mockImplementation(() => {
                throw new Error('File not found');
            });
            // Should not throw, should use defaults
            const trends = await dashboard['analyzeTrends'](mockMetrics);
            expect(trends).toEqual([]);
        });
        test('should handle command execution errors in maintenance', async () => {
            mockExecSync.mockImplementation(() => {
                throw new Error('Command failed');
            });
            const results = await dashboard['runScheduledMaintenance']();
            // Should handle errors and continue
            expect(results).toBeInstanceOf(Map);
            // Check if any failed results were recorded
            for (const [_id, result] of results) {
                if (!result.success) {
                    expect(result.issues.length).toBeGreaterThan(0);
                    expect(result.nextActions.length).toBeGreaterThan(0);
                }
            }
        });
    });
});
describe('ZeroErrorDashboardCLI', () => {
    // CLI tests would go here if needed
    // For now, focusing on the core dashboard functionality
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5jb25zb2xpZGF0aW9uLWJhY2t1cHMtMjAyNS0wOC0yM1QxNy01NC0xMC0wOTJaL3NyYy9fX3Rlc3RzX18vbGludGluZy9aZXJvRXJyb3JBY2hpZXZlbWVudERhc2hib2FyZC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7QUFFSCxpREFBeUM7QUFDekMsMkJBQXdFO0FBR3hFLHdHQUFxRztBQUVyRyw2QkFBNkI7QUFDN0IsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ2hDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUVyQixNQUFNLFlBQVksR0FBRyx3QkFBZ0QsQ0FBQztBQUN0RSxNQUFNLGlCQUFpQixHQUFHLGtCQUEwRCxDQUFDO0FBQ3JGLE1BQU0sZ0JBQWdCLEdBQUcsaUJBQXdELENBQUM7QUFDbEYsTUFBTSxjQUFjLEdBQUcsZUFBb0QsQ0FBQztBQUM1RSxNQUFNLGFBQWEsR0FBRyxjQUFrRCxDQUFDO0FBRXpFLFFBQVEsQ0FBQywrQkFBK0IsRUFBRSxHQUFHLEVBQUU7SUFDN0MsSUFBSSxTQUF3QyxDQUFDO0lBQzdDLElBQUksV0FBMkIsQ0FBQztJQUVoQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsS0FBSyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFMUIsOEJBQThCO1FBQzlCLEtBQUssY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxQyxLQUFLLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QyxLQUFLLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BELEtBQUssYUFBYSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWhELG9DQUFvQztRQUNwQyxLQUFLLFlB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O0FBQzFELENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC8uY29uc29saWRhdGlvbi1iYWNrdXBzLTIwMjUtMDgtMjNUMTctNTQtMTAtMDkyWi9zcmMvX190ZXN0c19fL2xpbnRpbmcvWmVyb0Vycm9yQWNoaWV2ZW1lbnREYXNoYm9hcmQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFplcm8tRXJyb3IgQWNoaWV2ZW1lbnQgRGFzaGJvYXJkIFRlc3RzXG4gKlxuICogQ29tcHJlaGVuc2l2ZSB0ZXN0IHN1aXRlIGZvciB0aGUgemVyby1lcnJvciBtb25pdG9yaW5nIGFuZFxuICogYWNoaWV2ZW1lbnQgdHJhY2tpbmcgc3lzdGVtLlxuICovXG5cbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJlYWRGaWxlU3luYywgd3JpdGVGaWxlU3luYyB9IGZyb20gJ2ZzJztcblxuaW1wb3J0IHsgTGludGluZ01ldHJpY3MgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9saW50aW5nL0xpbnRpbmdWYWxpZGF0aW9uRGFzaGJvYXJkJztcbmltcG9ydCB7IFplcm9FcnJvckFjaGlldmVtZW50RGFzaGJvYXJkIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbGludGluZy9aZXJvRXJyb3JBY2hpZXZlbWVudERhc2hib2FyZCc7XG5cbi8vIE1vY2sgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG52b2lkIGplc3QubW9jaygnY2hpbGRfcHJvY2VzcycpO1xudm9pZCBqZXN0Lm1vY2soJ2ZzJyk7XG5cbmNvbnN0IG1vY2tFeGVjU3luYyA9IGV4ZWNTeW5jIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGV4ZWNTeW5jPjtcbmNvbnN0IG1vY2tXcml0ZUZpbGVTeW5jID0gd3JpdGVGaWxlU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiB3cml0ZUZpbGVTeW5jPjtcbmNvbnN0IG1vY2tSZWFkRmlsZVN5bmMgPSByZWFkRmlsZVN5bmMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgcmVhZEZpbGVTeW5jPjtcbmNvbnN0IG1vY2tFeGlzdHNTeW5jID0gZXhpc3RzU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBleGlzdHNTeW5jPjtcbmNvbnN0IG1vY2tNa2RpclN5bmMgPSBta2RpclN5bmMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgbWtkaXJTeW5jPjtcblxuZGVzY3JpYmUoJ1plcm9FcnJvckFjaGlldmVtZW50RGFzaGJvYXJkJywgKCkgPT4ge1xuICBsZXQgZGFzaGJvYXJkOiBaZXJvRXJyb3JBY2hpZXZlbWVudERhc2hib2FyZDtcbiAgbGV0IG1vY2tNZXRyaWNzOiBMaW50aW5nTWV0cmljcztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICB2b2lkIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgLy8gTW9jayBmaWxlIHN5c3RlbSBvcGVyYXRpb25zXG4gICAgdm9pZCBtb2NrRXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgdm9pZCBtb2NrUmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnW10nKTtcbiAgICB2b2lkIG1vY2tXcml0ZUZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XG4gICAgdm9pZCBtb2NrTWtkaXJTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAnJyk7XG5cbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgY29tbWFuZCBleGVjdXRpb25cbiAgICB2b2lkIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgLy8gQ3JlYXRlIG1vY2sgbWV0cmljc1xuICAgIG1vY2tNZXRyaWNzID0ge1xuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgdG90YWxJc3N1ZXM6IDE1MDAsXG4gICAgICBlcnJvcnM6IDUwLFxuICAgICAgd2FybmluZ3M6IDE0NTAsXG4gICAgICBwYXJzZXJFcnJvcnM6IDAsXG4gICAgICBleHBsaWNpdEFueUVycm9yczogMTUwLFxuICAgICAgaW1wb3J0T3JkZXJJc3N1ZXM6IDIwMCxcbiAgICAgIHVudXNlZFZhcmlhYmxlczogMzAwLFxuICAgICAgcmVhY3RIb29rc0lzc3VlczogMTAwLFxuICAgICAgY29uc29sZVN0YXRlbWVudHM6IDUwLFxuICAgICAgZG9tYWluU3BlY2lmaWNJc3N1ZXM6IHtcbiAgICAgICAgYXN0cm9sb2dpY2FsQ2FsY3VsYXRpb25zOiAyNSxcbiAgICAgICAgY2FtcGFpZ25TeXN0ZW06IDE1LFxuICAgICAgICB0ZXN0RmlsZXM6IDEwLFxuICAgICAgfSxcbiAgICAgIHBlcmZvcm1hbmNlTWV0cmljczoge1xuICAgICAgICBsaW50aW5nRHVyYXRpb246IDI1MDAwLFxuICAgICAgICBjYWNoZUhpdFJhdGU6IDAuNzUsXG4gICAgICAgIG1lbW9yeVVzYWdlOiAyNTYsXG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiA1MDAsXG4gICAgICB9LFxuICAgICAgcXVhbGl0eVNjb3JlOiA4NSxcbiAgICAgIHJlZ3Jlc3Npb25EZXRlY3RlZDogZmFsc2UsXG4gICAgfTtcblxuICAgIGRhc2hib2FyZCA9IG5ldyBaZXJvRXJyb3JBY2hpZXZlbWVudERhc2hib2FyZCgpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIHZvaWQgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Rhc2hib2FyZCBHZW5lcmF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBjb21wcmVoZW5zaXZlIGRhc2hib2FyZCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRpb24gZGFzaGJvYXJkIHJlc3VsdFxuICAgICAgY29uc3QgbW9ja1ZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgIHBhc3NlZDogdHJ1ZSxcbiAgICAgICAgbWV0cmljczogbW9ja01ldHJpY3MsXG4gICAgICAgIGFsZXJ0czogW10sXG4gICAgICAgIHJlY29tbWVuZGF0aW9uczogWydDb250aW51ZSBzeXN0ZW1hdGljIGltcHJvdmVtZW50J10sXG4gICAgICAgIHJlZ3Jlc3Npb25BbmFseXNpczoge1xuICAgICAgICAgIGRldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBhZmZlY3RlZE1ldHJpY3M6IFtdLFxuICAgICAgICAgIHNldmVyaXR5OiAnbWlub3InIGFzIGNvbnN0LFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogW10sXG4gICAgICAgICAgaGlzdG9yaWNhbENvbXBhcmlzb246IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IDE1MDAsXG4gICAgICAgICAgICBwcmV2aW91czogMTYwMCxcbiAgICAgICAgICAgIGNoYW5nZTogLTEwMCxcbiAgICAgICAgICAgIGNoYW5nZVBlcmNlbnRhZ2U6IC02LjI1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHRoZSB2YWxpZGF0aW9uIGRhc2hib2FyZFxuICAgICAgdm9pZCBqZXN0XG4gICAgICAgIC5zcHlPbihkYXNoYm9hcmRbJ3ZhbGlkYXRpb25EYXNoYm9hcmQnXSwgJ3J1bkNvbXByZWhlbnNpdmVWYWxpZGF0aW9uJylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tWYWxpZGF0aW9uUmVzdWx0KTtcblxuICAgICAgYXdhaXQgZGFzaGJvYXJkLmdlbmVyYXRlRGFzaGJvYXJkKCk7XG5cbiAgICAgIC8vIFZlcmlmeSBkYXNoYm9hcmQgcmVwb3J0IHdhcyBnZW5lcmF0ZWRcbiAgICAgIGV4cGVjdChtb2NrV3JpdGVGaWxlU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCd6ZXJvLWVycm9yLWFjaGlldmVtZW50LWRhc2hib2FyZC5tZCcpLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnIyDwn46vIFplcm8tRXJyb3IgQWNoaWV2ZW1lbnQgRGFzaGJvYXJkJyksXG4gICAgICAgICd1dGY4JyxcbiAgICAgICk7XG5cbiAgICAgIC8vIFZlcmlmeSBKU09OIGRhdGEgd2FzIGdlbmVyYXRlZFxuICAgICAgZXhwZWN0KG1vY2tXcml0ZUZpbGVTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3plcm8tZXJyb3ItYWNoaWV2ZW1lbnQtZGFzaGJvYXJkLmpzb24nKSxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1widGltZXN0YW1wXCInKSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZGFzaGJvYXJkIGdlbmVyYXRpb24gZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRpb24gZGFzaGJvYXJkIGZhaWx1cmVcbiAgICAgIHZvaWQgamVzdFxuICAgICAgICAuc3B5T24oZGFzaGJvYXJkWyd2YWxpZGF0aW9uRGFzaGJvYXJkJ10sICdydW5Db21wcmVoZW5zaXZlVmFsaWRhdGlvbicpXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gZmFpbGVkJykpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoZGFzaGJvYXJkLmdlbmVyYXRlRGFzaGJvYXJkKCkpLnJlamVjdHMudG9UaHJvdygnVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSB0YXJnZXRzIHdpdGggY29ycmVjdCBwcm9ncmVzcyBjYWxjdWxhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgcGFzc2VkOiB0cnVlLFxuICAgICAgICBtZXRyaWNzOiBtb2NrTWV0cmljcyxcbiAgICAgICAgYWxlcnRzOiBbXSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXSxcbiAgICAgICAgcmVncmVzc2lvbkFuYWx5c2lzOiB7XG4gICAgICAgICAgZGV0ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGFmZmVjdGVkTWV0cmljczogW10sXG4gICAgICAgICAgc2V2ZXJpdHk6ICdtaW5vcicgYXMgY29uc3QsXG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXSxcbiAgICAgICAgICBoaXN0b3JpY2FsQ29tcGFyaXNvbjoge1xuICAgICAgICAgICAgY3VycmVudDogMTUwMCxcbiAgICAgICAgICAgIHByZXZpb3VzOiAxNjAwLFxuICAgICAgICAgICAgY2hhbmdlOiAtMTAwLFxuICAgICAgICAgICAgY2hhbmdlUGVyY2VudGFnZTogLTYuMjUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHZvaWQgamVzdFxuICAgICAgICAuc3B5T24oZGFzaGJvYXJkWyd2YWxpZGF0aW9uRGFzaGJvYXJkJ10sICdydW5Db21wcmVoZW5zaXZlVmFsaWRhdGlvbicpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVmFsaWRhdGlvblJlc3VsdCk7XG5cbiAgICAgIGF3YWl0IGRhc2hib2FyZC5nZW5lcmF0ZURhc2hib2FyZCgpO1xuXG4gICAgICAvLyBWZXJpZnkgdGFyZ2V0cyBmaWxlIHdhcyB3cml0dGVuXG4gICAgICBjb25zdCB0YXJnZXRzQ2FsbCA9IChtb2NrV3JpdGVGaWxlU3luYyBhcyBqZXN0Lk1vY2spLm1vY2suY2FsbHMuZmluZChjYWxsID0+XG4gICAgICAgIGNhbGxbMF0uaW5jbHVkZXMoJ3plcm8tZXJyb3ItdGFyZ2V0cy5qc29uJyksXG4gICAgICApO1xuXG4gICAgICBleHBlY3QodGFyZ2V0c0NhbGwpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIGNvbnN0IHRhcmdldHNEYXRhID0gSlNPTi5wYXJzZSh0YXJnZXRzQ2FsbFsxXSk7XG4gICAgICBleHBlY3QodGFyZ2V0c0RhdGEpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgIGV4cGVjdCh0YXJnZXRzRGF0YS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgLy8gQ2hlY2sgcGFyc2VyIGVycm9ycyB0YXJnZXRcbiAgICAgIGNvbnN0IHBhcnNlckVycm9yc1RhcmdldCA9IHRhcmdldHNEYXRhLmZpbmQodCA9PiB0Lm1ldHJpYyA9PT0gJ3BhcnNlckVycm9ycycpO1xuICAgICAgZXhwZWN0KHBhcnNlckVycm9yc1RhcmdldCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChwYXJzZXJFcnJvcnNUYXJnZXQuY3VycmVudFZhbHVlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlckVycm9yc1RhcmdldC50YXJnZXRWYWx1ZSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZXJFcnJvcnNUYXJnZXQucHJvZ3Jlc3MpLnRvQmUoMTAwKTsgLy8gQWxyZWFkeSBhY2hpZXZlZFxuICAgICAgZXhwZWN0KHBhcnNlckVycm9yc1RhcmdldC5wcmlvcml0eSkudG9CZSgnY3JpdGljYWwnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlYWwtVGltZSBNb25pdG9yaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBkZXRlY3Qgc2lnbmlmaWNhbnQgY2hhbmdlcyBpbiBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNNZXRyaWNzID0geyAuLi5tb2NrTWV0cmljcywgdG90YWxJc3N1ZXM6IDEwMDAgfTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNZXRyaWNzID0geyAuLi5tb2NrTWV0cmljcywgdG90YWxJc3N1ZXM6IDE1MDAgfTtcblxuICAgICAgY29uc3QgY2hhbmdlcyA9IGRhc2hib2FyZFsnZGV0ZWN0U2lnbmlmaWNhbnRDaGFuZ2VzJ10ocHJldmlvdXNNZXRyaWNzLCBjdXJyZW50TWV0cmljcyk7XG5cbiAgICAgIGV4cGVjdChjaGFuZ2VzKS50b0NvbnRhaW4oZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1RvdGFsIElzc3VlcyBpbmNyZWFzZWQnKSk7XG4gICAgICBleHBlY3QoY2hhbmdlc1swXSkudG9NYXRjaCgvNTBcXC4wJS8pOyAvLyA1MCUgaW5jcmVhc2VcbiAgICB9LCA1MDAwKTsgLy8gNSBzZWNvbmQgdGltZW91dFxuXG4gICAgdGVzdCgnc2hvdWxkIGlkZW50aWZ5IGNyaXRpY2FsIGlzc3VlcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBjcml0aWNhbE1ldHJpY3MgPSB7XG4gICAgICAgIC4uLm1vY2tNZXRyaWNzLFxuICAgICAgICBwYXJzZXJFcnJvcnM6IDUsXG4gICAgICAgIGV4cGxpY2l0QW55RXJyb3JzOiAyNTAsXG4gICAgICAgIHF1YWxpdHlTY29yZTogNDUsXG4gICAgICAgIHBlcmZvcm1hbmNlTWV0cmljczoge1xuICAgICAgICAgIC4uLm1vY2tNZXRyaWNzLnBlcmZvcm1hbmNlTWV0cmljcyxcbiAgICAgICAgICBsaW50aW5nRHVyYXRpb246IDc1MDAwLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY3JpdGljYWxJc3N1ZXMgPSBkYXNoYm9hcmRbJ2lkZW50aWZ5Q3JpdGljYWxJc3N1ZXMnXShjcml0aWNhbE1ldHJpY3MpO1xuXG4gICAgICBleHBlY3QoY3JpdGljYWxJc3N1ZXMpLnRvQ29udGFpbihleHBlY3Quc3RyaW5nQ29udGFpbmluZygnNSBwYXJzZXIgZXJyb3JzJykpO1xuICAgICAgZXhwZWN0KGNyaXRpY2FsSXNzdWVzKS50b0NvbnRhaW4oZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJzI1MCBleHBsaWNpdCBhbnkgZXJyb3JzJykpO1xuICAgICAgZXhwZWN0KGNyaXRpY2FsSXNzdWVzKS50b0NvbnRhaW4oZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1F1YWxpdHkgc2NvcmUgNDUnKSk7XG4gICAgICBleHBlY3QoY3JpdGljYWxJc3N1ZXMpLnRvQ29udGFpbihleHBlY3Quc3RyaW5nQ29udGFpbmluZygnNzUwMDBtcycpKTtcbiAgICB9LCAzMDAwKTsgLy8gMyBzZWNvbmQgdGltZW91dFxuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByZWFsLXRpbWUgbW9uaXRvcmluZyB1cGRhdGVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcmFwaWQgbWV0cmljIHVwZGF0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCB1cGRhdGVkTWV0cmljcyA9IHsgLi4ubW9ja01ldHJpY3MsIHRvdGFsSXNzdWVzOiAxMDAwICsgaSAqIDEwIH07XG4gICAgICAgIGRhc2hib2FyZFsnZGV0ZWN0U2lnbmlmaWNhbnRDaGFuZ2VzJ10obW9ja01ldHJpY3MsIHVwZGF0ZWRNZXRyaWNzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIHVwZGF0ZXMgcXVpY2tseVxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIFVuZGVyIDEgc2Vjb25kXG4gICAgfSwgNTAwMCk7IC8vIDUgc2Vjb25kIHRpbWVvdXRcblxuICAgIHRlc3QoJ3Nob3VsZCB2YWxpZGF0ZSBtb25pdG9yaW5nIGNvbnNpc3RlbmN5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdE1ldHJpY3MgPSB7IC4uLm1vY2tNZXRyaWNzLCB0b3RhbElzc3VlczogNTAwIH07XG5cbiAgICAgIC8vIFJ1biB0aGUgc2FtZSBkZXRlY3Rpb24gbXVsdGlwbGUgdGltZXNcbiAgICAgIGNvbnN0IHJlc3VsdHM6IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gZGFzaGJvYXJkWydkZXRlY3RTaWduaWZpY2FudENoYW5nZXMnXShtb2NrTWV0cmljcywgdGVzdE1ldHJpY3MpO1xuICAgICAgICB2b2lkIHJlc3VsdHMucHVzaChjaGFuZ2VzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc3VsdHMgc2hvdWxkIGJlIGNvbnNpc3RlbnRcbiAgICAgIGNvbnN0IGFsbFNhbWUgPSByZXN1bHRzLmV2ZXJ5KGNvdW50ID0+IGNvdW50ID09PSByZXN1bHRzWzBdKTtcbiAgICAgIGV4cGVjdChhbGxTYW1lKS50b0JlKHRydWUpO1xuICAgIH0sIDMwMDApOyAvLyAzIHNlY29uZCB0aW1lb3V0XG5cbiAgICB0ZXN0KCdzaG91bGQgdXBkYXRlIHJlYWwtdGltZSBzdGF0dXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgZGFzaGJvYXJkWyd1cGRhdGVSZWFsVGltZVN0YXR1cyddKG1vY2tNZXRyaWNzKTtcblxuICAgICAgY29uc3Qgc3RhdHVzQ2FsbCA9IChtb2NrV3JpdGVGaWxlU3luYyBhcyBqZXN0Lk1vY2spLm1vY2suY2FsbHMuZmluZChjYWxsID0+XG4gICAgICAgIGNhbGxbMF0uaW5jbHVkZXMoJ3plcm8tZXJyb3ItYWNoaWV2ZW1lbnQtc3RhdHVzLmpzb24nKSxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzdGF0dXNDYWxsKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICBjb25zdCBzdGF0dXNEYXRhID0gSlNPTi5wYXJzZShzdGF0dXNDYWxsWzFdKTtcbiAgICAgIGV4cGVjdChzdGF0dXNEYXRhLnF1YWxpdHlTY29yZSkudG9CZSg4NSk7XG4gICAgICBleHBlY3Qoc3RhdHVzRGF0YS50b3RhbElzc3VlcykudG9CZSgxNTAwKTtcbiAgICAgIGV4cGVjdChzdGF0dXNEYXRhLnBhcnNlckVycm9ycykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0dXNEYXRhLnN0YXR1cykudG9CZSgnZ29vZCcpOyAvLyBRdWFsaXR5IHNjb3JlIDg1ID0gZ29vZFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVHJlbmQgQW5hbHlzaXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSB0cmVuZHMgY29ycmVjdGx5IHdpdGggc3VmZmljaWVudCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBtZXRyaWNzIGhpc3Rvcnkgd2l0aCB0cmVuZCBkYXRhXG4gICAgICBjb25zdCBoaXN0b3J5RGF0YSA9IFtcbiAgICAgICAgeyAuLi5tb2NrTWV0cmljcywgdG90YWxJc3N1ZXM6IDIwMDAsIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjUtMDEtMDEnKSB9LFxuICAgICAgICB7IC4uLm1vY2tNZXRyaWNzLCB0b3RhbElzc3VlczogMTgwMCwgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMicpIH0sXG4gICAgICAgIHsgLi4ubW9ja01ldHJpY3MsIHRvdGFsSXNzdWVzOiAxNjAwLCB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI1LTAxLTAzJykgfSxcbiAgICAgICAgeyAuLi5tb2NrTWV0cmljcywgdG90YWxJc3N1ZXM6IDE1MDAsIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjUtMDEtMDQnKSB9LFxuICAgICAgXTtcblxuICAgICAgdm9pZCBtb2NrUmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZU9uY2UoSlNPTi5zdHJpbmdpZnkoaGlzdG9yeURhdGEpKTtcblxuICAgICAgY29uc3QgdHJlbmRzID0gYXdhaXQgZGFzaGJvYXJkWydhbmFseXplVHJlbmRzJ10obW9ja01ldHJpY3MpO1xuXG4gICAgICBleHBlY3QodHJlbmRzKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgICBleHBlY3QodHJlbmRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICBjb25zdCB0b3RhbElzc3Vlc1RyZW5kID0gdHJlbmRzLmZpbmQodCA9PiB0Lm1ldHJpYyA9PT0gJ3RvdGFsSXNzdWVzJyk7XG4gICAgICBleHBlY3QodG90YWxJc3N1ZXNUcmVuZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGlmICh0b3RhbElzc3Vlc1RyZW5kKSB7XG4gICAgICAgIGV4cGVjdCh0b3RhbElzc3Vlc1RyZW5kLnRyZW5kKS50b0JlKCdpbXByb3ZpbmcnKTsgLy8gRGVjcmVhc2luZyBpc3N1ZXMgPSBpbXByb3ZpbmdcbiAgICAgICAgZXhwZWN0KHRvdGFsSXNzdWVzVHJlbmQudmVsb2NpdHkpLnRvQmVMZXNzVGhhbigwKTsgLy8gTmVnYXRpdmUgdmVsb2NpdHkgPSBkZWNyZWFzaW5nXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGluc3VmZmljaWVudCBkYXRhIGZvciB0cmVuZCBhbmFseXNpcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgaW5zdWZmaWNpZW50IGhpc3RvcnkgZGF0YVxuICAgICAgY29uc3QgaGlzdG9yeURhdGEgPSBbbW9ja01ldHJpY3NdO1xuICAgICAgdm9pZCBtb2NrUmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZU9uY2UoSlNPTi5zdHJpbmdpZnkoaGlzdG9yeURhdGEpKTtcblxuICAgICAgY29uc3QgdHJlbmRzID0gYXdhaXQgZGFzaGJvYXJkWydhbmFseXplVHJlbmRzJ10obW9ja01ldHJpY3MpO1xuXG4gICAgICBleHBlY3QodHJlbmRzKS50b0VxdWFsKFtdKTsgLy8gTm8gdHJlbmRzIHdpdGggaW5zdWZmaWNpZW50IGRhdGFcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwcm9qZWN0IGZ1dHVyZSB2YWx1ZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSAtMTA7IC8vIEltcHJvdmluZyBieSAxMCBpc3N1ZXMgcGVyIGRheVxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gMTUwMDtcblxuICAgICAgY29uc3QgcHJvamVjdGlvbiA9IGRhc2hib2FyZFsncHJvamVjdEZ1dHVyZSddKHZlbG9jaXR5LCBjdXJyZW50VmFsdWUpO1xuXG4gICAgICBleHBlY3QocHJvamVjdGlvbi5zZXZlbkRheXMpLnRvQmUoMTQzMCk7IC8vIDE1MDAgLSAoMTAgKiA3KTtcbiAgICAgIGV4cGVjdChwcm9qZWN0aW9uLnRoaXJ0eURheXMpLnRvQmUoMTIwMCk7IC8vIDE1MDAgLSAoMTAgKiAzMCk7XG4gICAgICBleHBlY3QocHJvamVjdGlvbi5uaW5ldHlEYXlzKS50b0JlKDYwMCk7IC8vIDE1MDAgLSAoMTAgKiA5MClcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1F1YWxpdHkgR2F0ZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGV2YWx1YXRlIHF1YWxpdHkgZ2F0ZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZ2F0ZXMgPSBhd2FpdCBkYXNoYm9hcmRbJ2NoZWNrUXVhbGl0eUdhdGVzJ10obW9ja01ldHJpY3MpO1xuXG4gICAgICBleHBlY3QoZ2F0ZXMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgIGV4cGVjdChnYXRlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgLy8gQ2hlY2sgcGFyc2VyIGVycm9ycyBnYXRlIChzaG91bGQgcGFzcyB3aXRoIDAgZXJyb3JzKVxuICAgICAgY29uc3QgcGFyc2VyR2F0ZSA9IGdhdGVzLmZpbmQoZyA9PiBnLm5hbWUgPT09ICdwYXJzZXItZXJyb3JzJyk7XG4gICAgICBleHBlY3QocGFyc2VyR2F0ZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGlmIChwYXJzZXJHYXRlKSB7XG4gICAgICAgIGV4cGVjdChwYXJzZXJHYXRlLnN0YXR1cykudG9CZSgncGFzc2luZycpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBleHBsaWNpdCBhbnkgZ2F0ZSAoc2hvdWxkIHdhcm4gd2l0aCAxNTAgZXJyb3JzKVxuICAgICAgY29uc3QgYW55R2F0ZSA9IChnYXRlcyBhcyBhbnlbXSkuZmluZChnID0+IGcubmFtZSA9PT0gJ2V4cGxpY2l0LWFueScpO1xuICAgICAgZXhwZWN0KGFueUdhdGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBpZiAoYW55R2F0ZSkge1xuICAgICAgICBleHBlY3QoYW55R2F0ZS5zdGF0dXMpLnRvQmUoJ3dhcm5pbmcnKTsgLy8gMTUwID4gMTAwIGJ1dCA8PSAxNTBcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgcXVhbGl0eSBzY29yZSBnYXRlIChzaG91bGQgcGFzcyB3aXRoIDg1KVxuICAgICAgY29uc3QgcXVhbGl0eUdhdGUgPSAoZ2F0ZXMgYXMgYW55W10pLmZpbmQoZyA9PiBnLmlkID09PSAncXVhbGl0eS1zY29yZS1taW5pbXVtJyk7XG4gICAgICBleHBlY3QocXVhbGl0eUdhdGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBpZiAocXVhbGl0eUdhdGUpIHtcbiAgICAgICAgZXhwZWN0KHF1YWxpdHlHYXRlLnN0YXR1cykudG9CZSgncGFzc2luZycpOyAvLyA4NSA+PSA4MFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGlkZW50aWZ5IGZhaWxpbmcgcXVhbGl0eSBnYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZhaWxpbmdNZXRyaWNzID0ge1xuICAgICAgICAuLi5tb2NrTWV0cmljcyxcbiAgICAgICAgcGFyc2VyRXJyb3JzOiAzLFxuICAgICAgICBleHBsaWNpdEFueUVycm9yczogMjAwLFxuICAgICAgICBxdWFsaXR5U2NvcmU6IDY1LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2F0ZXMgPSBhd2FpdCBkYXNoYm9hcmRbJ2NoZWNrUXVhbGl0eUdhdGVzJ10oZmFpbGluZ01ldHJpY3MpO1xuXG4gICAgICBjb25zdCBwYXJzZXJHYXRlID0gZ2F0ZXMuZmluZChnID0+IGcubmFtZSA9PT0gJ3BhcnNlci1lcnJvcnMnKTtcbiAgICAgIGlmIChwYXJzZXJHYXRlKSB7XG4gICAgICAgIGV4cGVjdChwYXJzZXJHYXRlLnN0YXR1cykudG9CZSgnZmFpbGluZycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbnlHYXRlID0gZ2F0ZXMuZmluZChnID0+IGcubmFtZSA9PT0gJ2V4cGxpY2l0LWFueScpO1xuICAgICAgaWYgKGFueUdhdGUpIHtcbiAgICAgICAgZXhwZWN0KGFueUdhdGUuc3RhdHVzKS50b0JlKCdmYWlsaW5nJyk7IC8vIDIwMCA+IDE1MFxuICAgICAgfVxuXG4gICAgICBjb25zdCBxdWFsaXR5R2F0ZSA9IGdhdGVzLmZpbmQoZyA9PiBnLmlkID09PSAncXVhbGl0eS1zY29yZS1taW5pbXVtJyk7XG4gICAgICBpZiAocXVhbGl0eUdhdGUpIHtcbiAgICAgICAgZXhwZWN0KHF1YWxpdHlHYXRlLnN0YXR1cykudG9CZSgnd2FybmluZycpOyAvLyA2NSA8IDgwIGJ1dCA+PSA3MFxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGFyZ2V0IE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBwcm9ncmVzcyBjb3JyZWN0bHkgZm9yIGRpZmZlcmVudCBtZXRyaWMgdHlwZXMnLCAoKSA9PiB7XG4gICAgICAvLyBRdWFsaXR5IHNjb3JlIHByb2dyZXNzIChoaWdoZXIgaXMgYmV0dGVyKVxuICAgICAgY29uc3QgcXVhbGl0eVByb2dyZXNzID0gZGFzaGJvYXJkWydjYWxjdWxhdGVQcm9ncmVzcyddKDg1LCA5NSwgJ3F1YWxpdHlTY29yZScpO1xuICAgICAgZXhwZWN0KHF1YWxpdHlQcm9ncmVzcykudG9CZUNsb3NlVG8oODkuNDcsIDEpOyAvLyAoODUvOTUpICogMTAwXG5cbiAgICAgIC8vIEVycm9yIGNvdW50IHByb2dyZXNzIChsb3dlciBpcyBiZXR0ZXIpXG4gICAgICBjb25zdCBlcnJvclByb2dyZXNzID0gZGFzaGJvYXJkWydjYWxjdWxhdGVQcm9ncmVzcyddKDE1MCwgMCwgJ2V4cGxpY2l0QW55RXJyb3JzJyk7XG4gICAgICBleHBlY3QoZXJyb3JQcm9ncmVzcykudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KGVycm9yUHJvZ3Jlc3MpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGVzdGltYXRlIGNvbXBsZXRpb24gZGF0ZXMgYmFzZWQgb24gcHJvZ3Jlc3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkZWFkbGluZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApOyAvLyAzMCBkYXlzXG4gICAgICBjb25zdCBjb21wbGV0aW9uID0gZGFzaGJvYXJkWydlc3RpbWF0ZUNvbXBsZXRpb24nXSgxNTAsIDAsIGRlYWRsaW5lKTtcblxuICAgICAgZXhwZWN0KGNvbXBsZXRpb24pLnRvQmVJbnN0YW5jZU9mKERhdGUpO1xuICAgICAgZXhwZWN0KGNvbXBsZXRpb24uZ2V0VGltZSgpKS50b0JlR3JlYXRlclRoYW4oRGF0ZS5ub3coKSk7XG4gICAgICBleHBlY3QoY29tcGxldGlvbi5nZXRUaW1lKCkpLnRvQmVMZXNzVGhhbk9yRXF1YWwoZGVhZGxpbmUuZ2V0VGltZSgpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB1cGRhdGUgdGFyZ2V0cyB3aXRoIGN1cnJlbnQgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tWYWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICBwYXNzZWQ6IHRydWUsXG4gICAgICAgIG1ldHJpY3M6IG1vY2tNZXRyaWNzLFxuICAgICAgICBhbGVydHM6IFtdLFxuICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdLFxuICAgICAgICByZWdyZXNzaW9uQW5hbHlzaXM6IHtcbiAgICAgICAgICBkZXRlY3RlZDogZmFsc2UsXG4gICAgICAgICAgYWZmZWN0ZWRNZXRyaWNzOiBbXSxcbiAgICAgICAgICBzZXZlcml0eTogJ21pbm9yJyBhcyBjb25zdCxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdLFxuICAgICAgICAgIGhpc3RvcmljYWxDb21wYXJpc29uOiB7XG4gICAgICAgICAgICBjdXJyZW50OiAxNTAwLFxuICAgICAgICAgICAgcHJldmlvdXM6IDE2MDAsXG4gICAgICAgICAgICBjaGFuZ2U6IC0xMDAsXG4gICAgICAgICAgICBjaGFuZ2VQZXJjZW50YWdlOiAtNi4yNSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgdm9pZCBqZXN0XG4gICAgICAgIC5zcHlPbihkYXNoYm9hcmRbJ3ZhbGlkYXRpb25EYXNoYm9hcmQnXSwgJ3J1bkNvbXByZWhlbnNpdmVWYWxpZGF0aW9uJylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tWYWxpZGF0aW9uUmVzdWx0KTtcblxuICAgICAgY29uc3QgdGFyZ2V0cyA9IGF3YWl0IGRhc2hib2FyZFsndXBkYXRlVGFyZ2V0cyddKG1vY2tNZXRyaWNzKTtcblxuICAgICAgZXhwZWN0KHRhcmdldHMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgIGV4cGVjdCh0YXJnZXRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICAvLyBWZXJpZnkgYWxsIHRhcmdldHMgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgIGV4cGVjdCh0YXJnZXQpLnRvSGF2ZVByb3BlcnR5KCdtZXRyaWMnKTtcbiAgICAgICAgZXhwZWN0KHRhcmdldCkudG9IYXZlUHJvcGVydHkoJ2N1cnJlbnRWYWx1ZScpO1xuICAgICAgICBleHBlY3QodGFyZ2V0KS50b0hhdmVQcm9wZXJ0eSgndGFyZ2V0VmFsdWUnKTtcbiAgICAgICAgZXhwZWN0KHRhcmdldCkudG9IYXZlUHJvcGVydHkoJ3Byb2dyZXNzJyk7XG4gICAgICAgIGV4cGVjdCh0YXJnZXQpLnRvSGF2ZVByb3BlcnR5KCdwcmlvcml0eScpO1xuICAgICAgICBleHBlY3QodGFyZ2V0KS50b0hhdmVQcm9wZXJ0eSgnc3RyYXRlZ3knKTtcbiAgICAgICAgZXhwZWN0KHRhcmdldC5wcm9ncmVzcykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgZXhwZWN0KHRhcmdldC5wcm9ncmVzcykudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWFpbnRlbmFuY2UgUHJvY2VkdXJlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaW5pdGlhbGl6ZSBtYWludGVuYW5jZSBwcm9jZWR1cmVzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHByb2NlZHVyZXMgPSBkYXNoYm9hcmRbJ21haW50ZW5hbmNlUHJvY2VkdXJlcyddO1xuXG4gICAgICBleHBlY3QocHJvY2VkdXJlcy5zaXplKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocHJvY2VkdXJlcy5oYXMoJ2RhaWx5LWhlYWx0aC1jaGVjaycpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHByb2NlZHVyZXMuaGFzKCd3ZWVrbHktY2FjaGUtb3B0aW1pemF0aW9uJykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocHJvY2VkdXJlcy5oYXMoJ21vbnRobHktbWV0cmljcy1jbGVhbnVwJykpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGRhaWx5Q2hlY2sgPSBwcm9jZWR1cmVzLmdldCgnZGFpbHktaGVhbHRoLWNoZWNrJyk7XG4gICAgICBleHBlY3QoZGFpbHlDaGVjaykudG9CZURlZmluZWQoKTtcbiAgICAgIGlmIChkYWlseUNoZWNrKSB7XG4gICAgICAgIGV4cGVjdChkYWlseUNoZWNrLmZyZXF1ZW5jeSkudG9CZSgnZGFpbHknKTtcbiAgICAgICAgZXhwZWN0KGRhaWx5Q2hlY2suYXV0b21hdGVkKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QodHlwZW9mIGRhaWx5Q2hlY2sucHJvY2VkdXJlKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBuZXh0IHJ1biB0aW1lcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBiYXNlRGF0ZSA9IG5ldyBEYXRlKCcyMDI1LTAxLTE1VDEwOjAwOjAwWicpO1xuXG4gICAgICBjb25zdCBuZXh0RGFpbHkgPSBkYXNoYm9hcmRbJ2NhbGN1bGF0ZU5leHRSdW4nXShiYXNlRGF0ZSwgJ2RhaWx5Jyk7XG4gICAgICBleHBlY3QobmV4dERhaWx5LmdldERhdGUoKSkudG9CZSgxNik7IC8vIE5leHQgZGF5XG5cbiAgICAgIGNvbnN0IG5leHRXZWVrbHkgPSBkYXNoYm9hcmRbJ2NhbGN1bGF0ZU5leHRSdW4nXShiYXNlRGF0ZSwgJ3dlZWtseScpO1xuICAgICAgZXhwZWN0KG5leHRXZWVrbHkuZ2V0RGF0ZSgpKS50b0JlKDIyKTsgLy8gNyBkYXlzIGxhdGVyXG5cbiAgICAgIGNvbnN0IG5leHRNb250aGx5ID0gZGFzaGJvYXJkWydjYWxjdWxhdGVOZXh0UnVuJ10oYmFzZURhdGUsICdtb250aGx5Jyk7XG4gICAgICBleHBlY3QobmV4dE1vbnRobHkuZ2V0TW9udGgoKSkudG9CZSgxKTsgLy8gRmVicnVhcnkgKDAtaW5kZXhlZClcblxuICAgICAgY29uc3QgbmV4dFF1YXJ0ZXJseSA9IGRhc2hib2FyZFsnY2FsY3VsYXRlTmV4dFJ1biddKGJhc2VEYXRlLCAncXVhcnRlcmx5Jyk7XG4gICAgICBleHBlY3QobmV4dFF1YXJ0ZXJseS5nZXRNb250aCgpKS50b0JlKDMpOyAvLyBBcHJpbCAoMC1pbmRleGVkKVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJ1biBzY2hlZHVsZWQgbWFpbnRlbmFuY2UgcHJvY2VkdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBjb21tYW5kIGV4ZWN1dGlvbiBmb3IgbWFpbnRlbmFuY2VcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJzAnKTsgLy8gU3VjY2VzcyBleGl0IGNvZGVcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRhc2hib2FyZFsncnVuU2NoZWR1bGVkTWFpbnRlbmFuY2UnXSgpO1xuXG4gICAgICAvLyBTaG91bGQgcnVuIHByb2NlZHVyZXMgdGhhdCBhcmUgZHVlXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZUluc3RhbmNlT2YoTWFwKTtcblxuICAgICAgLy8gVmVyaWZ5IG1haW50ZW5hbmNlIHByb2NlZHVyZXMgd2VyZSB1cGRhdGVkXG4gICAgICBjb25zdCBkYWlseUNoZWNrID0gZGFzaGJvYXJkWydtYWludGVuYW5jZVByb2NlZHVyZXMnXS5nZXQoJ2RhaWx5LWhlYWx0aC1jaGVjaycpO1xuICAgICAgaWYgKGRhaWx5Q2hlY2sgJiYgcmVzdWx0cy5oYXMoJ2RhaWx5LWhlYWx0aC1jaGVjaycpKSB7XG4gICAgICAgIGV4cGVjdChkYWlseUNoZWNrLmxhc3RSdW4pLnRvQmVJbnN0YW5jZU9mKERhdGUpO1xuICAgICAgICBleHBlY3QoZGFpbHlDaGVjay5uZXh0UnVuKS50b0JlSW5zdGFuY2VPZihEYXRlKTtcbiAgICAgICAgaWYgKGRhaWx5Q2hlY2submV4dFJ1biAmJiBkYWlseUNoZWNrLmxhc3RSdW4pIHtcbiAgICAgICAgICBleHBlY3QoZGFpbHlDaGVjay5uZXh0UnVuLmdldFRpbWUoKSkudG9CZUdyZWF0ZXJUaGFuKGRhaWx5Q2hlY2subGFzdFJ1bi5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXBvcnQgR2VuZXJhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgZ2VuZXJhdGUgY29tcHJlaGVuc2l2ZSBtYXJrZG93biByZXBvcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IHtcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdDoge1xuICAgICAgICAgIHBhc3NlZDogdHJ1ZSxcbiAgICAgICAgICBtZXRyaWNzOiBtb2NrTWV0cmljcyxcbiAgICAgICAgICBhbGVydHM6IFtdLFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogWydDb250aW51ZSBpbXByb3ZlbWVudCddLFxuICAgICAgICAgIHJlZ3Jlc3Npb25BbmFseXNpczoge1xuICAgICAgICAgICAgZGV0ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYWZmZWN0ZWRNZXRyaWNzOiBbXSxcbiAgICAgICAgICAgIHNldmVyaXR5OiAnbWlub3InIGFzIGNvbnN0LFxuICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXSxcbiAgICAgICAgICAgIGhpc3RvcmljYWxDb21wYXJpc29uOiB7XG4gICAgICAgICAgICAgIGN1cnJlbnQ6IDE1MDAsXG4gICAgICAgICAgICAgIHByZXZpb3VzOiAxNjAwLFxuICAgICAgICAgICAgICBjaGFuZ2U6IC0xMDAsXG4gICAgICAgICAgICAgIGNoYW5nZVBlcmNlbnRhZ2U6IC02LjI1LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0cmVuZEFuYWx5c2lzOiBbXSxcbiAgICAgICAgdGFyZ2V0czogW10sXG4gICAgICAgIHF1YWxpdHlHYXRlczogW10sXG4gICAgICAgIG1haW50ZW5hbmNlUmVzdWx0czogbmV3IE1hcCgpLFxuICAgICAgICBnZW5lcmF0aW9uVGltZTogMTUwMCxcbiAgICAgIH07XG5cbiAgICAgIGRhc2hib2FyZFsnZ2VuZXJhdGVDb21wcmVoZW5zaXZlUmVwb3J0J10obW9ja0RhdGEpO1xuXG4gICAgICAvLyBWZXJpZnkgbWFya2Rvd24gcmVwb3J0IHdhcyBnZW5lcmF0ZWRcbiAgICAgIGNvbnN0IG1hcmtkb3duQ2FsbCA9IChtb2NrV3JpdGVGaWxlU3luYyBhcyBqZXN0Lk1vY2spLm1vY2suY2FsbHMuZmluZChjYWxsID0+IGNhbGxbMF0uaW5jbHVkZXMoJy5tZCcpKTtcblxuICAgICAgZXhwZWN0KG1hcmtkb3duQ2FsbCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtYXJrZG93bkNhbGxbMV0pLnRvQ29udGFpbignIyDwn46vIFplcm8tRXJyb3IgQWNoaWV2ZW1lbnQgRGFzaGJvYXJkJyk7XG4gICAgICBleHBlY3QobWFya2Rvd25DYWxsWzFdKS50b0NvbnRhaW4oJ1F1YWxpdHkgU2NvcmU6IDg1LzEwMCcpO1xuICAgICAgZXhwZWN0KG1hcmtkb3duQ2FsbFsxXSkudG9Db250YWluKCdUb3RhbCBJc3N1ZXM6IDE1MDAnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBKU09OIHJlcG9ydCB3aXRoIHN0cnVjdHVyZWQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tEYXRhID0ge1xuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0OiB7XG4gICAgICAgICAgcGFzc2VkOiB0cnVlLFxuICAgICAgICAgIG1ldHJpY3M6IG1vY2tNZXRyaWNzLFxuICAgICAgICAgIGFsZXJ0czogW10sXG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXSxcbiAgICAgICAgICByZWdyZXNzaW9uQW5hbHlzaXM6IHtcbiAgICAgICAgICAgIGRldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGFmZmVjdGVkTWV0cmljczogW10sXG4gICAgICAgICAgICBzZXZlcml0eTogJ21pbm9yJyBhcyBjb25zdCxcbiAgICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogW10sXG4gICAgICAgICAgICBoaXN0b3JpY2FsQ29tcGFyaXNvbjoge1xuICAgICAgICAgICAgICBjdXJyZW50OiAxNTAwLFxuICAgICAgICAgICAgICBwcmV2aW91czogMTYwMCxcbiAgICAgICAgICAgICAgY2hhbmdlOiAtMTAwLFxuICAgICAgICAgICAgICBjaGFuZ2VQZXJjZW50YWdlOiAtNi4yNSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJlbmRBbmFseXNpczogW10sXG4gICAgICAgIHRhcmdldHM6IFtdLFxuICAgICAgICBxdWFsaXR5R2F0ZXM6IFtdLFxuICAgICAgICBtYWludGVuYW5jZVJlc3VsdHM6IG5ldyBNYXAoKSxcbiAgICAgICAgZ2VuZXJhdGlvblRpbWU6IDE1MDAsXG4gICAgICB9O1xuXG4gICAgICBkYXNoYm9hcmRbJ2dlbmVyYXRlQ29tcHJlaGVuc2l2ZVJlcG9ydCddKG1vY2tEYXRhKTtcblxuICAgICAgLy8gVmVyaWZ5IEpTT04gcmVwb3J0IHdhcyBnZW5lcmF0ZWRcbiAgICAgIGNvbnN0IGpzb25DYWxsID0gKG1vY2tXcml0ZUZpbGVTeW5jIGFzIGplc3QuTW9jaykubW9jay5jYWxscy5maW5kKGNhbGwgPT4gY2FsbFswXS5pbmNsdWRlcygnLmpzb24nKSk7XG5cbiAgICAgIGV4cGVjdChqc29uQ2FsbCkudG9CZURlZmluZWQoKTtcblxuICAgICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGpzb25DYWxsWzFdKTtcbiAgICAgIGV4cGVjdChqc29uRGF0YSkudG9IYXZlUHJvcGVydHkoJ3RpbWVzdGFtcCcpO1xuICAgICAgZXhwZWN0KGpzb25EYXRhKS50b0hhdmVQcm9wZXJ0eSgnZ2VuZXJhdGlvblRpbWUnLCAxNTAwKTtcbiAgICAgIGV4cGVjdChqc29uRGF0YSkudG9IYXZlUHJvcGVydHkoJ3N1bW1hcnknKTtcbiAgICAgIGV4cGVjdChqc29uRGF0YSkudG9IYXZlUHJvcGVydHkoJ21ldHJpY3MnKTtcbiAgICAgIGV4cGVjdChqc29uRGF0YS5zdW1tYXJ5KS50b0hhdmVQcm9wZXJ0eSgncXVhbGl0eVNjb3JlJywgODUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSGVscGVyIE1ldGhvZHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGdldCBtZXRyaWMgdmFsdWVzIGNvcnJlY3RseSBmcm9tIG5lc3RlZCBvYmplY3RzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUxID0gZGFzaGJvYXJkWydnZXRNZXRyaWNWYWx1ZSddKG1vY2tNZXRyaWNzLCAndG90YWxJc3N1ZXMnKTtcbiAgICAgIGV4cGVjdCh2YWx1ZTEpLnRvQmUoMTUwMCk7XG5cbiAgICAgIGNvbnN0IHZhbHVlMiA9IGRhc2hib2FyZFsnZ2V0TWV0cmljVmFsdWUnXShtb2NrTWV0cmljcywgJ3BlcmZvcm1hbmNlTWV0cmljcy5saW50aW5nRHVyYXRpb24nKTtcbiAgICAgIGV4cGVjdCh2YWx1ZTIpLnRvQmUoMjUwMDApO1xuXG4gICAgICBjb25zdCB2YWx1ZTMgPSBkYXNoYm9hcmRbJ2dldE1ldHJpY1ZhbHVlJ10obW9ja01ldHJpY3MsICdkb21haW5TcGVjaWZpY0lzc3Vlcy5hc3Ryb2xvZ2ljYWxDYWxjdWxhdGlvbnMnKTtcbiAgICAgIGV4cGVjdCh2YWx1ZTMpLnRvQmUoMjUpO1xuXG4gICAgICBjb25zdCB2YWx1ZTQgPSBkYXNoYm9hcmRbJ2dldE1ldHJpY1ZhbHVlJ10obW9ja01ldHJpY3MsICdub25leGlzdGVudC5wYXRoJyk7XG4gICAgICBleHBlY3QodmFsdWU0KS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBvdmVyYWxsIHByb2dyZXNzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSBbXG4gICAgICAgIHsgcHJvZ3Jlc3M6IDEwMCwgbWV0cmljOiAncGFyc2VyRXJyb3JzJyB9LFxuICAgICAgICB7IHByb2dyZXNzOiA3NSwgbWV0cmljOiAnZXhwbGljaXRBbnlFcnJvcnMnIH0sXG4gICAgICAgIHsgcHJvZ3Jlc3M6IDUwLCBtZXRyaWM6ICd0b3RhbElzc3VlcycgfSxcbiAgICAgICAgeyBwcm9ncmVzczogODUsIG1ldHJpYzogJ3F1YWxpdHlTY29yZScgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG92ZXJhbGxQcm9ncmVzcyA9IGRhc2hib2FyZFsnY2FsY3VsYXRlT3ZlcmFsbFByb2dyZXNzJ10odGFyZ2V0cyBhcyBhbnkpO1xuICAgICAgZXhwZWN0KG92ZXJhbGxQcm9ncmVzcykudG9CZSg3OCk7IC8vICgxMDAgKyA3NSArIDUwICsgODUpIC8gNCA9IDc3LjUsIHJvdW5kZWQgdG8gNzhcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZXQgb3ZlcmFsbCBzdGF0dXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1ZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgIHBhc3NlZDogdHJ1ZSxcbiAgICAgICAgbWV0cmljczogbW9ja01ldHJpY3MsXG4gICAgICAgIGFsZXJ0czogW10sXG4gICAgICAgIHJlY29tbWVuZGF0aW9uczogW10sXG4gICAgICAgIHJlZ3Jlc3Npb25BbmFseXNpczoge1xuICAgICAgICAgIGRldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBhZmZlY3RlZE1ldHJpY3M6IFtdLFxuICAgICAgICAgIHNldmVyaXR5OiAnbWlub3InIGFzIGNvbnN0LFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogW10sXG4gICAgICAgICAgaGlzdG9yaWNhbENvbXBhcmlzb246IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IDE1MDAsXG4gICAgICAgICAgICBwcmV2aW91czogMTYwMCxcbiAgICAgICAgICAgIGNoYW5nZTogLTEwMCxcbiAgICAgICAgICAgIGNoYW5nZVBlcmNlbnRhZ2U6IC02LjI1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwYXNzaW5nR2F0ZXMgPSBbXG4gICAgICAgIHsgc3RhdHVzOiAncGFzc2luZycsIGJsb2Nrc0RlcGxveW1lbnQ6IHRydWUgfSxcbiAgICAgICAgeyBzdGF0dXM6ICdwYXNzaW5nJywgYmxvY2tzRGVwbG95bWVudDogZmFsc2UgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHN0YXR1czEgPSBkYXNoYm9hcmRbJ2dldE92ZXJhbGxTdGF0dXMnXShtb2NrVmFsaWRhdGlvblJlc3VsdCwgcGFzc2luZ0dhdGVzIGFzIGFueSk7XG4gICAgICBleHBlY3Qoc3RhdHVzMSkudG9CZSgn8J+RjSBHT09EJyk7IC8vIFF1YWxpdHkgc2NvcmUgODUgPSBnb29kXG5cbiAgICAgIGNvbnN0IGZhaWxpbmdHYXRlcyA9IFt7IHN0YXR1czogJ2ZhaWxpbmcnLCBibG9ja3NEZXBsb3ltZW50OiB0cnVlIH1dO1xuXG4gICAgICBjb25zdCBzdGF0dXMyID0gZGFzaGJvYXJkWydnZXRPdmVyYWxsU3RhdHVzJ10obW9ja1ZhbGlkYXRpb25SZXN1bHQsIGZhaWxpbmdHYXRlcyBhcyBhbnkpO1xuICAgICAgZXhwZWN0KHN0YXR1czIpLnRvQmUoJ/CfmqggQ1JJVElDQUwnKTsgLy8gRmFpbGluZyBkZXBsb3ltZW50LWJsb2NraW5nIGdhdGUgPSBjcml0aWNhbFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBmaWxlIHN5c3RlbSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tSZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIG5vdCBmb3VuZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3csIHNob3VsZCB1c2UgZGVmYXVsdHNcbiAgICAgIGNvbnN0IHRyZW5kcyA9IGF3YWl0IGRhc2hib2FyZFsnYW5hbHl6ZVRyZW5kcyddKG1vY2tNZXRyaWNzKTtcbiAgICAgIGV4cGVjdCh0cmVuZHMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBjb21tYW5kIGV4ZWN1dGlvbiBlcnJvcnMgaW4gbWFpbnRlbmFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21tYW5kIGZhaWxlZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBkYXNoYm9hcmRbJ3J1blNjaGVkdWxlZE1haW50ZW5hbmNlJ10oKTtcblxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBlcnJvcnMgYW5kIGNvbnRpbnVlXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZUluc3RhbmNlT2YoTWFwKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYW55IGZhaWxlZCByZXN1bHRzIHdlcmUgcmVjb3JkZWRcbiAgICAgIGZvciAoY29uc3QgW19pZCwgcmVzdWx0XSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm5leHRBY3Rpb25zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdaZXJvRXJyb3JEYXNoYm9hcmRDTEknLCAoKSA9PiB7XG4gIC8vIENMSSB0ZXN0cyB3b3VsZCBnbyBoZXJlIGlmIG5lZWRlZFxuICAvLyBGb3Igbm93LCBmb2N1c2luZyBvbiB0aGUgY29yZSBkYXNoYm9hcmQgZnVuY3Rpb25hbGl0eVxufSk7XG4iXSwidmVyc2lvbiI6M30=