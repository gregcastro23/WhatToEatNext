166e160beec0ec3ece98d021b45cfcdd
"use strict";
/**
 * Progressive Improvement Engine
 * Orchestrates batch processing with adaptive strategies and progress tracking
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressiveImprovementEngine = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const AnyTypeClassifier_1 = require("./AnyTypeClassifier");
const DomainContextAnalyzer_1 = require("./DomainContextAnalyzer");
const SafeTypeReplacer_1 = require("./SafeTypeReplacer");
class ProgressiveImprovementEngine {
    classifier;
    replacer;
    analyzer;
    processedFiles = new Set();
    batchCounter = 0;
    batchHistory = [];
    adaptiveConfig;
    safetyCheckpoints = new Map();
    constructor(initialConfig) {
        this.classifier = new AnyTypeClassifier_1.AnyTypeClassifier();
        this.replacer = new SafeTypeReplacer_1.SafeTypeReplacer();
        this.analyzer = new DomainContextAnalyzer_1.DomainContextAnalyzer();
        // Initialize adaptive configuration with defaults
        this.adaptiveConfig = {
            maxFilesPerBatch: initialConfig?.maxFilesPerBatch || 15,
            targetReductionPercentage: initialConfig?.targetReductionPercentage || 15,
            confidenceThreshold: initialConfig?.confidenceThreshold || 0.8,
            enableDomainAnalysis: initialConfig?.enableDomainAnalysis ?? true,
            enableDocumentation: initialConfig?.enableDocumentation ?? true,
            safetyLevel: initialConfig?.safetyLevel || 'MODERATE',
            validationFrequency: initialConfig?.validationFrequency || 5
        };
    }
    /**
     * Adapt strategy based on recent batch performance
     */
    adaptStrategy() {
        if (this.batchHistory.length < 2)
            return;
        const recentBatches = this.batchHistory.slice(-3);
        const averageSuccessRate = recentBatches.reduce((sum, batch) => sum + (batch.replacementsSuccessful / Math.max(1, batch.replacementsAttempted)), 0) / recentBatches.length;
        const averageSafetyScore = recentBatches.reduce((sum, batch) => sum + batch.safetyScore, 0) / recentBatches.length;
        console.log(`Adapting strategy - Success rate: ${(averageSuccessRate * 100).toFixed(1)}%, Safety score: ${averageSafetyScore.toFixed(2)}`);
        // Adapt batch size based on safety score
        if (averageSafetyScore < 0.7) {
            // Reduce batch size for safety
            this.adaptiveConfig.maxFilesPerBatch = Math.max(5, Math.floor(this.adaptiveConfig.maxFilesPerBatch * 0.7));
            this.adaptiveConfig.confidenceThreshold = Math.min(0.95, this.adaptiveConfig.confidenceThreshold + 0.1);
            console.log(`Reduced batch size to ${this.adaptiveConfig.maxFilesPerBatch} and increased confidence threshold to ${this.adaptiveConfig.confidenceThreshold}`);
        }
        else if (averageSafetyScore > 0.9 && averageSuccessRate > 0.8) {
            // Increase batch size for efficiency
            this.adaptiveConfig.maxFilesPerBatch = Math.min(25, Math.floor(this.adaptiveConfig.maxFilesPerBatch * 1.2));
            this.adaptiveConfig.confidenceThreshold = Math.max(0.7, this.adaptiveConfig.confidenceThreshold - 0.05);
            console.log(`Increased batch size to ${this.adaptiveConfig.maxFilesPerBatch} and decreased confidence threshold to ${this.adaptiveConfig.confidenceThreshold}`);
        }
        // Adapt confidence threshold based on success rate
        if (averageSuccessRate < 0.5) {
            this.adaptiveConfig.confidenceThreshold = Math.min(0.95, this.adaptiveConfig.confidenceThreshold + 0.1);
            console.log(`Low success rate, increased confidence threshold to ${this.adaptiveConfig.confidenceThreshold}`);
        }
        // Adapt validation frequency based on safety
        if (averageSafetyScore < 0.8) {
            this.adaptiveConfig.validationFrequency = Math.max(3, this.adaptiveConfig.validationFrequency - 1);
            console.log(`Increased validation frequency to every ${this.adaptiveConfig.validationFrequency} files`);
        }
    }
    /**
     * Create a safety checkpoint
     */
    async createSafetyCheckpoint() {
        const progress = await this.getCurrentProgress();
        this.safetyCheckpoints.set(this.batchCounter, progress);
        console.log(`Safety checkpoint created at batch ${this.batchCounter}`);
    }
    /**
     * Get comprehensive progress metrics
     */
    async getProgressMetrics() {
        return await this.getCurrentProgress();
    }
    /**
     * Get batch execution history
     */
    getBatchHistory() {
        return [...this.batchHistory];
    }
    /**
     * Get current adaptive configuration
     */
    getAdaptiveConfig() {
        return { ...this.adaptiveConfig };
    }
    /**
     * Set realistic targets based on historical success rates and codebase analysis
     */
    async setRealisticTargets() {
        const currentProgress = await this.getCurrentProgress();
        const candidateFiles = await this.findFilesWithAnyTypes();
        // Analyze file types and complexity
        const fileAnalysis = await this.analyzeFileComplexity(candidateFiles.slice(0, 20));
        // Calculate base success rate expectations
        const baseSuccessRate = this.calculateExpectedSuccessRate(fileAnalysis);
        // Historical data shows previous attempts achieved 1.7% reduction (30 fixes)
        // Target 10x improvement = 17% reduction (300 fixes)
        // But be realistic based on file analysis
        let recommendedTarget = 15; // Default 15% as per requirements
        const reasoning = [];
        // Adjust based on file complexity
        if (fileAnalysis.testFilePercentage > 30) {
            reasoning.push(`${fileAnalysis.testFilePercentage.toFixed(1)}% of files are test files - focusing on non-test files first`);
            recommendedTarget = Math.max(12, recommendedTarget - 3);
        }
        if (fileAnalysis.arrayTypePercentage > 20) {
            reasoning.push(`${fileAnalysis.arrayTypePercentage.toFixed(1)}% are array types with historically 100% success rate`);
            recommendedTarget = Math.min(20, recommendedTarget + 2);
        }
        if (fileAnalysis.recordTypePercentage > 15) {
            reasoning.push(`${fileAnalysis.recordTypePercentage.toFixed(1)}% are Record types with mixed success - being selective`);
            recommendedTarget = Math.max(10, recommendedTarget - 2);
        }
        if (fileAnalysis.functionParamPercentage > 25) {
            reasoning.push(`${fileAnalysis.functionParamPercentage.toFixed(1)}% are function parameters with high failure rate - being conservative`);
            recommendedTarget = Math.max(8, recommendedTarget - 5);
        }
        // Adjust based on historical batch performance if available
        if (this.batchHistory.length > 0) {
            const avgSuccessRate = this.batchHistory.reduce((sum, batch) => sum + (batch.replacementsSuccessful / Math.max(1, batch.replacementsAttempted)), 0) / this.batchHistory.length;
            if (avgSuccessRate > 0.8) {
                reasoning.push(`High historical success rate (${(avgSuccessRate * 100).toFixed(1)}%) - increasing target`);
                recommendedTarget = Math.min(25, recommendedTarget + 3);
            }
            else if (avgSuccessRate < 0.5) {
                reasoning.push(`Low historical success rate (${(avgSuccessRate * 100).toFixed(1)}%) - reducing target`);
                recommendedTarget = Math.max(5, recommendedTarget - 5);
            }
        }
        // Create realistic milestones
        const milestones = [
            {
                percentage: Math.floor(recommendedTarget * 0.25),
                description: 'Initial progress - focus on high-confidence array types',
                estimatedBatches: Math.ceil(candidateFiles.length * 0.1 / this.adaptiveConfig.maxFilesPerBatch)
            },
            {
                percentage: Math.floor(recommendedTarget * 0.5),
                description: 'Mid-point - expand to Record types and simple patterns',
                estimatedBatches: Math.ceil(candidateFiles.length * 0.3 / this.adaptiveConfig.maxFilesPerBatch)
            },
            {
                percentage: Math.floor(recommendedTarget * 0.75),
                description: 'Advanced progress - tackle more complex patterns',
                estimatedBatches: Math.ceil(candidateFiles.length * 0.6 / this.adaptiveConfig.maxFilesPerBatch)
            },
            {
                percentage: recommendedTarget,
                description: 'Target achievement - complete remaining high-confidence cases',
                estimatedBatches: Math.ceil(candidateFiles.length * 0.8 / this.adaptiveConfig.maxFilesPerBatch)
            }
        ];
        reasoning.push(`Recommended target: ${recommendedTarget}% reduction (${Math.floor(currentProgress.totalAnyTypes * recommendedTarget / 100)} fixes)`);
        reasoning.push(`Based on analysis of ${candidateFiles.length} files with any types`);
        // Update adaptive config with realistic target
        this.adaptiveConfig.targetReductionPercentage = recommendedTarget;
        return {
            recommendedTarget,
            reasoning,
            milestones
        };
    }
    /**
     * Monitor progress with realistic milestone tracking
     */
    async monitorProgress() {
        const currentProgress = await this.getCurrentProgress();
        const targetInfo = await this.setRealisticTargets();
        // Check milestone achievements
        const milestoneStatus = targetInfo.milestones.map(milestone => ({
            milestone: milestone.percentage,
            achieved: currentProgress.reductionPercentage >= milestone.percentage,
            description: milestone.description
        }));
        const recommendations = [];
        let needsManualIntervention = false;
        // Analyze if we need manual intervention
        if (this.batchHistory.length >= 5) {
            const recentBatches = this.batchHistory.slice(-5);
            const avgSuccessRate = recentBatches.reduce((sum, batch) => sum + (batch.replacementsSuccessful / Math.max(1, batch.replacementsAttempted)), 0) / recentBatches.length;
            const avgSafetyScore = recentBatches.reduce((sum, batch) => sum + batch.safetyScore, 0) / recentBatches.length;
            if (avgSuccessRate < 0.3) {
                needsManualIntervention = true;
                recommendations.push('Low success rate detected - consider manual review of remaining any types');
                recommendations.push('Focus on documenting intentional any types instead of replacement');
            }
            if (avgSafetyScore < 0.7) {
                needsManualIntervention = true;
                recommendations.push('Safety concerns detected - pause automated processing');
                recommendations.push('Review recent changes and consider rollback if necessary');
            }
            // Check for stagnation
            const recentProgress = recentBatches.reduce((sum, batch) => sum + batch.replacementsSuccessful, 0);
            if (recentProgress < 5 && recentBatches.length >= 3) {
                needsManualIntervention = true;
                recommendations.push('Progress has stagnated - remaining any types may require manual analysis');
                recommendations.push('Consider switching to documentation mode for remaining types');
            }
        }
        // Provide strategic recommendations based on current state
        if (currentProgress.reductionPercentage < 5) {
            recommendations.push('Early stage - focus on array types (any[]) for quick wins');
            recommendations.push('Increase confidence threshold to 0.9 for maximum safety');
        }
        else if (currentProgress.reductionPercentage < 10) {
            recommendations.push('Good progress - expand to Record<string, any> patterns');
            recommendations.push('Consider enabling domain-specific analysis for better suggestions');
        }
        else if (currentProgress.reductionPercentage >= targetInfo.recommendedTarget * 0.8) {
            recommendations.push('Approaching target - focus on documentation for remaining intentional types');
            recommendations.push('Consider manual review for complex remaining cases');
        }
        return {
            currentProgress,
            milestoneStatus,
            recommendations,
            needsManualIntervention
        };
    }
    /**
     * Analyze success rate and adapt strategy accordingly
     */
    analyzeSuccessRateAndAdapt() {
        if (this.batchHistory.length < 2) {
            return {
                currentSuccessRate: 0,
                trend: 'stable',
                adaptations: ['Insufficient data for trend analysis']
            };
        }
        const recentBatches = this.batchHistory.slice(-5);
        const currentSuccessRate = recentBatches.reduce((sum, batch) => sum + (batch.replacementsSuccessful / Math.max(1, batch.replacementsAttempted)), 0) / recentBatches.length;
        // Determine trend
        let trend = 'stable';
        const adaptations = [];
        if (recentBatches.length >= 3) {
            const firstHalf = recentBatches.slice(0, Math.floor(recentBatches.length / 2));
            const secondHalf = recentBatches.slice(Math.floor(recentBatches.length / 2));
            const firstHalfRate = firstHalf.reduce((sum, batch) => sum + (batch.replacementsSuccessful / Math.max(1, batch.replacementsAttempted)), 0) / firstHalf.length;
            const secondHalfRate = secondHalf.reduce((sum, batch) => sum + (batch.replacementsSuccessful / Math.max(1, batch.replacementsAttempted)), 0) / secondHalf.length;
            if (secondHalfRate > firstHalfRate + 0.1) {
                trend = 'improving';
                adaptations.push('Success rate improving - consider increasing batch size');
            }
            else if (secondHalfRate < firstHalfRate - 0.1) {
                trend = 'declining';
                adaptations.push('Success rate declining - reducing batch size and increasing confidence threshold');
                // Apply adaptations
                this.adaptiveConfig.maxFilesPerBatch = Math.max(5, Math.floor(this.adaptiveConfig.maxFilesPerBatch * 0.8));
                this.adaptiveConfig.confidenceThreshold = Math.min(0.95, this.adaptiveConfig.confidenceThreshold + 0.1);
            }
        }
        // Success rate based adaptations
        if (currentSuccessRate < 0.3) {
            adaptations.push('Very low success rate - switching to documentation mode recommended');
            adaptations.push('Consider manual review of remaining any types');
        }
        else if (currentSuccessRate < 0.5) {
            adaptations.push('Low success rate - increasing confidence threshold to 0.9');
            this.adaptiveConfig.confidenceThreshold = Math.min(0.95, this.adaptiveConfig.confidenceThreshold + 0.1);
        }
        else if (currentSuccessRate > 0.8) {
            adaptations.push('High success rate - can afford to be more aggressive');
            this.adaptiveConfig.confidenceThreshold = Math.max(0.7, this.adaptiveConfig.confidenceThreshold - 0.05);
        }
        return {
            currentSuccessRate,
            trend,
            adaptations
        };
    }
    /**
     * Execute a single batch of improvements with adaptive sizing
     */
    async executeBatch(config) {
        const startTime = Date.now();
        this.batchCounter++;
        // Use adaptive config if no config provided, or merge with provided config
        const effectiveConfig = config ? { ...this.adaptiveConfig, ...config } : this.adaptiveConfig;
        const batchMetrics = {
            batchNumber: this.batchCounter,
            filesProcessed: 0,
            anyTypesAnalyzed: 0,
            replacementsAttempted: 0,
            replacementsSuccessful: 0,
            compilationErrors: 0,
            rollbacksPerformed: 0,
            executionTime: 0,
            safetyScore: 1.0
        };
        try {
            // Create safety checkpoint before starting
            await this.createSafetyCheckpoint();
            // Get initial TypeScript error count for safety monitoring
            const initialErrorCount = await this.getTypeScriptErrorCount();
            // Find files with explicit any types
            const candidateFiles = await this.findFilesWithAnyTypes();
            const filesToProcess = candidateFiles
                .filter(file => !this.processedFiles.has(file))
                .slice(0, effectiveConfig.maxFilesPerBatch);
            if (filesToProcess.length === 0) {
                console.log('No more files to process in this batch');
                batchMetrics.executionTime = Date.now() - startTime;
                this.batchHistory.push(batchMetrics);
                return batchMetrics;
            }
            console.log(`Processing batch ${this.batchCounter}: ${filesToProcess.length} files (adaptive batch size: ${effectiveConfig.maxFilesPerBatch})`);
            // Process each file
            for (const filePath of filesToProcess) {
                try {
                    const fileResult = await this.processFile(filePath, effectiveConfig);
                    batchMetrics.filesProcessed++;
                    batchMetrics.anyTypesAnalyzed += fileResult.anyTypesAnalyzed;
                    batchMetrics.replacementsAttempted += fileResult.replacementsAttempted;
                    batchMetrics.replacementsSuccessful += fileResult.replacementsSuccessful;
                    if (fileResult.rollbackPerformed) {
                        batchMetrics.rollbacksPerformed++;
                    }
                    this.processedFiles.add(filePath);
                    // Validate build every few files based on adaptive config
                    if (batchMetrics.filesProcessed % effectiveConfig.validationFrequency === 0) {
                        console.log(`Safety checkpoint: validating build after ${batchMetrics.filesProcessed} files`);
                        const currentErrorCount = await this.getTypeScriptErrorCount();
                        // Safety check: ensure we're not increasing errors significantly
                        if (currentErrorCount > initialErrorCount + 5) { // Allow small increase for temporary states
                            console.warn(`Error count increased from ${initialErrorCount} to ${currentErrorCount}, pausing batch`);
                            batchMetrics.compilationErrors = currentErrorCount - initialErrorCount;
                            batchMetrics.safetyScore = Math.max(0, 1 - (batchMetrics.compilationErrors / 10));
                            break;
                        }
                    }
                }
                catch (error) {
                    console.error(`Failed to process file ${filePath}:`, error);
                    batchMetrics.rollbacksPerformed++;
                }
            }
            // Final safety validation
            const finalErrorCount = await this.getTypeScriptErrorCount();
            if (finalErrorCount > initialErrorCount) {
                batchMetrics.compilationErrors = finalErrorCount - initialErrorCount;
                batchMetrics.safetyScore = Math.max(0, 1 - (batchMetrics.compilationErrors / 20));
            }
            batchMetrics.executionTime = Date.now() - startTime;
            // Store batch metrics for adaptive strategy
            this.batchHistory.push(batchMetrics);
            // Calculate success rate for this batch
            const successRate = batchMetrics.replacementsAttempted > 0
                ? batchMetrics.replacementsSuccessful / batchMetrics.replacementsAttempted
                : 0;
            console.log(`Batch ${this.batchCounter} completed:`, {
                filesProcessed: batchMetrics.filesProcessed,
                replacementsSuccessful: batchMetrics.replacementsSuccessful,
                successRate: `${(successRate * 100).toFixed(1)}%`,
                safetyScore: batchMetrics.safetyScore.toFixed(2),
                executionTime: `${(batchMetrics.executionTime / 1000).toFixed(1)}s`
            });
            // Adapt strategy based on performance
            this.adaptStrategy();
            return batchMetrics;
        }
        catch (error) {
            console.error(`Batch ${this.batchCounter} failed:`, error);
            batchMetrics.executionTime = Date.now() - startTime;
            batchMetrics.safetyScore = 0;
            this.batchHistory.push(batchMetrics);
            return batchMetrics;
        }
    }
    /**
     * Execute the full campaign with progressive improvement and adaptive strategies
     */
    async executeFullCampaign(config) {
        const campaignStart = Date.now();
        // Use adaptive config if no config provided, or merge with provided config
        const effectiveConfig = config ? { ...this.adaptiveConfig, ...config } : this.adaptiveConfig;
        const initialProgress = await this.getCurrentProgress();
        console.log('Starting Unintentional Any Elimination Campaign');
        console.log(`Initial state: ${initialProgress.totalAnyTypes} any types found`);
        console.log(`Target: ${effectiveConfig.targetReductionPercentage}% reduction`);
        console.log(`Initial batch size: ${effectiveConfig.maxFilesPerBatch}, confidence threshold: ${effectiveConfig.confidenceThreshold}`);
        const result = {
            totalAnyTypesAnalyzed: 0,
            intentionalTypesIdentified: 0,
            unintentionalTypesReplaced: 0,
            documentationAdded: 0,
            reductionAchieved: 0,
            safetyEvents: [],
            validationResults: []
        };
        let batchCount = 0;
        let consecutiveFailures = 0;
        const maxConsecutiveFailures = 3;
        const maxBatches = 50; // Safety limit
        while (batchCount < maxBatches && consecutiveFailures < maxConsecutiveFailures) {
            try {
                console.log(`\n--- Starting batch ${batchCount + 1} ---`);
                const batchMetrics = await this.executeBatch();
                batchCount++;
                result.totalAnyTypesAnalyzed += batchMetrics.anyTypesAnalyzed;
                result.unintentionalTypesReplaced += batchMetrics.replacementsSuccessful;
                // Check if we should continue
                if (batchMetrics.filesProcessed === 0) {
                    console.log('No more files to process, campaign complete');
                    break;
                }
                // Safety check with adaptive response
                if (batchMetrics.safetyScore < 0.7) {
                    console.warn(`Low safety score (${batchMetrics.safetyScore.toFixed(2)}), adapting strategy`);
                    consecutiveFailures++;
                    result.safetyEvents.push({
                        type: 'LOW_SAFETY_SCORE',
                        timestamp: new Date(),
                        description: `Safety score ${batchMetrics.safetyScore.toFixed(2)} below threshold`,
                        severity: 'warning',
                        batchNumber: batchCount
                    });
                }
                else {
                    consecutiveFailures = 0;
                }
                // Check progress towards target with detailed reporting
                const currentProgress = await this.getCurrentProgress();
                const reductionAchieved = initialProgress.totalAnyTypes > 0
                    ? ((initialProgress.totalAnyTypes - currentProgress.totalAnyTypes) / initialProgress.totalAnyTypes) * 100
                    : 0;
                console.log(`\nProgress Report:`);
                console.log(`  Reduction achieved: ${reductionAchieved.toFixed(1)}% (target: ${effectiveConfig.targetReductionPercentage}%)`);
                console.log(`  Types replaced: ${result.unintentionalTypesReplaced}`);
                console.log(`  Batches completed: ${batchCount}`);
                console.log(`  Current batch size: ${this.adaptiveConfig.maxFilesPerBatch}`);
                console.log(`  Current confidence threshold: ${this.adaptiveConfig.confidenceThreshold.toFixed(2)}`);
                if (reductionAchieved >= effectiveConfig.targetReductionPercentage) {
                    console.log('\nðŸŽ‰ Target reduction achieved!');
                    break;
                }
                // Brief pause between batches for system stability
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            catch (error) {
                console.error(`Campaign batch ${batchCount + 1} failed:`, error);
                consecutiveFailures++;
                result.safetyEvents.push({
                    type: 'BATCH_FAILURE',
                    timestamp: new Date(),
                    description: `Batch ${batchCount + 1} failed: ${error.message}`,
                    severity: 'error',
                    batchNumber: batchCount + 1
                });
            }
        }
        // Calculate final results with comprehensive metrics
        const finalProgress = await this.getCurrentProgress();
        result.reductionAchieved = initialProgress.totalAnyTypes > 0
            ? ((initialProgress.totalAnyTypes - finalProgress.totalAnyTypes) / initialProgress.totalAnyTypes) * 100
            : 0;
        result.intentionalTypesIdentified = finalProgress.classifiedIntentional;
        // Calculate average success rate from batch history
        const totalAttempted = this.batchHistory.reduce((sum, batch) => sum + batch.replacementsAttempted, 0);
        const totalSuccessful = this.batchHistory.reduce((sum, batch) => sum + batch.replacementsSuccessful, 0);
        const overallSuccessRate = totalAttempted > 0 ? (totalSuccessful / totalAttempted) * 100 : 0;
        const campaignTime = Date.now() - campaignStart;
        console.log(`\n=== Campaign Summary ===`);
        console.log(`Duration: ${(campaignTime / 1000).toFixed(1)}s`);
        console.log(`Batches processed: ${batchCount}`);
        console.log(`Files processed: ${this.processedFiles.size}`);
        console.log(`Reduction achieved: ${result.reductionAchieved.toFixed(1)}%`);
        console.log(`Types replaced: ${result.unintentionalTypesReplaced}`);
        console.log(`Overall success rate: ${overallSuccessRate.toFixed(1)}%`);
        console.log(`Safety events: ${result.safetyEvents.length}`);
        console.log(`Final batch size: ${this.adaptiveConfig.maxFilesPerBatch}`);
        console.log(`Final confidence threshold: ${this.adaptiveConfig.confidenceThreshold.toFixed(2)}`);
        return result;
    }
    async processFile(filePath, config) {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        const lines = fileContent.split('\n');
        // Find all any type usages in the file
        const anyTypeContexts = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (this.containsAnyType(line)) {
                const context = {
                    filePath,
                    lineNumber: i + 1,
                    codeSnippet: line,
                    surroundingLines: this.getSurroundingLines(lines, i, 2),
                    hasExistingComment: this.hasCommentAbove(lines, i),
                    existingComment: this.getCommentAbove(lines, i),
                    isInTestFile: this.isTestFile(filePath),
                    domainContext: await this.analyzer.analyzeDomain({
                        filePath,
                        lineNumber: i + 1,
                        codeSnippet: line,
                        surroundingLines: this.getSurroundingLines(lines, i, 2),
                        hasExistingComment: false,
                        isInTestFile: this.isTestFile(filePath),
                        domainContext: { domain: 'utility', intentionalityHints: [], suggestedTypes: [], preservationReasons: [] }
                    })
                };
                anyTypeContexts.push(context);
            }
        }
        if (anyTypeContexts.length === 0) {
            return {
                anyTypesAnalyzed: 0,
                replacementsAttempted: 0,
                replacementsSuccessful: 0,
                rollbackPerformed: false
            };
        }
        // Classify all any types in the file
        const classifications = await this.classifier.classifyBatch(anyTypeContexts);
        // Create replacements for unintentional any types
        const replacements = [];
        for (let i = 0; i < classifications.length; i++) {
            const classification = classifications[i];
            const context = anyTypeContexts[i];
            if (!classification.isIntentional &&
                classification.confidence >= config.confidenceThreshold &&
                classification.suggestedReplacement) {
                replacements.push({
                    original: 'any',
                    replacement: classification.suggestedReplacement,
                    filePath: context.filePath,
                    lineNumber: context.lineNumber,
                    confidence: classification.confidence,
                    validationRequired: true
                });
            }
        }
        // Apply replacements
        let replacementsSuccessful = 0;
        let rollbackPerformed = false;
        if (replacements.length > 0) {
            const result = await this.replacer.processBatch(replacements);
            replacementsSuccessful = result.appliedReplacements.length;
            rollbackPerformed = result.rollbackPerformed;
        }
        return {
            anyTypesAnalyzed: anyTypeContexts.length,
            replacementsAttempted: replacements.length,
            replacementsSuccessful,
            rollbackPerformed
        };
    }
    async findFilesWithAnyTypes() {
        try {
            // Use grep to find files with explicit any types, excluding node_modules and test files initially
            const output = (0, child_process_1.execSync)('grep -r -l ":\\s*any" src/ --include="*.ts" --include="*.tsx" --exclude-dir=node_modules | head -100', { encoding: 'utf8', stdio: 'pipe' });
            return output.trim().split('\n').filter(line => line.trim().length > 0);
        }
        catch (error) {
            console.warn('Failed to find files with any types, using fallback method');
            return this.findFilesWithAnyTypesFallback();
        }
    }
    findFilesWithAnyTypesFallback() {
        const files = [];
        const srcDir = path.join(process.cwd(), 'src');
        const walkDir = (dir) => {
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
                    walkDir(fullPath);
                }
                else if (entry.isFile() && (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx'))) {
                    try {
                        const content = fs.readFileSync(fullPath, 'utf8');
                        if (content.includes(': any') || content.includes('any[]') || content.includes('Record<string, any>')) {
                            files.push(fullPath);
                        }
                    }
                    catch (error) {
                        // Skip files that can't be read
                    }
                }
            }
        };
        if (fs.existsSync(srcDir)) {
            walkDir(srcDir);
        }
        return files.slice(0, 100); // Limit to prevent overwhelming
    }
    containsAnyType(line) {
        // Match various any type patterns
        const anyPatterns = [
            /:\s*any(?=\s*[=;,\)\]\}])/,
            /:\s*any\[\]/,
            /:\s*Array<any>/,
            /:\s*Record<\w+,\s*any>/,
            /\[key:\s*\w+\]:\s*any/ // [key: string]: any
        ];
        return anyPatterns.some(pattern => pattern.test(line));
    }
    getSurroundingLines(lines, index, radius) {
        const start = Math.max(0, index - radius);
        const end = Math.min(lines.length, index + radius + 1);
        return lines.slice(start, end);
    }
    hasCommentAbove(lines, index) {
        if (index === 0)
            return false;
        const prevLine = lines[index - 1].trim();
        return prevLine.startsWith('//') || prevLine.startsWith('/*') || prevLine.includes('*/');
    }
    getCommentAbove(lines, index) {
        if (!this.hasCommentAbove(lines, index))
            return undefined;
        return lines[index - 1].trim();
    }
    isTestFile(filePath) {
        return filePath.includes('test') ||
            filePath.includes('spec') ||
            filePath.includes('__tests__') ||
            filePath.endsWith('.test.ts') ||
            filePath.endsWith('.test.tsx') ||
            filePath.endsWith('.spec.ts') ||
            filePath.endsWith('.spec.tsx');
    }
    async getTypeScriptErrorCount() {
        try {
            const output = (0, child_process_1.execSync)('yarn tsc --noEmit --skipLibCheck 2>&1 | grep -c "error TS"', {
                encoding: 'utf8',
                stdio: 'pipe'
            });
            return parseInt(output.trim()) || 0;
        }
        catch (error) {
            // If grep finds no matches, it returns exit code 1, but that means 0 errors
            const errorData = error;
            if (errorData.status === 1) {
                return 0;
            }
            console.warn('Could not get TypeScript error count:', error);
            return -1; // Indicates measurement failure
        }
    }
    /**
     * Analyze file complexity to set realistic expectations
     */
    async analyzeFileComplexity(files) {
        let testFiles = 0;
        let arrayTypes = 0;
        let recordTypes = 0;
        let functionParams = 0;
        let totalAnyTypes = 0;
        for (const filePath of files) {
            try {
                const content = fs.readFileSync(filePath, 'utf8');
                const lines = content.split('\n');
                if (this.isTestFile(filePath)) {
                    testFiles++;
                }
                for (const line of lines) {
                    if (this.containsAnyType(line)) {
                        totalAnyTypes++;
                        if (line.includes('any[]') || line.includes('Array<any>')) {
                            arrayTypes++;
                        }
                        else if (line.includes('Record<') && line.includes('any>')) {
                            recordTypes++;
                        }
                        else if (line.includes('(') && line.includes(': any') && line.includes(')')) {
                            functionParams++;
                        }
                    }
                }
            }
            catch (error) {
                // Skip files that can't be read
            }
        }
        const testFilePercentage = files.length > 0 ? (testFiles / files.length) * 100 : 0;
        const arrayTypePercentage = totalAnyTypes > 0 ? (arrayTypes / totalAnyTypes) * 100 : 0;
        const recordTypePercentage = totalAnyTypes > 0 ? (recordTypes / totalAnyTypes) * 100 : 0;
        const functionParamPercentage = totalAnyTypes > 0 ? (functionParams / totalAnyTypes) * 100 : 0;
        // Calculate complexity score (0-1, where 1 is most complex)
        const complexityScore = Math.min(1, (testFilePercentage * 0.1 + // Test files are easier
            functionParamPercentage * 0.4 + // Function params are harder
            recordTypePercentage * 0.2) / 100 // Record types are moderate
        );
        return {
            testFilePercentage,
            arrayTypePercentage,
            recordTypePercentage,
            functionParamPercentage,
            complexityScore
        };
    }
    /**
     * Calculate expected success rate based on file analysis
     */
    calculateExpectedSuccessRate(analysis) {
        // Base success rate expectations based on historical data
        let expectedRate = 0.6; // 60% base expectation
        // Array types have historically 100% success rate
        expectedRate += (analysis.arrayTypePercentage / 100) * 0.4;
        // Record types have mixed results - moderate boost
        expectedRate += (analysis.recordTypePercentage / 100) * 0.1;
        // Function parameters have high failure rate - penalty
        expectedRate -= (analysis.functionParamPercentage / 100) * 0.3;
        // Test files are generally easier but less impactful
        expectedRate += (analysis.testFilePercentage / 100) * 0.1;
        return Math.max(0.2, Math.min(0.9, expectedRate));
    }
    async getCurrentProgress() {
        const totalFiles = await this.findFilesWithAnyTypes();
        let totalAnyTypes = 0;
        // Count total any types across all files (sample for performance)
        const sampleSize = Math.min(30, totalFiles.length);
        for (const filePath of totalFiles.slice(0, sampleSize)) {
            try {
                const content = fs.readFileSync(filePath, 'utf8');
                const lines = content.split('\n');
                totalAnyTypes += lines.filter(line => this.containsAnyType(line)).length;
            }
            catch (error) {
                // Skip files that can't be read
            }
        }
        // Estimate total based on sample
        const estimatedTotal = sampleSize > 0
            ? Math.floor((totalAnyTypes / sampleSize) * totalFiles.length)
            : 0;
        // Calculate metrics from batch history
        const totalReplacements = this.batchHistory.reduce((sum, batch) => sum + batch.replacementsSuccessful, 0);
        const totalAttempted = this.batchHistory.reduce((sum, batch) => sum + batch.replacementsAttempted, 0);
        const averageSuccessRate = totalAttempted > 0 ? totalReplacements / totalAttempted : 0;
        // Calculate reduction percentage
        const reductionPercentage = estimatedTotal > 0 ? (totalReplacements / estimatedTotal) * 100 : 0;
        // Get current TypeScript error count for comprehensive metrics
        const currentTSErrors = await this.getTypeScriptErrorCount();
        return {
            totalAnyTypes: estimatedTotal,
            classifiedIntentional: 0,
            classifiedUnintentional: totalAttempted,
            successfulReplacements: totalReplacements,
            documentedIntentional: 0,
            remainingUnintentional: Math.max(0, estimatedTotal - totalReplacements),
            reductionPercentage,
            targetReductionPercentage: this.adaptiveConfig.targetReductionPercentage,
            batchesCompleted: this.batchCounter,
            averageSuccessRate,
            // Base ProgressMetrics properties
            typeScriptErrors: {
                current: currentTSErrors >= 0 ? currentTSErrors : 0,
                target: 0,
                reduction: 0,
                percentage: 0
            },
            lintingWarnings: { current: 0, target: 0, reduction: 0, percentage: 0 },
            buildPerformance: { currentTime: 0, targetTime: 0, cacheHitRate: 0, memoryUsage: 0 },
            enterpriseSystems: { current: 0, target: 0, transformedExports: 0 }
        };
    }
}
exports.ProgressiveImprovementEngine = ProgressiveImprovementEngine;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9Qcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsaURBQXlDO0FBQ3pDLHVDQUF5QjtBQUN6QiwyQ0FBNkI7QUFXN0IsMkRBQXdEO0FBQ3hELG1FQUFnRTtBQUNoRSx5REFBc0Q7QUFFdEQsTUFBYSw0QkFBNEI7SUFDL0IsVUFBVSxDQUFvQjtJQUM5QixRQUFRLENBQW1CO0lBQzNCLFFBQVEsQ0FBd0I7SUFDaEMsY0FBYyxHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3hDLFlBQVksR0FBRyxDQUFDLENBQUM7SUFDakIsWUFBWSxHQUFtQixFQUFFLENBQUM7SUFDbEMsY0FBYyxDQUF5QjtJQUN2QyxpQkFBaUIsR0FBMEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUU3RSxZQUFZLGFBQStDO1FBQ3pELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxxQ0FBaUIsRUFBRSxDQUFDO1FBQzFDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxtQ0FBZ0IsRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSw2Q0FBcUIsRUFBRSxDQUFDO1FBRTVDLGtEQUFrRDtRQUNsRCxJQUFJLENBQUMsY0FBYyxHQUFHO1lBQ3BCLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFO1lBQ3ZELHlCQUF5QixFQUFFLGFBQWEsRUFBRSx5QkFBeUIsSUFBSSxFQUFFO1lBQ3pFLG1CQUFtQixFQUFFLGFBQWEsRUFBRSxtQkFBbUIsSUFBSSxHQUFHO1lBQzlELG9CQUFvQixFQUFFLGFBQWEsRUFBRSxvQkFBb0IsSUFBSSxJQUFJO1lBQ2pFLG1CQUFtQixFQUFFLGFBQWEsRUFBRSxtQkFBbUIsSUFBSSxJQUFJ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QUUsQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLENBQUMsRUFBRTtZQUNwRixpQkFBaUIsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxrQkFBa0IsRUFBRSxDQUFDLEVBQUU7U0FDcEUsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQTc1QkQsb0VBNjVCQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvR3JlZ0Nhc3Ryby9EZXNrdG9wL1doYXRUb0VhdE5leHQvc3JjL3NlcnZpY2VzL2NhbXBhaWduL3VuaW50ZW50aW9uYWwtYW55LWVsaW1pbmF0aW9uL1Byb2dyZXNzaXZlSW1wcm92ZW1lbnRFbmdpbmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9ncmVzc2l2ZSBJbXByb3ZlbWVudCBFbmdpbmVcbiAqIE9yY2hlc3RyYXRlcyBiYXRjaCBwcm9jZXNzaW5nIHdpdGggYWRhcHRpdmUgc3RyYXRlZ2llcyBhbmQgcHJvZ3Jlc3MgdHJhY2tpbmdcbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtcbiAgICBCYXRjaE1ldHJpY3MsXG4gICAgQ2xhc3NpZmljYXRpb25Db250ZXh0LFxuICAgIFR5cGVSZXBsYWNlbWVudCxcbiAgICBVbmludGVudGlvbmFsQW55Q2FtcGFpZ25SZXN1bHQsXG4gICAgVW5pbnRlbnRpb25hbEFueUNvbmZpZyxcbiAgICBVbmludGVudGlvbmFsQW55UHJvZ3Jlc3Ncbn0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCB7IEFueVR5cGVDbGFzc2lmaWVyIH0gZnJvbSAnLi9BbnlUeXBlQ2xhc3NpZmllcic7XG5pbXBvcnQgeyBEb21haW5Db250ZXh0QW5hbHl6ZXIgfSBmcm9tICcuL0RvbWFpbkNvbnRleHRBbmFseXplcic7XG5pbXBvcnQgeyBTYWZlVHlwZVJlcGxhY2VyIH0gZnJvbSAnLi9TYWZlVHlwZVJlcGxhY2VyJztcblxuZXhwb3J0IGNsYXNzIFByb2dyZXNzaXZlSW1wcm92ZW1lbnRFbmdpbmUge1xuICBwcml2YXRlIGNsYXNzaWZpZXI6IEFueVR5cGVDbGFzc2lmaWVyO1xuICBwcml2YXRlIHJlcGxhY2VyOiBTYWZlVHlwZVJlcGxhY2VyO1xuICBwcml2YXRlIGFuYWx5emVyOiBEb21haW5Db250ZXh0QW5hbHl6ZXI7XG4gIHByaXZhdGUgcHJvY2Vzc2VkRmlsZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIGJhdGNoQ291bnRlciA9IDA7XG4gIHByaXZhdGUgYmF0Y2hIaXN0b3J5OiBCYXRjaE1ldHJpY3NbXSA9IFtdO1xuICBwcml2YXRlIGFkYXB0aXZlQ29uZmlnOiBVbmludGVudGlvbmFsQW55Q29uZmlnO1xuICBwcml2YXRlIHNhZmV0eUNoZWNrcG9pbnRzOiBNYXA8bnVtYmVyLCBVbmludGVudGlvbmFsQW55UHJvZ3Jlc3M+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb25maWc/OiBQYXJ0aWFsPFVuaW50ZW50aW9uYWxBbnlDb25maWc+KSB7XG4gICAgdGhpcy5jbGFzc2lmaWVyID0gbmV3IEFueVR5cGVDbGFzc2lmaWVyKCk7XG4gICAgdGhpcy5yZXBsYWNlciA9IG5ldyBTYWZlVHlwZVJlcGxhY2VyKCk7XG4gICAgdGhpcy5hbmFseXplciA9IG5ldyBEb21haW5Db250ZXh0QW5hbHl6ZXIoKTtcblxuICAgIC8vIEluaXRpYWxpemUgYWRhcHRpdmUgY29uZmlndXJhdGlvbiB3aXRoIGRlZmF1bHRzXG4gICAgdGhpcy5hZGFwdGl2ZUNvbmZpZyA9IHtcbiAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IGluaXRpYWxDb25maWc/Lm1heEZpbGVzUGVyQmF0Y2ggfHwgMTUsXG4gICAgICB0YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlOiBpbml0aWFsQ29uZmlnPy50YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlIHx8IDE1LFxuICAgICAgY29uZmlkZW5jZVRocmVzaG9sZDogaW5pdGlhbENvbmZpZz8uY29uZmlkZW5jZVRocmVzaG9sZCB8fCAwLjgsXG4gICAgICBlbmFibGVEb21haW5BbmFseXNpczogaW5pdGlhbENvbmZpZz8uZW5hYmxlRG9tYWluQW5hbHlzaXMgPz8gdHJ1ZSxcbiAgICAgIGVuYWJsZURvY3VtZW50YXRpb246IGluaXRpYWxDb25maWc/LmVuYWJsZURvY3VtZW50YXRpb24gPz8gdHJ1ZSxcbiAgICAgIHNhZmV0eUxldmVsOiBpbml0aWFsQ29uZmlnPy5zYWZldHlMZXZlbCB8fCAnTU9ERVJBVEUnLFxuICAgICAgdmFsaWRhdGlvbkZyZXF1ZW5jeTogaW5pdGlhbENvbmZpZz8udmFsaWRhdGlvbkZyZXF1ZW5jeSB8fCA1XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGFwdCBzdHJhdGVneSBiYXNlZCBvbiByZWNlbnQgYmF0Y2ggcGVyZm9ybWFuY2VcbiAgICovXG4gIHByaXZhdGUgYWRhcHRTdHJhdGVneSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5iYXRjaEhpc3RvcnkubGVuZ3RoIDwgMikgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVjZW50QmF0Y2hlcyA9IHRoaXMuYmF0Y2hIaXN0b3J5LnNsaWNlKC0zKTtcbiAgICBjb25zdCBhdmVyYWdlU3VjY2Vzc1JhdGUgPSByZWNlbnRCYXRjaGVzLnJlZHVjZSgoc3VtLCBiYXRjaCkgPT5cbiAgICAgIHN1bSArIChiYXRjaC5yZXBsYWNlbWVudHNTdWNjZXNzZnVsIC8gTWF0aC5tYXgoMSwgYmF0Y2gucmVwbGFjZW1lbnRzQXR0ZW1wdGVkKSksIDBcbiAgICApIC8gcmVjZW50QmF0Y2hlcy5sZW5ndGg7XG5cbiAgICBjb25zdCBhdmVyYWdlU2FmZXR5U2NvcmUgPSByZWNlbnRCYXRjaGVzLnJlZHVjZSgoc3VtLCBiYXRjaCkgPT5cbiAgICAgIHN1bSArIGJhdGNoLnNhZmV0eVNjb3JlLCAwXG4gICAgKSAvIHJlY2VudEJhdGNoZXMubGVuZ3RoO1xuXG4gICAgY29uc29sZS5sb2coYEFkYXB0aW5nIHN0cmF0ZWd5IC0gU3VjY2VzcyByYXRlOiAkeyhhdmVyYWdlU3VjY2Vzc1JhdGUgKiAxMDApLnRvRml4ZWQoMSl9JSwgU2FmZXR5IHNjb3JlOiAke2F2ZXJhZ2VTYWZldHlTY29yZS50b0ZpeGVkKDIpfWApO1xuXG4gICAgLy8gQWRhcHQgYmF0Y2ggc2l6ZSBiYXNlZCBvbiBzYWZldHkgc2NvcmVcbiAgICBpZiAoYXZlcmFnZVNhZmV0eVNjb3JlIDwgMC43KSB7XG4gICAgICAvLyBSZWR1Y2UgYmF0Y2ggc2l6ZSBmb3Igc2FmZXR5XG4gICAgICB0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2ggPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKHRoaXMuYWRhcHRpdmVDb25maWcubWF4RmlsZXNQZXJCYXRjaCAqIDAuNykpO1xuICAgICAgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkID0gTWF0aC5taW4oMC45NSwgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkICsgMC4xKTtcbiAgICAgIGNvbnNvbGUubG9nKGBSZWR1Y2VkIGJhdGNoIHNpemUgdG8gJHt0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2h9IGFuZCBpbmNyZWFzZWQgY29uZmlkZW5jZSB0aHJlc2hvbGQgdG8gJHt0aGlzLmFkYXB0aXZlQ29uZmlnLmNvbmZpZGVuY2VUaHJlc2hvbGR9YCk7XG4gICAgfSBlbHNlIGlmIChhdmVyYWdlU2FmZXR5U2NvcmUgPiAwLjkgJiYgYXZlcmFnZVN1Y2Nlc3NSYXRlID4gMC44KSB7XG4gICAgICAvLyBJbmNyZWFzZSBiYXRjaCBzaXplIGZvciBlZmZpY2llbmN5XG4gICAgICB0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2ggPSBNYXRoLm1pbigyNSwgTWF0aC5mbG9vcih0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2ggKiAxLjIpKTtcbiAgICAgIHRoaXMuYWRhcHRpdmVDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZCA9IE1hdGgubWF4KDAuNywgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkIC0gMC4wNSk7XG4gICAgICBjb25zb2xlLmxvZyhgSW5jcmVhc2VkIGJhdGNoIHNpemUgdG8gJHt0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2h9IGFuZCBkZWNyZWFzZWQgY29uZmlkZW5jZSB0aHJlc2hvbGQgdG8gJHt0aGlzLmFkYXB0aXZlQ29uZmlnLmNvbmZpZGVuY2VUaHJlc2hvbGR9YCk7XG4gICAgfVxuXG4gICAgLy8gQWRhcHQgY29uZmlkZW5jZSB0aHJlc2hvbGQgYmFzZWQgb24gc3VjY2VzcyByYXRlXG4gICAgaWYgKGF2ZXJhZ2VTdWNjZXNzUmF0ZSA8IDAuNSkge1xuICAgICAgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkID0gTWF0aC5taW4oMC45NSwgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkICsgMC4xKTtcbiAgICAgIGNvbnNvbGUubG9nKGBMb3cgc3VjY2VzcyByYXRlLCBpbmNyZWFzZWQgY29uZmlkZW5jZSB0aHJlc2hvbGQgdG8gJHt0aGlzLmFkYXB0aXZlQ29uZmlnLmNvbmZpZGVuY2VUaHJlc2hvbGR9YCk7XG4gICAgfVxuXG4gICAgLy8gQWRhcHQgdmFsaWRhdGlvbiBmcmVxdWVuY3kgYmFzZWQgb24gc2FmZXR5XG4gICAgaWYgKGF2ZXJhZ2VTYWZldHlTY29yZSA8IDAuOCkge1xuICAgICAgdGhpcy5hZGFwdGl2ZUNvbmZpZy52YWxpZGF0aW9uRnJlcXVlbmN5ID0gTWF0aC5tYXgoMywgdGhpcy5hZGFwdGl2ZUNvbmZpZy52YWxpZGF0aW9uRnJlcXVlbmN5IC0gMSk7XG4gICAgICBjb25zb2xlLmxvZyhgSW5jcmVhc2VkIHZhbGlkYXRpb24gZnJlcXVlbmN5IHRvIGV2ZXJ5ICR7dGhpcy5hZGFwdGl2ZUNvbmZpZy52YWxpZGF0aW9uRnJlcXVlbmN5fSBmaWxlc2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzYWZldHkgY2hlY2twb2ludFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVTYWZldHlDaGVja3BvaW50KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHByb2dyZXNzID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50UHJvZ3Jlc3MoKTtcbiAgICB0aGlzLnNhZmV0eUNoZWNrcG9pbnRzLnNldCh0aGlzLmJhdGNoQ291bnRlciwgcHJvZ3Jlc3MpO1xuICAgIGNvbnNvbGUubG9nKGBTYWZldHkgY2hlY2twb2ludCBjcmVhdGVkIGF0IGJhdGNoICR7dGhpcy5iYXRjaENvdW50ZXJ9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbXByZWhlbnNpdmUgcHJvZ3Jlc3MgbWV0cmljc1xuICAgKi9cbiAgYXN5bmMgZ2V0UHJvZ3Jlc3NNZXRyaWNzKCk6IFByb21pc2U8VW5pbnRlbnRpb25hbEFueVByb2dyZXNzPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q3VycmVudFByb2dyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJhdGNoIGV4ZWN1dGlvbiBoaXN0b3J5XG4gICAqL1xuICBnZXRCYXRjaEhpc3RvcnkoKTogQmF0Y2hNZXRyaWNzW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5iYXRjaEhpc3RvcnldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGFkYXB0aXZlIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldEFkYXB0aXZlQ29uZmlnKCk6IFVuaW50ZW50aW9uYWxBbnlDb25maWcge1xuICAgIHJldHVybiB7IC4uLnRoaXMuYWRhcHRpdmVDb25maWcgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcmVhbGlzdGljIHRhcmdldHMgYmFzZWQgb24gaGlzdG9yaWNhbCBzdWNjZXNzIHJhdGVzIGFuZCBjb2RlYmFzZSBhbmFseXNpc1xuICAgKi9cbiAgYXN5bmMgc2V0UmVhbGlzdGljVGFyZ2V0cygpOiBQcm9taXNlPHtcbiAgICByZWNvbW1lbmRlZFRhcmdldDogbnVtYmVyO1xuICAgIHJlYXNvbmluZzogc3RyaW5nW107XG4gICAgbWlsZXN0b25lczogQXJyYXk8eyBwZXJjZW50YWdlOiBudW1iZXI7IGRlc2NyaXB0aW9uOiBzdHJpbmc7IGVzdGltYXRlZEJhdGNoZXM6IG51bWJlciB9PjtcbiAgfT4ge1xuICAgIGNvbnN0IGN1cnJlbnRQcm9ncmVzcyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFByb2dyZXNzKCk7XG4gICAgY29uc3QgY2FuZGlkYXRlRmlsZXMgPSBhd2FpdCB0aGlzLmZpbmRGaWxlc1dpdGhBbnlUeXBlcygpO1xuXG4gICAgLy8gQW5hbHl6ZSBmaWxlIHR5cGVzIGFuZCBjb21wbGV4aXR5XG4gICAgY29uc3QgZmlsZUFuYWx5c2lzID0gYXdhaXQgdGhpcy5hbmFseXplRmlsZUNvbXBsZXhpdHkoY2FuZGlkYXRlRmlsZXMuc2xpY2UoMCwgMjApKTtcblxuICAgIC8vIENhbGN1bGF0ZSBiYXNlIHN1Y2Nlc3MgcmF0ZSBleHBlY3RhdGlvbnNcbiAgICBjb25zdCBiYXNlU3VjY2Vzc1JhdGUgPSB0aGlzLmNhbGN1bGF0ZUV4cGVjdGVkU3VjY2Vzc1JhdGUoZmlsZUFuYWx5c2lzKTtcblxuICAgIC8vIEhpc3RvcmljYWwgZGF0YSBzaG93cyBwcmV2aW91cyBhdHRlbXB0cyBhY2hpZXZlZCAxLjclIHJlZHVjdGlvbiAoMzAgZml4ZXMpXG4gICAgLy8gVGFyZ2V0IDEweCBpbXByb3ZlbWVudCA9IDE3JSByZWR1Y3Rpb24gKDMwMCBmaXhlcylcbiAgICAvLyBCdXQgYmUgcmVhbGlzdGljIGJhc2VkIG9uIGZpbGUgYW5hbHlzaXNcblxuICAgIGxldCByZWNvbW1lbmRlZFRhcmdldCA9IDE1OyAvLyBEZWZhdWx0IDE1JSBhcyBwZXIgcmVxdWlyZW1lbnRzXG4gICAgY29uc3QgcmVhc29uaW5nOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gQWRqdXN0IGJhc2VkIG9uIGZpbGUgY29tcGxleGl0eVxuICAgIGlmIChmaWxlQW5hbHlzaXMudGVzdEZpbGVQZXJjZW50YWdlID4gMzApIHtcbiAgICAgIHJlYXNvbmluZy5wdXNoKGAke2ZpbGVBbmFseXNpcy50ZXN0RmlsZVBlcmNlbnRhZ2UudG9GaXhlZCgxKX0lIG9mIGZpbGVzIGFyZSB0ZXN0IGZpbGVzIC0gZm9jdXNpbmcgb24gbm9uLXRlc3QgZmlsZXMgZmlyc3RgKTtcbiAgICAgIHJlY29tbWVuZGVkVGFyZ2V0ID0gTWF0aC5tYXgoMTIsIHJlY29tbWVuZGVkVGFyZ2V0IC0gMyk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVBbmFseXNpcy5hcnJheVR5cGVQZXJjZW50YWdlID4gMjApIHtcbiAgICAgIHJlYXNvbmluZy5wdXNoKGAke2ZpbGVBbmFseXNpcy5hcnJheVR5cGVQZXJjZW50YWdlLnRvRml4ZWQoMSl9JSBhcmUgYXJyYXkgdHlwZXMgd2l0aCBoaXN0b3JpY2FsbHkgMTAwJSBzdWNjZXNzIHJhdGVgKTtcbiAgICAgIHJlY29tbWVuZGVkVGFyZ2V0ID0gTWF0aC5taW4oMjAsIHJlY29tbWVuZGVkVGFyZ2V0ICsgMik7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVBbmFseXNpcy5yZWNvcmRUeXBlUGVyY2VudGFnZSA+IDE1KSB7XG4gICAgICByZWFzb25pbmcucHVzaChgJHtmaWxlQW5hbHlzaXMucmVjb3JkVHlwZVBlcmNlbnRhZ2UudG9GaXhlZCgxKX0lIGFyZSBSZWNvcmQgdHlwZXMgd2l0aCBtaXhlZCBzdWNjZXNzIC0gYmVpbmcgc2VsZWN0aXZlYCk7XG4gICAgICByZWNvbW1lbmRlZFRhcmdldCA9IE1hdGgubWF4KDEwLCByZWNvbW1lbmRlZFRhcmdldCAtIDIpO1xuICAgIH1cblxuICAgIGlmIChmaWxlQW5hbHlzaXMuZnVuY3Rpb25QYXJhbVBlcmNlbnRhZ2UgPiAyNSkge1xuICAgICAgcmVhc29uaW5nLnB1c2goYCR7ZmlsZUFuYWx5c2lzLmZ1bmN0aW9uUGFyYW1QZXJjZW50YWdlLnRvRml4ZWQoMSl9JSBhcmUgZnVuY3Rpb24gcGFyYW1ldGVycyB3aXRoIGhpZ2ggZmFpbHVyZSByYXRlIC0gYmVpbmcgY29uc2VydmF0aXZlYCk7XG4gICAgICByZWNvbW1lbmRlZFRhcmdldCA9IE1hdGgubWF4KDgsIHJlY29tbWVuZGVkVGFyZ2V0IC0gNSk7XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IGJhc2VkIG9uIGhpc3RvcmljYWwgYmF0Y2ggcGVyZm9ybWFuY2UgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMuYmF0Y2hIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGF2Z1N1Y2Nlc3NSYXRlID0gdGhpcy5iYXRjaEhpc3RvcnkucmVkdWNlKChzdW0sIGJhdGNoKSA9PlxuICAgICAgICBzdW0gKyAoYmF0Y2gucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCAvIE1hdGgubWF4KDEsIGJhdGNoLnJlcGxhY2VtZW50c0F0dGVtcHRlZCkpLCAwXG4gICAgICApIC8gdGhpcy5iYXRjaEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgICBpZiAoYXZnU3VjY2Vzc1JhdGUgPiAwLjgpIHtcbiAgICAgICAgcmVhc29uaW5nLnB1c2goYEhpZ2ggaGlzdG9yaWNhbCBzdWNjZXNzIHJhdGUgKCR7KGF2Z1N1Y2Nlc3NSYXRlICogMTAwKS50b0ZpeGVkKDEpfSUpIC0gaW5jcmVhc2luZyB0YXJnZXRgKTtcbiAgICAgICAgcmVjb21tZW5kZWRUYXJnZXQgPSBNYXRoLm1pbigyNSwgcmVjb21tZW5kZWRUYXJnZXQgKyAzKTtcbiAgICAgIH0gZWxzZSBpZiAoYXZnU3VjY2Vzc1JhdGUgPCAwLjUpIHtcbiAgICAgICAgcmVhc29uaW5nLnB1c2goYExvdyBoaXN0b3JpY2FsIHN1Y2Nlc3MgcmF0ZSAoJHsoYXZnU3VjY2Vzc1JhdGUgKiAxMDApLnRvRml4ZWQoMSl9JSkgLSByZWR1Y2luZyB0YXJnZXRgKTtcbiAgICAgICAgcmVjb21tZW5kZWRUYXJnZXQgPSBNYXRoLm1heCg1LCByZWNvbW1lbmRlZFRhcmdldCAtIDUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSByZWFsaXN0aWMgbWlsZXN0b25lc1xuICAgIGNvbnN0IG1pbGVzdG9uZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHBlcmNlbnRhZ2U6IE1hdGguZmxvb3IocmVjb21tZW5kZWRUYXJnZXQgKiAwLjI1KSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdJbml0aWFsIHByb2dyZXNzIC0gZm9jdXMgb24gaGlnaC1jb25maWRlbmNlIGFycmF5IHR5cGVzJyxcbiAgICAgICAgZXN0aW1hdGVkQmF0Y2hlczogTWF0aC5jZWlsKGNhbmRpZGF0ZUZpbGVzLmxlbmd0aCAqIDAuMSAvIHRoaXMuYWRhcHRpdmVDb25maWcubWF4RmlsZXNQZXJCYXRjaClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBlcmNlbnRhZ2U6IE1hdGguZmxvb3IocmVjb21tZW5kZWRUYXJnZXQgKiAwLjUpLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ01pZC1wb2ludCAtIGV4cGFuZCB0byBSZWNvcmQgdHlwZXMgYW5kIHNpbXBsZSBwYXR0ZXJucycsXG4gICAgICAgIGVzdGltYXRlZEJhdGNoZXM6IE1hdGguY2VpbChjYW5kaWRhdGVGaWxlcy5sZW5ndGggKiAwLjMgLyB0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2gpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwZXJjZW50YWdlOiBNYXRoLmZsb29yKHJlY29tbWVuZGVkVGFyZ2V0ICogMC43NSksXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQWR2YW5jZWQgcHJvZ3Jlc3MgLSB0YWNrbGUgbW9yZSBjb21wbGV4IHBhdHRlcm5zJyxcbiAgICAgICAgZXN0aW1hdGVkQmF0Y2hlczogTWF0aC5jZWlsKGNhbmRpZGF0ZUZpbGVzLmxlbmd0aCAqIDAuNiAvIHRoaXMuYWRhcHRpdmVDb25maWcubWF4RmlsZXNQZXJCYXRjaClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBlcmNlbnRhZ2U6IHJlY29tbWVuZGVkVGFyZ2V0LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1RhcmdldCBhY2hpZXZlbWVudCAtIGNvbXBsZXRlIHJlbWFpbmluZyBoaWdoLWNvbmZpZGVuY2UgY2FzZXMnLFxuICAgICAgICBlc3RpbWF0ZWRCYXRjaGVzOiBNYXRoLmNlaWwoY2FuZGlkYXRlRmlsZXMubGVuZ3RoICogMC44IC8gdGhpcy5hZGFwdGl2ZUNvbmZpZy5tYXhGaWxlc1BlckJhdGNoKVxuICAgICAgfVxuICAgIF07XG5cbiAgICByZWFzb25pbmcucHVzaChgUmVjb21tZW5kZWQgdGFyZ2V0OiAke3JlY29tbWVuZGVkVGFyZ2V0fSUgcmVkdWN0aW9uICgke01hdGguZmxvb3IoY3VycmVudFByb2dyZXNzLnRvdGFsQW55VHlwZXMgKiByZWNvbW1lbmRlZFRhcmdldCAvIDEwMCl9IGZpeGVzKWApO1xuICAgIHJlYXNvbmluZy5wdXNoKGBCYXNlZCBvbiBhbmFseXNpcyBvZiAke2NhbmRpZGF0ZUZpbGVzLmxlbmd0aH0gZmlsZXMgd2l0aCBhbnkgdHlwZXNgKTtcblxuICAgIC8vIFVwZGF0ZSBhZGFwdGl2ZSBjb25maWcgd2l0aCByZWFsaXN0aWMgdGFyZ2V0XG4gICAgdGhpcy5hZGFwdGl2ZUNvbmZpZy50YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlID0gcmVjb21tZW5kZWRUYXJnZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVjb21tZW5kZWRUYXJnZXQsXG4gICAgICByZWFzb25pbmcsXG4gICAgICBtaWxlc3RvbmVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb25pdG9yIHByb2dyZXNzIHdpdGggcmVhbGlzdGljIG1pbGVzdG9uZSB0cmFja2luZ1xuICAgKi9cbiAgYXN5bmMgbW9uaXRvclByb2dyZXNzKCk6IFByb21pc2U8e1xuICAgIGN1cnJlbnRQcm9ncmVzczogVW5pbnRlbnRpb25hbEFueVByb2dyZXNzO1xuICAgIG1pbGVzdG9uZVN0YXR1czogQXJyYXk8eyBtaWxlc3RvbmU6IG51bWJlcjsgYWNoaWV2ZWQ6IGJvb2xlYW47IGRlc2NyaXB0aW9uOiBzdHJpbmcgfT47XG4gICAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbiAgICBuZWVkc01hbnVhbEludGVydmVudGlvbjogYm9vbGVhbjtcbiAgfT4ge1xuICAgIGNvbnN0IGN1cnJlbnRQcm9ncmVzcyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFByb2dyZXNzKCk7XG4gICAgY29uc3QgdGFyZ2V0SW5mbyA9IGF3YWl0IHRoaXMuc2V0UmVhbGlzdGljVGFyZ2V0cygpO1xuXG4gICAgLy8gQ2hlY2sgbWlsZXN0b25lIGFjaGlldmVtZW50c1xuICAgIGNvbnN0IG1pbGVzdG9uZVN0YXR1cyA9IHRhcmdldEluZm8ubWlsZXN0b25lcy5tYXAobWlsZXN0b25lID0+ICh7XG4gICAgICBtaWxlc3RvbmU6IG1pbGVzdG9uZS5wZXJjZW50YWdlLFxuICAgICAgYWNoaWV2ZWQ6IGN1cnJlbnRQcm9ncmVzcy5yZWR1Y3Rpb25QZXJjZW50YWdlID49IG1pbGVzdG9uZS5wZXJjZW50YWdlLFxuICAgICAgZGVzY3JpcHRpb246IG1pbGVzdG9uZS5kZXNjcmlwdGlvblxuICAgIH0pKTtcblxuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBsZXQgbmVlZHNNYW51YWxJbnRlcnZlbnRpb24gPSBmYWxzZTtcblxuICAgIC8vIEFuYWx5emUgaWYgd2UgbmVlZCBtYW51YWwgaW50ZXJ2ZW50aW9uXG4gICAgaWYgKHRoaXMuYmF0Y2hIaXN0b3J5Lmxlbmd0aCA+PSA1KSB7XG4gICAgICBjb25zdCByZWNlbnRCYXRjaGVzID0gdGhpcy5iYXRjaEhpc3Rvcnkuc2xpY2UoLTUpO1xuICAgICAgY29uc3QgYXZnU3VjY2Vzc1JhdGUgPSByZWNlbnRCYXRjaGVzLnJlZHVjZSgoc3VtLCBiYXRjaCkgPT5cbiAgICAgICAgc3VtICsgKGJhdGNoLnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwgLyBNYXRoLm1heCgxLCBiYXRjaC5yZXBsYWNlbWVudHNBdHRlbXB0ZWQpKSwgMFxuICAgICAgKSAvIHJlY2VudEJhdGNoZXMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBhdmdTYWZldHlTY29yZSA9IHJlY2VudEJhdGNoZXMucmVkdWNlKChzdW0sIGJhdGNoKSA9PiBzdW0gKyBiYXRjaC5zYWZldHlTY29yZSwgMCkgLyByZWNlbnRCYXRjaGVzLmxlbmd0aDtcblxuICAgICAgaWYgKGF2Z1N1Y2Nlc3NSYXRlIDwgMC4zKSB7XG4gICAgICAgIG5lZWRzTWFudWFsSW50ZXJ2ZW50aW9uID0gdHJ1ZTtcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0xvdyBzdWNjZXNzIHJhdGUgZGV0ZWN0ZWQgLSBjb25zaWRlciBtYW51YWwgcmV2aWV3IG9mIHJlbWFpbmluZyBhbnkgdHlwZXMnKTtcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0ZvY3VzIG9uIGRvY3VtZW50aW5nIGludGVudGlvbmFsIGFueSB0eXBlcyBpbnN0ZWFkIG9mIHJlcGxhY2VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdmdTYWZldHlTY29yZSA8IDAuNykge1xuICAgICAgICBuZWVkc01hbnVhbEludGVydmVudGlvbiA9IHRydWU7XG4gICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdTYWZldHkgY29uY2VybnMgZGV0ZWN0ZWQgLSBwYXVzZSBhdXRvbWF0ZWQgcHJvY2Vzc2luZycpO1xuICAgICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnUmV2aWV3IHJlY2VudCBjaGFuZ2VzIGFuZCBjb25zaWRlciByb2xsYmFjayBpZiBuZWNlc3NhcnknKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHN0YWduYXRpb25cbiAgICAgIGNvbnN0IHJlY2VudFByb2dyZXNzID0gcmVjZW50QmF0Y2hlcy5yZWR1Y2UoKHN1bSwgYmF0Y2gpID0+IHN1bSArIGJhdGNoLnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwsIDApO1xuICAgICAgaWYgKHJlY2VudFByb2dyZXNzIDwgNSAmJiByZWNlbnRCYXRjaGVzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIG5lZWRzTWFudWFsSW50ZXJ2ZW50aW9uID0gdHJ1ZTtcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ1Byb2dyZXNzIGhhcyBzdGFnbmF0ZWQgLSByZW1haW5pbmcgYW55IHR5cGVzIG1heSByZXF1aXJlIG1hbnVhbCBhbmFseXNpcycpO1xuICAgICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnQ29uc2lkZXIgc3dpdGNoaW5nIHRvIGRvY3VtZW50YXRpb24gbW9kZSBmb3IgcmVtYWluaW5nIHR5cGVzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZSBzdHJhdGVnaWMgcmVjb21tZW5kYXRpb25zIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcbiAgICBpZiAoY3VycmVudFByb2dyZXNzLnJlZHVjdGlvblBlcmNlbnRhZ2UgPCA1KSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnRWFybHkgc3RhZ2UgLSBmb2N1cyBvbiBhcnJheSB0eXBlcyAoYW55W10pIGZvciBxdWljayB3aW5zJyk7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnSW5jcmVhc2UgY29uZmlkZW5jZSB0aHJlc2hvbGQgdG8gMC45IGZvciBtYXhpbXVtIHNhZmV0eScpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFByb2dyZXNzLnJlZHVjdGlvblBlcmNlbnRhZ2UgPCAxMCkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0dvb2QgcHJvZ3Jlc3MgLSBleHBhbmQgdG8gUmVjb3JkPHN0cmluZywgYW55PiBwYXR0ZXJucycpO1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0NvbnNpZGVyIGVuYWJsaW5nIGRvbWFpbi1zcGVjaWZpYyBhbmFseXNpcyBmb3IgYmV0dGVyIHN1Z2dlc3Rpb25zJyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50UHJvZ3Jlc3MucmVkdWN0aW9uUGVyY2VudGFnZSA+PSB0YXJnZXRJbmZvLnJlY29tbWVuZGVkVGFyZ2V0ICogMC44KSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnQXBwcm9hY2hpbmcgdGFyZ2V0IC0gZm9jdXMgb24gZG9jdW1lbnRhdGlvbiBmb3IgcmVtYWluaW5nIGludGVudGlvbmFsIHR5cGVzJyk7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnQ29uc2lkZXIgbWFudWFsIHJldmlldyBmb3IgY29tcGxleCByZW1haW5pbmcgY2FzZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudFByb2dyZXNzLFxuICAgICAgbWlsZXN0b25lU3RhdHVzLFxuICAgICAgcmVjb21tZW5kYXRpb25zLFxuICAgICAgbmVlZHNNYW51YWxJbnRlcnZlbnRpb25cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuYWx5emUgc3VjY2VzcyByYXRlIGFuZCBhZGFwdCBzdHJhdGVneSBhY2NvcmRpbmdseVxuICAgKi9cbiAgYW5hbHl6ZVN1Y2Nlc3NSYXRlQW5kQWRhcHQoKToge1xuICAgIGN1cnJlbnRTdWNjZXNzUmF0ZTogbnVtYmVyO1xuICAgIHRyZW5kOiAnaW1wcm92aW5nJyB8ICdkZWNsaW5pbmcnIHwgJ3N0YWJsZSc7XG4gICAgYWRhcHRhdGlvbnM6IHN0cmluZ1tdO1xuICB9IHtcbiAgICBpZiAodGhpcy5iYXRjaEhpc3RvcnkubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudFN1Y2Nlc3NSYXRlOiAwLFxuICAgICAgICB0cmVuZDogJ3N0YWJsZScsXG4gICAgICAgIGFkYXB0YXRpb25zOiBbJ0luc3VmZmljaWVudCBkYXRhIGZvciB0cmVuZCBhbmFseXNpcyddXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlY2VudEJhdGNoZXMgPSB0aGlzLmJhdGNoSGlzdG9yeS5zbGljZSgtNSk7XG4gICAgY29uc3QgY3VycmVudFN1Y2Nlc3NSYXRlID0gcmVjZW50QmF0Y2hlcy5yZWR1Y2UoKHN1bSwgYmF0Y2gpID0+XG4gICAgICBzdW0gKyAoYmF0Y2gucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCAvIE1hdGgubWF4KDEsIGJhdGNoLnJlcGxhY2VtZW50c0F0dGVtcHRlZCkpLCAwXG4gICAgKSAvIHJlY2VudEJhdGNoZXMubGVuZ3RoO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRyZW5kXG4gICAgbGV0IHRyZW5kOiAnaW1wcm92aW5nJyB8ICdkZWNsaW5pbmcnIHwgJ3N0YWJsZScgPSAnc3RhYmxlJztcbiAgICBjb25zdCBhZGFwdGF0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmIChyZWNlbnRCYXRjaGVzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCBmaXJzdEhhbGYgPSByZWNlbnRCYXRjaGVzLnNsaWNlKDAsIE1hdGguZmxvb3IocmVjZW50QmF0Y2hlcy5sZW5ndGggLyAyKSk7XG4gICAgICBjb25zdCBzZWNvbmRIYWxmID0gcmVjZW50QmF0Y2hlcy5zbGljZShNYXRoLmZsb29yKHJlY2VudEJhdGNoZXMubGVuZ3RoIC8gMikpO1xuXG4gICAgICBjb25zdCBmaXJzdEhhbGZSYXRlID0gZmlyc3RIYWxmLnJlZHVjZSgoc3VtLCBiYXRjaCkgPT5cbiAgICAgICAgc3VtICsgKGJhdGNoLnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwgLyBNYXRoLm1heCgxLCBiYXRjaC5yZXBsYWNlbWVudHNBdHRlbXB0ZWQpKSwgMFxuICAgICAgKSAvIGZpcnN0SGFsZi5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IHNlY29uZEhhbGZSYXRlID0gc2Vjb25kSGFsZi5yZWR1Y2UoKHN1bSwgYmF0Y2gpID0+XG4gICAgICAgIHN1bSArIChiYXRjaC5yZXBsYWNlbWVudHNTdWNjZXNzZnVsIC8gTWF0aC5tYXgoMSwgYmF0Y2gucmVwbGFjZW1lbnRzQXR0ZW1wdGVkKSksIDBcbiAgICAgICkgLyBzZWNvbmRIYWxmLmxlbmd0aDtcblxuICAgICAgaWYgKHNlY29uZEhhbGZSYXRlID4gZmlyc3RIYWxmUmF0ZSArIDAuMSkge1xuICAgICAgICB0cmVuZCA9ICdpbXByb3ZpbmcnO1xuICAgICAgICBhZGFwdGF0aW9ucy5wdXNoKCdTdWNjZXNzIHJhdGUgaW1wcm92aW5nIC0gY29uc2lkZXIgaW5jcmVhc2luZyBiYXRjaCBzaXplJyk7XG4gICAgICB9IGVsc2UgaWYgKHNlY29uZEhhbGZSYXRlIDwgZmlyc3RIYWxmUmF0ZSAtIDAuMSkge1xuICAgICAgICB0cmVuZCA9ICdkZWNsaW5pbmcnO1xuICAgICAgICBhZGFwdGF0aW9ucy5wdXNoKCdTdWNjZXNzIHJhdGUgZGVjbGluaW5nIC0gcmVkdWNpbmcgYmF0Y2ggc2l6ZSBhbmQgaW5jcmVhc2luZyBjb25maWRlbmNlIHRocmVzaG9sZCcpO1xuXG4gICAgICAgIC8vIEFwcGx5IGFkYXB0YXRpb25zXG4gICAgICAgIHRoaXMuYWRhcHRpdmVDb25maWcubWF4RmlsZXNQZXJCYXRjaCA9IE1hdGgubWF4KDUsIE1hdGguZmxvb3IodGhpcy5hZGFwdGl2ZUNvbmZpZy5tYXhGaWxlc1BlckJhdGNoICogMC44KSk7XG4gICAgICAgIHRoaXMuYWRhcHRpdmVDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZCA9IE1hdGgubWluKDAuOTUsIHRoaXMuYWRhcHRpdmVDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZCArIDAuMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3VjY2VzcyByYXRlIGJhc2VkIGFkYXB0YXRpb25zXG4gICAgaWYgKGN1cnJlbnRTdWNjZXNzUmF0ZSA8IDAuMykge1xuICAgICAgYWRhcHRhdGlvbnMucHVzaCgnVmVyeSBsb3cgc3VjY2VzcyByYXRlIC0gc3dpdGNoaW5nIHRvIGRvY3VtZW50YXRpb24gbW9kZSByZWNvbW1lbmRlZCcpO1xuICAgICAgYWRhcHRhdGlvbnMucHVzaCgnQ29uc2lkZXIgbWFudWFsIHJldmlldyBvZiByZW1haW5pbmcgYW55IHR5cGVzJyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50U3VjY2Vzc1JhdGUgPCAwLjUpIHtcbiAgICAgIGFkYXB0YXRpb25zLnB1c2goJ0xvdyBzdWNjZXNzIHJhdGUgLSBpbmNyZWFzaW5nIGNvbmZpZGVuY2UgdGhyZXNob2xkIHRvIDAuOScpO1xuICAgICAgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkID0gTWF0aC5taW4oMC45NSwgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkICsgMC4xKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRTdWNjZXNzUmF0ZSA+IDAuOCkge1xuICAgICAgYWRhcHRhdGlvbnMucHVzaCgnSGlnaCBzdWNjZXNzIHJhdGUgLSBjYW4gYWZmb3JkIHRvIGJlIG1vcmUgYWdncmVzc2l2ZScpO1xuICAgICAgdGhpcy5hZGFwdGl2ZUNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkID0gTWF0aC5tYXgoMC43LCB0aGlzLmFkYXB0aXZlQ29uZmlnLmNvbmZpZGVuY2VUaHJlc2hvbGQgLSAwLjA1KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudFN1Y2Nlc3NSYXRlLFxuICAgICAgdHJlbmQsXG4gICAgICBhZGFwdGF0aW9uc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHNpbmdsZSBiYXRjaCBvZiBpbXByb3ZlbWVudHMgd2l0aCBhZGFwdGl2ZSBzaXppbmdcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVCYXRjaChjb25maWc/OiBVbmludGVudGlvbmFsQW55Q29uZmlnKTogUHJvbWlzZTxCYXRjaE1ldHJpY3M+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuYmF0Y2hDb3VudGVyKys7XG5cbiAgICAvLyBVc2UgYWRhcHRpdmUgY29uZmlnIGlmIG5vIGNvbmZpZyBwcm92aWRlZCwgb3IgbWVyZ2Ugd2l0aCBwcm92aWRlZCBjb25maWdcbiAgICBjb25zdCBlZmZlY3RpdmVDb25maWcgPSBjb25maWcgPyB7IC4uLnRoaXMuYWRhcHRpdmVDb25maWcsIC4uLmNvbmZpZyB9IDogdGhpcy5hZGFwdGl2ZUNvbmZpZztcblxuICAgIGNvbnN0IGJhdGNoTWV0cmljczogQmF0Y2hNZXRyaWNzID0ge1xuICAgICAgYmF0Y2hOdW1iZXI6IHRoaXMuYmF0Y2hDb3VudGVyLFxuICAgICAgZmlsZXNQcm9jZXNzZWQ6IDAsXG4gICAgICBhbnlUeXBlc0FuYWx5emVkOiAwLFxuICAgICAgcmVwbGFjZW1lbnRzQXR0ZW1wdGVkOiAwLFxuICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bDogMCxcbiAgICAgIGNvbXBpbGF0aW9uRXJyb3JzOiAwLFxuICAgICAgcm9sbGJhY2tzUGVyZm9ybWVkOiAwLFxuICAgICAgZXhlY3V0aW9uVGltZTogMCxcbiAgICAgIHNhZmV0eVNjb3JlOiAxLjBcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBzYWZldHkgY2hlY2twb2ludCBiZWZvcmUgc3RhcnRpbmdcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlU2FmZXR5Q2hlY2twb2ludCgpO1xuXG4gICAgICAvLyBHZXQgaW5pdGlhbCBUeXBlU2NyaXB0IGVycm9yIGNvdW50IGZvciBzYWZldHkgbW9uaXRvcmluZ1xuICAgICAgY29uc3QgaW5pdGlhbEVycm9yQ291bnQgPSBhd2FpdCB0aGlzLmdldFR5cGVTY3JpcHRFcnJvckNvdW50KCk7XG5cbiAgICAgIC8vIEZpbmQgZmlsZXMgd2l0aCBleHBsaWNpdCBhbnkgdHlwZXNcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZUZpbGVzID0gYXdhaXQgdGhpcy5maW5kRmlsZXNXaXRoQW55VHlwZXMoKTtcbiAgICAgIGNvbnN0IGZpbGVzVG9Qcm9jZXNzID0gY2FuZGlkYXRlRmlsZXNcbiAgICAgICAgLmZpbHRlcihmaWxlID0+ICF0aGlzLnByb2Nlc3NlZEZpbGVzLmhhcyhmaWxlKSlcbiAgICAgICAgLnNsaWNlKDAsIGVmZmVjdGl2ZUNvbmZpZy5tYXhGaWxlc1BlckJhdGNoKTtcblxuICAgICAgaWYgKGZpbGVzVG9Qcm9jZXNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gbW9yZSBmaWxlcyB0byBwcm9jZXNzIGluIHRoaXMgYmF0Y2gnKTtcbiAgICAgICAgYmF0Y2hNZXRyaWNzLmV4ZWN1dGlvblRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmJhdGNoSGlzdG9yeS5wdXNoKGJhdGNoTWV0cmljcyk7XG4gICAgICAgIHJldHVybiBiYXRjaE1ldHJpY3M7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGJhdGNoICR7dGhpcy5iYXRjaENvdW50ZXJ9OiAke2ZpbGVzVG9Qcm9jZXNzLmxlbmd0aH0gZmlsZXMgKGFkYXB0aXZlIGJhdGNoIHNpemU6ICR7ZWZmZWN0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2h9KWApO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggZmlsZVxuICAgICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlc1RvUHJvY2Vzcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGZpbGVSZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlKGZpbGVQYXRoLCBlZmZlY3RpdmVDb25maWcpO1xuXG4gICAgICAgICAgYmF0Y2hNZXRyaWNzLmZpbGVzUHJvY2Vzc2VkKys7XG4gICAgICAgICAgYmF0Y2hNZXRyaWNzLmFueVR5cGVzQW5hbHl6ZWQgKz0gZmlsZVJlc3VsdC5hbnlUeXBlc0FuYWx5emVkO1xuICAgICAgICAgIGJhdGNoTWV0cmljcy5yZXBsYWNlbWVudHNBdHRlbXB0ZWQgKz0gZmlsZVJlc3VsdC5yZXBsYWNlbWVudHNBdHRlbXB0ZWQ7XG4gICAgICAgICAgYmF0Y2hNZXRyaWNzLnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwgKz0gZmlsZVJlc3VsdC5yZXBsYWNlbWVudHNTdWNjZXNzZnVsO1xuXG4gICAgICAgICAgaWYgKGZpbGVSZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpIHtcbiAgICAgICAgICAgIGJhdGNoTWV0cmljcy5yb2xsYmFja3NQZXJmb3JtZWQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnByb2Nlc3NlZEZpbGVzLmFkZChmaWxlUGF0aCk7XG5cbiAgICAgICAgICAvLyBWYWxpZGF0ZSBidWlsZCBldmVyeSBmZXcgZmlsZXMgYmFzZWQgb24gYWRhcHRpdmUgY29uZmlnXG4gICAgICAgICAgaWYgKGJhdGNoTWV0cmljcy5maWxlc1Byb2Nlc3NlZCAlIGVmZmVjdGl2ZUNvbmZpZy52YWxpZGF0aW9uRnJlcXVlbmN5ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2FmZXR5IGNoZWNrcG9pbnQ6IHZhbGlkYXRpbmcgYnVpbGQgYWZ0ZXIgJHtiYXRjaE1ldHJpY3MuZmlsZXNQcm9jZXNzZWR9IGZpbGVzYCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RXJyb3JDb3VudCA9IGF3YWl0IHRoaXMuZ2V0VHlwZVNjcmlwdEVycm9yQ291bnQoKTtcblxuICAgICAgICAgICAgLy8gU2FmZXR5IGNoZWNrOiBlbnN1cmUgd2UncmUgbm90IGluY3JlYXNpbmcgZXJyb3JzIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIGlmIChjdXJyZW50RXJyb3JDb3VudCA+IGluaXRpYWxFcnJvckNvdW50ICsgNSkgeyAvLyBBbGxvdyBzbWFsbCBpbmNyZWFzZSBmb3IgdGVtcG9yYXJ5IHN0YXRlc1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGNvdW50IGluY3JlYXNlZCBmcm9tICR7aW5pdGlhbEVycm9yQ291bnR9IHRvICR7Y3VycmVudEVycm9yQ291bnR9LCBwYXVzaW5nIGJhdGNoYCk7XG4gICAgICAgICAgICAgIGJhdGNoTWV0cmljcy5jb21waWxhdGlvbkVycm9ycyA9IGN1cnJlbnRFcnJvckNvdW50IC0gaW5pdGlhbEVycm9yQ291bnQ7XG4gICAgICAgICAgICAgIGJhdGNoTWV0cmljcy5zYWZldHlTY29yZSA9IE1hdGgubWF4KDAsIDEgLSAoYmF0Y2hNZXRyaWNzLmNvbXBpbGF0aW9uRXJyb3JzIC8gMTApKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgZmlsZSAke2ZpbGVQYXRofTpgLCBlcnJvcik7XG4gICAgICAgICAgYmF0Y2hNZXRyaWNzLnJvbGxiYWNrc1BlcmZvcm1lZCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIHNhZmV0eSB2YWxpZGF0aW9uXG4gICAgICBjb25zdCBmaW5hbEVycm9yQ291bnQgPSBhd2FpdCB0aGlzLmdldFR5cGVTY3JpcHRFcnJvckNvdW50KCk7XG4gICAgICBpZiAoZmluYWxFcnJvckNvdW50ID4gaW5pdGlhbEVycm9yQ291bnQpIHtcbiAgICAgICAgYmF0Y2hNZXRyaWNzLmNvbXBpbGF0aW9uRXJyb3JzID0gZmluYWxFcnJvckNvdW50IC0gaW5pdGlhbEVycm9yQ291bnQ7XG4gICAgICAgIGJhdGNoTWV0cmljcy5zYWZldHlTY29yZSA9IE1hdGgubWF4KDAsIDEgLSAoYmF0Y2hNZXRyaWNzLmNvbXBpbGF0aW9uRXJyb3JzIC8gMjApKTtcbiAgICAgIH1cblxuICAgICAgYmF0Y2hNZXRyaWNzLmV4ZWN1dGlvblRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBTdG9yZSBiYXRjaCBtZXRyaWNzIGZvciBhZGFwdGl2ZSBzdHJhdGVneVxuICAgICAgdGhpcy5iYXRjaEhpc3RvcnkucHVzaChiYXRjaE1ldHJpY3MpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgc3VjY2VzcyByYXRlIGZvciB0aGlzIGJhdGNoXG4gICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IGJhdGNoTWV0cmljcy5yZXBsYWNlbWVudHNBdHRlbXB0ZWQgPiAwXG4gICAgICAgID8gYmF0Y2hNZXRyaWNzLnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwgLyBiYXRjaE1ldHJpY3MucmVwbGFjZW1lbnRzQXR0ZW1wdGVkXG4gICAgICAgIDogMDtcblxuICAgICAgY29uc29sZS5sb2coYEJhdGNoICR7dGhpcy5iYXRjaENvdW50ZXJ9IGNvbXBsZXRlZDpgLCB7XG4gICAgICAgIGZpbGVzUHJvY2Vzc2VkOiBiYXRjaE1ldHJpY3MuZmlsZXNQcm9jZXNzZWQsXG4gICAgICAgIHJlcGxhY2VtZW50c1N1Y2Nlc3NmdWw6IGJhdGNoTWV0cmljcy5yZXBsYWNlbWVudHNTdWNjZXNzZnVsLFxuICAgICAgICBzdWNjZXNzUmF0ZTogYCR7KHN1Y2Nlc3NSYXRlICogMTAwKS50b0ZpeGVkKDEpfSVgLFxuICAgICAgICBzYWZldHlTY29yZTogYmF0Y2hNZXRyaWNzLnNhZmV0eVNjb3JlLnRvRml4ZWQoMiksXG4gICAgICAgIGV4ZWN1dGlvblRpbWU6IGAkeyhiYXRjaE1ldHJpY3MuZXhlY3V0aW9uVGltZSAvIDEwMDApLnRvRml4ZWQoMSl9c2BcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGFwdCBzdHJhdGVneSBiYXNlZCBvbiBwZXJmb3JtYW5jZVxuICAgICAgdGhpcy5hZGFwdFN0cmF0ZWd5KCk7XG5cbiAgICAgIHJldHVybiBiYXRjaE1ldHJpY3M7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgQmF0Y2ggJHt0aGlzLmJhdGNoQ291bnRlcn0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIGJhdGNoTWV0cmljcy5leGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGJhdGNoTWV0cmljcy5zYWZldHlTY29yZSA9IDA7XG4gICAgICB0aGlzLmJhdGNoSGlzdG9yeS5wdXNoKGJhdGNoTWV0cmljcyk7XG4gICAgICByZXR1cm4gYmF0Y2hNZXRyaWNzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBmdWxsIGNhbXBhaWduIHdpdGggcHJvZ3Jlc3NpdmUgaW1wcm92ZW1lbnQgYW5kIGFkYXB0aXZlIHN0cmF0ZWdpZXNcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVGdWxsQ2FtcGFpZ24oY29uZmlnPzogVW5pbnRlbnRpb25hbEFueUNvbmZpZyk6IFByb21pc2U8VW5pbnRlbnRpb25hbEFueUNhbXBhaWduUmVzdWx0PiB7XG4gICAgY29uc3QgY2FtcGFpZ25TdGFydCA9IERhdGUubm93KCk7XG5cbiAgICAvLyBVc2UgYWRhcHRpdmUgY29uZmlnIGlmIG5vIGNvbmZpZyBwcm92aWRlZCwgb3IgbWVyZ2Ugd2l0aCBwcm92aWRlZCBjb25maWdcbiAgICBjb25zdCBlZmZlY3RpdmVDb25maWcgPSBjb25maWcgPyB7IC4uLnRoaXMuYWRhcHRpdmVDb25maWcsIC4uLmNvbmZpZyB9IDogdGhpcy5hZGFwdGl2ZUNvbmZpZztcblxuICAgIGNvbnN0IGluaXRpYWxQcm9ncmVzcyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFByb2dyZXNzKCk7XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgVW5pbnRlbnRpb25hbCBBbnkgRWxpbWluYXRpb24gQ2FtcGFpZ24nKTtcbiAgICBjb25zb2xlLmxvZyhgSW5pdGlhbCBzdGF0ZTogJHtpbml0aWFsUHJvZ3Jlc3MudG90YWxBbnlUeXBlc30gYW55IHR5cGVzIGZvdW5kYCk7XG4gICAgY29uc29sZS5sb2coYFRhcmdldDogJHtlZmZlY3RpdmVDb25maWcudGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZX0lIHJlZHVjdGlvbmApO1xuICAgIGNvbnNvbGUubG9nKGBJbml0aWFsIGJhdGNoIHNpemU6ICR7ZWZmZWN0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2h9LCBjb25maWRlbmNlIHRocmVzaG9sZDogJHtlZmZlY3RpdmVDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZH1gKTtcblxuICAgIGNvbnN0IHJlc3VsdDogVW5pbnRlbnRpb25hbEFueUNhbXBhaWduUmVzdWx0ID0ge1xuICAgICAgdG90YWxBbnlUeXBlc0FuYWx5emVkOiAwLFxuICAgICAgaW50ZW50aW9uYWxUeXBlc0lkZW50aWZpZWQ6IDAsXG4gICAgICB1bmludGVudGlvbmFsVHlwZXNSZXBsYWNlZDogMCxcbiAgICAgIGRvY3VtZW50YXRpb25BZGRlZDogMCxcbiAgICAgIHJlZHVjdGlvbkFjaGlldmVkOiAwLFxuICAgICAgc2FmZXR5RXZlbnRzOiBbXSxcbiAgICAgIHZhbGlkYXRpb25SZXN1bHRzOiBbXVxuICAgIH07XG5cbiAgICBsZXQgYmF0Y2hDb3VudCA9IDA7XG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIGNvbnN0IG1heENvbnNlY3V0aXZlRmFpbHVyZXMgPSAzO1xuICAgIGNvbnN0IG1heEJhdGNoZXMgPSA1MDsgLy8gU2FmZXR5IGxpbWl0XG5cbiAgICB3aGlsZSAoYmF0Y2hDb3VudCA8IG1heEJhdGNoZXMgJiYgY29uc2VjdXRpdmVGYWlsdXJlcyA8IG1heENvbnNlY3V0aXZlRmFpbHVyZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4tLS0gU3RhcnRpbmcgYmF0Y2ggJHtiYXRjaENvdW50ICsgMX0gLS0tYCk7XG4gICAgICAgIGNvbnN0IGJhdGNoTWV0cmljcyA9IGF3YWl0IHRoaXMuZXhlY3V0ZUJhdGNoKCk7XG4gICAgICAgIGJhdGNoQ291bnQrKztcblxuICAgICAgICByZXN1bHQudG90YWxBbnlUeXBlc0FuYWx5emVkICs9IGJhdGNoTWV0cmljcy5hbnlUeXBlc0FuYWx5emVkO1xuICAgICAgICByZXN1bHQudW5pbnRlbnRpb25hbFR5cGVzUmVwbGFjZWQgKz0gYmF0Y2hNZXRyaWNzLnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWw7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGNvbnRpbnVlXG4gICAgICAgIGlmIChiYXRjaE1ldHJpY3MuZmlsZXNQcm9jZXNzZWQgPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gbW9yZSBmaWxlcyB0byBwcm9jZXNzLCBjYW1wYWlnbiBjb21wbGV0ZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2FmZXR5IGNoZWNrIHdpdGggYWRhcHRpdmUgcmVzcG9uc2VcbiAgICAgICAgaWYgKGJhdGNoTWV0cmljcy5zYWZldHlTY29yZSA8IDAuNykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgTG93IHNhZmV0eSBzY29yZSAoJHtiYXRjaE1ldHJpY3Muc2FmZXR5U2NvcmUudG9GaXhlZCgyKX0pLCBhZGFwdGluZyBzdHJhdGVneWApO1xuICAgICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMrKztcblxuICAgICAgICAgIHJlc3VsdC5zYWZldHlFdmVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnTE9XX1NBRkVUWV9TQ09SRScsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFNhZmV0eSBzY29yZSAke2JhdGNoTWV0cmljcy5zYWZldHlTY29yZS50b0ZpeGVkKDIpfSBiZWxvdyB0aHJlc2hvbGRgLFxuICAgICAgICAgICAgc2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIGJhdGNoTnVtYmVyOiBiYXRjaENvdW50XG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBwcm9ncmVzcyB0b3dhcmRzIHRhcmdldCB3aXRoIGRldGFpbGVkIHJlcG9ydGluZ1xuICAgICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRQcm9ncmVzcygpO1xuICAgICAgICBjb25zdCByZWR1Y3Rpb25BY2hpZXZlZCA9IGluaXRpYWxQcm9ncmVzcy50b3RhbEFueVR5cGVzID4gMFxuICAgICAgICAgID8gKChpbml0aWFsUHJvZ3Jlc3MudG90YWxBbnlUeXBlcyAtIGN1cnJlbnRQcm9ncmVzcy50b3RhbEFueVR5cGVzKSAvIGluaXRpYWxQcm9ncmVzcy50b3RhbEFueVR5cGVzKSAqIDEwMFxuICAgICAgICAgIDogMDtcblxuICAgICAgICBjb25zb2xlLmxvZyhgXFxuUHJvZ3Jlc3MgUmVwb3J0OmApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBSZWR1Y3Rpb24gYWNoaWV2ZWQ6ICR7cmVkdWN0aW9uQWNoaWV2ZWQudG9GaXhlZCgxKX0lICh0YXJnZXQ6ICR7ZWZmZWN0aXZlQ29uZmlnLnRhcmdldFJlZHVjdGlvblBlcmNlbnRhZ2V9JSlgKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgVHlwZXMgcmVwbGFjZWQ6ICR7cmVzdWx0LnVuaW50ZW50aW9uYWxUeXBlc1JlcGxhY2VkfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBCYXRjaGVzIGNvbXBsZXRlZDogJHtiYXRjaENvdW50fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBDdXJyZW50IGJhdGNoIHNpemU6ICR7dGhpcy5hZGFwdGl2ZUNvbmZpZy5tYXhGaWxlc1BlckJhdGNofWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBDdXJyZW50IGNvbmZpZGVuY2UgdGhyZXNob2xkOiAke3RoaXMuYWRhcHRpdmVDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZC50b0ZpeGVkKDIpfWApO1xuXG4gICAgICAgIGlmIChyZWR1Y3Rpb25BY2hpZXZlZCA+PSBlZmZlY3RpdmVDb25maWcudGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdcXG7wn46JIFRhcmdldCByZWR1Y3Rpb24gYWNoaWV2ZWQhJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCcmllZiBwYXVzZSBiZXR3ZWVuIGJhdGNoZXMgZm9yIHN5c3RlbSBzdGFiaWxpdHlcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQ2FtcGFpZ24gYmF0Y2ggJHtiYXRjaENvdW50ICsgMX0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcysrO1xuXG4gICAgICAgIHJlc3VsdC5zYWZldHlFdmVudHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ0JBVENIX0ZBSUxVUkUnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJhdGNoICR7YmF0Y2hDb3VudCArIDF9IGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICAgICAgYmF0Y2hOdW1iZXI6IGJhdGNoQ291bnQgKyAxXG4gICAgICAgIH0gYXMgYW55KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgZmluYWwgcmVzdWx0cyB3aXRoIGNvbXByZWhlbnNpdmUgbWV0cmljc1xuICAgIGNvbnN0IGZpbmFsUHJvZ3Jlc3MgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRQcm9ncmVzcygpO1xuICAgIHJlc3VsdC5yZWR1Y3Rpb25BY2hpZXZlZCA9IGluaXRpYWxQcm9ncmVzcy50b3RhbEFueVR5cGVzID4gMFxuICAgICAgPyAoKGluaXRpYWxQcm9ncmVzcy50b3RhbEFueVR5cGVzIC0gZmluYWxQcm9ncmVzcy50b3RhbEFueVR5cGVzKSAvIGluaXRpYWxQcm9ncmVzcy50b3RhbEFueVR5cGVzKSAqIDEwMFxuICAgICAgOiAwO1xuICAgIHJlc3VsdC5pbnRlbnRpb25hbFR5cGVzSWRlbnRpZmllZCA9IGZpbmFsUHJvZ3Jlc3MuY2xhc3NpZmllZEludGVudGlvbmFsO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugc3VjY2VzcyByYXRlIGZyb20gYmF0Y2ggaGlzdG9yeVxuICAgIGNvbnN0IHRvdGFsQXR0ZW1wdGVkID0gdGhpcy5iYXRjaEhpc3RvcnkucmVkdWNlKChzdW0sIGJhdGNoKSA9PiBzdW0gKyBiYXRjaC5yZXBsYWNlbWVudHNBdHRlbXB0ZWQsIDApO1xuICAgIGNvbnN0IHRvdGFsU3VjY2Vzc2Z1bCA9IHRoaXMuYmF0Y2hIaXN0b3J5LnJlZHVjZSgoc3VtLCBiYXRjaCkgPT4gc3VtICsgYmF0Y2gucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCwgMCk7XG4gICAgY29uc3Qgb3ZlcmFsbFN1Y2Nlc3NSYXRlID0gdG90YWxBdHRlbXB0ZWQgPiAwID8gKHRvdGFsU3VjY2Vzc2Z1bCAvIHRvdGFsQXR0ZW1wdGVkKSAqIDEwMCA6IDA7XG5cbiAgICBjb25zdCBjYW1wYWlnblRpbWUgPSBEYXRlLm5vdygpIC0gY2FtcGFpZ25TdGFydDtcblxuICAgIGNvbnNvbGUubG9nKGBcXG49PT0gQ2FtcGFpZ24gU3VtbWFyeSA9PT1gKTtcbiAgICBjb25zb2xlLmxvZyhgRHVyYXRpb246ICR7KGNhbXBhaWduVGltZSAvIDEwMDApLnRvRml4ZWQoMSl9c2ApO1xuICAgIGNvbnNvbGUubG9nKGBCYXRjaGVzIHByb2Nlc3NlZDogJHtiYXRjaENvdW50fWApO1xuICAgIGNvbnNvbGUubG9nKGBGaWxlcyBwcm9jZXNzZWQ6ICR7dGhpcy5wcm9jZXNzZWRGaWxlcy5zaXplfWApO1xuICAgIGNvbnNvbGUubG9nKGBSZWR1Y3Rpb24gYWNoaWV2ZWQ6ICR7cmVzdWx0LnJlZHVjdGlvbkFjaGlldmVkLnRvRml4ZWQoMSl9JWApO1xuICAgIGNvbnNvbGUubG9nKGBUeXBlcyByZXBsYWNlZDogJHtyZXN1bHQudW5pbnRlbnRpb25hbFR5cGVzUmVwbGFjZWR9YCk7XG4gICAgY29uc29sZS5sb2coYE92ZXJhbGwgc3VjY2VzcyByYXRlOiAke292ZXJhbGxTdWNjZXNzUmF0ZS50b0ZpeGVkKDEpfSVgKTtcbiAgICBjb25zb2xlLmxvZyhgU2FmZXR5IGV2ZW50czogJHtyZXN1bHQuc2FmZXR5RXZlbnRzLmxlbmd0aH1gKTtcbiAgICBjb25zb2xlLmxvZyhgRmluYWwgYmF0Y2ggc2l6ZTogJHt0aGlzLmFkYXB0aXZlQ29uZmlnLm1heEZpbGVzUGVyQmF0Y2h9YCk7XG4gICAgY29uc29sZS5sb2coYEZpbmFsIGNvbmZpZGVuY2UgdGhyZXNob2xkOiAke3RoaXMuYWRhcHRpdmVDb25maWcuY29uZmlkZW5jZVRocmVzaG9sZC50b0ZpeGVkKDIpfWApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0ZpbGUoZmlsZVBhdGg6IHN0cmluZywgY29uZmlnOiBVbmludGVudGlvbmFsQW55Q29uZmlnKTogUHJvbWlzZTx7XG4gICAgYW55VHlwZXNBbmFseXplZDogbnVtYmVyO1xuICAgIHJlcGxhY2VtZW50c0F0dGVtcHRlZDogbnVtYmVyO1xuICAgIHJlcGxhY2VtZW50c1N1Y2Nlc3NmdWw6IG51bWJlcjtcbiAgICByb2xsYmFja1BlcmZvcm1lZDogYm9vbGVhbjtcbiAgfT4ge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IGxpbmVzID0gZmlsZUNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuXG4gICAgLy8gRmluZCBhbGwgYW55IHR5cGUgdXNhZ2VzIGluIHRoZSBmaWxlXG4gICAgY29uc3QgYW55VHlwZUNvbnRleHRzOiBDbGFzc2lmaWNhdGlvbkNvbnRleHRbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgaWYgKHRoaXMuY29udGFpbnNBbnlUeXBlKGxpbmUpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBpICsgMSxcbiAgICAgICAgICBjb2RlU25pcHBldDogbGluZSxcbiAgICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiB0aGlzLmdldFN1cnJvdW5kaW5nTGluZXMobGluZXMsIGksIDIpLFxuICAgICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogdGhpcy5oYXNDb21tZW50QWJvdmUobGluZXMsIGkpLFxuICAgICAgICAgIGV4aXN0aW5nQ29tbWVudDogdGhpcy5nZXRDb21tZW50QWJvdmUobGluZXMsIGkpLFxuICAgICAgICAgIGlzSW5UZXN0RmlsZTogdGhpcy5pc1Rlc3RGaWxlKGZpbGVQYXRoKSxcbiAgICAgICAgICBkb21haW5Db250ZXh0OiBhd2FpdCB0aGlzLmFuYWx5emVyLmFuYWx5emVEb21haW4oe1xuICAgICAgICAgICAgZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBpICsgMSxcbiAgICAgICAgICAgIGNvZGVTbmlwcGV0OiBsaW5lLFxuICAgICAgICAgICAgc3Vycm91bmRpbmdMaW5lczogdGhpcy5nZXRTdXJyb3VuZGluZ0xpbmVzKGxpbmVzLCBpLCAyKSxcbiAgICAgICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICBpc0luVGVzdEZpbGU6IHRoaXMuaXNUZXN0RmlsZShmaWxlUGF0aCksXG4gICAgICAgICAgICBkb21haW5Db250ZXh0OiB7IGRvbWFpbjogJ3V0aWxpdHknIGFzIGFueSwgaW50ZW50aW9uYWxpdHlIaW50czogW10sIHN1Z2dlc3RlZFR5cGVzOiBbXSwgcHJlc2VydmF0aW9uUmVhc29uczogW10gfVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgYW55VHlwZUNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFueVR5cGVDb250ZXh0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFueVR5cGVzQW5hbHl6ZWQ6IDAsXG4gICAgICAgIHJlcGxhY2VtZW50c0F0dGVtcHRlZDogMCxcbiAgICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bDogMCxcbiAgICAgICAgcm9sbGJhY2tQZXJmb3JtZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENsYXNzaWZ5IGFsbCBhbnkgdHlwZXMgaW4gdGhlIGZpbGVcbiAgICBjb25zdCBjbGFzc2lmaWNhdGlvbnMgPSBhd2FpdCB0aGlzLmNsYXNzaWZpZXIuY2xhc3NpZnlCYXRjaChhbnlUeXBlQ29udGV4dHMpO1xuXG4gICAgLy8gQ3JlYXRlIHJlcGxhY2VtZW50cyBmb3IgdW5pbnRlbnRpb25hbCBhbnkgdHlwZXNcbiAgICBjb25zdCByZXBsYWNlbWVudHM6IFR5cGVSZXBsYWNlbWVudFtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzaWZpY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2xhc3NpZmljYXRpb24gPSBjbGFzc2lmaWNhdGlvbnNbaV07XG4gICAgICBjb25zdCBjb250ZXh0ID0gYW55VHlwZUNvbnRleHRzW2ldO1xuXG4gICAgICBpZiAoIWNsYXNzaWZpY2F0aW9uLmlzSW50ZW50aW9uYWwgJiZcbiAgICAgICAgICBjbGFzc2lmaWNhdGlvbi5jb25maWRlbmNlID49IGNvbmZpZy5jb25maWRlbmNlVGhyZXNob2xkICYmXG4gICAgICAgICAgY2xhc3NpZmljYXRpb24uc3VnZ2VzdGVkUmVwbGFjZW1lbnQpIHtcblxuICAgICAgICByZXBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiBjbGFzc2lmaWNhdGlvbi5zdWdnZXN0ZWRSZXBsYWNlbWVudCxcbiAgICAgICAgICBmaWxlUGF0aDogY29udGV4dC5maWxlUGF0aCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBjb250ZXh0LmxpbmVOdW1iZXIsXG4gICAgICAgICAgY29uZmlkZW5jZTogY2xhc3NpZmljYXRpb24uY29uZmlkZW5jZSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgcmVwbGFjZW1lbnRzXG4gICAgbGV0IHJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwgPSAwO1xuICAgIGxldCByb2xsYmFja1BlcmZvcm1lZCA9IGZhbHNlO1xuXG4gICAgaWYgKHJlcGxhY2VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcGxhY2VyLnByb2Nlc3NCYXRjaChyZXBsYWNlbWVudHMpO1xuICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCA9IHJlc3VsdC5hcHBsaWVkUmVwbGFjZW1lbnRzLmxlbmd0aDtcbiAgICAgIHJvbGxiYWNrUGVyZm9ybWVkID0gcmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhbnlUeXBlc0FuYWx5emVkOiBhbnlUeXBlQ29udGV4dHMubGVuZ3RoLFxuICAgICAgcmVwbGFjZW1lbnRzQXR0ZW1wdGVkOiByZXBsYWNlbWVudHMubGVuZ3RoLFxuICAgICAgcmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCxcbiAgICAgIHJvbGxiYWNrUGVyZm9ybWVkXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZEZpbGVzV2l0aEFueVR5cGVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGdyZXAgdG8gZmluZCBmaWxlcyB3aXRoIGV4cGxpY2l0IGFueSB0eXBlcywgZXhjbHVkaW5nIG5vZGVfbW9kdWxlcyBhbmQgdGVzdCBmaWxlcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKFxuICAgICAgICAnZ3JlcCAtciAtbCBcIjpcXFxccyphbnlcIiBzcmMvIC0taW5jbHVkZT1cIioudHNcIiAtLWluY2x1ZGU9XCIqLnRzeFwiIC0tZXhjbHVkZS1kaXI9bm9kZV9tb2R1bGVzIHwgaGVhZCAtMTAwJyxcbiAgICAgICAgeyBlbmNvZGluZzogJ3V0ZjgnLCBzdGRpbzogJ3BpcGUnIH1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBvdXRwdXQudHJpbSgpLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKS5sZW5ndGggPiAwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZmluZCBmaWxlcyB3aXRoIGFueSB0eXBlcywgdXNpbmcgZmFsbGJhY2sgbWV0aG9kJyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5kRmlsZXNXaXRoQW55VHlwZXNGYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmluZEZpbGVzV2l0aEFueVR5cGVzRmFsbGJhY2soKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHNyY0RpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnc3JjJyk7XG5cbiAgICBjb25zdCB3YWxrRGlyID0gKGRpcjogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpICYmICFlbnRyeS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSAmJiBlbnRyeS5uYW1lICE9PSAnbm9kZV9tb2R1bGVzJykge1xuICAgICAgICAgIHdhbGtEaXIoZnVsbFBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRmlsZSgpICYmIChlbnRyeS5uYW1lLmVuZHNXaXRoKCcudHMnKSB8fCBlbnRyeS5uYW1lLmVuZHNXaXRoKCcudHN4JykpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZnVsbFBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgICBpZiAoY29udGVudC5pbmNsdWRlcygnOiBhbnknKSB8fCBjb250ZW50LmluY2x1ZGVzKCdhbnlbXScpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ1JlY29yZDxzdHJpbmcsIGFueT4nKSkge1xuICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZ1bGxQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gU2tpcCBmaWxlcyB0aGF0IGNhbid0IGJlIHJlYWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoc3JjRGlyKSkge1xuICAgICAgd2Fsa0RpcihzcmNEaXIpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlcy5zbGljZSgwLCAxMDApOyAvLyBMaW1pdCB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZ1xuICB9XG5cbiAgcHJpdmF0ZSBjb250YWluc0FueVR5cGUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gTWF0Y2ggdmFyaW91cyBhbnkgdHlwZSBwYXR0ZXJuc1xuICAgIGNvbnN0IGFueVBhdHRlcm5zID0gW1xuICAgICAgLzpcXHMqYW55KD89XFxzKls9OyxcXClcXF1cXH1dKS8sICAvLyA6IGFueSBmb2xsb3dlZCBieSBkZWxpbWl0ZXJcbiAgICAgIC86XFxzKmFueVxcW1xcXS8sICAgICAgICAgICAgICAgIC8vIDogYW55W11cbiAgICAgIC86XFxzKkFycmF5PGFueT4vLCAgICAgICAgICAgICAvLyA6IEFycmF5PGFueT5cbiAgICAgIC86XFxzKlJlY29yZDxcXHcrLFxccyphbnk+LywgICAgIC8vIDogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgL1xcW2tleTpcXHMqXFx3K1xcXTpcXHMqYW55LyAgICAgICAvLyBba2V5OiBzdHJpbmddOiBhbnlcbiAgICBdO1xuXG4gICAgcmV0dXJuIGFueVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QobGluZSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdXJyb3VuZGluZ0xpbmVzKGxpbmVzOiBzdHJpbmdbXSwgaW5kZXg6IG51bWJlciwgcmFkaXVzOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBpbmRleCAtIHJhZGl1cyk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBpbmRleCArIHJhZGl1cyArIDEpO1xuICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFzQ29tbWVudEFib3ZlKGxpbmVzOiBzdHJpbmdbXSwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHByZXZMaW5lID0gbGluZXNbaW5kZXggLSAxXS50cmltKCk7XG4gICAgcmV0dXJuIHByZXZMaW5lLnN0YXJ0c1dpdGgoJy8vJykgfHwgcHJldkxpbmUuc3RhcnRzV2l0aCgnLyonKSB8fCBwcmV2TGluZS5pbmNsdWRlcygnKi8nKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q29tbWVudEFib3ZlKGxpbmVzOiBzdHJpbmdbXSwgaW5kZXg6IG51bWJlcik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCF0aGlzLmhhc0NvbW1lbnRBYm92ZShsaW5lcywgaW5kZXgpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBsaW5lc1tpbmRleCAtIDFdLnRyaW0oKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNUZXN0RmlsZShmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZpbGVQYXRoLmluY2x1ZGVzKCd0ZXN0JykgfHxcbiAgICAgICAgICAgZmlsZVBhdGguaW5jbHVkZXMoJ3NwZWMnKSB8fFxuICAgICAgICAgICBmaWxlUGF0aC5pbmNsdWRlcygnX190ZXN0c19fJykgfHxcbiAgICAgICAgICAgZmlsZVBhdGguZW5kc1dpdGgoJy50ZXN0LnRzJykgfHxcbiAgICAgICAgICAgZmlsZVBhdGguZW5kc1dpdGgoJy50ZXN0LnRzeCcpIHx8XG4gICAgICAgICAgIGZpbGVQYXRoLmVuZHNXaXRoKCcuc3BlYy50cycpIHx8XG4gICAgICAgICAgIGZpbGVQYXRoLmVuZHNXaXRoKCcuc3BlYy50c3gnKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0VHlwZVNjcmlwdEVycm9yQ291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoJ3lhcm4gdHNjIC0tbm9FbWl0IC0tc2tpcExpYkNoZWNrIDI+JjEgfCBncmVwIC1jIFwiZXJyb3IgVFNcIicsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgc3RkaW86ICdwaXBlJ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VJbnQob3V0cHV0LnRyaW0oKSkgfHwgMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgZ3JlcCBmaW5kcyBubyBtYXRjaGVzLCBpdCByZXR1cm5zIGV4aXQgY29kZSAxLCBidXQgdGhhdCBtZWFucyAwIGVycm9yc1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gZXJyb3IgYXMgYW55O1xuICAgICAgaWYgKGVycm9yRGF0YS5zdGF0dXMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBnZXQgVHlwZVNjcmlwdCBlcnJvciBjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gLTE7IC8vIEluZGljYXRlcyBtZWFzdXJlbWVudCBmYWlsdXJlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFuYWx5emUgZmlsZSBjb21wbGV4aXR5IHRvIHNldCByZWFsaXN0aWMgZXhwZWN0YXRpb25zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGFuYWx5emVGaWxlQ29tcGxleGl0eShmaWxlczogc3RyaW5nW10pOiBQcm9taXNlPHtcbiAgICB0ZXN0RmlsZVBlcmNlbnRhZ2U6IG51bWJlcjtcbiAgICBhcnJheVR5cGVQZXJjZW50YWdlOiBudW1iZXI7XG4gICAgcmVjb3JkVHlwZVBlcmNlbnRhZ2U6IG51bWJlcjtcbiAgICBmdW5jdGlvblBhcmFtUGVyY2VudGFnZTogbnVtYmVyO1xuICAgIGNvbXBsZXhpdHlTY29yZTogbnVtYmVyO1xuICB9PiB7XG4gICAgbGV0IHRlc3RGaWxlcyA9IDA7XG4gICAgbGV0IGFycmF5VHlwZXMgPSAwO1xuICAgIGxldCByZWNvcmRUeXBlcyA9IDA7XG4gICAgbGV0IGZ1bmN0aW9uUGFyYW1zID0gMDtcbiAgICBsZXQgdG90YWxBbnlUeXBlcyA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGZpbGVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVGVzdEZpbGUoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgdGVzdEZpbGVzKys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5jb250YWluc0FueVR5cGUobGluZSkpIHtcbiAgICAgICAgICAgIHRvdGFsQW55VHlwZXMrKztcblxuICAgICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ2FueVtdJykgfHwgbGluZS5pbmNsdWRlcygnQXJyYXk8YW55PicpKSB7XG4gICAgICAgICAgICAgIGFycmF5VHlwZXMrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5pbmNsdWRlcygnUmVjb3JkPCcpICYmIGxpbmUuaW5jbHVkZXMoJ2FueT4nKSkge1xuICAgICAgICAgICAgICByZWNvcmRUeXBlcysrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCcoJykgJiYgbGluZS5pbmNsdWRlcygnOiBhbnknKSAmJiBsaW5lLmluY2x1ZGVzKCcpJykpIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFNraXAgZmlsZXMgdGhhdCBjYW4ndCBiZSByZWFkXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGVzdEZpbGVQZXJjZW50YWdlID0gZmlsZXMubGVuZ3RoID4gMCA/ICh0ZXN0RmlsZXMgLyBmaWxlcy5sZW5ndGgpICogMTAwIDogMDtcbiAgICBjb25zdCBhcnJheVR5cGVQZXJjZW50YWdlID0gdG90YWxBbnlUeXBlcyA+IDAgPyAoYXJyYXlUeXBlcyAvIHRvdGFsQW55VHlwZXMpICogMTAwIDogMDtcbiAgICBjb25zdCByZWNvcmRUeXBlUGVyY2VudGFnZSA9IHRvdGFsQW55VHlwZXMgPiAwID8gKHJlY29yZFR5cGVzIC8gdG90YWxBbnlUeXBlcykgKiAxMDAgOiAwO1xuICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1QZXJjZW50YWdlID0gdG90YWxBbnlUeXBlcyA+IDAgPyAoZnVuY3Rpb25QYXJhbXMgLyB0b3RhbEFueVR5cGVzKSAqIDEwMCA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgY29tcGxleGl0eSBzY29yZSAoMC0xLCB3aGVyZSAxIGlzIG1vc3QgY29tcGxleClcbiAgICBjb25zdCBjb21wbGV4aXR5U2NvcmUgPSBNYXRoLm1pbigxLFxuICAgICAgKHRlc3RGaWxlUGVyY2VudGFnZSAqIDAuMSArIC8vIFRlc3QgZmlsZXMgYXJlIGVhc2llclxuICAgICAgIGZ1bmN0aW9uUGFyYW1QZXJjZW50YWdlICogMC40ICsgLy8gRnVuY3Rpb24gcGFyYW1zIGFyZSBoYXJkZXJcbiAgICAgICByZWNvcmRUeXBlUGVyY2VudGFnZSAqIDAuMikgLyAxMDAgLy8gUmVjb3JkIHR5cGVzIGFyZSBtb2RlcmF0ZVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGVzdEZpbGVQZXJjZW50YWdlLFxuICAgICAgYXJyYXlUeXBlUGVyY2VudGFnZSxcbiAgICAgIHJlY29yZFR5cGVQZXJjZW50YWdlLFxuICAgICAgZnVuY3Rpb25QYXJhbVBlcmNlbnRhZ2UsXG4gICAgICBjb21wbGV4aXR5U2NvcmVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBleHBlY3RlZCBzdWNjZXNzIHJhdGUgYmFzZWQgb24gZmlsZSBhbmFseXNpc1xuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVFeHBlY3RlZFN1Y2Nlc3NSYXRlKGFuYWx5c2lzOiB7XG4gICAgdGVzdEZpbGVQZXJjZW50YWdlOiBudW1iZXI7XG4gICAgYXJyYXlUeXBlUGVyY2VudGFnZTogbnVtYmVyO1xuICAgIHJlY29yZFR5cGVQZXJjZW50YWdlOiBudW1iZXI7XG4gICAgZnVuY3Rpb25QYXJhbVBlcmNlbnRhZ2U6IG51bWJlcjtcbiAgICBjb21wbGV4aXR5U2NvcmU6IG51bWJlcjtcbiAgfSk6IG51bWJlciB7XG4gICAgLy8gQmFzZSBzdWNjZXNzIHJhdGUgZXhwZWN0YXRpb25zIGJhc2VkIG9uIGhpc3RvcmljYWwgZGF0YVxuICAgIGxldCBleHBlY3RlZFJhdGUgPSAwLjY7IC8vIDYwJSBiYXNlIGV4cGVjdGF0aW9uXG5cbiAgICAvLyBBcnJheSB0eXBlcyBoYXZlIGhpc3RvcmljYWxseSAxMDAlIHN1Y2Nlc3MgcmF0ZVxuICAgIGV4cGVjdGVkUmF0ZSArPSAoYW5hbHlzaXMuYXJyYXlUeXBlUGVyY2VudGFnZSAvIDEwMCkgKiAwLjQ7XG5cbiAgICAvLyBSZWNvcmQgdHlwZXMgaGF2ZSBtaXhlZCByZXN1bHRzIC0gbW9kZXJhdGUgYm9vc3RcbiAgICBleHBlY3RlZFJhdGUgKz0gKGFuYWx5c2lzLnJlY29yZFR5cGVQZXJjZW50YWdlIC8gMTAwKSAqIDAuMTtcblxuICAgIC8vIEZ1bmN0aW9uIHBhcmFtZXRlcnMgaGF2ZSBoaWdoIGZhaWx1cmUgcmF0ZSAtIHBlbmFsdHlcbiAgICBleHBlY3RlZFJhdGUgLT0gKGFuYWx5c2lzLmZ1bmN0aW9uUGFyYW1QZXJjZW50YWdlIC8gMTAwKSAqIDAuMztcblxuICAgIC8vIFRlc3QgZmlsZXMgYXJlIGdlbmVyYWxseSBlYXNpZXIgYnV0IGxlc3MgaW1wYWN0ZnVsXG4gICAgZXhwZWN0ZWRSYXRlICs9IChhbmFseXNpcy50ZXN0RmlsZVBlcmNlbnRhZ2UgLyAxMDApICogMC4xO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAuMiwgTWF0aC5taW4oMC45LCBleHBlY3RlZFJhdGUpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q3VycmVudFByb2dyZXNzKCk6IFByb21pc2U8VW5pbnRlbnRpb25hbEFueVByb2dyZXNzPiB7XG4gICAgY29uc3QgdG90YWxGaWxlcyA9IGF3YWl0IHRoaXMuZmluZEZpbGVzV2l0aEFueVR5cGVzKCk7XG4gICAgbGV0IHRvdGFsQW55VHlwZXMgPSAwO1xuXG4gICAgLy8gQ291bnQgdG90YWwgYW55IHR5cGVzIGFjcm9zcyBhbGwgZmlsZXMgKHNhbXBsZSBmb3IgcGVyZm9ybWFuY2UpXG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IE1hdGgubWluKDMwLCB0b3RhbEZpbGVzLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiB0b3RhbEZpbGVzLnNsaWNlKDAsIHNhbXBsZVNpemUpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICB0b3RhbEFueVR5cGVzICs9IGxpbmVzLmZpbHRlcihsaW5lID0+IHRoaXMuY29udGFpbnNBbnlUeXBlKGxpbmUpKS5sZW5ndGg7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBTa2lwIGZpbGVzIHRoYXQgY2FuJ3QgYmUgcmVhZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVzdGltYXRlIHRvdGFsIGJhc2VkIG9uIHNhbXBsZVxuICAgIGNvbnN0IGVzdGltYXRlZFRvdGFsID0gc2FtcGxlU2l6ZSA+IDBcbiAgICAgID8gTWF0aC5mbG9vcigodG90YWxBbnlUeXBlcyAvIHNhbXBsZVNpemUpICogdG90YWxGaWxlcy5sZW5ndGgpXG4gICAgICA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgbWV0cmljcyBmcm9tIGJhdGNoIGhpc3RvcnlcbiAgICBjb25zdCB0b3RhbFJlcGxhY2VtZW50cyA9IHRoaXMuYmF0Y2hIaXN0b3J5LnJlZHVjZSgoc3VtLCBiYXRjaCkgPT4gc3VtICsgYmF0Y2gucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCwgMCk7XG4gICAgY29uc3QgdG90YWxBdHRlbXB0ZWQgPSB0aGlzLmJhdGNoSGlzdG9yeS5yZWR1Y2UoKHN1bSwgYmF0Y2gpID0+IHN1bSArIGJhdGNoLnJlcGxhY2VtZW50c0F0dGVtcHRlZCwgMCk7XG4gICAgY29uc3QgYXZlcmFnZVN1Y2Nlc3NSYXRlID0gdG90YWxBdHRlbXB0ZWQgPiAwID8gdG90YWxSZXBsYWNlbWVudHMgLyB0b3RhbEF0dGVtcHRlZCA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgcmVkdWN0aW9uIHBlcmNlbnRhZ2VcbiAgICBjb25zdCByZWR1Y3Rpb25QZXJjZW50YWdlID0gZXN0aW1hdGVkVG90YWwgPiAwID8gKHRvdGFsUmVwbGFjZW1lbnRzIC8gZXN0aW1hdGVkVG90YWwpICogMTAwIDogMDtcblxuICAgIC8vIEdldCBjdXJyZW50IFR5cGVTY3JpcHQgZXJyb3IgY291bnQgZm9yIGNvbXByZWhlbnNpdmUgbWV0cmljc1xuICAgIGNvbnN0IGN1cnJlbnRUU0Vycm9ycyA9IGF3YWl0IHRoaXMuZ2V0VHlwZVNjcmlwdEVycm9yQ291bnQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEFueVR5cGVzOiBlc3RpbWF0ZWRUb3RhbCxcbiAgICAgIGNsYXNzaWZpZWRJbnRlbnRpb25hbDogMCwgLy8gV291bGQgYmUgdHJhY2tlZCB3aXRoIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAgY2xhc3NpZmllZFVuaW50ZW50aW9uYWw6IHRvdGFsQXR0ZW1wdGVkLFxuICAgICAgc3VjY2Vzc2Z1bFJlcGxhY2VtZW50czogdG90YWxSZXBsYWNlbWVudHMsXG4gICAgICBkb2N1bWVudGVkSW50ZW50aW9uYWw6IDAsIC8vIFdvdWxkIGJlIHRyYWNrZWQgd2l0aCBkb2N1bWVudGF0aW9uIHN5c3RlbVxuICAgICAgcmVtYWluaW5nVW5pbnRlbnRpb25hbDogTWF0aC5tYXgoMCwgZXN0aW1hdGVkVG90YWwgLSB0b3RhbFJlcGxhY2VtZW50cyksXG4gICAgICByZWR1Y3Rpb25QZXJjZW50YWdlLFxuICAgICAgdGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZTogdGhpcy5hZGFwdGl2ZUNvbmZpZy50YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlLFxuICAgICAgYmF0Y2hlc0NvbXBsZXRlZDogdGhpcy5iYXRjaENvdW50ZXIsXG4gICAgICBhdmVyYWdlU3VjY2Vzc1JhdGUsXG4gICAgICAvLyBCYXNlIFByb2dyZXNzTWV0cmljcyBwcm9wZXJ0aWVzXG4gICAgICB0eXBlU2NyaXB0RXJyb3JzOiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRUU0Vycm9ycyA+PSAwID8gY3VycmVudFRTRXJyb3JzIDogMCxcbiAgICAgICAgdGFyZ2V0OiAwLFxuICAgICAgICByZWR1Y3Rpb246IDAsXG4gICAgICAgIHBlcmNlbnRhZ2U6IDBcbiAgICAgIH0sXG4gICAgICBsaW50aW5nV2FybmluZ3M6IHsgY3VycmVudDogMCwgdGFyZ2V0OiAwLCByZWR1Y3Rpb246IDAsIHBlcmNlbnRhZ2U6IDAgfSxcbiAgICAgIGJ1aWxkUGVyZm9ybWFuY2U6IHsgY3VycmVudFRpbWU6IDAsIHRhcmdldFRpbWU6IDAsIGNhY2hlSGl0UmF0ZTogMCwgbWVtb3J5VXNhZ2U6IDAgfSxcbiAgICAgIGVudGVycHJpc2VTeXN0ZW1zOiB7IGN1cnJlbnQ6IDAsIHRhcmdldDogMCwgdHJhbnNmb3JtZWRFeHBvcnRzOiAwIH1cbiAgICB9O1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=