176dbbf4d4b06e6d91d6c1212e0b07f0
"use strict";
/**
 * Integration Tests for End-to-End Workflows
 * Tests complete classification and replacement workflows, campaign system integration,
 * safety protocol activation, and realistic batch processing scenarios
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('fs');
jest.mock('child_process');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const AnyTypeClassifier_1 = require("../AnyTypeClassifier");
const DomainContextAnalyzer_1 = require("../DomainContextAnalyzer");
const ProgressiveImprovementEngine_1 = require("../ProgressiveImprovementEngine");
const SafeTypeReplacer_1 = require("../SafeTypeReplacer");
const UnintentionalAnyEliminationCampaign_1 = require("../UnintentionalAnyEliminationCampaign");
const types_1 = require("../types");
const mockFs = fs;
const mockExecSync = child_process_1.execSync;
describe('Integration Workflows', () => {
    let classifier;
    let replacer;
    let analyzer;
    let engine;
    let campaign;
    beforeEach(() => {
        jest.clearAllMocks();
        classifier = new AnyTypeClassifier_1.AnyTypeClassifier();
        replacer = new SafeTypeReplacer_1.SafeTypeReplacer('./.test-backups', 0.7, 30000, 3);
        analyzer = new DomainContextAnalyzer_1.DomainContextAnalyzer();
        engine = new ProgressiveImprovementEngine_1.ProgressiveImprovementEngine();
        campaign = new UnintentionalAnyEliminationCampaign_1.UnintentionalAnyEliminationCampaign();
        // Mock file system defaults
        mockFs.existsSync.mockReturnValue(true);
        mockFs.mkdirSync.mockImplementation(() => undefined);
        mockFs.readFileSync.mockReturnValue('const data: any = {};');
        mockFs.writeFileSync.mockImplementation(() => undefined);
        mockFs.readdirSync.mockReturnValue([]);
        mockFs.statSync.mockReturnValue({ mtime: new Date() });
        // Mock successful TypeScript compilation by default
        mockExecSync.mockImplementation((command) => {
            if (command.includes('grep -c "error TS"')) {
                const error = new Error('No matches');
                error.status = 1;
                throw error;
            }
            if (command.includes('grep -r -l')) {
                return 'src/test1.ts\nsrc/test2.ts\n';
            }
            return '';
        });
    });
    describe('Complete Classification and Replacement Workflows', () => {
        test('should execute complete workflow from classification to replacement', async () => {
            // Setup test scenario with various any types
            const testFiles = {
                'src/arrays.ts': 'const items: any[] = []; const data: Array<any> = [];',
                'src/records.ts': 'const config: Record<string, any> = {}; const map: { [key: string]: any } = {};',
                'src/functions.ts': 'function process(param: any): any { return param; }',
                'src/errors.ts': '} catch (error: any) { console.log(error); }',
                'src/api.ts': 'const response: any = await fetch("/api/data");'
            };
            mockFs.readFileSync.mockImplementation((path) => {
                const fileName = path.toString();
                for (const [file, content] of Object.entries(testFiles)) {
                    if (fileName.includes(file.split('/').pop()?.replace('.ts', ''))) {
                        return content;
                    }
                }
                return 'backup content';
            });
            // Step 1: Analyze domain context for each file
            const contexts = [];
            for (const [filePath, content] of Object.entries(testFiles)) {
                const lines = content.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes(': any')) {
                        const context = {
                            filePath,
                            lineNumber: i + 1,
                            codeSnippet: lines[i],
                            surroundingLines: [],
                            hasExistingComment: false,
                            isInTestFile: false,
                            domainContext: await analyzer.analyzeDomain({
                                filePath,
                                lineNumber: i + 1,
                                codeSnippet: lines[i],
                                surroundingLines: [],
                                hasExistingComment: false,
                                isInTestFile: false,
                                domainContext: { domain: types_1.CodeDomain.UTILITY, intentionalityHints: [], suggestedTypes: [], preservationReasons: [] }
                            })
                        };
                        contexts.push(context);
                    }
                }
            }
            expect(contexts.length).toBeGreaterThan(0);
            // Step 2: Classify all any types
            const classifications = await classifier.classifyBatch(contexts);
            expect(classifications).toHaveLength(contexts.length);
            // Verify classification results
            const arrayClassifications = classifications.filter(c => c.category === types_1.AnyTypeCategory.ARRAY_TYPE);
            const recordClassifications = classifications.filter(c => c.category === types_1.AnyTypeCategory.RECORD_TYPE);
            const errorClassifications = classifications.filter(c => c.category === types_1.AnyTypeCategory.ERROR_HANDLING);
            const apiClassifications = classifications.filter(c => c.category === types_1.AnyTypeCategory.EXTERNAL_API);
            expect(arrayClassifications.length).toBeGreaterThan(0);
            expect(recordClassifications.length).toBeGreaterThan(0);
            expect(errorClassifications.length).toBeGreaterThan(0);
            expect(apiClassifications.length).toBeGreaterThan(0);
            // Step 3: Create replacements for unintentional types
            const replacements = classifications
                .filter(c => !c.isIntentional && c.suggestedReplacement)
                .map((c, i) => ({
                original: 'any',
                replacement: c.suggestedReplacement,
                filePath: contexts[i].filePath,
                lineNumber: contexts[i].lineNumber,
                confidence: c.confidence,
                validationRequired: true
            }));
            expect(replacements.length).toBeGreaterThan(0);
            // Step 4: Apply replacements with safety validation
            const replacementResult = await replacer.processBatch(replacements);
            expect(replacementResult.success).toBe(true);
            expect(replacementResult.appliedReplacements.length).toBeGreaterThan(0);
            expect(replacementResult.rollbackPerformed).toBe(false);
            // Verify that intentional types (errors, API responses) were preserved
            const intentionalTypes = classifications.filter(c => c.isIntentional);
            expect(intentionalTypes.length).toBeGreaterThan(0);
            expect(intentionalTypes.some(c => c.category === types_1.AnyTypeCategory.ERROR_HANDLING)).toBe(true);
            expect(intentionalTypes.some(c => c.category === types_1.AnyTypeCategory.EXTERNAL_API)).toBe(true);
        });
        test('should handle mixed success and failure scenarios', async () => {
            const mixedScenarios = {
                'src/safe.ts': 'const items: any[] = []; const data: Record<string, any> = {};',
                'src/risky.ts': 'const complex: any = getComplexObject(); function dangerous(param: any): any { return param; }',
                'src/intentional.ts': '} catch (error: any) { /* Intentionally any: error handling */ }'
            };
            mockFs.readFileSync.mockImplementation((path) => {
                const fileName = path.toString();
                for (const [file, content] of Object.entries(mixedScenarios)) {
                    if (fileName.includes(file.split('/').pop()?.replace('.ts', ''))) {
                        return content;
                    }
                }
                return 'backup content';
            });
            // Mock compilation to fail for risky replacements
            let compilationAttempts = 0;
            mockExecSync.mockImplementation((command) => {
                if (command.includes('tsc')) {
                    compilationAttempts++;
                    if (compilationAttempts > 2) { // Fail after a few attempts
                        const error = new Error('Compilation failed');
                        error.stdout = 'error TS2322: Type mismatch in dangerous function';
                        throw error;
                    }
                }
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            const config = {
                maxFilesPerBatch: 3,
                targetReductionPercentage: 15,
                confidenceThreshold: 0.8,
                enableDomainAnalysis: true,
                enableDocumentation: true,
                safetyLevel: 'MODERATE',
                validationFrequency: 1
            };
            const batchResult = await engine.executeBatch(config);
            expect(batchResult.filesProcessed).toBeGreaterThan(0);
            expect(batchResult.replacementsAttempted).toBeGreaterThan(0);
            // Some replacements should succeed, others may fail due to compilation issues
            expect(batchResult.replacementsSuccessful).toBeGreaterThanOrEqual(0);
            if (batchResult.rollbacksPerformed > 0) {
                expect(batchResult.safetyScore).toBeLessThan(1.0);
            }
        });
        test('should preserve domain-specific intentional any types', async () => {
            const domainSpecificFiles = {
                'src/calculations/planetary/positions.ts': `
          const planetaryData: any = await getReliablePlanetaryPositions();
          const transitDates: any = validateTransitDate(planet, date, sign);
        `,
                'src/data/ingredients/spices.ts': `
          const spiceData: any = await fetchSpiceInfo();
          const ingredient: any = processIngredientData();
        `,
                'src/services/campaign/metrics.ts': `
          const campaignConfig: any = getDynamicConfig();
          const metrics: any = calculateProgressMetrics();
        `
            };
            mockFs.readFileSync.mockImplementation((path) => {
                const fileName = path.toString();
                for (const [file, content] of Object.entries(domainSpecificFiles)) {
                    if (fileName.includes(file.split('/').slice(-1)[0].replace('.ts', ''))) {
                        return content;
                    }
                }
                return 'backup content';
            });
            // Process each domain-specific file
            const results = [];
            for (const [filePath, content] of Object.entries(domainSpecificFiles)) {
                const lines = content.trim().split('\n').filter(line => line.trim());
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes(': any')) {
                        const context = {
                            filePath,
                            lineNumber: i + 1,
                            codeSnippet: lines[i].trim(),
                            surroundingLines: lines.slice(Math.max(0, i - 1), i + 2),
                            hasExistingComment: false,
                            isInTestFile: false,
                            domainContext: await analyzer.analyzeDomain({
                                filePath,
                                lineNumber: i + 1,
                                codeSnippet: lines[i].trim(),
                                surroundingLines: [],
                                hasExistingComment: false,
                                isInTestFile: false,
                                domainContext: { domain: types_1.CodeDomain.UTILITY, intentionalityHints: [], suggestedTypes: [], preservationReasons: [] }
                            })
                        };
                        const classification = await classifier.classify(context);
                        results.push({ context, classification });
                    }
                }
            }
            // Verify domain-specific preservation
            const astrologicalResults = results.filter(r => r.context.filePath.includes('planetary') || r.context.filePath.includes('calculations'));
            const recipeResults = results.filter(r => r.context.filePath.includes('ingredients') || r.context.filePath.includes('spices'));
            const campaignResults = results.filter(r => r.context.filePath.includes('campaign') || r.context.filePath.includes('metrics'));
            // Astrological domain should preserve most any types
            expect(astrologicalResults.some(r => r.classification.isIntentional)).toBe(true);
            // Recipe domain should suggest specific types for some cases
            expect(recipeResults.some(r => !r.classification.isIntentional && r.classification.suggestedReplacement)).toBe(true);
            // Campaign domain should preserve flexible configurations
            expect(campaignResults.some(r => r.classification.isIntentional)).toBe(true);
        });
    });
    describe('Campaign System Integration', () => {
        test('should integrate with existing campaign infrastructure', async () => {
            const campaignConfig = {
                maxFilesPerBatch: 5,
                targetReductionPercentage: 20,
                confidenceThreshold: 0.85,
                enableDomainAnalysis: true,
                enableDocumentation: true,
                safetyLevel: 'HIGH',
                validationFrequency: 3
            };
            // Mock campaign execution
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('test')) {
                    return 'const items: any[] = []; const data: Record<string, any> = {};';
                }
                return 'backup content';
            });
            const campaignResult = await campaign.execute(campaignConfig);
            expect(campaignResult).toBeDefined();
            expect(campaignResult.totalAnyTypesAnalyzed).toBeGreaterThanOrEqual(0);
            expect(campaignResult.reductionAchieved).toBeGreaterThanOrEqual(0);
            expect(campaignResult.safetyEvents).toBeInstanceOf(Array);
            expect(campaignResult.validationResults).toBeInstanceOf(Array);
        });
        test('should follow campaign safety protocols', async () => {
            // Mock scenario that triggers safety protocols
            let errorCount = 0;
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -c "error TS"')) {
                    errorCount++;
                    if (errorCount > 2) {
                        return '15'; // Return increasing error count
                    }
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                if (command.includes('grep -r -l')) {
                    return 'src/problematic.ts\n';
                }
                return '';
            });
            mockFs.readFileSync.mockReturnValue('const dangerous: any = performRiskyOperation();');
            const campaignConfig = {
                maxFilesPerBatch: 1,
                targetReductionPercentage: 10,
                confidenceThreshold: 0.7,
                enableDomainAnalysis: true,
                enableDocumentation: true,
                safetyLevel: 'MAXIMUM',
                validationFrequency: 1
            };
            const campaignResult = await campaign.execute(campaignConfig);
            expect(campaignResult.safetyEvents.length).toBeGreaterThan(0);
            expect(campaignResult.safetyEvents.some(event => event.type === 'LOW_SAFETY_SCORE' || event.type === 'BATCH_FAILURE')).toBe(true);
        });
        test('should integrate with progress tracking and metrics', async () => {
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('metrics')) {
                    return 'const progressData: any = getMetrics(); const config: Record<string, any> = {};';
                }
                return 'const items: any[] = [];';
            });
            const initialProgress = await engine.getProgressMetrics();
            expect(initialProgress).toBeDefined();
            expect(initialProgress.totalAnyTypes).toBeGreaterThanOrEqual(0);
            const batchResult = await engine.executeBatch({
                maxFilesPerBatch: 2,
                targetReductionPercentage: 15,
                confidenceThreshold: 0.8,
                enableDomainAnalysis: true,
                enableDocumentation: true,
                safetyLevel: 'MODERATE',
                validationFrequency: 5
            });
            const finalProgress = await engine.getProgressMetrics();
            expect(finalProgress).toBeDefined();
            const batchHistory = engine.getBatchHistory();
            expect(batchHistory).toContain(batchResult);
            expect(batchHistory.length).toBeGreaterThan(0);
        });
    });
    describe('Safety Protocol Activation and Rollback Scenarios', () => {
        test('should activate rollback on compilation failures', async () => {
            mockFs.readFileSync.mockReturnValue('const data: any = getValue();');
            // Mock compilation failure
            mockExecSync.mockImplementation((command) => {
                if (command.includes('tsc')) {
                    const error = new Error('Compilation failed');
                    error.stdout = 'error TS2322: Type "unknown" is not assignable to type "string"';
                    throw error;
                }
                return '';
            });
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'src/test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322');
        });
        test('should handle emergency rollback scenarios', async () => {
            const multipleReplacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'src/test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'any',
                    replacement: 'string',
                    filePath: 'src/test2.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('test1'))
                    return 'const items: any[] = [];';
                if (path.includes('test2'))
                    return 'const data: any = getValue();';
                return 'backup content';
            });
            // Mock overall build failure after individual replacements succeed
            let buildCheckCount = 0;
            mockExecSync.mockImplementation((command) => {
                if (command.includes('tsc') && command.includes('--noEmit')) {
                    buildCheckCount++;
                    if (buildCheckCount > 1) { // Fail on overall build check
                        const error = new Error('Overall build failed');
                        error.stdout = 'error TS2322: Multiple type conflicts detected';
                        throw error;
                    }
                }
                return '';
            });
            const result = await replacer.processBatch(multipleReplacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('Multiple type conflicts detected');
        });
        test('should validate rollback integrity', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'src/test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const originalContent = 'const items: any[] = [];';
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('.backup')) {
                    return originalContent;
                }
                return originalContent;
            });
            // Mock compilation failure to trigger rollback
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type error';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.backupPath).toBeDefined();
            // Verify backup was created and used for rollback
            expect(mockFs.writeFileSync).toHaveBeenCalledWith(expect.stringContaining('.backup'), originalContent, 'utf8');
        });
    });
    describe('Realistic Batch Processing with Actual Codebase Samples', () => {
        test('should process realistic TypeScript codebase patterns', async () => {
            const realisticCodeSamples = {
                'src/components/RecipeCard.tsx': `
          import React from 'react';
          interface Props {
            recipe: any;
            onSelect: (recipe: any) => void;
          }
          export const RecipeCard: React.FC<Props> = ({ recipe, onSelect }) => {
            const handleClick = (event: any) => {
              event.preventDefault();
              onSelect(recipe);
            };
            return <div onClick={handleClick}>{recipe.name}</div>;
          };
        `,
                'src/services/ApiService.ts': `
          class ApiService {
            async fetchData(endpoint: string): Promise<any> {
              try {
                const response = await fetch(endpoint);
                const data: any = await response.json();
                return this.transformData(data);
              } catch (error: any) {
                console.error('API Error:', error);
                throw error;
              }
            }

            private transformData(data: any): any {
              return { ...data, processed: true };
            }
          }
        `,
                'src/utils/helpers.ts': `
          export const processItems = (items: any[]): any[] => {
            return items.map((item: any) => ({
              ...item,
              id: item.id || generateId()
            }));
          };

          export const createConfig = (): Record<string, any> => {
            return {
              apiUrl: process.env.API_URL,
              timeout: 5000,
              retries: 3
            };
          };
        `,
                'src/__tests__/helpers.test.ts': `
          import { processItems } from '../utils/helpers';

          describe('helpers', () => {
            test('processItems', () => {
              const mockItems: any[] = [{ name: 'test' }];
              const result = processItems(mockItems);
              expect(result).toBeDefined();
            });

            test('with mock data', () => {
              const mockFn = jest.fn() as any;
              mockFn.mockReturnValue({ data: 'test' });
              expect(mockFn()).toEqual({ data: 'test' });
            });
          });
        `
            };
            mockFs.readFileSync.mockImplementation((path) => {
                const fileName = path.toString();
                for (const [file, content] of Object.entries(realisticCodeSamples)) {
                    if (fileName.includes(file.split('/').pop()?.replace('.tsx', '').replace('.ts', ''))) {
                        return content;
                    }
                }
                return 'backup content';
            });
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return Object.keys(realisticCodeSamples).join('\n');
                }
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            const config = {
                maxFilesPerBatch: 4,
                targetReductionPercentage: 15,
                confidenceThreshold: 0.8,
                enableDomainAnalysis: true,
                enableDocumentation: true,
                safetyLevel: 'MODERATE',
                validationFrequency: 2
            };
            const batchResult = await engine.executeBatch(config);
            expect(batchResult.filesProcessed).toBe(4);
            expect(batchResult.anyTypesAnalyzed).toBeGreaterThan(10); // Multiple any types in samples
            expect(batchResult.replacementsAttempted).toBeGreaterThan(0);
            // Some replacements should be successful (arrays, records)
            // Some should be preserved (error handling, test mocks, API responses)
            expect(batchResult.replacementsSuccessful).toBeGreaterThanOrEqual(0);
            expect(batchResult.safetyScore).toBeGreaterThan(0.5);
        });
        test('should handle large-scale batch processing', async () => {
            // Generate a large number of files with various any type patterns
            const generateFileContent = (index) => {
                const patterns = [
                    `const items${index}: any[] = [];`,
                    `const config${index}: Record<string, any> = {};`,
                    `function process${index}(data: any): any { return data; }`,
                    `const response${index}: any = await fetch("/api/${index}");`,
                    `} catch (error${index}: any) { console.log(error${index}); }`
                ];
                return patterns[index % patterns.length];
            };
            const fileCount = 50;
            mockExecSync.mockImplementation((command) => {
                if (command.includes('grep -r -l')) {
                    return Array(fileCount).fill(null).map((_, i) => `src/file${i}.ts`).join('\n');
                }
                if (command.includes('grep -c "error TS"')) {
                    const error = new Error('No matches');
                    error.status = 1;
                    throw error;
                }
                return '';
            });
            mockFs.readFileSync.mockImplementation((path) => {
                const match = path.toString().match(/file(\d+)\.ts/);
                if (match) {
                    const index = parseInt(match[1]);
                    return generateFileContent(index);
                }
                return 'backup content';
            });
            const config = {
                maxFilesPerBatch: 10,
                targetReductionPercentage: 20,
                confidenceThreshold: 0.8,
                enableDomainAnalysis: true,
                enableDocumentation: true,
                safetyLevel: 'MODERATE',
                validationFrequency: 5
            };
            const startTime = Date.now();
            const campaignResult = await campaign.execute(config);
            const endTime = Date.now();
            expect(campaignResult.totalAnyTypesAnalyzed).toBeGreaterThan(0);
            expect(campaignResult.reductionAchieved).toBeGreaterThanOrEqual(0);
            expect(endTime - startTime).toBeLessThan(30000); // Should complete within 30 seconds
            // Verify performance characteristics
            expect(campaignResult.safetyEvents.length).toBeLessThan(10); // Should have minimal safety issues
        });
        test('should adapt to different codebase characteristics', async () => {
            // Test with different codebase profiles
            const codebases = {
                'test-heavy': {
                    files: {
                        'src/test1.test.ts': 'const mockData: any = {}; const spy: any = jest.fn();',
                        'src/test2.spec.ts': 'const fixture: any = createFixture();'
                    },
                    expectedBehavior: 'preserve most any types due to test context'
                },
                'api-heavy': {
                    files: {
                        'src/api1.ts': 'const response: any = await fetch("/api"); const data: any = response.json();',
                        'src/api2.ts': 'const result: any = await apiCall();'
                    },
                    expectedBehavior: 'preserve API-related any types'
                },
                'utility-heavy': {
                    files: {
                        'src/util1.ts': 'const items: any[] = []; const map: Record<string, any> = {};',
                        'src/util2.ts': 'function transform(data: any[]): any[] { return data; }'
                    },
                    expectedBehavior: 'replace many utility any types'
                }
            };
            for (const [codebaseType, { files, expectedBehavior }] of Object.entries(codebases)) {
                mockFs.readFileSync.mockImplementation((path) => {
                    const fileName = path.toString();
                    for (const [file, content] of Object.entries(files)) {
                        if (fileName.includes(file.split('/').pop()?.replace(/\.(test|spec)\.ts$/, '').replace('.ts', ''))) {
                            return content;
                        }
                    }
                    return 'backup content';
                });
                mockExecSync.mockImplementation((command) => {
                    if (command.includes('grep -r -l')) {
                        return Object.keys(files).join('\n');
                    }
                    if (command.includes('grep -c "error TS"')) {
                        const error = new Error('No matches');
                        error.status = 1;
                        throw error;
                    }
                    return '';
                });
                const config = {
                    maxFilesPerBatch: Object.keys(files).length,
                    targetReductionPercentage: 15,
                    confidenceThreshold: 0.8,
                    enableDomainAnalysis: true,
                    enableDocumentation: true,
                    safetyLevel: 'MODERATE',
                    validationFrequency: 2
                };
                const batchResult = await engine.executeBatch(config);
                expect(batchResult.filesProcessed).toBe(Object.keys(files).length);
                expect(batchResult.anyTypesAnalyzed).toBeGreaterThan(0);
                // Verify behavior matches expectations
                if (codebaseType === 'test-heavy') {
                    // Test files should have lower replacement rates
                    expect(batchResult.replacementsSuccessful / Math.max(1, batchResult.replacementsAttempted)).toBeLessThan(0.5);
                }
                else if (codebaseType === 'utility-heavy') {
                    // Utility files should have higher replacement rates
                    expect(batchResult.replacementsSuccessful / Math.max(1, batchResult.replacementsAttempted)).toBeGreaterThan(0.3);
                }
                console.log(`${codebaseType}: ${expectedBehavior} - Success rate: ${(batchResult.replacementsSuccessful / Math.max(1, batchResult.replacementsAttempted) * 100).toFixed(1)}%`);
            }
        });
    });
    describe('Error Recovery and Resilience', () => {
        test('should recover from transient failures', async () => {
            let failureCount = 0;
            mockExecSync.mockImplementation((command) => {
                if (command.includes('tsc')) {
                    failureCount++;
                    if (failureCount <= 2) {
                        // Fail first two attempts, then succeed
                        const error = new Error('Transient failure');
                        error.stdout = 'error TS2322: Temporary type conflict';
                        throw error;
                    }
                }
                if (command.includes('grep -r -l')) {
                    return 'src/test.ts\n';
                }
                return '';
            });
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'src/test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(replacement);
            // Should eventually succeed after retries
            expect(result.success).toBe(true);
            expect(failureCount).toBeGreaterThan(2);
        });
        test('should maintain data integrity during failures', async () => {
            const originalContent = 'const items: any[] = []; const data: Record<string, any> = {};';
            let backupContent = '';
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('.backup')) {
                    return backupContent;
                }
                return originalContent;
            });
            mockFs.writeFileSync.mockImplementation((path, content) => {
                if (path.includes('.backup')) {
                    backupContent = content;
                }
            });
            // Mock failure scenario
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type error';
                throw error;
            });
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'src/test.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'Record<string, any>',
                    replacement: 'Record<string, unknown>',
                    filePath: 'src/test.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            // Verify backup was created with original content
            expect(backupContent).toBe(originalContent);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5kdXBsaWNhdGUtZGlycy1iYWNrdXAtMjAyNTA5MDctMTY0ODAyL3NlcnZpY2VzIDIvY2FtcGFpZ24vdW5pbnRlbnRpb25hbC1hbnktZWxpbWluYXRpb24vX190ZXN0c19fL0ludGVncmF0aW9uV29ya2Zsb3dzLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0dBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkgsb0JBQW9CO0FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQWhCM0IsaURBQXlDO0FBQ3pDLHVDQUF5QjtBQUN6Qiw0REFBeUQ7QUFDekQsb0VBQWlFO0FBQ2pFLGtGQUErRTtBQUMvRSwwREFBdUQ7QUFDdkQsZ0dBQTZGO0FBQzdGLG9DQUtrQjtBQU1sQixNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBQzVDLE1BQU0sWUFBWSxHQUFHLHdCQUFnRCxDQUFDO0FBRXRFLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7SUFDckMsSUFBSSxVQUE2QixDQUFDO0lBQ2xDLElBQUksUUFBMEIsQ0FBQztJQUMvQixJQUFJLFFBQStCLENBQUM7SUFDcEMsSUFBSSxNQUFvQyxDQUFDO0lBQ3pDLElBQUksUUFBNkMsQ0FBQztJQUVsRCxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXJCLFVBQVUsR0FBRyxJQUFJLHFDQUFpQixFQUFFLENBQUM7UUFDckMsUUFBUSxHQUFHLElBQUksbUNBQWdCLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNsRSxRQUFRLEdBQUcsSUFBSSw2Q0FBcUIsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sR0FBRyxJQUFJLDJEQUE0QixFQUFFLENBQUM7UUFDNUMsUUFB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QUNkLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxZQUFZLEdBQUc7Z0JBQ25CO29CQUNFLFFBQVEsRUFBRSxPQUFPO29CQUNqQixXQUFXLEVBQUUsV0FBVztvQkFDeEIsUUFBUSxFQUFFLGFBQWE7b0JBQ3ZCLFVBQVUsRUFBRSxDQUFDO29CQUNiLFVBQVUsRUFBRSxHQUFHO29CQUNmLGtCQUFrQixFQUFFLElBQUk7aUJBQ3pCO2dCQUNEO29CQUNFLFFBQVEsRUFBRSxxQkFBcUI7b0JBQy9CLFdBQVcsRUFBRSx5QkFBeUI7b0JBQ3RDLFFBQVEsRUFBRSxhQUFhO29CQUN2QixVQUFVLEVBQUUsQ0FBQztvQkFDYixVQUFVLEVBQUUsR0FBRztvQkFDZixrQkFBa0IsRUFBRSxJQUFJO2lCQUN6QjthQUNGLENBQUM7WUFFRixNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFekQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbkMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUU1QyxrREFBa0Q7WUFDbEQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUM5QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0Ly5kdXBsaWNhdGUtZGlycy1iYWNrdXAtMjAyNTA5MDctMTY0ODAyL3NlcnZpY2VzIDIvY2FtcGFpZ24vdW5pbnRlbnRpb25hbC1hbnktZWxpbWluYXRpb24vX190ZXN0c19fL0ludGVncmF0aW9uV29ya2Zsb3dzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlZ3JhdGlvbiBUZXN0cyBmb3IgRW5kLXRvLUVuZCBXb3JrZmxvd3NcbiAqIFRlc3RzIGNvbXBsZXRlIGNsYXNzaWZpY2F0aW9uIGFuZCByZXBsYWNlbWVudCB3b3JrZmxvd3MsIGNhbXBhaWduIHN5c3RlbSBpbnRlZ3JhdGlvbixcbiAqIHNhZmV0eSBwcm90b2NvbCBhY3RpdmF0aW9uLCBhbmQgcmVhbGlzdGljIGJhdGNoIHByb2Nlc3Npbmcgc2NlbmFyaW9zXG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IEFueVR5cGVDbGFzc2lmaWVyIH0gZnJvbSAnLi4vQW55VHlwZUNsYXNzaWZpZXInO1xuaW1wb3J0IHsgRG9tYWluQ29udGV4dEFuYWx5emVyIH0gZnJvbSAnLi4vRG9tYWluQ29udGV4dEFuYWx5emVyJztcbmltcG9ydCB7IFByb2dyZXNzaXZlSW1wcm92ZW1lbnRFbmdpbmUgfSBmcm9tICcuLi9Qcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lJztcbmltcG9ydCB7IFNhZmVUeXBlUmVwbGFjZXIgfSBmcm9tICcuLi9TYWZlVHlwZVJlcGxhY2VyJztcbmltcG9ydCB7IFVuaW50ZW50aW9uYWxBbnlFbGltaW5hdGlvbkNhbXBhaWduIH0gZnJvbSAnLi4vVW5pbnRlbnRpb25hbEFueUVsaW1pbmF0aW9uQ2FtcGFpZ24nO1xuaW1wb3J0IHtcbiAgICBBbnlUeXBlQ2F0ZWdvcnksXG4gICAgQ2xhc3NpZmljYXRpb25Db250ZXh0LFxuICAgIENvZGVEb21haW4sXG4gICAgVW5pbnRlbnRpb25hbEFueUNvbmZpZ1xufSBmcm9tICcuLi90eXBlcyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ2ZzJyk7XG5qZXN0Lm1vY2soJ2NoaWxkX3Byb2Nlc3MnKTtcblxuY29uc3QgbW9ja0ZzID0gZnMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzPjtcbmNvbnN0IG1vY2tFeGVjU3luYyA9IGV4ZWNTeW5jIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGV4ZWNTeW5jPjtcblxuZGVzY3JpYmUoJ0ludGVncmF0aW9uIFdvcmtmbG93cycsICgpID0+IHtcbiAgbGV0IGNsYXNzaWZpZXI6IEFueVR5cGVDbGFzc2lmaWVyO1xuICBsZXQgcmVwbGFjZXI6IFNhZmVUeXBlUmVwbGFjZXI7XG4gIGxldCBhbmFseXplcjogRG9tYWluQ29udGV4dEFuYWx5emVyO1xuICBsZXQgZW5naW5lOiBQcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lO1xuICBsZXQgY2FtcGFpZ246IFVuaW50ZW50aW9uYWxBbnlFbGltaW5hdGlvbkNhbXBhaWduO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgY2xhc3NpZmllciA9IG5ldyBBbnlUeXBlQ2xhc3NpZmllcigpO1xuICAgIHJlcGxhY2VyID0gbmV3IFNhZmVUeXBlUmVwbGFjZXIoJy4vLnRlc3QtYmFja3VwcycsIDAuNywgMzAwMDAsIDMpO1xuICAgIGFuYWx5emVyID0gbmV3IERvbWFpbkNvbnRleHRBbmFseXplcigpO1xuICAgIGVuZ2luZSA9IG5ldyBQcm9ncmVzc2l2ZUltcHJvdmVtZW50RW5naW5lKCk7XG4gICAgY2FtcGFpZ24gPSBuZXcgVW5pbnRlbnRpb25hbEFueUVsaW1pbmF0aW9uQ2FtcGFpZ24oKTtcblxuICAgIC8vIE1vY2sgZmlsZSBzeXN0ZW0gZGVmYXVsdHNcbiAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgbW9ja0ZzLm1rZGlyU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdW5kZWZpbmVkIGFzIGFueSk7XG4gICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhdGE6IGFueSA9IHt9OycpO1xuICAgIG1vY2tGcy53cml0ZUZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIG1vY2tGcy5yZWFkZGlyU3luYy5tb2NrUmV0dXJuVmFsdWUoW10pO1xuICAgIG1vY2tGcy5zdGF0U3luYy5tb2NrUmV0dXJuVmFsdWUoeyBtdGltZTogbmV3IERhdGUoKSB9IGFzIGFueSk7XG5cbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgVHlwZVNjcmlwdCBjb21waWxhdGlvbiBieSBkZWZhdWx0XG4gICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLWMgXCJlcnJvciBUU1wiJykpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIG1hdGNoZXMnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0YXR1cyA9IDE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLXIgLWwnKSkge1xuICAgICAgICByZXR1cm4gJ3NyYy90ZXN0MS50c1xcbnNyYy90ZXN0Mi50c1xcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV0ZSBDbGFzc2lmaWNhdGlvbiBhbmQgUmVwbGFjZW1lbnQgV29ya2Zsb3dzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBleGVjdXRlIGNvbXBsZXRlIHdvcmtmbG93IGZyb20gY2xhc3NpZmljYXRpb24gdG8gcmVwbGFjZW1lbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXR1cCB0ZXN0IHNjZW5hcmlvIHdpdGggdmFyaW91cyBhbnkgdHlwZXNcbiAgICAgIGNvbnN0IHRlc3RGaWxlcyA9IHtcbiAgICAgICAgJ3NyYy9hcnJheXMudHMnOiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107IGNvbnN0IGRhdGE6IEFycmF5PGFueT4gPSBbXTsnLFxuICAgICAgICAnc3JjL3JlY29yZHMudHMnOiAnY29uc3QgY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307IGNvbnN0IG1hcDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9OycsXG4gICAgICAgICdzcmMvZnVuY3Rpb25zLnRzJzogJ2Z1bmN0aW9uIHByb2Nlc3MocGFyYW06IGFueSk6IGFueSB7IHJldHVybiBwYXJhbTsgfScsXG4gICAgICAgICdzcmMvZXJyb3JzLnRzJzogJ30gY2F0Y2ggKGVycm9yOiBhbnkpIHsgY29uc29sZS5sb2coZXJyb3IpOyB9JyxcbiAgICAgICAgJ3NyYy9hcGkudHMnOiAnY29uc3QgcmVzcG9uc2U6IGFueSA9IGF3YWl0IGZldGNoKFwiL2FwaS9kYXRhXCIpOydcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ZpbGUsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHRlc3RGaWxlcykpIHtcbiAgICAgICAgICBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoZmlsZS5zcGxpdCgnLycpLnBvcCgpPy5yZXBsYWNlKCcudHMnLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdiYWNrdXAgY29udGVudCc7XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RlcCAxOiBBbmFseXplIGRvbWFpbiBjb250ZXh0IGZvciBlYWNoIGZpbGVcbiAgICAgIGNvbnN0IGNvbnRleHRzOiBDbGFzc2lmaWNhdGlvbkNvbnRleHRbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBbZmlsZVBhdGgsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHRlc3RGaWxlcykpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmNsdWRlcygnOiBhbnknKSkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogaSArIDEsXG4gICAgICAgICAgICAgIGNvZGVTbmlwcGV0OiBsaW5lc1tpXSxcbiAgICAgICAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGRvbWFpbkNvbnRleHQ6IGF3YWl0IGFuYWx5emVyLmFuYWx5emVEb21haW4oe1xuICAgICAgICAgICAgICAgIGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGkgKyAxLFxuICAgICAgICAgICAgICAgIGNvZGVTbmlwcGV0OiBsaW5lc1tpXSxcbiAgICAgICAgICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZG9tYWluQ29udGV4dDogeyBkb21haW46IENvZGVEb21haW4uVVRJTElUWSwgaW50ZW50aW9uYWxpdHlIaW50czogW10sIHN1Z2dlc3RlZFR5cGVzOiBbXSwgcHJlc2VydmF0aW9uUmVhc29uczogW10gfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChjb250ZXh0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgLy8gU3RlcCAyOiBDbGFzc2lmeSBhbGwgYW55IHR5cGVzXG4gICAgICBjb25zdCBjbGFzc2lmaWNhdGlvbnMgPSBhd2FpdCBjbGFzc2lmaWVyLmNsYXNzaWZ5QmF0Y2goY29udGV4dHMpO1xuICAgICAgZXhwZWN0KGNsYXNzaWZpY2F0aW9ucykudG9IYXZlTGVuZ3RoKGNvbnRleHRzLmxlbmd0aCk7XG5cbiAgICAgIC8vIFZlcmlmeSBjbGFzc2lmaWNhdGlvbiByZXN1bHRzXG4gICAgICBjb25zdCBhcnJheUNsYXNzaWZpY2F0aW9ucyA9IGNsYXNzaWZpY2F0aW9ucy5maWx0ZXIoYyA9PiBjLmNhdGVnb3J5ID09PSBBbnlUeXBlQ2F0ZWdvcnkuQVJSQVlfVFlQRSk7XG4gICAgICBjb25zdCByZWNvcmRDbGFzc2lmaWNhdGlvbnMgPSBjbGFzc2lmaWNhdGlvbnMuZmlsdGVyKGMgPT4gYy5jYXRlZ29yeSA9PT0gQW55VHlwZUNhdGVnb3J5LlJFQ09SRF9UWVBFKTtcbiAgICAgIGNvbnN0IGVycm9yQ2xhc3NpZmljYXRpb25zID0gY2xhc3NpZmljYXRpb25zLmZpbHRlcihjID0+IGMuY2F0ZWdvcnkgPT09IEFueVR5cGVDYXRlZ29yeS5FUlJPUl9IQU5ETElORyk7XG4gICAgICBjb25zdCBhcGlDbGFzc2lmaWNhdGlvbnMgPSBjbGFzc2lmaWNhdGlvbnMuZmlsdGVyKGMgPT4gYy5jYXRlZ29yeSA9PT0gQW55VHlwZUNhdGVnb3J5LkVYVEVSTkFMX0FQSSk7XG5cbiAgICAgIGV4cGVjdChhcnJheUNsYXNzaWZpY2F0aW9ucy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChyZWNvcmRDbGFzc2lmaWNhdGlvbnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoZXJyb3JDbGFzc2lmaWNhdGlvbnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoYXBpQ2xhc3NpZmljYXRpb25zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICAvLyBTdGVwIDM6IENyZWF0ZSByZXBsYWNlbWVudHMgZm9yIHVuaW50ZW50aW9uYWwgdHlwZXNcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IGNsYXNzaWZpY2F0aW9uc1xuICAgICAgICAuZmlsdGVyKGMgPT4gIWMuaXNJbnRlbnRpb25hbCAmJiBjLnN1Z2dlc3RlZFJlcGxhY2VtZW50KVxuICAgICAgICAubWFwKChjLCBpKSA9PiAoe1xuICAgICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgICByZXBsYWNlbWVudDogYy5zdWdnZXN0ZWRSZXBsYWNlbWVudCEsXG4gICAgICAgICAgZmlsZVBhdGg6IGNvbnRleHRzW2ldLmZpbGVQYXRoLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGNvbnRleHRzW2ldLmxpbmVOdW1iZXIsXG4gICAgICAgICAgY29uZmlkZW5jZTogYy5jb25maWRlbmNlLFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KSk7XG5cbiAgICAgIGV4cGVjdChyZXBsYWNlbWVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG5cbiAgICAgIC8vIFN0ZXAgNDogQXBwbHkgcmVwbGFjZW1lbnRzIHdpdGggc2FmZXR5IHZhbGlkYXRpb25cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50UmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKHJlcGxhY2VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChyZXBsYWNlbWVudFJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlcGxhY2VtZW50UmVzdWx0LmFwcGxpZWRSZXBsYWNlbWVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVwbGFjZW1lbnRSZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAvLyBWZXJpZnkgdGhhdCBpbnRlbnRpb25hbCB0eXBlcyAoZXJyb3JzLCBBUEkgcmVzcG9uc2VzKSB3ZXJlIHByZXNlcnZlZFxuICAgICAgY29uc3QgaW50ZW50aW9uYWxUeXBlcyA9IGNsYXNzaWZpY2F0aW9ucy5maWx0ZXIoYyA9PiBjLmlzSW50ZW50aW9uYWwpO1xuICAgICAgZXhwZWN0KGludGVudGlvbmFsVHlwZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoaW50ZW50aW9uYWxUeXBlcy5zb21lKGMgPT4gYy5jYXRlZ29yeSA9PT0gQW55VHlwZUNhdGVnb3J5LkVSUk9SX0hBTkRMSU5HKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChpbnRlbnRpb25hbFR5cGVzLnNvbWUoYyA9PiBjLmNhdGVnb3J5ID09PSBBbnlUeXBlQ2F0ZWdvcnkuRVhURVJOQUxfQVBJKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgc3VjY2VzcyBhbmQgZmFpbHVyZSBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtaXhlZFNjZW5hcmlvcyA9IHtcbiAgICAgICAgJ3NyYy9zYWZlLnRzJzogJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOyBjb25zdCBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307JyxcbiAgICAgICAgJ3NyYy9yaXNreS50cyc6ICdjb25zdCBjb21wbGV4OiBhbnkgPSBnZXRDb21wbGV4T2JqZWN0KCk7IGZ1bmN0aW9uIGRhbmdlcm91cyhwYXJhbTogYW55KTogYW55IHsgcmV0dXJuIHBhcmFtOyB9JyxcbiAgICAgICAgJ3NyYy9pbnRlbnRpb25hbC50cyc6ICd9IGNhdGNoIChlcnJvcjogYW55KSB7IC8qIEludGVudGlvbmFsbHkgYW55OiBlcnJvciBoYW5kbGluZyAqLyB9J1xuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgZm9yIChjb25zdCBbZmlsZSwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMobWl4ZWRTY2VuYXJpb3MpKSB7XG4gICAgICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKGZpbGUuc3BsaXQoJy8nKS5wb3AoKT8ucmVwbGFjZSgnLnRzJywgJycpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnYmFja3VwIGNvbnRlbnQnO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgY29tcGlsYXRpb24gdG8gZmFpbCBmb3Igcmlza3kgcmVwbGFjZW1lbnRzXG4gICAgICBsZXQgY29tcGlsYXRpb25BdHRlbXB0cyA9IDA7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kKSA9PiB7XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCd0c2MnKSkge1xuICAgICAgICAgIGNvbXBpbGF0aW9uQXR0ZW1wdHMrKztcbiAgICAgICAgICBpZiAoY29tcGlsYXRpb25BdHRlbXB0cyA+IDIpIHsgLy8gRmFpbCBhZnRlciBhIGZldyBhdHRlbXB0c1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IFR5cGUgbWlzbWF0Y2ggaW4gZGFuZ2Vyb3VzIGZ1bmN0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtYyBcImVycm9yIFRTXCInKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBtYXRjaGVzJykgYXMgYW55O1xuICAgICAgICAgIGVycm9yLnN0YXR1cyA9IDE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbmZpZzogVW5pbnRlbnRpb25hbEFueUNvbmZpZyA9IHtcbiAgICAgICAgbWF4RmlsZXNQZXJCYXRjaDogMyxcbiAgICAgICAgdGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZTogMTUsXG4gICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuOCxcbiAgICAgICAgZW5hYmxlRG9tYWluQW5hbHlzaXM6IHRydWUsXG4gICAgICAgIGVuYWJsZURvY3VtZW50YXRpb246IHRydWUsXG4gICAgICAgIHNhZmV0eUxldmVsOiAnTU9ERVJBVEUnLFxuICAgICAgICB2YWxpZGF0aW9uRnJlcXVlbmN5OiAxXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBiYXRjaFJlc3VsdCA9IGF3YWl0IGVuZ2luZS5leGVjdXRlQmF0Y2goY29uZmlnKTtcblxuICAgICAgZXhwZWN0KGJhdGNoUmVzdWx0LmZpbGVzUHJvY2Vzc2VkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoYmF0Y2hSZXN1bHQucmVwbGFjZW1lbnRzQXR0ZW1wdGVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAvLyBTb21lIHJlcGxhY2VtZW50cyBzaG91bGQgc3VjY2VlZCwgb3RoZXJzIG1heSBmYWlsIGR1ZSB0byBjb21waWxhdGlvbiBpc3N1ZXNcbiAgICAgIGV4cGVjdChiYXRjaFJlc3VsdC5yZXBsYWNlbWVudHNTdWNjZXNzZnVsKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuXG4gICAgICBpZiAoYmF0Y2hSZXN1bHQucm9sbGJhY2tzUGVyZm9ybWVkID4gMCkge1xuICAgICAgICBleHBlY3QoYmF0Y2hSZXN1bHQuc2FmZXR5U2NvcmUpLnRvQmVMZXNzVGhhbigxLjApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHByZXNlcnZlIGRvbWFpbi1zcGVjaWZpYyBpbnRlbnRpb25hbCBhbnkgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkb21haW5TcGVjaWZpY0ZpbGVzID0ge1xuICAgICAgICAnc3JjL2NhbGN1bGF0aW9ucy9wbGFuZXRhcnkvcG9zaXRpb25zLnRzJzogYFxuICAgICAgICAgIGNvbnN0IHBsYW5ldGFyeURhdGE6IGFueSA9IGF3YWl0IGdldFJlbGlhYmxlUGxhbmV0YXJ5UG9zaXRpb25zKCk7XG4gICAgICAgICAgY29uc3QgdHJhbnNpdERhdGVzOiBhbnkgPSB2YWxpZGF0ZVRyYW5zaXREYXRlKHBsYW5ldCwgZGF0ZSwgc2lnbik7XG4gICAgICAgIGAsXG4gICAgICAgICdzcmMvZGF0YS9pbmdyZWRpZW50cy9zcGljZXMudHMnOiBgXG4gICAgICAgICAgY29uc3Qgc3BpY2VEYXRhOiBhbnkgPSBhd2FpdCBmZXRjaFNwaWNlSW5mbygpO1xuICAgICAgICAgIGNvbnN0IGluZ3JlZGllbnQ6IGFueSA9IHByb2Nlc3NJbmdyZWRpZW50RGF0YSgpO1xuICAgICAgICBgLFxuICAgICAgICAnc3JjL3NlcnZpY2VzL2NhbXBhaWduL21ldHJpY3MudHMnOiBgXG4gICAgICAgICAgY29uc3QgY2FtcGFpZ25Db25maWc6IGFueSA9IGdldER5bmFtaWNDb25maWcoKTtcbiAgICAgICAgICBjb25zdCBtZXRyaWNzOiBhbnkgPSBjYWxjdWxhdGVQcm9ncmVzc01ldHJpY3MoKTtcbiAgICAgICAgYFxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgZm9yIChjb25zdCBbZmlsZSwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZG9tYWluU3BlY2lmaWNGaWxlcykpIHtcbiAgICAgICAgICBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoZmlsZS5zcGxpdCgnLycpLnNsaWNlKC0xKVswXS5yZXBsYWNlKCcudHMnLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdiYWNrdXAgY29udGVudCc7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGRvbWFpbi1zcGVjaWZpYyBmaWxlXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtmaWxlUGF0aCwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZG9tYWluU3BlY2lmaWNGaWxlcykpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnRyaW0oKS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobGluZXNbaV0uaW5jbHVkZXMoJzogYW55JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgZmlsZVBhdGgsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGkgKyAxLFxuICAgICAgICAgICAgICBjb2RlU25pcHBldDogbGluZXNbaV0udHJpbSgpLFxuICAgICAgICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBsaW5lcy5zbGljZShNYXRoLm1heCgwLCBpLTEpLCBpKzIpLFxuICAgICAgICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICAgICAgICBkb21haW5Db250ZXh0OiBhd2FpdCBhbmFseXplci5hbmFseXplRG9tYWluKHtcbiAgICAgICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBpICsgMSxcbiAgICAgICAgICAgICAgICBjb2RlU25pcHBldDogbGluZXNbaV0udHJpbSgpLFxuICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICAgICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkb21haW5Db250ZXh0OiB7IGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLCBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSwgc3VnZ2VzdGVkVHlwZXM6IFtdLCBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXSB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBjbGFzc2lmaWNhdGlvbiA9IGF3YWl0IGNsYXNzaWZpZXIuY2xhc3NpZnkoY29udGV4dCk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goeyBjb250ZXh0LCBjbGFzc2lmaWNhdGlvbiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGRvbWFpbi1zcGVjaWZpYyBwcmVzZXJ2YXRpb25cbiAgICAgIGNvbnN0IGFzdHJvbG9naWNhbFJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihyID0+XG4gICAgICAgIHIuY29udGV4dC5maWxlUGF0aC5pbmNsdWRlcygncGxhbmV0YXJ5JykgfHwgci5jb250ZXh0LmZpbGVQYXRoLmluY2x1ZGVzKCdjYWxjdWxhdGlvbnMnKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlY2lwZVJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihyID0+XG4gICAgICAgIHIuY29udGV4dC5maWxlUGF0aC5pbmNsdWRlcygnaW5ncmVkaWVudHMnKSB8fCByLmNvbnRleHQuZmlsZVBhdGguaW5jbHVkZXMoJ3NwaWNlcycpXG4gICAgICApO1xuICAgICAgY29uc3QgY2FtcGFpZ25SZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIociA9PlxuICAgICAgICByLmNvbnRleHQuZmlsZVBhdGguaW5jbHVkZXMoJ2NhbXBhaWduJykgfHwgci5jb250ZXh0LmZpbGVQYXRoLmluY2x1ZGVzKCdtZXRyaWNzJylcbiAgICAgICk7XG5cbiAgICAgIC8vIEFzdHJvbG9naWNhbCBkb21haW4gc2hvdWxkIHByZXNlcnZlIG1vc3QgYW55IHR5cGVzXG4gICAgICBleHBlY3QoYXN0cm9sb2dpY2FsUmVzdWx0cy5zb21lKHIgPT4gci5jbGFzc2lmaWNhdGlvbi5pc0ludGVudGlvbmFsKSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gUmVjaXBlIGRvbWFpbiBzaG91bGQgc3VnZ2VzdCBzcGVjaWZpYyB0eXBlcyBmb3Igc29tZSBjYXNlc1xuICAgICAgZXhwZWN0KHJlY2lwZVJlc3VsdHMuc29tZShyID0+ICFyLmNsYXNzaWZpY2F0aW9uLmlzSW50ZW50aW9uYWwgJiYgci5jbGFzc2lmaWNhdGlvbi5zdWdnZXN0ZWRSZXBsYWNlbWVudCkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIENhbXBhaWduIGRvbWFpbiBzaG91bGQgcHJlc2VydmUgZmxleGlibGUgY29uZmlndXJhdGlvbnNcbiAgICAgIGV4cGVjdChjYW1wYWlnblJlc3VsdHMuc29tZShyID0+IHIuY2xhc3NpZmljYXRpb24uaXNJbnRlbnRpb25hbCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYW1wYWlnbiBTeXN0ZW0gSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGludGVncmF0ZSB3aXRoIGV4aXN0aW5nIGNhbXBhaWduIGluZnJhc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FtcGFpZ25Db25maWc6IFVuaW50ZW50aW9uYWxBbnlDb25maWcgPSB7XG4gICAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDUsXG4gICAgICAgIHRhcmdldFJlZHVjdGlvblBlcmNlbnRhZ2U6IDIwLFxuICAgICAgICBjb25maWRlbmNlVGhyZXNob2xkOiAwLjg1LFxuICAgICAgICBlbmFibGVEb21haW5BbmFseXNpczogdHJ1ZSxcbiAgICAgICAgZW5hYmxlRG9jdW1lbnRhdGlvbjogdHJ1ZSxcbiAgICAgICAgc2FmZXR5TGV2ZWw6ICdISUdIJyxcbiAgICAgICAgdmFsaWRhdGlvbkZyZXF1ZW5jeTogM1xuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjYW1wYWlnbiBleGVjdXRpb25cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ3Rlc3QnKSkge1xuICAgICAgICAgIHJldHVybiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107IGNvbnN0IGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTsnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnYmFja3VwIGNvbnRlbnQnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNhbXBhaWduUmVzdWx0ID0gYXdhaXQgY2FtcGFpZ24uZXhlY3V0ZShjYW1wYWlnbkNvbmZpZyk7XG5cbiAgICAgIGV4cGVjdChjYW1wYWlnblJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChjYW1wYWlnblJlc3VsdC50b3RhbEFueVR5cGVzQW5hbHl6ZWQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICBleHBlY3QoY2FtcGFpZ25SZXN1bHQucmVkdWN0aW9uQWNoaWV2ZWQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICBleHBlY3QoY2FtcGFpZ25SZXN1bHQuc2FmZXR5RXZlbnRzKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgICBleHBlY3QoY2FtcGFpZ25SZXN1bHQudmFsaWRhdGlvblJlc3VsdHMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBmb2xsb3cgY2FtcGFpZ24gc2FmZXR5IHByb3RvY29scycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc2NlbmFyaW8gdGhhdCB0cmlnZ2VycyBzYWZldHkgcHJvdG9jb2xzXG4gICAgICBsZXQgZXJyb3JDb3VudCA9IDA7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kKSA9PiB7XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdncmVwIC1jIFwiZXJyb3IgVFNcIicpKSB7XG4gICAgICAgICAgZXJyb3JDb3VudCsrO1xuICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gMikge1xuICAgICAgICAgICAgcmV0dXJuICcxNSc7IC8vIFJldHVybiBpbmNyZWFzaW5nIGVycm9yIGNvdW50XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBtYXRjaGVzJykgYXMgYW55O1xuICAgICAgICAgIGVycm9yLnN0YXR1cyA9IDE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLXIgLWwnKSkge1xuICAgICAgICAgIHJldHVybiAnc3JjL3Byb2JsZW1hdGljLnRzXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhbmdlcm91czogYW55ID0gcGVyZm9ybVJpc2t5T3BlcmF0aW9uKCk7Jyk7XG5cbiAgICAgIGNvbnN0IGNhbXBhaWduQ29uZmlnOiBVbmludGVudGlvbmFsQW55Q29uZmlnID0ge1xuICAgICAgICBtYXhGaWxlc1BlckJhdGNoOiAxLFxuICAgICAgICB0YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlOiAxMCxcbiAgICAgICAgY29uZmlkZW5jZVRocmVzaG9sZDogMC43LFxuICAgICAgICBlbmFibGVEb21haW5BbmFseXNpczogdHJ1ZSxcbiAgICAgICAgZW5hYmxlRG9jdW1lbnRhdGlvbjogdHJ1ZSxcbiAgICAgICAgc2FmZXR5TGV2ZWw6ICdNQVhJTVVNJyxcbiAgICAgICAgdmFsaWRhdGlvbkZyZXF1ZW5jeTogMVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FtcGFpZ25SZXN1bHQgPSBhd2FpdCBjYW1wYWlnbi5leGVjdXRlKGNhbXBhaWduQ29uZmlnKTtcblxuICAgICAgZXhwZWN0KGNhbXBhaWduUmVzdWx0LnNhZmV0eUV2ZW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChjYW1wYWlnblJlc3VsdC5zYWZldHlFdmVudHMuc29tZShldmVudCA9PlxuICAgICAgICBldmVudC50eXBlID09PSAnTE9XX1NBRkVUWV9TQ09SRScgfHwgZXZlbnQudHlwZSA9PT0gJ0JBVENIX0ZBSUxVUkUnXG4gICAgICApKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGludGVncmF0ZSB3aXRoIHByb2dyZXNzIHRyYWNraW5nIGFuZCBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pbmNsdWRlcygnbWV0cmljcycpKSB7XG4gICAgICAgICAgcmV0dXJuICdjb25zdCBwcm9ncmVzc0RhdGE6IGFueSA9IGdldE1ldHJpY3MoKTsgY29uc3QgY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW5pdGlhbFByb2dyZXNzID0gYXdhaXQgZW5naW5lLmdldFByb2dyZXNzTWV0cmljcygpO1xuICAgICAgZXhwZWN0KGluaXRpYWxQcm9ncmVzcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChpbml0aWFsUHJvZ3Jlc3MudG90YWxBbnlUeXBlcykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcblxuICAgICAgY29uc3QgYmF0Y2hSZXN1bHQgPSBhd2FpdCBlbmdpbmUuZXhlY3V0ZUJhdGNoKHtcbiAgICAgICAgbWF4RmlsZXNQZXJCYXRjaDogMixcbiAgICAgICAgdGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZTogMTUsXG4gICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuOCxcbiAgICAgICAgZW5hYmxlRG9tYWluQW5hbHlzaXM6IHRydWUsXG4gICAgICAgIGVuYWJsZURvY3VtZW50YXRpb246IHRydWUsXG4gICAgICAgIHNhZmV0eUxldmVsOiAnTU9ERVJBVEUnLFxuICAgICAgICB2YWxpZGF0aW9uRnJlcXVlbmN5OiA1XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZmluYWxQcm9ncmVzcyA9IGF3YWl0IGVuZ2luZS5nZXRQcm9ncmVzc01ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChmaW5hbFByb2dyZXNzKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICBjb25zdCBiYXRjaEhpc3RvcnkgPSBlbmdpbmUuZ2V0QmF0Y2hIaXN0b3J5KCk7XG4gICAgICBleHBlY3QoYmF0Y2hIaXN0b3J5KS50b0NvbnRhaW4oYmF0Y2hSZXN1bHQpO1xuICAgICAgZXhwZWN0KGJhdGNoSGlzdG9yeS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhZmV0eSBQcm90b2NvbCBBY3RpdmF0aW9uIGFuZCBSb2xsYmFjayBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFjdGl2YXRlIHJvbGxiYWNrIG9uIGNvbXBpbGF0aW9uIGZhaWx1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGRhdGE6IGFueSA9IGdldFZhbHVlKCk7Jyk7XG5cbiAgICAgIC8vIE1vY2sgY29tcGlsYXRpb24gZmFpbHVyZVxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygndHNjJykpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IFR5cGUgXCJ1bmtub3duXCIgaXMgbm90IGFzc2lnbmFibGUgdG8gdHlwZSBcInN0cmluZ1wiJztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duJyxcbiAgICAgICAgZmlsZVBhdGg6ICdzcmMvdGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMyMicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBlbWVyZ2VuY3kgcm9sbGJhY2sgc2NlbmFyaW9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbXVsdGlwbGVSZXBsYWNlbWVudHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgICAgZmlsZVBhdGg6ICdzcmMvdGVzdDEudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAnc3RyaW5nJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3NyYy90ZXN0Mi50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ3Rlc3QxJykpIHJldHVybiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107JztcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoJ3Rlc3QyJykpIHJldHVybiAnY29uc3QgZGF0YTogYW55ID0gZ2V0VmFsdWUoKTsnO1xuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIG92ZXJhbGwgYnVpbGQgZmFpbHVyZSBhZnRlciBpbmRpdmlkdWFsIHJlcGxhY2VtZW50cyBzdWNjZWVkXG4gICAgICBsZXQgYnVpbGRDaGVja0NvdW50ID0gMDtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ3RzYycpICYmIGNvbW1hbmQuaW5jbHVkZXMoJy0tbm9FbWl0JykpIHtcbiAgICAgICAgICBidWlsZENoZWNrQ291bnQrKztcbiAgICAgICAgICBpZiAoYnVpbGRDaGVja0NvdW50ID4gMSkgeyAvLyBGYWlsIG9uIG92ZXJhbGwgYnVpbGQgY2hlY2tcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdPdmVyYWxsIGJ1aWxkIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IE11bHRpcGxlIHR5cGUgY29uZmxpY3RzIGRldGVjdGVkJztcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKG11bHRpcGxlUmVwbGFjZW1lbnRzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0NvbnRhaW4oJ011bHRpcGxlIHR5cGUgY29uZmxpY3RzIGRldGVjdGVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgcm9sbGJhY2sgaW50ZWdyaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAnc3JjL3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxDb250ZW50ID0gJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOyc7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogYW55KSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbENvbnRlbnQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBjb21waWxhdGlvbiBmYWlsdXJlIHRvIHRyaWdnZXIgcm9sbGJhY2tcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICBlcnJvci5zdGRvdXQgPSAnZXJyb3IgVFMyMzIyOiBUeXBlIGVycm9yJztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5iYWNrdXBQYXRoKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBWZXJpZnkgYmFja3VwIHdhcyBjcmVhdGVkIGFuZCB1c2VkIGZvciByb2xsYmFja1xuICAgICAgZXhwZWN0KG1vY2tGcy53cml0ZUZpbGVTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJy5iYWNrdXAnKSxcbiAgICAgICAgb3JpZ2luYWxDb250ZW50LFxuICAgICAgICAndXRmOCdcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWFsaXN0aWMgQmF0Y2ggUHJvY2Vzc2luZyB3aXRoIEFjdHVhbCBDb2RlYmFzZSBTYW1wbGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBwcm9jZXNzIHJlYWxpc3RpYyBUeXBlU2NyaXB0IGNvZGViYXNlIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVhbGlzdGljQ29kZVNhbXBsZXMgPSB7XG4gICAgICAgICdzcmMvY29tcG9uZW50cy9SZWNpcGVDYXJkLnRzeCc6IGBcbiAgICAgICAgICBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICAgICAgICAgIGludGVyZmFjZSBQcm9wcyB7XG4gICAgICAgICAgICByZWNpcGU6IGFueTtcbiAgICAgICAgICAgIG9uU2VsZWN0OiAocmVjaXBlOiBhbnkpID0+IHZvaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydCBjb25zdCBSZWNpcGVDYXJkOiBSZWFjdC5GQzxQcm9wcz4gPSAoeyByZWNpcGUsIG9uU2VsZWN0IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgb25TZWxlY3QocmVjaXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gPGRpdiBvbkNsaWNrPXtoYW5kbGVDbGlja30+e3JlY2lwZS5uYW1lfTwvZGl2PjtcbiAgICAgICAgICB9O1xuICAgICAgICBgLFxuICAgICAgICAnc3JjL3NlcnZpY2VzL0FwaVNlcnZpY2UudHMnOiBgXG4gICAgICAgICAgY2xhc3MgQXBpU2VydmljZSB7XG4gICAgICAgICAgICBhc3luYyBmZXRjaERhdGEoZW5kcG9pbnQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YTogYW55ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybURhdGEoZGF0YSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByaXZhdGUgdHJhbnNmb3JtRGF0YShkYXRhOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5kYXRhLCBwcm9jZXNzZWQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgICdzcmMvdXRpbHMvaGVscGVycy50cyc6IGBcbiAgICAgICAgICBleHBvcnQgY29uc3QgcHJvY2Vzc0l0ZW1zID0gKGl0ZW1zOiBhbnlbXSk6IGFueVtdID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW06IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGV4cG9ydCBjb25zdCBjcmVhdGVDb25maWcgPSAoKTogUmVjb3JkPHN0cmluZywgYW55PiA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBhcGlVcmw6IHByb2Nlc3MuZW52LkFQSV9VUkwsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgICAgICAgIHJldHJpZXM6IDNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgYCxcbiAgICAgICAgJ3NyYy9fX3Rlc3RzX18vaGVscGVycy50ZXN0LnRzJzogYFxuICAgICAgICAgIGltcG9ydCB7IHByb2Nlc3NJdGVtcyB9IGZyb20gJy4uL3V0aWxzL2hlbHBlcnMnO1xuXG4gICAgICAgICAgZGVzY3JpYmUoJ2hlbHBlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICB0ZXN0KCdwcm9jZXNzSXRlbXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vY2tJdGVtczogYW55W10gPSBbeyBuYW1lOiAndGVzdCcgfV07XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NJdGVtcyhtb2NrSXRlbXMpO1xuICAgICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRlc3QoJ3dpdGggbW9jayBkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtb2NrRm4gPSBqZXN0LmZuKCkgYXMgYW55O1xuICAgICAgICAgICAgICBtb2NrRm4ubW9ja1JldHVyblZhbHVlKHsgZGF0YTogJ3Rlc3QnIH0pO1xuICAgICAgICAgICAgICBleHBlY3QobW9ja0ZuKCkpLnRvRXF1YWwoeyBkYXRhOiAndGVzdCcgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgYFxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgZm9yIChjb25zdCBbZmlsZSwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMocmVhbGlzdGljQ29kZVNhbXBsZXMpKSB7XG4gICAgICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKGZpbGUuc3BsaXQoJy8nKS5wb3AoKT8ucmVwbGFjZSgnLnRzeCcsICcnKS5yZXBsYWNlKCcudHMnLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdiYWNrdXAgY29udGVudCc7XG4gICAgICB9KTtcblxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoY29tbWFuZCkgPT4ge1xuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtciAtbCcpKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlYWxpc3RpY0NvZGVTYW1wbGVzKS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5pbmNsdWRlcygnZ3JlcCAtYyBcImVycm9yIFRTXCInKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBtYXRjaGVzJykgYXMgYW55O1xuICAgICAgICAgIGVycm9yLnN0YXR1cyA9IDE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbmZpZzogVW5pbnRlbnRpb25hbEFueUNvbmZpZyA9IHtcbiAgICAgICAgbWF4RmlsZXNQZXJCYXRjaDogNCxcbiAgICAgICAgdGFyZ2V0UmVkdWN0aW9uUGVyY2VudGFnZTogMTUsXG4gICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuOCxcbiAgICAgICAgZW5hYmxlRG9tYWluQW5hbHlzaXM6IHRydWUsXG4gICAgICAgIGVuYWJsZURvY3VtZW50YXRpb246IHRydWUsXG4gICAgICAgIHNhZmV0eUxldmVsOiAnTU9ERVJBVEUnLFxuICAgICAgICB2YWxpZGF0aW9uRnJlcXVlbmN5OiAyXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBiYXRjaFJlc3VsdCA9IGF3YWl0IGVuZ2luZS5leGVjdXRlQmF0Y2goY29uZmlnKTtcblxuICAgICAgZXhwZWN0KGJhdGNoUmVzdWx0LmZpbGVzUHJvY2Vzc2VkKS50b0JlKDQpO1xuICAgICAgZXhwZWN0KGJhdGNoUmVzdWx0LmFueVR5cGVzQW5hbHl6ZWQpLnRvQmVHcmVhdGVyVGhhbigxMCk7IC8vIE11bHRpcGxlIGFueSB0eXBlcyBpbiBzYW1wbGVzXG4gICAgICBleHBlY3QoYmF0Y2hSZXN1bHQucmVwbGFjZW1lbnRzQXR0ZW1wdGVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG5cbiAgICAgIC8vIFNvbWUgcmVwbGFjZW1lbnRzIHNob3VsZCBiZSBzdWNjZXNzZnVsIChhcnJheXMsIHJlY29yZHMpXG4gICAgICAvLyBTb21lIHNob3VsZCBiZSBwcmVzZXJ2ZWQgKGVycm9yIGhhbmRsaW5nLCB0ZXN0IG1vY2tzLCBBUEkgcmVzcG9uc2VzKVxuICAgICAgZXhwZWN0KGJhdGNoUmVzdWx0LnJlcGxhY2VtZW50c1N1Y2Nlc3NmdWwpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICBleHBlY3QoYmF0Y2hSZXN1bHQuc2FmZXR5U2NvcmUpLnRvQmVHcmVhdGVyVGhhbigwLjUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsYXJnZS1zY2FsZSBiYXRjaCBwcm9jZXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR2VuZXJhdGUgYSBsYXJnZSBudW1iZXIgb2YgZmlsZXMgd2l0aCB2YXJpb3VzIGFueSB0eXBlIHBhdHRlcm5zXG4gICAgICBjb25zdCBnZW5lcmF0ZUZpbGVDb250ZW50ID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgICAgICAgYGNvbnN0IGl0ZW1zJHtpbmRleH06IGFueVtdID0gW107YCxcbiAgICAgICAgICBgY29uc3QgY29uZmlnJHtpbmRleH06IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtgLFxuICAgICAgICAgIGBmdW5jdGlvbiBwcm9jZXNzJHtpbmRleH0oZGF0YTogYW55KTogYW55IHsgcmV0dXJuIGRhdGE7IH1gLFxuICAgICAgICAgIGBjb25zdCByZXNwb25zZSR7aW5kZXh9OiBhbnkgPSBhd2FpdCBmZXRjaChcIi9hcGkvJHtpbmRleH1cIik7YCxcbiAgICAgICAgICBgfSBjYXRjaCAoZXJyb3Ike2luZGV4fTogYW55KSB7IGNvbnNvbGUubG9nKGVycm9yJHtpbmRleH0pOyB9YFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gcGF0dGVybnNbaW5kZXggJSBwYXR0ZXJucy5sZW5ndGhdO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZmlsZUNvdW50ID0gNTA7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kKSA9PiB7XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdncmVwIC1yIC1sJykpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkoZmlsZUNvdW50KS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gYHNyYy9maWxlJHtpfS50c2ApLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLmluY2x1ZGVzKCdncmVwIC1jIFwiZXJyb3IgVFNcIicpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIG1hdGNoZXMnKSBhcyBhbnk7XG4gICAgICAgICAgZXJyb3Iuc3RhdHVzID0gMTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHBhdGgudG9TdHJpbmcoKS5tYXRjaCgvZmlsZShcXGQrKVxcLnRzLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUZpbGVDb250ZW50KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2JhY2t1cCBjb250ZW50JztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb25maWc6IFVuaW50ZW50aW9uYWxBbnlDb25maWcgPSB7XG4gICAgICAgIG1heEZpbGVzUGVyQmF0Y2g6IDEwLFxuICAgICAgICB0YXJnZXRSZWR1Y3Rpb25QZXJjZW50YWdlOiAyMCxcbiAgICAgICAgY29uZmlkZW5jZVRocmVzaG9sZDogMC44LFxuICAgICAgICBlbmFibGVEb21haW5BbmFseXNpczogdHJ1ZSxcbiAgICAgICAgZW5hYmxlRG9jdW1lbnRhdGlvbjogdHJ1ZSxcbiAgICAgICAgc2FmZXR5TGV2ZWw6ICdNT0RFUkFURScsXG4gICAgICAgIHZhbGlkYXRpb25GcmVxdWVuY3k6IDVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBjYW1wYWlnblJlc3VsdCA9IGF3YWl0IGNhbXBhaWduLmV4ZWN1dGUoY29uZmlnKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QoY2FtcGFpZ25SZXN1bHQudG90YWxBbnlUeXBlc0FuYWx5emVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoY2FtcGFpZ25SZXN1bHQucmVkdWN0aW9uQWNoaWV2ZWQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDMwMDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAzMCBzZWNvbmRzXG5cbiAgICAgIC8vIFZlcmlmeSBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3NcbiAgICAgIGV4cGVjdChjYW1wYWlnblJlc3VsdC5zYWZldHlFdmVudHMubGVuZ3RoKS50b0JlTGVzc1RoYW4oMTApOyAvLyBTaG91bGQgaGF2ZSBtaW5pbWFsIHNhZmV0eSBpc3N1ZXNcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhZGFwdCB0byBkaWZmZXJlbnQgY29kZWJhc2UgY2hhcmFjdGVyaXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIGRpZmZlcmVudCBjb2RlYmFzZSBwcm9maWxlc1xuICAgICAgY29uc3QgY29kZWJhc2VzID0ge1xuICAgICAgICAndGVzdC1oZWF2eSc6IHtcbiAgICAgICAgICBmaWxlczoge1xuICAgICAgICAgICAgJ3NyYy90ZXN0MS50ZXN0LnRzJzogJ2NvbnN0IG1vY2tEYXRhOiBhbnkgPSB7fTsgY29uc3Qgc3B5OiBhbnkgPSBqZXN0LmZuKCk7JyxcbiAgICAgICAgICAgICdzcmMvdGVzdDIuc3BlYy50cyc6ICdjb25zdCBmaXh0dXJlOiBhbnkgPSBjcmVhdGVGaXh0dXJlKCk7J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhwZWN0ZWRCZWhhdmlvcjogJ3ByZXNlcnZlIG1vc3QgYW55IHR5cGVzIGR1ZSB0byB0ZXN0IGNvbnRleHQnXG4gICAgICAgIH0sXG4gICAgICAgICdhcGktaGVhdnknOiB7XG4gICAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAgICdzcmMvYXBpMS50cyc6ICdjb25zdCByZXNwb25zZTogYW55ID0gYXdhaXQgZmV0Y2goXCIvYXBpXCIpOyBjb25zdCBkYXRhOiBhbnkgPSByZXNwb25zZS5qc29uKCk7JyxcbiAgICAgICAgICAgICdzcmMvYXBpMi50cyc6ICdjb25zdCByZXN1bHQ6IGFueSA9IGF3YWl0IGFwaUNhbGwoKTsnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHBlY3RlZEJlaGF2aW9yOiAncHJlc2VydmUgQVBJLXJlbGF0ZWQgYW55IHR5cGVzJ1xuICAgICAgICB9LFxuICAgICAgICAndXRpbGl0eS1oZWF2eSc6IHtcbiAgICAgICAgICBmaWxlczoge1xuICAgICAgICAgICAgJ3NyYy91dGlsMS50cyc6ICdjb25zdCBpdGVtczogYW55W10gPSBbXTsgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307JyxcbiAgICAgICAgICAgICdzcmMvdXRpbDIudHMnOiAnZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGE6IGFueVtdKTogYW55W10geyByZXR1cm4gZGF0YTsgfSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4cGVjdGVkQmVoYXZpb3I6ICdyZXBsYWNlIG1hbnkgdXRpbGl0eSBhbnkgdHlwZXMnXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAoY29uc3QgW2NvZGViYXNlVHlwZSwgeyBmaWxlcywgZXhwZWN0ZWRCZWhhdmlvciB9XSBvZiBPYmplY3QuZW50cmllcyhjb2RlYmFzZXMpKSB7XG4gICAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtmaWxlLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhmaWxlcykpIHtcbiAgICAgICAgICAgIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhmaWxlLnNwbGl0KCcvJykucG9wKCk/LnJlcGxhY2UoL1xcLih0ZXN0fHNwZWMpXFwudHMkLywgJycpLnJlcGxhY2UoJy50cycsICcnKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnYmFja3VwIGNvbnRlbnQnO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChjb21tYW5kKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLXIgLWwnKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbGVzKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLWMgXCJlcnJvciBUU1wiJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBtYXRjaGVzJykgYXMgYW55O1xuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzID0gMTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZzogVW5pbnRlbnRpb25hbEFueUNvbmZpZyA9IHtcbiAgICAgICAgICBtYXhGaWxlc1BlckJhdGNoOiBPYmplY3Qua2V5cyhmaWxlcykubGVuZ3RoLFxuICAgICAgICAgIHRhcmdldFJlZHVjdGlvblBlcmNlbnRhZ2U6IDE1LFxuICAgICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuOCxcbiAgICAgICAgICBlbmFibGVEb21haW5BbmFseXNpczogdHJ1ZSxcbiAgICAgICAgICBlbmFibGVEb2N1bWVudGF0aW9uOiB0cnVlLFxuICAgICAgICAgIHNhZmV0eUxldmVsOiAnTU9ERVJBVEUnLFxuICAgICAgICAgIHZhbGlkYXRpb25GcmVxdWVuY3k6IDJcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiYXRjaFJlc3VsdCA9IGF3YWl0IGVuZ2luZS5leGVjdXRlQmF0Y2goY29uZmlnKTtcblxuICAgICAgICBleHBlY3QoYmF0Y2hSZXN1bHQuZmlsZXNQcm9jZXNzZWQpLnRvQmUoT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCk7XG4gICAgICAgIGV4cGVjdChiYXRjaFJlc3VsdC5hbnlUeXBlc0FuYWx5emVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG5cbiAgICAgICAgLy8gVmVyaWZ5IGJlaGF2aW9yIG1hdGNoZXMgZXhwZWN0YXRpb25zXG4gICAgICAgIGlmIChjb2RlYmFzZVR5cGUgPT09ICd0ZXN0LWhlYXZ5Jykge1xuICAgICAgICAgIC8vIFRlc3QgZmlsZXMgc2hvdWxkIGhhdmUgbG93ZXIgcmVwbGFjZW1lbnQgcmF0ZXNcbiAgICAgICAgICBleHBlY3QoYmF0Y2hSZXN1bHQucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCAvIE1hdGgubWF4KDEsIGJhdGNoUmVzdWx0LnJlcGxhY2VtZW50c0F0dGVtcHRlZCkpLnRvQmVMZXNzVGhhbigwLjUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGViYXNlVHlwZSA9PT0gJ3V0aWxpdHktaGVhdnknKSB7XG4gICAgICAgICAgLy8gVXRpbGl0eSBmaWxlcyBzaG91bGQgaGF2ZSBoaWdoZXIgcmVwbGFjZW1lbnQgcmF0ZXNcbiAgICAgICAgICBleHBlY3QoYmF0Y2hSZXN1bHQucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCAvIE1hdGgubWF4KDEsIGJhdGNoUmVzdWx0LnJlcGxhY2VtZW50c0F0dGVtcHRlZCkpLnRvQmVHcmVhdGVyVGhhbigwLjMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYCR7Y29kZWJhc2VUeXBlfTogJHtleHBlY3RlZEJlaGF2aW9yfSAtIFN1Y2Nlc3MgcmF0ZTogJHsoYmF0Y2hSZXN1bHQucmVwbGFjZW1lbnRzU3VjY2Vzc2Z1bCAvIE1hdGgubWF4KDEsIGJhdGNoUmVzdWx0LnJlcGxhY2VtZW50c0F0dGVtcHRlZCkgKiAxMDApLnRvRml4ZWQoMSl9JWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgUmVjb3ZlcnkgYW5kIFJlc2lsaWVuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlY292ZXIgZnJvbSB0cmFuc2llbnQgZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgZmFpbHVyZUNvdW50ID0gMDtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ3RzYycpKSB7XG4gICAgICAgICAgZmFpbHVyZUNvdW50Kys7XG4gICAgICAgICAgaWYgKGZhaWx1cmVDb3VudCA8PSAyKSB7XG4gICAgICAgICAgICAvLyBGYWlsIGZpcnN0IHR3byBhdHRlbXB0cywgdGhlbiBzdWNjZWVkXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHJhbnNpZW50IGZhaWx1cmUnKSBhcyBhbnk7XG4gICAgICAgICAgICBlcnJvci5zdGRvdXQgPSAnZXJyb3IgVFMyMzIyOiBUZW1wb3JhcnkgdHlwZSBjb25mbGljdCc7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dyZXAgLXIgLWwnKSkge1xuICAgICAgICAgIHJldHVybiAnc3JjL3Rlc3QudHNcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IGFueVtdID0gW107Jyk7XG5cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3NyYy90ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICAvLyBTaG91bGQgZXZlbnR1YWxseSBzdWNjZWVkIGFmdGVyIHJldHJpZXNcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChmYWlsdXJlQ291bnQpLnRvQmVHcmVhdGVyVGhhbigyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBtYWludGFpbiBkYXRhIGludGVncml0eSBkdXJpbmcgZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbENvbnRlbnQgPSAnY29uc3QgaXRlbXM6IGFueVtdID0gW107IGNvbnN0IGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTsnO1xuICAgICAgbGV0IGJhY2t1cENvbnRlbnQgPSAnJztcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pbmNsdWRlcygnLmJhY2t1cCcpKSB7XG4gICAgICAgICAgcmV0dXJuIGJhY2t1cENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ29udGVudDtcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRnMud3JpdGVGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IGFueSwgY29udGVudDogYW55KSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICBiYWNrdXBDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZmFpbHVyZSBzY2VuYXJpb1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDb21waWxhdGlvbiBmYWlsZWQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IFR5cGUgZXJyb3InO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXBsYWNlbWVudHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgICAgZmlsZVBhdGg6ICdzcmMvdGVzdC50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ1JlY29yZDxzdHJpbmcsIGFueT4nLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAnUmVjb3JkPHN0cmluZywgdW5rbm93bj4nLFxuICAgICAgICAgIGZpbGVQYXRoOiAnc3JjL3Rlc3QudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5wcm9jZXNzQmF0Y2gocmVwbGFjZW1lbnRzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFZlcmlmeSBiYWNrdXAgd2FzIGNyZWF0ZWQgd2l0aCBvcmlnaW5hbCBjb250ZW50XG4gICAgICBleHBlY3QoYmFja3VwQ29udGVudCkudG9CZShvcmlnaW5hbENvbnRlbnQpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9