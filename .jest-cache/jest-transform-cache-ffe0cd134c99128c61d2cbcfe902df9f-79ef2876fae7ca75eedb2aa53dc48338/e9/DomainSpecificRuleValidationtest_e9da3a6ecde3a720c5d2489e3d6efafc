9f0b4d7c0383e91d50d9c4cc525b8079
"use strict";
/**
 * Domain-Specific Rule Validation Test Suite
 *
 * Tests the validation and optimization of domain-specific ESLint rules for:
 * - Astrological calculation files
 * - Campaign system files
 * - Test files
 * - Configuration files
 *
 * Requirements: 4.1, 4.2, 4.3, 4.4
 */
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const { DomainSpecificRuleValidator } = require('../../scripts/validateDomainSpecificRules.cjs');
describe('Domain-Specific Rule Validation', () => {
    let validator;
    const projectRoot = process.cwd();
    beforeEach(() => {
        validator = new DomainSpecificRuleValidator();
    });
    afterEach(() => {
        // Clean up any temporary test files
        const tempFiles = [
            'temp-planetary-test.ts',
            'temp-elemental-test.ts',
            'temp-fallback-test.ts',
            'src/services/campaign/temp-logging-test.ts',
            'src/services/campaign/temp-variable-test.ts',
            'temp-mock-test.test.ts',
            'temp-relaxation-test.test.ts',
            'temp-globals-test.test.ts',
            'temp-require-test.config.js',
            'temp-config-relaxation.config.ts'
        ];
        tempFiles.forEach(file => {
            try {
                (0, child_process_1.execSync)(`rm -f "${(0, path_1.join)(projectRoot, file)}"`);
            }
            catch { }
        });
    });
    describe('Overall Validation', () => {
        test('should validate all domain-specific rules', async () => {
            const results = await validator.validateDomainSpecificRules();
            expect(results).toBeDefined();
            expect(results.overall).toBeDefined();
            expect(results.overall.score).toBeGreaterThanOrEqual(0);
            expect(results.overall.score).toBeLessThanOrEqual(100);
            // Check that all categories are present
            expect(results.astrologicalFiles).toBeDefined();
            expect(results.campaignSystemFiles).toBeDefined();
            expect(results.testFiles).toBeDefined();
            expect(results.configurationFiles).toBeDefined();
        });
        test('should generate validation report', async () => {
            const _results = await validator.validateDomainSpecificRules();
            // Check that report file is created
            const reportPath = (0, path_1.join)(projectRoot, 'domain-specific-rule-validation-report.json');
            expect((0, fs_1.existsSync)(reportPath)).toBe(true);
            // Verify report content
            const reportContent = JSON.parse((0, fs_1.readFileSync)(reportPath, 'utf8'));
            expect(reportContent.overall).toBeDefined();
            expect(reportContent.astrologicalFiles).toBeDefined();
            expect(reportContent.campaignSystemFiles).toBeDefined();
            expect(reportContent.testFiles).toBeDefined();
            expect(reportContent.configurationFiles).toBeDefined();
        });
    });
    describe('Astrological File Rules', () => {
        test('should preserve mathematical constants', async () => {
            // Create test file with protected constants
            const testContent = `
        const DEGREES_PER_SIGN = 30;
        const RELIABLE_POSITIONS = { sun: { sign: 'aries', degree: 8.5 } };

        // This should be flagged
        // DEGREES_PER_SIGN = 25;
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/calculations/temp-constants-test.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                // Run ESLint to check for violations
                (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs`, {
                    stdio: 'pipe',
                    cwd: projectRoot
                });
                // If no error, constants are properly preserved
                expect(true).toBe(true);
            }
            catch (error) {
                // Check if it's a legitimate constant preservation error
                const output = error.stderr?.toString() || '';
                if (output.includes('preserve-planetary-constants')) {
                    fail('Mathematical constants should be preserved');
                }
            }
            finally {
                // Clean up
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should recognize planetary variable patterns', async () => {
            const testContent = `
        const planet = 'mars';
        const position = { sign: 'cancer', degree: 22.63 };
        const longitude = 112.63;
        const retrograde = false;
        const UNUSED_planet = 'unused';
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/calculations/temp-planetary-vars.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('planet') || msg.message.includes('position') || msg.message.includes('longitude')));
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                // ESLint errors are expected, check if they're the right kind
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('planet') || msg.message.includes('position') || msg.message.includes('longitude')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should validate elemental properties structure', async () => {
            const validElementalContent = `
        const elementalProps = {
          Fire: 0.8,
          Water: 0.2,
          Earth: 0.1,
          Air: 0.3
        };
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/calculations/temp-elemental-valid.ts');
            (0, fs_1.writeFileSync)(testFile, validElementalContent);
            try {
                (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs`, {
                    stdio: 'pipe',
                    cwd: projectRoot
                });
                // Valid elemental properties should not cause errors
                expect(true).toBe(true);
            }
            catch (error) {
                const output = error.stderr?.toString() || '';
                if (output.includes('validate-elemental-properties')) {
                    fail('Valid elemental properties should not be flagged');
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should detect invalid elemental properties', async () => {
            const invalidElementalContent = `
        const badElementalProps = {
          Fire: 0.8,
          Water: 0.2,
          // Missing Earth and Air - should be flagged
        };
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/calculations/temp-elemental-invalid.ts');
            (0, fs_1.writeFileSync)(testFile, invalidElementalContent);
            try {
                (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs`, {
                    stdio: 'pipe',
                    cwd: projectRoot
                });
                // Should have caught the invalid properties
                // If we reach here without error, the rule didn't work
                console.warn('Invalid elemental properties not caught by validation rule');
            }
            catch (error) {
                const output = error.stderr?.toString() || '';
                // We expect this to fail with our custom rule
                expect(output.includes('validate-elemental-properties') || output.length > 0).toBe(true);
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should preserve fallback values', async () => {
            const testContent = `
        const FALLBACK_POSITIONS = { sun: { sign: 'aries', degree: 8.5 } };
        const RELIABLE_DATA = { mars: { sign: 'cancer', degree: 22.63 } };
        const MARCH2025_BACKUP = { moon: { sign: 'aries', degree: 1.57 } };
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/calculations/temp-fallback-valid.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs`, {
                    stdio: 'pipe',
                    cwd: projectRoot
                });
                // Valid fallback values should not cause errors
                expect(true).toBe(true);
            }
            catch (error) {
                const output = error.stderr?.toString() || '';
                if (output.includes('preserve-fallback-values')) {
                    fail('Valid fallback values should not be flagged');
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
    });
    describe('Campaign System File Rules', () => {
        test('should allow enterprise patterns', async () => {
            const testContent = `
        class CampaignController {
          private complexMethod() {
            // Complex enterprise logic with high complexity
            let result = 0;
            for (let i = 0; i < 10; i++) {
              for (let j = 0; j < 10; j++) {
                if (i > 5) {
                  if (j > 5) {
                    result += i * j;
                  } else {
                    result += i + j;
                  }
                } else {
                  result += i - j;
                }
              }
            }
            return result;
          }
        }
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/services/campaign/temp-enterprise-test.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2 // error level
                    );
                    // Campaign files should allow higher complexity
                    expect(complexityErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const complexityErrors = result[0].messages.filter((msg) => msg.ruleId === 'complexity' && msg.severity === 2);
                        expect(complexityErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should allow extensive logging', async () => {
            const testContent = `
        console.log('Campaign progress update');
        console.warn('Safety protocol activated');
        console.error('Campaign failure detected');
        console.info('Metrics collected');
        console.debug('Detailed debugging info');
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/services/campaign/temp-logging-test.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2 // error level
                    );
                    // Campaign files should allow console logging
                    expect(consoleErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const consoleErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-console' && msg.severity === 2);
                        expect(consoleErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should recognize campaign variable patterns', async () => {
            const testContent = `
        const campaign = 'typescript-elimination';
        const progress = 0.75;
        const metrics = { errors: 100 };
        const safety = true;
        const UNUSED_campaign = 'unused';
      `;
            const testFile = (0, path_1.join)(projectRoot, 'src/services/campaign/temp-campaign-vars.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('campaign') || msg.message.includes('progress') ||
                            msg.message.includes('metrics') || msg.message.includes('safety')));
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('campaign') || msg.message.includes('progress') ||
                                msg.message.includes('metrics') || msg.message.includes('safety')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
    });
    describe('Test File Rules', () => {
        test('should allow mock variable patterns', async () => {
            const testContent = `
        const mockFunction = jest.fn();
        const stubValue = 'test-stub';
        const testData = { id: 1 };
        const UNUSED_mock = 'unused';
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-mock-patterns.test.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                        (msg.message.includes('mockFunction') || msg.message.includes('stubValue') ||
                            msg.message.includes('testData')));
                    expect(unusedVarErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const unusedVarErrors = result[0].messages.filter((msg) => msg.ruleId === '@typescript-eslint/no-unused-vars' &&
                            (msg.message.includes('mockFunction') || msg.message.includes('stubValue') ||
                                msg.message.includes('testData')));
                        expect(unusedVarErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should have relaxed rules for testing patterns', async () => {
            const testContent = `
        const anyValue: any = 'test-any';
        console.log('Test output');
        const value = someObject!.property; // non-null assertion
        const magicNumber = 42; // magic number
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-test-relaxations.test.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const restrictiveErrors = result[0].messages.filter((msg) => (msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2) ||
                        (msg.ruleId === 'no-console' && msg.severity === 2) ||
                        (msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2) ||
                        (msg.ruleId === 'no-magic-numbers' && msg.severity === 2));
                    expect(restrictiveErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const restrictiveErrors = result[0].messages.filter((msg) => (msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2) ||
                            (msg.ruleId === 'no-console' && msg.severity === 2) ||
                            (msg.ruleId === '@typescript-eslint/no-non-null-assertion' && msg.severity === 2) ||
                            (msg.ruleId === 'no-magic-numbers' && msg.severity === 2));
                        expect(restrictiveErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should have Jest globals available', async () => {
            const testContent = `
        describe('Test suite', () => {
          it('should work', () => {
            expect(true).toBe(true);
          });

          beforeEach(() => {
            jest.clearAllMocks();
          });
        });
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-jest-globals.test.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                        (msg.message.includes('describe') || msg.message.includes('it') ||
                            msg.message.includes('expect') || msg.message.includes('jest')));
                    expect(undefErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const undefErrors = result[0].messages.filter((msg) => msg.ruleId === 'no-undef' &&
                            (msg.message.includes('describe') || msg.message.includes('it') ||
                                msg.message.includes('expect') || msg.message.includes('jest')));
                        expect(undefErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
    });
    describe('Configuration File Rules', () => {
        test('should allow dynamic requires', async () => {
            const testContent = `
        const config = require('./some-config');
        const dynamicModule = require(process.env.MODULE_NAME);
        module.exports = { ...config };
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-dynamic-require.config.js');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const requireErrors = result[0].messages.filter((msg) => msg.ruleId === 'import/no-dynamic-require' && msg.severity === 2);
                    expect(requireErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const requireErrors = result[0].messages.filter((msg) => msg.ruleId === 'import/no-dynamic-require' && msg.severity === 2);
                        expect(requireErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
        test('should have relaxed rules for build patterns', async () => {
            const testContent = `
        const anyConfig: any = process.env.CONFIG;
        console.log('Configuration loaded');
        const dynamicRequire = require(process.env.MODULE);
      `;
            const testFile = (0, path_1.join)(projectRoot, 'temp-build-patterns.config.ts');
            (0, fs_1.writeFileSync)(testFile, testContent);
            try {
                const output = (0, child_process_1.execSync)(`npx eslint "${testFile}" --config eslint.config.cjs --format json`, {
                    encoding: 'utf8',
                    cwd: projectRoot
                });
                const result = JSON.parse(output);
                if (result.length > 0 && result[0].messages) {
                    const restrictiveErrors = result[0].messages.filter((msg) => (msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2) ||
                        (msg.ruleId === 'no-console' && msg.severity === 2) ||
                        (msg.ruleId === 'import/no-dynamic-require' && msg.severity === 2));
                    expect(restrictiveErrors.length).toBe(0);
                }
            }
            catch (error) {
                const output = error.stdout?.toString() || '';
                if (output) {
                    const result = JSON.parse(output);
                    if (result.length > 0 && result[0].messages) {
                        const restrictiveErrors = result[0].messages.filter((msg) => (msg.ruleId === '@typescript-eslint/no-explicit-any' && msg.severity === 2) ||
                            (msg.ruleId === 'no-console' && msg.severity === 2) ||
                            (msg.ruleId === 'import/no-dynamic-require' && msg.severity === 2));
                        expect(restrictiveErrors.length).toBe(0);
                    }
                }
            }
            finally {
                try {
                    (0, child_process_1.execSync)(`rm -f "${testFile}"`);
                }
                catch { }
            }
        });
    });
    describe('ESLint Configuration Integration', () => {
        test('should have proper file pattern matching', () => {
            // Test that ESLint config has the right file patterns
            const eslintConfigPath = (0, path_1.join)(projectRoot, 'eslint.config.cjs');
            expect((0, fs_1.existsSync)(eslintConfigPath)).toBe(true);
            const configContent = (0, fs_1.readFileSync)(eslintConfigPath, 'utf8');
            // Check for astrological file patterns
            expect(configContent).toContain('**/calculations/**/*.ts');
            expect(configContent).toContain('**/data/planets/**/*.ts');
            expect(configContent).toContain('**/utils/reliableAstronomy.ts');
            // Check for campaign system patterns
            expect(configContent).toContain('**/services/campaign/**/*.ts');
            // Check for test file patterns
            expect(configContent).toContain('**/*.test.ts');
            expect(configContent).toContain('**/*.spec.ts');
            expect(configContent).toContain('**/__tests__/**/*.ts');
            // Check for config file patterns
            expect(configContent).toContain('*.config.js');
            expect(configContent).toContain('*.config.ts');
        });
        test('should have custom astrological rules plugin', () => {
            const pluginPath = (0, path_1.join)(projectRoot, 'src/eslint-plugins/astrological-rules.cjs');
            expect((0, fs_1.existsSync)(pluginPath)).toBe(true);
            const pluginContent = (0, fs_1.readFileSync)(pluginPath, 'utf8');
            // Check for custom rules
            expect(pluginContent).toContain('preserve-planetary-constants');
            expect(pluginContent).toContain('validate-planetary-position-structure');
            expect(pluginContent).toContain('validate-elemental-properties');
            expect(pluginContent).toContain('require-transit-date-validation');
            expect(pluginContent).toContain('preserve-fallback-values');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9fX3Rlc3RzX18vbGludGluZy9Eb21haW5TcGVjaWZpY1J1bGVWYWxpZGF0aW9uLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7O0dBVUc7O0FBRUgsaURBQXlDO0FBQ3pDLDJCQUE2RDtBQUM3RCwrQkFBNEI7QUFFNUIsTUFBTSxFQUFFLDJCQUEyQixFQUFFLEdBQUcsT0FBTyxDQUFDLCtDQUErQyxDQUFDLENBQUM7QUFFakcsUUFBUSxDQUFDLGlDQUFpQyxFQUFFLEdBQUcsRUFBRTtJQUMvQyxJQUFJLFNBQTZDLENBQUM7SUFDbEQsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRWxDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxTQUFTLEdBQUcsSUFBSSwyQkFBMkIsRUFBRSxDQUFDO0lBQ2hELENBQUMsQ0FBQyxDQUFDO0lBRUgsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLG9DQUFvQztRQUNwQyxNQUFNLFNBQVMsR0FBRztZQUNoQix3QkFBd0I7WUFDeEIsd0JBQXdCO1lBQ3hCLHVCQUF1QjtZQUN2Qiw0Q0FBNEM7WUFDNUMsNkNBQTZDO1lBQzdDLHdCQUF3QjtZQUN4Qiw4QkFBOEI7WUFDOUIsMkJBQTJCO1lBQzNCLDZCQUE2QjtZQUM3QixrQ0FBa0M7U0FDbkMsQ0FBQztRQUVGLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdkIsSUFBSTtnQkFDRixJQUFBLHdCQUFRLEVBQUMsVUFBVSxJQUFBLFdBQUksRUFBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2hEO1lBQUMsTUFBTSxHQUFFO1FBQ1osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7UUFDbEMsSUFBSSxDQUFDLDJDQUEyQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lB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QUFJLENBQUMsQ0FBQztZQUUxQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFZLEVBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRXZELHlCQUF5QjtZQUN6QixNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsU0FBUyxDQUFDLDhCQUE4QixDQUFDLENBQUM7WUFDaEUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1lBQ3pFLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxTQUFTLENBQUMsK0JBQStCLENBQUMsQ0FBQztZQUNqRSxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsU0FBUyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7WUFDbkUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLFNBQVMsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1FBQzlELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvR3JlZ0Nhc3Ryby9EZXNrdG9wL1doYXRUb0VhdE5leHQvc3JjL19fdGVzdHNfXy9saW50aW5nL0RvbWFpblNwZWNpZmljUnVsZVZhbGlkYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERvbWFpbi1TcGVjaWZpYyBSdWxlIFZhbGlkYXRpb24gVGVzdCBTdWl0ZVxuICpcbiAqIFRlc3RzIHRoZSB2YWxpZGF0aW9uIGFuZCBvcHRpbWl6YXRpb24gb2YgZG9tYWluLXNwZWNpZmljIEVTTGludCBydWxlcyBmb3I6XG4gKiAtIEFzdHJvbG9naWNhbCBjYWxjdWxhdGlvbiBmaWxlc1xuICogLSBDYW1wYWlnbiBzeXN0ZW0gZmlsZXNcbiAqIC0gVGVzdCBmaWxlc1xuICogLSBDb25maWd1cmF0aW9uIGZpbGVzXG4gKlxuICogUmVxdWlyZW1lbnRzOiA0LjEsIDQuMiwgNC4zLCA0LjRcbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jLCB3cml0ZUZpbGVTeW5jIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5jb25zdCB7IERvbWFpblNwZWNpZmljUnVsZVZhbGlkYXRvciB9ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0cy92YWxpZGF0ZURvbWFpblNwZWNpZmljUnVsZXMuY2pzJyk7XG5cbmRlc2NyaWJlKCdEb21haW4tU3BlY2lmaWMgUnVsZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICBsZXQgdmFsaWRhdG9yOiB0eXBlb2YgRG9tYWluU3BlY2lmaWNSdWxlVmFsaWRhdG9yO1xuICBjb25zdCBwcm9qZWN0Um9vdCA9IHByb2Nlc3MuY3dkKCk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdmFsaWRhdG9yID0gbmV3IERvbWFpblNwZWNpZmljUnVsZVZhbGlkYXRvcigpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIGFueSB0ZW1wb3JhcnkgdGVzdCBmaWxlc1xuICAgIGNvbnN0IHRlbXBGaWxlcyA9IFtcbiAgICAgICd0ZW1wLXBsYW5ldGFyeS10ZXN0LnRzJyxcbiAgICAgICd0ZW1wLWVsZW1lbnRhbC10ZXN0LnRzJyxcbiAgICAgICd0ZW1wLWZhbGxiYWNrLXRlc3QudHMnLFxuICAgICAgJ3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi90ZW1wLWxvZ2dpbmctdGVzdC50cycsXG4gICAgICAnc3JjL3NlcnZpY2VzL2NhbXBhaWduL3RlbXAtdmFyaWFibGUtdGVzdC50cycsXG4gICAgICAndGVtcC1tb2NrLXRlc3QudGVzdC50cycsXG4gICAgICAndGVtcC1yZWxheGF0aW9uLXRlc3QudGVzdC50cycsXG4gICAgICAndGVtcC1nbG9iYWxzLXRlc3QudGVzdC50cycsXG4gICAgICAndGVtcC1yZXF1aXJlLXRlc3QuY29uZmlnLmpzJyxcbiAgICAgICd0ZW1wLWNvbmZpZy1yZWxheGF0aW9uLmNvbmZpZy50cydcbiAgICBdO1xuXG4gICAgdGVtcEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBleGVjU3luYyhgcm0gLWYgXCIke2pvaW4ocHJvamVjdFJvb3QsIGZpbGUpfVwiYCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdPdmVyYWxsIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHZhbGlkYXRlIGFsbCBkb21haW4tc3BlY2lmaWMgcnVsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlRG9tYWluU3BlY2lmaWNSdWxlcygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLm92ZXJhbGwpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0cy5vdmVyYWxsLnNjb3JlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdHMub3ZlcmFsbC5zY29yZSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDApO1xuXG4gICAgICAvLyBDaGVjayB0aGF0IGFsbCBjYXRlZ29yaWVzIGFyZSBwcmVzZW50XG4gICAgICBleHBlY3QocmVzdWx0cy5hc3Ryb2xvZ2ljYWxGaWxlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmNhbXBhaWduU3lzdGVtRmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0cy50ZXN0RmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0cy5jb25maWd1cmF0aW9uRmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2VuZXJhdGUgdmFsaWRhdGlvbiByZXBvcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBfcmVzdWx0cyA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZURvbWFpblNwZWNpZmljUnVsZXMoKTtcblxuICAgICAgLy8gQ2hlY2sgdGhhdCByZXBvcnQgZmlsZSBpcyBjcmVhdGVkXG4gICAgICBjb25zdCByZXBvcnRQYXRoID0gam9pbihwcm9qZWN0Um9vdCwgJ2RvbWFpbi1zcGVjaWZpYy1ydWxlLXZhbGlkYXRpb24tcmVwb3J0Lmpzb24nKTtcbiAgICAgIGV4cGVjdChleGlzdHNTeW5jKHJlcG9ydFBhdGgpKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBWZXJpZnkgcmVwb3J0IGNvbnRlbnRcbiAgICAgIGNvbnN0IHJlcG9ydENvbnRlbnQgPSBKU09OLnBhcnNlKHJlYWRGaWxlU3luYyhyZXBvcnRQYXRoLCAndXRmOCcpKTtcbiAgICAgIGV4cGVjdChyZXBvcnRDb250ZW50Lm92ZXJhbGwpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVwb3J0Q29udGVudC5hc3Ryb2xvZ2ljYWxGaWxlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXBvcnRDb250ZW50LmNhbXBhaWduU3lzdGVtRmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVwb3J0Q29udGVudC50ZXN0RmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVwb3J0Q29udGVudC5jb25maWd1cmF0aW9uRmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBc3Ryb2xvZ2ljYWwgRmlsZSBSdWxlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcHJlc2VydmUgbWF0aGVtYXRpY2FsIGNvbnN0YW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB0ZXN0IGZpbGUgd2l0aCBwcm90ZWN0ZWQgY29uc3RhbnRzXG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgY29uc3QgREVHUkVFU19QRVJfU0lHTiA9IDMwO1xuICAgICAgICBjb25zdCBSRUxJQUJMRV9QT1NJVElPTlMgPSB7IHN1bjogeyBzaWduOiAnYXJpZXMnLCBkZWdyZWU6IDguNSB9IH07XG5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgZmxhZ2dlZFxuICAgICAgICAvLyBERUdSRUVTX1BFUl9TSUdOID0gMjU7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICdzcmMvY2FsY3VsYXRpb25zL3RlbXAtY29uc3RhbnRzLXRlc3QudHMnKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUnVuIEVTTGludCB0byBjaGVjayBmb3IgdmlvbGF0aW9uc1xuICAgICAgICBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janNgLCB7XG4gIHN0ZGlvOiAncGlwZScsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiBubyBlcnJvciwgY29uc3RhbnRzIGFyZSBwcm9wZXJseSBwcmVzZXJ2ZWRcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgbGVnaXRpbWF0ZSBjb25zdGFudCBwcmVzZXJ2YXRpb24gZXJyb3JcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3RkZXJyPy50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0LmluY2x1ZGVzKCdwcmVzZXJ2ZS1wbGFuZXRhcnktY29uc3RhbnRzJykpIHtcbiAgICAgICAgICBmYWlsKCdNYXRoZW1hdGljYWwgY29uc3RhbnRzIHNob3VsZCBiZSBwcmVzZXJ2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjU3luYyhgcm0gLWYgXCIke3Rlc3RGaWxlfVwiYCk7XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWNvZ25pemUgcGxhbmV0YXJ5IHZhcmlhYmxlIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGNvbnN0IHBsYW5ldCA9ICdtYXJzJztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7IHNpZ246ICdjYW5jZXInLCBkZWdyZWU6IDIyLjYzIH07XG4gICAgICAgIGNvbnN0IGxvbmdpdHVkZSA9IDExMi42MztcbiAgICAgICAgY29uc3QgcmV0cm9ncmFkZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBVTlVTRURfcGxhbmV0ID0gJ3VudXNlZCc7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICdzcmMvY2FsY3VsYXRpb25zL3RlbXAtcGxhbmV0YXJ5LXZhcnMudHMnKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG5cbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiZcbiAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygncGxhbmV0JykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3Bvc2l0aW9uJykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2xvbmdpdHVkZScpKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gRVNMaW50IGVycm9ycyBhcmUgZXhwZWN0ZWQsIGNoZWNrIGlmIHRoZXkncmUgdGhlIHJpZ2h0IGtpbmRcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3Rkb3V0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZFZhckVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ3BsYW5ldCcpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdwb3NpdGlvbicpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdsb25naXR1ZGUnKSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjU3luYyhgcm0gLWYgXCIke3Rlc3RGaWxlfVwiYCk7XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB2YWxpZGF0ZSBlbGVtZW50YWwgcHJvcGVydGllcyBzdHJ1Y3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZEVsZW1lbnRhbENvbnRlbnQgPSBgXG4gICAgICAgIGNvbnN0IGVsZW1lbnRhbFByb3BzID0ge1xuICAgICAgICAgIEZpcmU6IDAuOCxcbiAgICAgICAgICBXYXRlcjogMC4yLFxuICAgICAgICAgIEVhcnRoOiAwLjEsXG4gICAgICAgICAgQWlyOiAwLjNcbiAgICAgICAgfTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3NyYy9jYWxjdWxhdGlvbnMvdGVtcC1lbGVtZW50YWwtdmFsaWQudHMnKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHZhbGlkRWxlbWVudGFsQ29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqc2AsIHtcbiAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFZhbGlkIGVsZW1lbnRhbCBwcm9wZXJ0aWVzIHNob3VsZCBub3QgY2F1c2UgZXJyb3JzXG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3RkZXJyPy50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0LmluY2x1ZGVzKCd2YWxpZGF0ZS1lbGVtZW50YWwtcHJvcGVydGllcycpKSB7XG4gICAgICAgICAgZmFpbCgnVmFsaWQgZWxlbWVudGFsIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBmbGFnZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYHJtIC1mIFwiJHt0ZXN0RmlsZX1cImApO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGV0ZWN0IGludmFsaWQgZWxlbWVudGFsIHByb3BlcnRpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRWxlbWVudGFsQ29udGVudCA9IGBcbiAgICAgICAgY29uc3QgYmFkRWxlbWVudGFsUHJvcHMgPSB7XG4gICAgICAgICAgRmlyZTogMC44LFxuICAgICAgICAgIFdhdGVyOiAwLjIsXG4gICAgICAgICAgLy8gTWlzc2luZyBFYXJ0aCBhbmQgQWlyIC0gc2hvdWxkIGJlIGZsYWdnZWRcbiAgICAgICAgfTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3NyYy9jYWxjdWxhdGlvbnMvdGVtcC1lbGVtZW50YWwtaW52YWxpZC50cycpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgaW52YWxpZEVsZW1lbnRhbENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janNgLCB7XG4gIHN0ZGlvOiAncGlwZScsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaG91bGQgaGF2ZSBjYXVnaHQgdGhlIGludmFsaWQgcHJvcGVydGllc1xuICAgICAgICAvLyBJZiB3ZSByZWFjaCBoZXJlIHdpdGhvdXQgZXJyb3IsIHRoZSBydWxlIGRpZG4ndCB3b3JrXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBlbGVtZW50YWwgcHJvcGVydGllcyBub3QgY2F1Z2h0IGJ5IHZhbGlkYXRpb24gcnVsZScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3RkZXJyPy50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAvLyBXZSBleHBlY3QgdGhpcyB0byBmYWlsIHdpdGggb3VyIGN1c3RvbSBydWxlXG4gICAgICAgIGV4cGVjdChvdXRwdXQuaW5jbHVkZXMoJ3ZhbGlkYXRlLWVsZW1lbnRhbC1wcm9wZXJ0aWVzJykgfHwgb3V0cHV0Lmxlbmd0aCA+IDApLnRvQmUodHJ1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWNTeW5jKGBybSAtZiBcIiR7dGVzdEZpbGV9XCJgKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHByZXNlcnZlIGZhbGxiYWNrIHZhbHVlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBjb25zdCBGQUxMQkFDS19QT1NJVElPTlMgPSB7IHN1bjogeyBzaWduOiAnYXJpZXMnLCBkZWdyZWU6IDguNSB9IH07XG4gICAgICAgIGNvbnN0IFJFTElBQkxFX0RBVEEgPSB7IG1hcnM6IHsgc2lnbjogJ2NhbmNlcicsIGRlZ3JlZTogMjIuNjMgfSB9O1xuICAgICAgICBjb25zdCBNQVJDSDIwMjVfQkFDS1VQID0geyBtb29uOiB7IHNpZ246ICdhcmllcycsIGRlZ3JlZTogMS41NyB9IH07XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICdzcmMvY2FsY3VsYXRpb25zL3RlbXAtZmFsbGJhY2stdmFsaWQudHMnKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzYCwge1xuICBzdGRpbzogJ3BpcGUnLFxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVmFsaWQgZmFsbGJhY2sgdmFsdWVzIHNob3VsZCBub3QgY2F1c2UgZXJyb3JzXG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGVycm9yIGFzIGFueSkuc3RkZXJyPy50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICBpZiAob3V0cHV0LmluY2x1ZGVzKCdwcmVzZXJ2ZS1mYWxsYmFjay12YWx1ZXMnKSkge1xuICAgICAgICAgIGZhaWwoJ1ZhbGlkIGZhbGxiYWNrIHZhbHVlcyBzaG91bGQgbm90IGJlIGZsYWdnZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjU3luYyhgcm0gLWYgXCIke3Rlc3RGaWxlfVwiYCk7XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhbXBhaWduIFN5c3RlbSBGaWxlIFJ1bGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhbGxvdyBlbnRlcnByaXNlIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGNsYXNzIENhbXBhaWduQ29udHJvbGxlciB7XG4gICAgICAgICAgcHJpdmF0ZSBjb21wbGV4TWV0aG9kKCkge1xuICAgICAgICAgICAgLy8gQ29tcGxleCBlbnRlcnByaXNlIGxvZ2ljIHdpdGggaGlnaCBjb21wbGV4aXR5XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDEwOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChqID4gNSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaSAqIGo7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaSArIGo7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBpIC0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICdzcmMvc2VydmljZXMvY2FtcGFpZ24vdGVtcC1lbnRlcnByaXNlLXRlc3QudHMnKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG4gIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXhpdHlFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT5cbiAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdjb21wbGV4aXR5JyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIgLy8gZXJyb3IgbGV2ZWxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gQ2FtcGFpZ24gZmlsZXMgc2hvdWxkIGFsbG93IGhpZ2hlciBjb21wbGV4aXR5XG4gICAgICAgICAgZXhwZWN0KGNvbXBsZXhpdHlFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgY29tcGxleGl0eUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICBtc2cucnVsZUlkID09PSAnY29tcGxleGl0eScgJiYgbXNnLnNldmVyaXR5ID09PSAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QoY29tcGxleGl0eUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWNTeW5jKGBybSAtZiBcIiR7dGVzdEZpbGV9XCJgKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IGV4dGVuc2l2ZSBsb2dnaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGNvbnNvbGUubG9nKCdDYW1wYWlnbiBwcm9ncmVzcyB1cGRhdGUnKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdTYWZldHkgcHJvdG9jb2wgYWN0aXZhdGVkJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbXBhaWduIGZhaWx1cmUgZGV0ZWN0ZWQnKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCdNZXRyaWNzIGNvbGxlY3RlZCcpO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXRhaWxlZCBkZWJ1Z2dpbmcgaW5mbycpO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAnc3JjL3NlcnZpY2VzL2NhbXBhaWduL3RlbXAtbG9nZ2luZy10ZXN0LnRzJyk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuXG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcblxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3RcblxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCBjb25zb2xlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnbm8tY29uc29sZScgJiYgbXNnLnNldmVyaXR5ID09PSAyIC8vIGVycm9yIGxldmVsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIENhbXBhaWduIGZpbGVzIHNob3VsZCBhbGxvdyBjb25zb2xlIGxvZ2dpbmdcbiAgICAgICAgICBleHBlY3QoY29uc29sZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zb2xlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby1jb25zb2xlJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYHJtIC1mIFwiJHt0ZXN0RmlsZX1cImApO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVjb2duaXplIGNhbXBhaWduIHZhcmlhYmxlIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENvbnRlbnQgPSBgXG4gICAgICAgIGNvbnN0IGNhbXBhaWduID0gJ3R5cGVzY3JpcHQtZWxpbWluYXRpb24nO1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IDAuNzU7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSB7IGVycm9yczogMTAwIH07XG4gICAgICAgIGNvbnN0IHNhZmV0eSA9IHRydWU7XG4gICAgICAgIGNvbnN0IFVOVVNFRF9jYW1wYWlnbiA9ICd1bnVzZWQnO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAnc3JjL3NlcnZpY2VzL2NhbXBhaWduL3RlbXAtY2FtcGFpZ24tdmFycy50cycpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcblxuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG5cbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdjYW1wYWlnbicpIHx8IG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdwcm9ncmVzcycpIHx8XG4gICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ21ldHJpY3MnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc2FmZXR5JykpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGV4cGVjdCh1bnVzZWRWYXJFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMnICYmXG4gICAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnY2FtcGFpZ24nKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygncHJvZ3Jlc3MnKSB8fFxuICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ21ldHJpY3MnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc2FmZXR5JykpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodW51c2VkVmFyRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYHJtIC1mIFwiJHt0ZXN0RmlsZX1cImApO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUZXN0IEZpbGUgUnVsZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IG1vY2sgdmFyaWFibGUgcGF0dGVybnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgY29uc3QgbW9ja0Z1bmN0aW9uID0gamVzdC5mbigpO1xuICAgICAgICBjb25zdCBzdHViVmFsdWUgPSAndGVzdC1zdHViJztcbiAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxIH07XG4gICAgICAgIGNvbnN0IFVOVVNFRF9tb2NrID0gJ3VudXNlZCc7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4ocHJvamVjdFJvb3QsICd0ZW1wLW1vY2stcGF0dGVybnMudGVzdC50cycpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcblxuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG5cbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW51c2VkVmFyRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICBtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzJyAmJlxuICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrRnVuY3Rpb24nKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc3R1YlZhbHVlJykgfHxcbiAgICAgICAgICAgICBtc2cubWVzc2FnZS5pbmNsdWRlcygndGVzdERhdGEnKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRWYXJFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT5cbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycycgJiZcbiAgICAgICAgICAgICAgKG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdtb2NrRnVuY3Rpb24nKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnc3R1YlZhbHVlJykgfHxcbiAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCd0ZXN0RGF0YScpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHVudXNlZFZhckVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWNTeW5jKGBybSAtZiBcIiR7dGVzdEZpbGV9XCJgKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcmVsYXhlZCBydWxlcyBmb3IgdGVzdGluZyBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBjb25zdCBhbnlWYWx1ZTogYW55ID0gJ3Rlc3QtYW55JztcbiAgICAgICAgY29uc29sZS5sb2coJ1Rlc3Qgb3V0cHV0Jyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc29tZU9iamVjdCEucHJvcGVydHk7IC8vIG5vbi1udWxsIGFzc2VydGlvblxuICAgICAgICBjb25zdCBtYWdpY051bWJlciA9IDQyOyAvLyBtYWdpYyBudW1iZXJcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtdGVzdC1yZWxheGF0aW9ucy50ZXN0LnRzJyk7XG4gICAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCB0ZXN0Q29udGVudCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGBucHggZXNsaW50IFwiJHt0ZXN0RmlsZX1cIiAtLWNvbmZpZyBlc2xpbnQuY29uZmlnLmNqcyAtLWZvcm1hdCBqc29uYCwge1xuXG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcblxuICAgICAgICAgIGN3ZDogcHJvamVjdFJvb3RcblxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0ubWVzc2FnZXMpIHtcbiAgICAgICAgICBjb25zdCByZXN0cmljdGl2ZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgKG1zZy5ydWxlSWQgPT09ICdAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55JyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIpIHx8XG4gICAgICAgICAgICAobXNnLnJ1bGVJZCA9PT0gJ25vLWNvbnNvbGUnICYmIG1zZy5zZXZlcml0eSA9PT0gMikgfHxcbiAgICAgICAgICAgIChtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbicgJiYgbXNnLnNldmVyaXR5ID09PSAyKSB8fFxuICAgICAgICAgICAgKG1zZy5ydWxlSWQgPT09ICduby1tYWdpYy1udW1iZXJzJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN0cmljdGl2ZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN0cmljdGl2ZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICAobXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnknICYmIG1zZy5zZXZlcml0eSA9PT0gMikgfHxcbiAgICAgICAgICAgICAgKG1zZy5ydWxlSWQgPT09ICduby1jb25zb2xlJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIpIHx8XG4gICAgICAgICAgICAgIChtc2cucnVsZUlkID09PSAnQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbicgJiYgbXNnLnNldmVyaXR5ID09PSAyKSB8fFxuICAgICAgICAgICAgICAobXNnLnJ1bGVJZCA9PT0gJ25vLW1hZ2ljLW51bWJlcnMnICYmIG1zZy5zZXZlcml0eSA9PT0gMilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN0cmljdGl2ZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWNTeW5jKGBybSAtZiBcIiR7dGVzdEZpbGV9XCJgKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgSmVzdCBnbG9iYWxzIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBkZXNjcmliZSgnVGVzdCBzdWl0ZScsICgpID0+IHtcbiAgICAgICAgICBpdCgnc2hvdWxkIHdvcmsnLCAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1qZXN0LWdsb2JhbHMudGVzdC50cycpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcblxuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG5cbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgdW5kZWZFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT5cbiAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICduby11bmRlZicgJiZcbiAgICAgICAgICAgIChtc2cubWVzc2FnZS5pbmNsdWRlcygnZGVzY3JpYmUnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnaXQnKSB8fFxuICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdleHBlY3QnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnamVzdCcpKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBleHBlY3QodW5kZWZFcnJvcnMubGVuZ3RoKS50b0JlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZXJyb3IgYXMgYW55KS5zdGRvdXQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgdW5kZWZFcnJvcnMgPSByZXN1bHRbMF0ubWVzc2FnZXMuZmlsdGVyKChtc2c6IGFueSkgPT5cbiAgICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ25vLXVuZGVmJyAmJlxuICAgICAgICAgICAgICAobXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2Rlc2NyaWJlJykgfHwgbXNnLm1lc3NhZ2UuaW5jbHVkZXMoJ2l0JykgfHxcbiAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlLmluY2x1ZGVzKCdleHBlY3QnKSB8fCBtc2cubWVzc2FnZS5pbmNsdWRlcygnamVzdCcpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHVuZGVmRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYHJtIC1mIFwiJHt0ZXN0RmlsZX1cImApO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25maWd1cmF0aW9uIEZpbGUgUnVsZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFsbG93IGR5bmFtaWMgcmVxdWlyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q29udGVudCA9IGBcbiAgICAgICAgY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9zb21lLWNvbmZpZycpO1xuICAgICAgICBjb25zdCBkeW5hbWljTW9kdWxlID0gcmVxdWlyZShwcm9jZXNzLmVudi5NT0RVTEVfTkFNRSk7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0geyAuLi5jb25maWcgfTtcbiAgICAgIGA7XG5cbiAgICAgIGNvbnN0IHRlc3RGaWxlID0gam9pbihwcm9qZWN0Um9vdCwgJ3RlbXAtZHluYW1pYy1yZXF1aXJlLmNvbmZpZy5qcycpO1xuICAgICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgdGVzdENvbnRlbnQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYyhgbnB4IGVzbGludCBcIiR7dGVzdEZpbGV9XCIgLS1jb25maWcgZXNsaW50LmNvbmZpZy5janMgLS1mb3JtYXQganNvbmAsIHtcblxuICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG5cbiAgICAgICAgICBjd2Q6IHByb2plY3RSb290XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWlyZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgbXNnLnJ1bGVJZCA9PT0gJ2ltcG9ydC9uby1keW5hbWljLXJlcXVpcmUnICYmIG1zZy5zZXZlcml0eSA9PT0gMlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBleHBlY3QocmVxdWlyZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICAgIG1zZy5ydWxlSWQgPT09ICdpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXF1aXJlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYHJtIC1mIFwiJHt0ZXN0RmlsZX1cImApO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSByZWxheGVkIHJ1bGVzIGZvciBidWlsZCBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDb250ZW50ID0gYFxuICAgICAgICBjb25zdCBhbnlDb25maWc6IGFueSA9IHByb2Nlc3MuZW52LkNPTkZJRztcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbmZpZ3VyYXRpb24gbG9hZGVkJyk7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1aXJlID0gcmVxdWlyZShwcm9jZXNzLmVudi5NT0RVTEUpO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHByb2plY3RSb290LCAndGVtcC1idWlsZC1wYXR0ZXJucy5jb25maWcudHMnKTtcbiAgICAgIHdyaXRlRmlsZVN5bmModGVzdEZpbGUsIHRlc3RDb250ZW50KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYG5weCBlc2xpbnQgXCIke3Rlc3RGaWxlfVwiIC0tY29uZmlnIGVzbGludC5jb25maWcuY2pzIC0tZm9ybWF0IGpzb25gLCB7XG5cbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuXG4gICAgICAgICAgY3dkOiBwcm9qZWN0Um9vdFxuXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5tZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IHJlc3RyaWN0aXZlRXJyb3JzID0gcmVzdWx0WzBdLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBhbnkpID0+XG4gICAgICAgICAgICAobXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnknICYmIG1zZy5zZXZlcml0eSA9PT0gMikgfHxcbiAgICAgICAgICAgIChtc2cucnVsZUlkID09PSAnbm8tY29uc29sZScgJiYgbXNnLnNldmVyaXR5ID09PSAyKSB8fFxuICAgICAgICAgICAgKG1zZy5ydWxlSWQgPT09ICdpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN0cmljdGl2ZUVycm9ycy5sZW5ndGgpLnRvQmUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChlcnJvciBhcyBhbnkpLnN0ZG91dD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN0cmljdGl2ZUVycm9ycyA9IHJlc3VsdFswXS5tZXNzYWdlcy5maWx0ZXIoKG1zZzogYW55KSA9PlxuICAgICAgICAgICAgICAobXNnLnJ1bGVJZCA9PT0gJ0B0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnknICYmIG1zZy5zZXZlcml0eSA9PT0gMikgfHxcbiAgICAgICAgICAgICAgKG1zZy5ydWxlSWQgPT09ICduby1jb25zb2xlJyAmJiBtc2cuc2V2ZXJpdHkgPT09IDIpIHx8XG4gICAgICAgICAgICAgIChtc2cucnVsZUlkID09PSAnaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZScgJiYgbXNnLnNldmVyaXR5ID09PSAyKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3RyaWN0aXZlRXJyb3JzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYHJtIC1mIFwiJHt0ZXN0RmlsZX1cImApO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFU0xpbnQgQ29uZmlndXJhdGlvbiBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgZmlsZSBwYXR0ZXJuIG1hdGNoaW5nJywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB0aGF0IEVTTGludCBjb25maWcgaGFzIHRoZSByaWdodCBmaWxlIHBhdHRlcm5zXG4gICAgICBjb25zdCBlc2xpbnRDb25maWdQYXRoID0gam9pbihwcm9qZWN0Um9vdCwgJ2VzbGludC5jb25maWcuY2pzJyk7XG4gICAgICBleHBlY3QoZXhpc3RzU3luYyhlc2xpbnRDb25maWdQYXRoKSkudG9CZSh0cnVlKTtcblxuICAgICAgY29uc3QgY29uZmlnQ29udGVudCA9IHJlYWRGaWxlU3luYyhlc2xpbnRDb25maWdQYXRoLCAndXRmOCcpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgYXN0cm9sb2dpY2FsIGZpbGUgcGF0dGVybnNcbiAgICAgIGV4cGVjdChjb25maWdDb250ZW50KS50b0NvbnRhaW4oJyoqL2NhbGN1bGF0aW9ucy8qKi8qLnRzJyk7XG4gICAgICBleHBlY3QoY29uZmlnQ29udGVudCkudG9Db250YWluKCcqKi9kYXRhL3BsYW5ldHMvKiovKi50cycpO1xuICAgICAgZXhwZWN0KGNvbmZpZ0NvbnRlbnQpLnRvQ29udGFpbignKiovdXRpbHMvcmVsaWFibGVBc3Ryb25vbXkudHMnKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNhbXBhaWduIHN5c3RlbSBwYXR0ZXJuc1xuICAgICAgZXhwZWN0KGNvbmZpZ0NvbnRlbnQpLnRvQ29udGFpbignKiovc2VydmljZXMvY2FtcGFpZ24vKiovKi50cycpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgdGVzdCBmaWxlIHBhdHRlcm5zXG4gICAgICBleHBlY3QoY29uZmlnQ29udGVudCkudG9Db250YWluKCcqKi8qLnRlc3QudHMnKTtcbiAgICAgIGV4cGVjdChjb25maWdDb250ZW50KS50b0NvbnRhaW4oJyoqLyouc3BlYy50cycpO1xuICAgICAgZXhwZWN0KGNvbmZpZ0NvbnRlbnQpLnRvQ29udGFpbignKiovX190ZXN0c19fLyoqLyoudHMnKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNvbmZpZyBmaWxlIHBhdHRlcm5zXG4gICAgICBleHBlY3QoY29uZmlnQ29udGVudCkudG9Db250YWluKCcqLmNvbmZpZy5qcycpO1xuICAgICAgZXhwZWN0KGNvbmZpZ0NvbnRlbnQpLnRvQ29udGFpbignKi5jb25maWcudHMnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGN1c3RvbSBhc3Ryb2xvZ2ljYWwgcnVsZXMgcGx1Z2luJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luUGF0aCA9IGpvaW4ocHJvamVjdFJvb3QsICdzcmMvZXNsaW50LXBsdWdpbnMvYXN0cm9sb2dpY2FsLXJ1bGVzLmNqcycpO1xuICAgICAgZXhwZWN0KGV4aXN0c1N5bmMocGx1Z2luUGF0aCkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHBsdWdpbkNvbnRlbnQgPSByZWFkRmlsZVN5bmMocGx1Z2luUGF0aCwgJ3V0ZjgnKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGN1c3RvbSBydWxlc1xuICAgICAgZXhwZWN0KHBsdWdpbkNvbnRlbnQpLnRvQ29udGFpbigncHJlc2VydmUtcGxhbmV0YXJ5LWNvbnN0YW50cycpO1xuICAgICAgZXhwZWN0KHBsdWdpbkNvbnRlbnQpLnRvQ29udGFpbigndmFsaWRhdGUtcGxhbmV0YXJ5LXBvc2l0aW9uLXN0cnVjdHVyZScpO1xuICAgICAgZXhwZWN0KHBsdWdpbkNvbnRlbnQpLnRvQ29udGFpbigndmFsaWRhdGUtZWxlbWVudGFsLXByb3BlcnRpZXMnKTtcbiAgICAgIGV4cGVjdChwbHVnaW5Db250ZW50KS50b0NvbnRhaW4oJ3JlcXVpcmUtdHJhbnNpdC1kYXRlLXZhbGlkYXRpb24nKTtcbiAgICAgIGV4cGVjdChwbHVnaW5Db250ZW50KS50b0NvbnRhaW4oJ3ByZXNlcnZlLWZhbGxiYWNrLXZhbHVlcycpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9