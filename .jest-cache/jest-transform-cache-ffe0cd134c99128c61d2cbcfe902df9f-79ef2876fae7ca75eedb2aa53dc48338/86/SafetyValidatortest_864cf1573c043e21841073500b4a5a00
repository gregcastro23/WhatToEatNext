7927fa58cc3dc2738c381d62d0d1c220
"use strict";
/**
 * SafetyValidator Tests
 * Comprehensive test suite for the Safety Validation System
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock execSync for command execution tests
jest.mock('child_process');
// Mock fs for file system tests
jest.mock('fs');
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const SafetyValidator_1 = require("../SafetyValidator");
const types_1 = require("../types");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('SafetyValidator', () => {
    let validator;
    beforeEach(() => {
        validator = new SafetyValidator_1.SafetyValidator();
        jest.clearAllMocks();
    });
    describe('TypeScript Compilation Validation', () => {
        test('handles successful compilation', async () => {
            mockExecSync.mockReturnValue('');
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(true);
            expect(result.compilationErrors).toHaveLength(0);
            expect(result.performanceMetrics).toBeDefined();
        });
        test('handles compilation errors', async () => {
            const errorOutput = `
        src/test.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/test.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        Found 2 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = errorOutput;
                throw error;
            });
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors).toHaveLength(2);
            expect(result.compilationErrors[0]).toContain('error TS2322');
            expect(result.compilationErrors[1]).toContain('error TS2304');
        });
        test('handles compilation timeout', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('Timeout');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors.length).toBeGreaterThanOrEqual(0);
        });
    });
    describe('Build Validation After Batch', () => {
        test('validates build successfully', async () => {
            mockExecSync.mockReturnValue('');
            const result = await validator.validateBuildAfterBatch(['test.ts']);
            expect(result.buildSuccessful).toBe(true);
            expect(result.performanceMetrics).toBeDefined();
            expect(result.performanceMetrics.buildTime).toBeGreaterThanOrEqual(0);
        });
        test('includes test validation when requested', async () => {
            mockExecSync.mockReturnValue('');
            const result = await validator.validateBuildAfterBatch(['test.ts'], true);
            expect(result.buildSuccessful).toBe(true);
            expect(result.testResults).toBeDefined();
            expect(result.testResults.testsPass).toBe(true);
        });
        test('handles performance threshold violations', async () => {
            // Mock slow build
            mockExecSync.mockImplementation(() => {
                // Simulate slow execution
                const start = Date.now();
                while (Date.now() - start < 100) {
                    // Busy wait to simulate slow build
                }
                return '';
            });
            const slowValidator = new SafetyValidator_1.SafetyValidator(60000, {
                maximumBuildTime: 50 // Very low threshold
            });
            const result = await slowValidator.validateBuildAfterBatch(['test.ts']);
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors.some(error => error.includes('Build time') && error.includes('exceeds threshold'))).toBe(true);
        });
    });
    describe('Rollback Validation', () => {
        test('validates rollback capability successfully', async () => {
            const originalFiles = new Map([['test.ts', 'test.ts']]);
            const backupFiles = new Map([['test.ts', 'test.ts.backup']]);
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue('backup content');
            mockFs.mkdirSync.mockReturnValue(undefined);
            mockFs.writeFileSync.mockReturnValue(undefined);
            mockFs.rmSync.mockReturnValue(undefined);
            const result = await validator.validateRollbackCapability(originalFiles, backupFiles);
            expect(result.canRollback).toBe(true);
            expect(result.backupIntegrity).toBe(true);
            expect(result.rollbackErrors).toHaveLength(0);
        });
        test('detects missing backup files', async () => {
            const originalFiles = new Map([['test.ts', 'test.ts']]);
            const backupFiles = new Map([['test.ts', 'missing.backup']]);
            mockFs.existsSync.mockReturnValue(false);
            const result = await validator.validateRollbackCapability(originalFiles, backupFiles);
            expect(result.canRollback).toBe(false);
            expect(result.backupIntegrity).toBe(false);
            expect(result.rollbackErrors).toContain('Backup file missing: missing.backup');
        });
        test('detects empty backup files', async () => {
            const originalFiles = new Map([['test.ts', 'test.ts']]);
            const backupFiles = new Map([['test.ts', 'empty.backup']]);
            mockFs.existsSync.mockReturnValue(true);
            mockFs.readFileSync.mockReturnValue(''); // Empty backup
            const result = await validator.validateRollbackCapability(originalFiles, backupFiles);
            expect(result.backupIntegrity).toBe(false);
            expect(result.rollbackErrors).toContain('Backup file is empty: empty.backup');
        });
    });
    describe('Safety Score Calculation', () => {
        test('calculates safety score for array replacement', () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, context);
            expect(result.isValid).toBe(true);
            expect(result.safetyScore).toBeGreaterThan(0.8);
            expect(result.validationErrors).toHaveLength(0);
        });
        test('reduces safety score for error handling contexts', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const errorContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'catch (error: any) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, errorContext);
            expect(result.safetyScore).toBeLessThan(0.8);
            expect(result.warnings.some(w => w.includes('Error handling context'))).toBe(true);
        });
        test('boosts safety score for test files', () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const testContext = {
                filePath: 'test.test.ts',
                lineNumber: 1,
                codeSnippet: 'const mockData: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: true,
                domainContext: {
                    domain: types_1.CodeDomain.TEST,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, testContext);
            expect(result.safetyScore).toBeGreaterThan(0.8);
        });
        test('warns about external API contexts', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'api.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const apiContext = {
                filePath: 'api.ts',
                lineNumber: 1,
                codeSnippet: 'const response: any = await fetch("/api/data");',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.SERVICE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, apiContext);
            expect(result.warnings.some(w => w.includes('External API context'))).toBe(true);
            expect(result.recommendations.some(r => r.includes('Verify API response types'))).toBe(true);
        });
        test('handles function parameter replacements with caution', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'function.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const functionContext = {
                filePath: 'function.ts',
                lineNumber: 1,
                codeSnippet: 'function process(data: any) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = validator.calculateSafetyScore(replacement, functionContext);
            expect(result.safetyScore).toBeLessThanOrEqual(0.8); // Function parameters are riskier
        });
    });
    describe('Safety Thresholds Management', () => {
        test('gets current safety thresholds', () => {
            const thresholds = validator.getSafetyThresholds();
            expect(thresholds.minimumSafetyScore).toBeDefined();
            expect(thresholds.maximumErrorCount).toBeDefined();
            expect(thresholds.maximumBuildTime).toBeDefined();
        });
        test('updates safety thresholds', () => {
            const newThresholds = {
                minimumSafetyScore: 0.9,
                maximumBuildTime: 60000
            };
            validator.updateSafetyThresholds(newThresholds);
            const updatedThresholds = validator.getSafetyThresholds();
            expect(updatedThresholds.minimumSafetyScore).toBe(0.9);
            expect(updatedThresholds.maximumBuildTime).toBe(60000);
        });
    });
    describe('Performance Metrics Validation', () => {
        test('validates acceptable performance metrics', () => {
            const fastValidator = new SafetyValidator_1.SafetyValidator(60000, {
                maximumBuildTime: 30000
            });
            const mockReplacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const mockContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const result = fastValidator.calculateSafetyScore(mockReplacement, mockContext);
            expect(result.isValid).toBe(true);
        });
    });
    describe('Error Output Parsing', () => {
        test('parses TypeScript errors correctly', async () => {
            const complexErrorOutput = `
        src/file1.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/file2.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        src/file3.ts(20,15): error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
        Found 3 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = complexErrorOutput;
                throw error;
            });
            const result = await validator.validateTypeScriptCompilation();
            expect(result.buildSuccessful).toBe(false);
            expect(result.compilationErrors).toHaveLength(3);
            expect(result.compilationErrors[0]).toContain('TS2322');
            expect(result.compilationErrors[1]).toContain('TS2304');
            expect(result.compilationErrors[2]).toContain('TS2345');
        });
        test('limits error count to maximum threshold', async () => {
            const manyErrorsOutput = Array.from({ length: 20 }, (_, i) => `src/file${i}.ts(${i},5): error TS2322: Type error ${i}.`).join('\n');
            mockExecSync.mockImplementation(() => {
                const error = new Error('Many errors');
                error.stdout = manyErrorsOutput;
                throw error;
            });
            const limitedValidator = new SafetyValidator_1.SafetyValidator(60000, {
                maximumErrorCount: 5
            });
            const result = await limitedValidator.validateTypeScriptCompilation();
            expect(result.compilationErrors.length).toBeLessThanOrEqual(5);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZXR5VmFsaWRhdG9yLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9ILDRDQUE0QztBQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBRzNCLGdDQUFnQztBQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBVmhCLGlEQUF5QztBQUN6Qyx1Q0FBeUI7QUFDekIsd0RBQXFEO0FBQ3JELG9DQUE4RTtBQUk5RSxNQUFNLFlBQVksR0FBRyx3QkFBZ0QsQ0FBQztBQUl0RSxNQUFNLE1BQU0sR0FBRyxFQUE0QixDQUFDO0FBRTVDLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEVBQUU7SUFDL0IsSUFBSSxTQUEwQixDQUFDO0lBRS9CLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxTQUFTLEdBQUcsSUFBSSxpQ0FBZSxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLG1DQUFtQyxFQUFFLEdBQUcsRUFBRTtRQUNqRCxJQUFJLENBQUMsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDaEQsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUVqQyxNQUFNLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO1lBRS9ELE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakQsTUFB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Q0FBaUMsQ0FBQyxHQUFHLENBQzFELENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWIsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtnQkFDbkMsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFRLENBQUM7Z0JBQzlDLEtBQUssQ0FBQyxNQUFNLEdBQUcsZ0JBQWdCLENBQUM7Z0JBQ2hDLE1BQU0sS0FBSyxDQUFDO1lBQ2QsQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLGdCQUFnQixHQUFHLElBQUksaUNBQWUsQ0FBQyxLQUFLLEVBQUU7Z0JBQ2xELGlCQUFpQixFQUFFLENBQUM7YUFDckIsQ0FBQyxDQUFDO1lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO1lBRXRFLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakUsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9HcmVnQ2FzdHJvL0Rlc2t0b3AvV2hhdFRvRWF0TmV4dC9zcmMvc2VydmljZXMvY2FtcGFpZ24vdW5pbnRlbnRpb25hbC1hbnktZWxpbWluYXRpb24vX190ZXN0c19fL1NhZmV0eVZhbGlkYXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2FmZXR5VmFsaWRhdG9yIFRlc3RzXG4gKiBDb21wcmVoZW5zaXZlIHRlc3Qgc3VpdGUgZm9yIHRoZSBTYWZldHkgVmFsaWRhdGlvbiBTeXN0ZW1cbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgU2FmZXR5VmFsaWRhdG9yIH0gZnJvbSAnLi4vU2FmZXR5VmFsaWRhdG9yJztcbmltcG9ydCB7IENsYXNzaWZpY2F0aW9uQ29udGV4dCwgQ29kZURvbWFpbiwgVHlwZVJlcGxhY2VtZW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyBNb2NrIGV4ZWNTeW5jIGZvciBjb21tYW5kIGV4ZWN1dGlvbiB0ZXN0c1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBtb2NrRXhlY1N5bmMgPSBleGVjU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBleGVjU3luYz47XG5cbi8vIE1vY2sgZnMgZm9yIGZpbGUgc3lzdGVtIHRlc3RzXG5qZXN0Lm1vY2soJ2ZzJyk7XG5jb25zdCBtb2NrRnMgPSBmcyBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZnM+O1xuXG5kZXNjcmliZSgnU2FmZXR5VmFsaWRhdG9yJywgKCkgPT4ge1xuICBsZXQgdmFsaWRhdG9yOiBTYWZldHlWYWxpZGF0b3I7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdmFsaWRhdG9yID0gbmV3IFNhZmV0eVZhbGlkYXRvcigpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnVHlwZVNjcmlwdCBDb21waWxhdGlvbiBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ2hhbmRsZXMgc3VjY2Vzc2Z1bCBjb21waWxhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5idWlsZFN1Y2Nlc3NmdWwpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnBlcmZvcm1hbmNlTWV0cmljcykudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY29tcGlsYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JPdXRwdXQgPSBgXG4gICAgICAgIHNyYy90ZXN0LnRzKDEwLDUpOiBlcnJvciBUUzIzMjI6IFR5cGUgJ3N0cmluZycgaXMgbm90IGFzc2lnbmFibGUgdG8gdHlwZSAnbnVtYmVyJy5cbiAgICAgICAgc3JjL3Rlc3QudHMoMTUsMTApOiBlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgJ3Vua25vd25WYXJpYWJsZScuXG4gICAgICAgIEZvdW5kIDIgZXJyb3JzLlxuICAgICAgYDtcblxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDb21waWxhdGlvbiBmYWlsZWQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0ZG91dCA9IGVycm9yT3V0cHV0O1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5idWlsZFN1Y2Nlc3NmdWwpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9ycykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdlcnJvciBUUzIzMjInKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnNbMV0pLnRvQ29udGFpbignZXJyb3IgVFMyMzA0Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGNvbXBpbGF0aW9uIHRpbWVvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1RpbWVvdXQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnVElNRU9VVCc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0J1aWxkIFZhbGlkYXRpb24gQWZ0ZXIgQmF0Y2gnLCAoKSA9PiB7XG4gICAgdGVzdCgndmFsaWRhdGVzIGJ1aWxkIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVCdWlsZEFmdGVyQmF0Y2goWyd0ZXN0LnRzJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucGVyZm9ybWFuY2VNZXRyaWNzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wZXJmb3JtYW5jZU1ldHJpY3MhLmJ1aWxkVGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2luY2x1ZGVzIHRlc3QgdmFsaWRhdGlvbiB3aGVuIHJlcXVlc3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVCdWlsZEFmdGVyQmF0Y2goWyd0ZXN0LnRzJ10sIHRydWUpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmJ1aWxkU3VjY2Vzc2Z1bCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudGVzdFJlc3VsdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LnRlc3RSZXN1bHRzIS50ZXN0c1Bhc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIHBlcmZvcm1hbmNlIHRocmVzaG9sZCB2aW9sYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBzbG93IGJ1aWxkXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgLy8gU2ltdWxhdGUgc2xvdyBleGVjdXRpb25cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0IDwgMTAwKSB7XG4gICAgICAgICAgLy8gQnVzeSB3YWl0IHRvIHNpbXVsYXRlIHNsb3cgYnVpbGRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2xvd1ZhbGlkYXRvciA9IG5ldyBTYWZldHlWYWxpZGF0b3IoNjAwMDAsIHtcbiAgICAgICAgbWF4aW11bUJ1aWxkVGltZTogNTAgLy8gVmVyeSBsb3cgdGhyZXNob2xkXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2xvd1ZhbGlkYXRvci52YWxpZGF0ZUJ1aWxkQWZ0ZXJCYXRjaChbJ3Rlc3QudHMnXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYnVpbGRTdWNjZXNzZnVsKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMuc29tZShlcnJvciA9PlxuICAgICAgICBlcnJvci5pbmNsdWRlcygnQnVpbGQgdGltZScpICYmIGVycm9yLmluY2x1ZGVzKCdleGNlZWRzIHRocmVzaG9sZCcpXG4gICAgICApKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUm9sbGJhY2sgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCd2YWxpZGF0ZXMgcm9sbGJhY2sgY2FwYWJpbGl0eSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEZpbGVzID0gbmV3IE1hcChbWyd0ZXN0LnRzJywgJ3Rlc3QudHMnXV0pO1xuICAgICAgY29uc3QgYmFja3VwRmlsZXMgPSBuZXcgTWFwKFtbJ3Rlc3QudHMnLCAndGVzdC50cy5iYWNrdXAnXV0pO1xuXG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnYmFja3VwIGNvbnRlbnQnKTtcbiAgICAgIG1vY2tGcy5ta2RpclN5bmMubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRnMud3JpdGVGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tGcy5ybVN5bmMubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVJvbGxiYWNrQ2FwYWJpbGl0eShvcmlnaW5hbEZpbGVzLCBiYWNrdXBGaWxlcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY2FuUm9sbGJhY2spLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmJhY2t1cEludGVncml0eSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tFcnJvcnMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgbWlzc2luZyBiYWNrdXAgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEZpbGVzID0gbmV3IE1hcChbWyd0ZXN0LnRzJywgJ3Rlc3QudHMnXV0pO1xuICAgICAgY29uc3QgYmFja3VwRmlsZXMgPSBuZXcgTWFwKFtbJ3Rlc3QudHMnLCAnbWlzc2luZy5iYWNrdXAnXV0pO1xuXG4gICAgICBtb2NrRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVSb2xsYmFja0NhcGFiaWxpdHkob3JpZ2luYWxGaWxlcywgYmFja3VwRmlsZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmNhblJvbGxiYWNrKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYmFja3VwSW50ZWdyaXR5KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tFcnJvcnMpLnRvQ29udGFpbignQmFja3VwIGZpbGUgbWlzc2luZzogbWlzc2luZy5iYWNrdXAnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgZW1wdHkgYmFja3VwIGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGaWxlcyA9IG5ldyBNYXAoW1sndGVzdC50cycsICd0ZXN0LnRzJ11dKTtcbiAgICAgIGNvbnN0IGJhY2t1cEZpbGVzID0gbmV3IE1hcChbWyd0ZXN0LnRzJywgJ2VtcHR5LmJhY2t1cCddXSk7XG5cbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCcnKTsgLy8gRW1wdHkgYmFja3VwXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVJvbGxiYWNrQ2FwYWJpbGl0eShvcmlnaW5hbEZpbGVzLCBiYWNrdXBGaWxlcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYmFja3VwSW50ZWdyaXR5KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tFcnJvcnMpLnRvQ29udGFpbignQmFja3VwIGZpbGUgaXMgZW1wdHk6IGVtcHR5LmJhY2t1cCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FmZXR5IFNjb3JlIENhbGN1bGF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ2NhbGN1bGF0ZXMgc2FmZXR5IHNjb3JlIGZvciBhcnJheSByZXBsYWNlbWVudCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50LCBjb250ZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zYWZldHlTY29yZSkudG9CZUdyZWF0ZXJUaGFuKDAuOCk7XG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkYXRpb25FcnJvcnMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JlZHVjZXMgc2FmZXR5IHNjb3JlIGZvciBlcnJvciBoYW5kbGluZyBjb250ZXh0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVycm9yQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NhdGNoIChlcnJvcjogYW55KSB7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50LCBlcnJvckNvbnRleHQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eVNjb3JlKS50b0JlTGVzc1RoYW4oMC44KTtcbiAgICAgIGV4cGVjdChyZXN1bHQud2FybmluZ3Muc29tZSh3ID0+IHcuaW5jbHVkZXMoJ0Vycm9yIGhhbmRsaW5nIGNvbnRleHQnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdib29zdHMgc2FmZXR5IHNjb3JlIGZvciB0ZXN0IGZpbGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdGVzdENvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IG1vY2tEYXRhOiBhbnlbXSA9IFtdOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IHRydWUsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVEVTVCxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50LCB0ZXN0Q29udGV4dCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc2FmZXR5U2NvcmUpLnRvQmVHcmVhdGVyVGhhbigwLjgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnd2FybnMgYWJvdXQgZXh0ZXJuYWwgQVBJIGNvbnRleHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd24nLFxuICAgICAgICBmaWxlUGF0aDogJ2FwaS50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhcGlDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAnYXBpLnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCByZXNwb25zZTogYW55ID0gYXdhaXQgZmV0Y2goXCIvYXBpL2RhdGFcIik7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uU0VSVklDRSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50LCBhcGlDb250ZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC53YXJuaW5ncy5zb21lKHcgPT4gdy5pbmNsdWRlcygnRXh0ZXJuYWwgQVBJIGNvbnRleHQnKSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJlY29tbWVuZGF0aW9ucy5zb21lKHIgPT4gci5pbmNsdWRlcygnVmVyaWZ5IEFQSSByZXNwb25zZSB0eXBlcycpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgZnVuY3Rpb24gcGFyYW1ldGVyIHJlcGxhY2VtZW50cyB3aXRoIGNhdXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bicsXG4gICAgICAgIGZpbGVQYXRoOiAnZnVuY3Rpb24udHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZnVuY3Rpb25Db250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAnZnVuY3Rpb24udHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2Z1bmN0aW9uIHByb2Nlc3MoZGF0YTogYW55KSB7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50LCBmdW5jdGlvbkNvbnRleHQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnNhZmV0eVNjb3JlKS50b0JlTGVzc1RoYW5PckVxdWFsKDAuOCk7IC8vIEZ1bmN0aW9uIHBhcmFtZXRlcnMgYXJlIHJpc2tpZXJcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhZmV0eSBUaHJlc2hvbGRzIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnZ2V0cyBjdXJyZW50IHNhZmV0eSB0aHJlc2hvbGRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGhyZXNob2xkcyA9IHZhbGlkYXRvci5nZXRTYWZldHlUaHJlc2hvbGRzKCk7XG5cbiAgICAgIGV4cGVjdCh0aHJlc2hvbGRzLm1pbmltdW1TYWZldHlTY29yZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdCh0aHJlc2hvbGRzLm1heGltdW1FcnJvckNvdW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHRocmVzaG9sZHMubWF4aW11bUJ1aWxkVGltZSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3VwZGF0ZXMgc2FmZXR5IHRocmVzaG9sZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdUaHJlc2hvbGRzID0ge1xuICAgICAgICBtaW5pbXVtU2FmZXR5U2NvcmU6IDAuOSxcbiAgICAgICAgbWF4aW11bUJ1aWxkVGltZTogNjAwMDBcbiAgICAgIH07XG5cbiAgICAgIHZhbGlkYXRvci51cGRhdGVTYWZldHlUaHJlc2hvbGRzKG5ld1RocmVzaG9sZHMpO1xuICAgICAgY29uc3QgdXBkYXRlZFRocmVzaG9sZHMgPSB2YWxpZGF0b3IuZ2V0U2FmZXR5VGhyZXNob2xkcygpO1xuXG4gICAgICBleHBlY3QodXBkYXRlZFRocmVzaG9sZHMubWluaW11bVNhZmV0eVNjb3JlKS50b0JlKDAuOSk7XG4gICAgICBleHBlY3QodXBkYXRlZFRocmVzaG9sZHMubWF4aW11bUJ1aWxkVGltZSkudG9CZSg2MDAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBNZXRyaWNzIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgndmFsaWRhdGVzIGFjY2VwdGFibGUgcGVyZm9ybWFuY2UgbWV0cmljcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGZhc3RWYWxpZGF0b3IgPSBuZXcgU2FmZXR5VmFsaWRhdG9yKDYwMDAwLCB7XG4gICAgICAgIG1heGltdW1CdWlsZFRpbWU6IDMwMDAwXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1JlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZhc3RWYWxpZGF0b3IuY2FsY3VsYXRlU2FmZXR5U2NvcmUobW9ja1JlcGxhY2VtZW50LCBtb2NrQ29udGV4dCk7XG4gICAgICBleHBlY3QocmVzdWx0LmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBPdXRwdXQgUGFyc2luZycsICgpID0+IHtcbiAgICB0ZXN0KCdwYXJzZXMgVHlwZVNjcmlwdCBlcnJvcnMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcGxleEVycm9yT3V0cHV0ID0gYFxuICAgICAgICBzcmMvZmlsZTEudHMoMTAsNSk6IGVycm9yIFRTMjMyMjogVHlwZSAnc3RyaW5nJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlICdudW1iZXInLlxuICAgICAgICBzcmMvZmlsZTIudHMoMTUsMTApOiBlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgJ3Vua25vd25WYXJpYWJsZScuXG4gICAgICAgIHNyYy9maWxlMy50cygyMCwxNSk6IGVycm9yIFRTMjM0NTogQXJndW1lbnQgb2YgdHlwZSAnbnVtYmVyJyBpcyBub3QgYXNzaWduYWJsZSB0byBwYXJhbWV0ZXIgb2YgdHlwZSAnc3RyaW5nJy5cbiAgICAgICAgRm91bmQgMyBlcnJvcnMuXG4gICAgICBgO1xuXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gY29tcGxleEVycm9yT3V0cHV0O1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5idWlsZFN1Y2Nlc3NmdWwpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9ycykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdUUzIzMjInKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnNbMV0pLnRvQ29udGFpbignVFMyMzA0Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzWzJdKS50b0NvbnRhaW4oJ1RTMjM0NScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnbGltaXRzIGVycm9yIGNvdW50IHRvIG1heGltdW0gdGhyZXNob2xkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFueUVycm9yc091dHB1dCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDIwIH0sIChfLCBpKSA9PlxuICAgICAgICBgc3JjL2ZpbGUke2l9LnRzKCR7aX0sNSk6IGVycm9yIFRTMjMyMjogVHlwZSBlcnJvciAke2l9LmBcbiAgICAgICkuam9pbignXFxuJyk7XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTWFueSBlcnJvcnMnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0ZG91dCA9IG1hbnlFcnJvcnNPdXRwdXQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxpbWl0ZWRWYWxpZGF0b3IgPSBuZXcgU2FmZXR5VmFsaWRhdG9yKDYwMDAwLCB7XG4gICAgICAgIG1heGltdW1FcnJvckNvdW50OiA1XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGltaXRlZFZhbGlkYXRvci52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzLmxlbmd0aCkudG9CZUxlc3NUaGFuT3JFcXVhbCg1KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==