76887c51fd62cbf10d1454f0af918e81
"use strict";
/**
 * SafeTypeReplacer Tests
 * Comprehensive test suite for the Safe Type Replacer system
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock execSync for TypeScript compilation tests
jest.mock('child_process');
// Mock fs for file operations
jest.mock('fs');
// Mock SafetyValidator
jest.mock('../SafetyValidator', () => ({
    SafetyValidator: jest.fn().mockImplementation(() => ({
        calculateSafetyScore: jest.fn().mockReturnValue({
            isValid: true,
            safetyScore: 0.9,
            validationErrors: [],
            warnings: [],
            recommendations: []
        }),
        validateTypeScriptCompilation: jest.fn().mockResolvedValue({
            buildSuccessful: true,
            compilationErrors: [],
            lintingWarnings: [],
            performanceMetrics: { buildTime: 100, memoryUsage: 1000000 }
        }),
        validateBuildAfterBatch: jest.fn().mockResolvedValue({
            buildSuccessful: true,
            compilationErrors: [],
            lintingWarnings: [],
            performanceMetrics: { buildTime: 100, memoryUsage: 1000000 }
        }),
        validateRollbackCapability: jest.fn().mockResolvedValue({
            canRollback: true,
            backupIntegrity: true,
            rollbackErrors: [],
            restorationVerified: true
        }),
        updateSafetyThresholds: jest.fn()
    }))
}));
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const SafeTypeReplacer_1 = require("../SafeTypeReplacer");
const types_1 = require("../types");
const mockExecSync = child_process_1.execSync;
const mockFs = fs;
describe('SafeTypeReplacer', () => {
    let replacer;
    let testBackupDir;
    beforeEach(() => {
        jest.clearAllMocks();
        testBackupDir = './.test-backups';
        replacer = new SafeTypeReplacer_1.SafeTypeReplacer(testBackupDir, 0.7, 30000, 3);
        // Mock fs.existsSync to return false for backup directory initially
        mockFs.existsSync.mockImplementation((path) => {
            if (path === testBackupDir)
                return false;
            return true; // Assume other files exist
        });
        // Mock fs.mkdirSync
        mockFs.mkdirSync.mockImplementation(() => undefined);
        // Mock fs.readFileSync and writeFileSync
        mockFs.readFileSync.mockImplementation(() => 'const items: any[] = [];');
        mockFs.writeFileSync.mockImplementation(() => undefined);
        // Mock successful TypeScript compilation by default
        mockExecSync.mockImplementation(() => '');
    });
    describe('Constructor and Initialization', () => {
        test('creates backup directory if it does not exist', () => {
            expect(mockFs.mkdirSync).toHaveBeenCalledWith(testBackupDir, { recursive: true });
        });
        test('initializes with default strategies', () => {
            const strategies = replacer.getStrategies();
            expect(strategies).toHaveLength(10);
            expect(strategies[0].priority).toBe(1); // Array type strategy should be first
        });
        test('allows custom configuration', () => {
            const customReplacer = new SafeTypeReplacer_1.SafeTypeReplacer('.custom-backup', 0.8, 60000, 5);
            expect(customReplacer.getBackupDirectory()).toBe('.custom-backup');
        });
    });
    describe('Single Replacement Operations', () => {
        test('successfully replaces array types', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(1);
            expect(result.failedReplacements).toHaveLength(0);
            expect(result.rollbackPerformed).toBe(false);
        });
        test('handles low safety score rejection', async () => {
            const replacement = {
                original: 'any',
                replacement: 'string',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.3,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.failedReplacements).toHaveLength(1);
            expect(result.compilationErrors[0]).toContain('Safety score');
        });
        test('rolls back on TypeScript compilation failure', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock compilation failure
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type mismatch';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Type mismatch');
        });
        test('handles invalid line numbers', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 999,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];'); // Only 1 line
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Invalid line number');
        });
        test('handles pattern not found in line', async () => {
            const replacement = {
                original: 'string[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];'); // Pattern doesn't match
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Pattern "string[]" not found');
        });
    });
    describe('Batch Processing', () => {
        test('processes multiple replacements successfully', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'Record<string, unknown>',
                    replacement: 'Record<string, unknown>',
                    filePath: 'test2.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockImplementation((filePath) => {
                if (filePath.includes('test1.ts'))
                    return 'const items: any[] = [];';
                if (filePath.includes('test2.ts'))
                    return 'const data: Record<string, unknown> = {};';
                return 'backup content';
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(2);
            expect(result.failedReplacements).toHaveLength(0);
        });
        test('rolls back all changes on overall compilation failure', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                }
            ];
            // Mock overall compilation to fail
            mockExecSync.mockImplementation(() => {
                const error = new Error('Overall compilation failed');
                error.stdout = 'error TS2322: Overall type error';
                throw error;
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Overall type error');
        });
        test('groups replacements by file correctly', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'unknown[]',
                    filePath: 'test.ts',
                    lineNumber: 2,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'any',
                    replacement: 'unknown',
                    filePath: 'test.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockReturnValue('const x: any = 1;\nconst items: any[] = [];');
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(true);
            expect(result.appliedReplacements).toHaveLength(2);
        });
    });
    describe('Safety Score Calculation', () => {
        test('calculates higher scores for array replacements', () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.7,
                validationRequired: true
            };
            // Access private method through any cast for testing
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeGreaterThan(0.7); // Should be boosted for array replacement
        });
        test('calculates lower scores for error handling contexts', () => {
            const replacement = {
                original: 'catch (error: unknown)',
                replacement: 'catch (error: unknown)',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.8,
                validationRequired: true
            };
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeLessThan(0.8); // Should be reduced for error context
        });
        test('boosts scores for test files', () => {
            const replacement = {
                original: 'any',
                replacement: 'unknown',
                filePath: 'test.test.ts',
                lineNumber: 1,
                confidence: 0.7,
                validationRequired: true
            };
            const score = replacer.calculateSafetyScore(replacement);
            expect(score).toBeGreaterThan(0.7); // Should be boosted for test files
        });
    });
    describe('Rollback Verification', () => {
        test('verifies rollback capability successfully', async () => {
            const filePath = 'test.ts';
            const backupPath = 'backup.ts';
            mockFs.readFileSync.mockImplementation((path) => {
                if (path === filePath)
                    return 'modified content';
                if (path === backupPath)
                    return 'original content';
                return '';
            });
            const result = await replacer.verifyRollbackCapability(filePath, backupPath);
            expect(result.success).toBe(true);
        });
        test('detects missing backup file', async () => {
            const filePath = 'test.ts';
            const backupPath = 'missing-backup.ts';
            mockFs.existsSync.mockImplementation((path) => {
                return path !== backupPath; // Backup doesn't exist
            });
            const result = await replacer.verifyRollbackCapability(filePath, backupPath);
            expect(result.success).toBe(false);
            expect(result.error).toContain('Backup file does not exist');
        });
    });
    describe('Strategy Management', () => {
        test('allows adding custom strategies', () => {
            const customStrategy = {
                pattern: /custom_pattern/g,
                replacement: () => 'custom_replacement',
                validator: () => true,
                priority: 0
            };
            replacer.addStrategy(customStrategy);
            const strategies = replacer.getStrategies();
            expect(strategies[0]).toBe(customStrategy); // Should be first due to priority 0
        });
        test('maintains strategy priority order', () => {
            const strategies = replacer.getStrategies();
            for (let i = 1; i < strategies.length; i++) {
                expect(strategies[i].priority).toBeGreaterThanOrEqual(strategies[i - 1].priority);
            }
        });
    });
    describe('Backup Management', () => {
        test('creates backups with timestamp', async () => {
            const filePath = 'test.ts';
            mockFs.readFileSync.mockReturnValue('original content');
            const backupPath = await replacer.createBackup(filePath);
            expect(backupPath).toContain('.test-backups');
            expect(backupPath).toContain('test.ts');
            expect(backupPath).toContain('.backup');
            expect(mockFs.writeFileSync).toHaveBeenCalledWith(backupPath, 'original content', 'utf8');
        });
        test('cleans up old backup files', () => {
            const oldDate = new Date();
            oldDate.setDate(oldDate.getDate() - 10); // 10 days old
            mockFs.readdirSync.mockReturnValue(['old.backup', 'recent.backup', 'other.txt']);
            mockFs.statSync.mockImplementation((filePath) => {
                if (filePath.includes('old.backup')) {
                    return { mtime: oldDate };
                }
                return { mtime: new Date() }; // Recent file
            });
            replacer.cleanupOldBackups(7); // Keep 7 days
            expect(mockFs.unlinkSync).toHaveBeenCalledWith(path.join(testBackupDir, 'old.backup'));
            expect(mockFs.unlinkSync).not.toHaveBeenCalledWith(path.join(testBackupDir, 'recent.backup'));
        });
    });
    describe('Error Handling and Retries', () => {
        test('handles file system errors gracefully', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock backup creation to fail
            mockFs.writeFileSync.mockImplementation((filePath) => {
                if (filePath.includes('.backup')) {
                    throw new Error('Backup creation failed');
                }
            });
            // Expect the error to be thrown since backup creation is critical
            await expect(replacer.applyReplacement(replacement)).rejects.toThrow('Backup creation failed');
        });
        test('handles compilation errors with rollback', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            // Mock compilation to fail
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = 'error TS2322: Type error';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2322: Type error');
        });
    });
    describe('TypeScript Compilation Validation', () => {
        test('handles successful compilation', async () => {
            mockExecSync.mockReturnValue('');
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
        test('extracts TypeScript errors from output', async () => {
            const errorOutput = `
        src/test.ts(10,5): error TS2322: Type 'string' is not assignable to type 'number'.
        src/test.ts(15,10): error TS2304: Cannot find name 'unknownVariable'.
        Found 2 errors.
      `;
            mockExecSync.mockImplementation(() => {
                const error = new Error('Compilation failed');
                error.stdout = errorOutput;
                throw error;
            });
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(false);
            expect(result.errors).toHaveLength(2);
            expect(result.errors[0]).toContain('error TS2322');
            expect(result.errors[1]).toContain('error TS2304');
        });
        test('handles compilation timeout', async () => {
            mockExecSync.mockImplementation(() => {
                const error = new Error('Timeout');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await replacer.validateTypeScriptCompilation();
            expect(result.success).toBe(false);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]).toContain('Timeout');
        });
    });
    describe('Advanced Replacement Strategy Patterns', () => {
        test('infers array element types from context', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = ["hello", "world"];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferArrayElementType(context);
            expect(inferredType).toBe('string');
        });
        test('handles complex nested type inference', () => {
            const complexContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const nested: Record<string, any[]> = { items: [1, 2, 3] };',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const arrayType = replacer.inferArrayElementType(complexContext);
            const recordType = replacer.inferRecordValueType(complexContext);
            expect(arrayType).toBe('number');
            expect(recordType).toBe('number[]');
        });
        test('infers types from usage patterns in surrounding code', () => {
            const usageContext = {
                filePath: 'test.ts',
                lineNumber: 2,
                codeSnippet: 'const data: any = getValue();',
                surroundingLines: [
                    'function getValue() { return "test"; }',
                    'console.log(data.toUpperCase());',
                    'const length = data.length;'
                ],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferVariableType(usageContext);
            expect(inferredType).toBe('string');
        });
        test('infers Record value types from object literals', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const config: Record<string, unknown> = { name: "test", count: 42 };',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferRecordValueType(context);
            expect(['string', 'number', 'unknown']).toContain(inferredType);
        });
        test('infers function parameter types from parameter names', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function handleClick(event: unknown) { }',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.COMPONENT,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferFunctionParameterType(context, 'event');
            expect(inferredType).toBe('Event');
        });
        test('infers return types from function context', () => {
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function isValid(): any {',
                surroundingLines: ['  return true;'],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferReturnType(context);
            expect(inferredType).toBe('boolean');
        });
        test('detects error handling contexts correctly', () => {
            const errorContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'catch (error: unknown) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const isErrorContext = replacer.isInErrorHandlingContext(errorContext);
            expect(isErrorContext).toBe(true);
        });
        test('detects external API contexts correctly', () => {
            const apiContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const response: any = await fetch("/api/data");',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.SERVICE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const isApiContext = replacer.isExternalApiContext(apiContext);
            expect(isApiContext).toBe(true);
        });
        test('applies domain-specific type inference for astrological context', () => {
            const astroContext = {
                filePath: 'astrology.ts',
                lineNumber: 1,
                codeSnippet: 'const planetaryPositions: any[] = [];',
                surroundingLines: ['positions.push("mars");'],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.ASTROLOGICAL,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferArrayElementType(astroContext);
            expect(inferredType).toBe('string');
        });
        test('applies domain-specific type inference for recipe context', () => {
            const recipeContext = {
                filePath: 'recipe.ts',
                lineNumber: 1,
                codeSnippet: 'function processIngredient(ingredient: unknown) {',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.RECIPE,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const inferredType = replacer.inferFunctionParameterType(recipeContext, 'ingredient');
            expect(inferredType).toBe('Ingredient');
        });
        test('handles complex replacement patterns with validation', async () => {
            const mockContext = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'function process(data: unknown): any { return data; }',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            const strategies = replacer.getStrategies();
            // Test function parameter strategy
            const paramStrategy = strategies.find(s => s.priority === 4);
            expect(paramStrategy).toBeDefined();
            expect(paramStrategy?.validator(mockContext)).toBe(true);
            // Test return type strategy
            const returnStrategy = strategies.find(s => s.priority === 5);
            expect(returnStrategy).toBeDefined();
            expect(returnStrategy?.validator(mockContext)).toBe(true);
        });
    });
    describe('Comprehensive Error Recovery', () => {
        test('handles partial batch failures with selective rollback', async () => {
            const replacements = [
                {
                    original: 'any[]',
                    replacement: 'string[]',
                    filePath: 'test1.ts',
                    lineNumber: 1,
                    confidence: 0.9,
                    validationRequired: true
                },
                {
                    original: 'any',
                    replacement: 'InvalidType',
                    filePath: 'test2.ts',
                    lineNumber: 1,
                    confidence: 0.8,
                    validationRequired: true
                }
            ];
            mockFs.readFileSync.mockImplementation((filePath) => {
                if (filePath.includes('test1.ts'))
                    return 'const items: any[] = [];';
                if (filePath.includes('test2.ts'))
                    return 'const data: any = value;';
                return 'backup content';
            });
            // Mock compilation to fail for the second replacement
            let compilationCallCount = 0;
            mockExecSync.mockImplementation(() => {
                compilationCallCount++;
                if (compilationCallCount > 1) {
                    const error = new Error('Compilation failed');
                    error.stdout = 'error TS2304: Cannot find name "InvalidType"';
                    throw error;
                }
                return '';
            });
            const result = await replacer.processBatch(replacements);
            expect(result.success).toBe(false);
            expect(result.rollbackPerformed).toBe(true);
            expect(result.compilationErrors).toContain('error TS2304: Cannot find name "InvalidType"');
        });
        test('handles file system permission errors', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'readonly.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            mockFs.writeFileSync.mockImplementation(() => {
                throw new Error('EACCES: permission denied');
            });
            await expect(replacer.applyReplacement(replacement)).rejects.toThrow('EACCES: permission denied');
        });
        test('handles corrupted backup files', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockImplementation((path) => {
                if (path.includes('.backup')) {
                    throw new Error('Backup file corrupted');
                }
                return 'const items: any[] = [];';
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
        });
        test('handles network timeouts during validation', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            // Mock timeout error
            mockExecSync.mockImplementation(() => {
                const error = new Error('Command timed out');
                error.code = 'TIMEOUT';
                throw error;
            });
            const result = await replacer.applyReplacement(replacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors).toContain('Command timed out');
        });
    });
    describe('Performance and Memory Management', () => {
        test('handles large file processing efficiently', async () => {
            const largeContent = 'const items: any[] = [];\n'.repeat(10000);
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'large.ts',
                lineNumber: 5000,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue(largeContent);
            const startTime = Date.now();
            const result = await replacer.applyReplacement(replacement);
            const endTime = Date.now();
            expect(result.success).toBe(true);
            expect(endTime - startTime).toBeLessThan(2000); // Should complete within 2 seconds
        });
        test('manages memory during batch processing', async () => {
            const largeBatch = Array(1000).fill(null).map((_, i) => ({
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: `test${i}.ts`,
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            }));
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            const initialMemory = process.memoryUsage().heapUsed;
            const result = await replacer.processBatch(largeBatch);
            const finalMemory = process.memoryUsage().heapUsed;
            expect(result).toBeDefined();
            // Memory usage shouldn't grow excessively (allow 100MB increase)
            expect(finalMemory - initialMemory).toBeLessThan(100 * 1024 * 1024);
        });
        test('cleans up resources after processing', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            await replacer.applyReplacement(replacement);
            // Verify cleanup was called
            expect(mockFs.writeFileSync).toHaveBeenCalled();
            // Test backup cleanup
            replacer.cleanupOldBackups(0); // Clean all backups
            expect(mockFs.unlinkSync).toHaveBeenCalled();
        });
    });
    describe('Integration with Safety Validator', () => {
        test('integrates with safety validator for comprehensive validation', async () => {
            const replacement = {
                original: 'any[]',
                replacement: 'unknown[]',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.9,
                validationRequired: true
            };
            const context = {
                filePath: 'test.ts',
                lineNumber: 1,
                codeSnippet: 'const items: any[] = [];',
                surroundingLines: [],
                hasExistingComment: false,
                isInTestFile: false,
                domainContext: {
                    domain: types_1.CodeDomain.UTILITY,
                    intentionalityHints: [],
                    suggestedTypes: [],
                    preservationReasons: []
                }
            };
            mockFs.readFileSync.mockReturnValue('const items: any[] = [];');
            const result = await replacer.applyReplacement(replacement, context);
            expect(result.success).toBe(true);
        });
        test('respects safety validator recommendations', async () => {
            const lowConfidenceReplacement = {
                original: 'any',
                replacement: 'string',
                filePath: 'test.ts',
                lineNumber: 1,
                confidence: 0.3,
                validationRequired: true
            };
            const result = await replacer.applyReplacement(lowConfidenceReplacement);
            expect(result.success).toBe(false);
            expect(result.compilationErrors[0]).toContain('Safety score');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL0dyZWdDYXN0cm8vRGVza3RvcC9XaGF0VG9FYXROZXh0L3NyYy9zZXJ2aWNlcy9jYW1wYWlnbi91bmludGVudGlvbmFsLWFueS1lbGltaW5hdGlvbi9fX3Rlc3RzX18vU2FmZVR5cGVSZXBsYWNlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRSCxpREFBaUQ7QUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUczQiw4QkFBOEI7QUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUdoQix1QkFBdUI7QUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNuRCxvQkFBb0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDO1lBQzlDLE9BQU8sRUFBRSxJQUFJO1lBQ2IsV0FBVyxFQUFFLEdBQUc7WUFDaEIsZ0JBQWdCLEVBQUUsRUFBRTtZQUNwQixRQUFRLEVBQUUsRUFBRTtZQUNaLGVBQWUsRUFBRSxFQUFFO1NBQ3BCLENBQUM7UUFDRiw2QkFBNkIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUM7WUFDekQsZUFBZSxFQUFFLElBQUk7WUFDckIsaUJBQWlCLEVBQUUsRUFBRTtZQUNyQixlQUFlLEVBQUUsRUFBRTtZQUNuQixrQkFBa0IsRUFBRSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRTtTQUM3RCxDQUFDO1FBQ0YsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDO1lBQ25ELGVBQWUsRUFBRSxJQUFJO1lBQ3JCLGlCQUFpQixFQUFFLEVBQUU7WUFD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QVEsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDckUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsMkNBQTJDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDM0QsTUFBTSx3QkFBd0IsR0FBb0I7Z0JBQ2hELFFBQVEsRUFBRSxLQUFLO2dCQUNmLFdBQVcsRUFBRSxRQUFRO2dCQUNyQixRQUFRLEVBQUUsU0FBUztnQkFDbkIsVUFBVSxFQUFFLENBQUM7Z0JBQ2IsVUFBVSxFQUFFLEdBQUc7Z0JBQ2Ysa0JBQWtCLEVBQUUsSUFBSTthQUN6QixDQUFDO1lBRUYsTUFBTSxNQUFNLEdBQUcsTUFBTSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUN6RSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNuQyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvR3JlZ0Nhc3Ryby9EZXNrdG9wL1doYXRUb0VhdE5leHQvc3JjL3NlcnZpY2VzL2NhbXBhaWduL3VuaW50ZW50aW9uYWwtYW55LWVsaW1pbmF0aW9uL19fdGVzdHNfXy9TYWZlVHlwZVJlcGxhY2VyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTYWZlVHlwZVJlcGxhY2VyIFRlc3RzXG4gKiBDb21wcmVoZW5zaXZlIHRlc3Qgc3VpdGUgZm9yIHRoZSBTYWZlIFR5cGUgUmVwbGFjZXIgc3lzdGVtXG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBTYWZlVHlwZVJlcGxhY2VyIH0gZnJvbSAnLi4vU2FmZVR5cGVSZXBsYWNlcic7XG5pbXBvcnQgeyBDbGFzc2lmaWNhdGlvbkNvbnRleHQsIENvZGVEb21haW4sIFR5cGVSZXBsYWNlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gTW9jayBleGVjU3luYyBmb3IgVHlwZVNjcmlwdCBjb21waWxhdGlvbiB0ZXN0c1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBtb2NrRXhlY1N5bmMgPSBleGVjU3luYyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBleGVjU3luYz47XG5cbi8vIE1vY2sgZnMgZm9yIGZpbGUgb3BlcmF0aW9uc1xuamVzdC5tb2NrKCdmcycpO1xuY29uc3QgbW9ja0ZzID0gZnMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzPjtcblxuLy8gTW9jayBTYWZldHlWYWxpZGF0b3Jcbmplc3QubW9jaygnLi4vU2FmZXR5VmFsaWRhdG9yJywgKCkgPT4gKHtcbiAgU2FmZXR5VmFsaWRhdG9yOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgY2FsY3VsYXRlU2FmZXR5U2NvcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIHNhZmV0eVNjb3JlOiAwLjksXG4gICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW11cbiAgICB9KSxcbiAgICB2YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGJ1aWxkU3VjY2Vzc2Z1bDogdHJ1ZSxcbiAgICAgIGNvbXBpbGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgIGxpbnRpbmdXYXJuaW5nczogW10sXG4gICAgICBwZXJmb3JtYW5jZU1ldHJpY3M6IHsgYnVpbGRUaW1lOiAxMDAsIG1lbW9yeVVzYWdlOiAxMDAwMDAwIH1cbiAgICB9KSxcbiAgICB2YWxpZGF0ZUJ1aWxkQWZ0ZXJCYXRjaDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGJ1aWxkU3VjY2Vzc2Z1bDogdHJ1ZSxcbiAgICAgIGNvbXBpbGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgIGxpbnRpbmdXYXJuaW5nczogW10sXG4gICAgICBwZXJmb3JtYW5jZU1ldHJpY3M6IHsgYnVpbGRUaW1lOiAxMDAsIG1lbW9yeVVzYWdlOiAxMDAwMDAwIH1cbiAgICB9KSxcbiAgICB2YWxpZGF0ZVJvbGxiYWNrQ2FwYWJpbGl0eTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGNhblJvbGxiYWNrOiB0cnVlLFxuICAgICAgYmFja3VwSW50ZWdyaXR5OiB0cnVlLFxuICAgICAgcm9sbGJhY2tFcnJvcnM6IFtdLFxuICAgICAgcmVzdG9yYXRpb25WZXJpZmllZDogdHJ1ZVxuICAgIH0pLFxuICAgIHVwZGF0ZVNhZmV0eVRocmVzaG9sZHM6IGplc3QuZm4oKVxuICB9KSlcbn0pKTtcblxuZGVzY3JpYmUoJ1NhZmVUeXBlUmVwbGFjZXInLCAoKSA9PiB7XG4gIGxldCByZXBsYWNlcjogU2FmZVR5cGVSZXBsYWNlcjtcbiAgbGV0IHRlc3RCYWNrdXBEaXI6IHN0cmluZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICB0ZXN0QmFja3VwRGlyID0gJy4vLnRlc3QtYmFja3Vwcyc7XG4gICAgcmVwbGFjZXIgPSBuZXcgU2FmZVR5cGVSZXBsYWNlcih0ZXN0QmFja3VwRGlyLCAwLjcsIDMwMDAwLCAzKTtcblxuICAgIC8vIE1vY2sgZnMuZXhpc3RzU3luYyB0byByZXR1cm4gZmFsc2UgZm9yIGJhY2t1cCBkaXJlY3RvcnkgaW5pdGlhbGx5XG4gICAgbW9ja0ZzLmV4aXN0c1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICBpZiAocGF0aCA9PT0gdGVzdEJhY2t1cERpcikgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIEFzc3VtZSBvdGhlciBmaWxlcyBleGlzdFxuICAgIH0pO1xuXG4gICAgLy8gTW9jayBmcy5ta2RpclN5bmNcbiAgICBtb2NrRnMubWtkaXJTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB1bmRlZmluZWQgYXMgYW55KTtcblxuICAgIC8vIE1vY2sgZnMucmVhZEZpbGVTeW5jIGFuZCB3cml0ZUZpbGVTeW5jXG4gICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuICAgIG1vY2tGcy53cml0ZUZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB1bmRlZmluZWQpO1xuXG4gICAgLy8gTW9jayBzdWNjZXNzZnVsIFR5cGVTY3JpcHQgY29tcGlsYXRpb24gYnkgZGVmYXVsdFxuICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gJycpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uc3RydWN0b3IgYW5kIEluaXRpYWxpemF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ2NyZWF0ZXMgYmFja3VwIGRpcmVjdG9yeSBpZiBpdCBkb2VzIG5vdCBleGlzdCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChtb2NrRnMubWtkaXJTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh0ZXN0QmFja3VwRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2luaXRpYWxpemVzIHdpdGggZGVmYXVsdCBzdHJhdGVnaWVzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IHJlcGxhY2VyLmdldFN0cmF0ZWdpZXMoKTtcbiAgICAgIGV4cGVjdChzdHJhdGVnaWVzKS50b0hhdmVMZW5ndGgoMTApO1xuICAgICAgZXhwZWN0KHN0cmF0ZWdpZXNbMF0ucHJpb3JpdHkpLnRvQmUoMSk7IC8vIEFycmF5IHR5cGUgc3RyYXRlZ3kgc2hvdWxkIGJlIGZpcnN0XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdhbGxvd3MgY3VzdG9tIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21SZXBsYWNlciA9IG5ldyBTYWZlVHlwZVJlcGxhY2VyKCcuY3VzdG9tLWJhY2t1cCcsIDAuOCwgNjAwMDAsIDUpO1xuICAgICAgZXhwZWN0KGN1c3RvbVJlcGxhY2VyLmdldEJhY2t1cERpcmVjdG9yeSgpKS50b0JlKCcuY3VzdG9tLWJhY2t1cCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xlIFJlcGxhY2VtZW50IE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc3VjY2Vzc2Z1bGx5IHJlcGxhY2VzIGFycmF5IHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBpdGVtczogYW55W10gPSBbXTsnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWRSZXBsYWNlbWVudHMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBsb3cgc2FmZXR5IHNjb3JlIHJlamVjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICdzdHJpbmcnLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjMsIC8vIExvdyBjb25maWRlbmNlXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmZhaWxlZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdTYWZldHkgc2NvcmUnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JvbGxzIGJhY2sgb24gVHlwZVNjcmlwdCBjb21waWxhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgY29tcGlsYXRpb24gZmFpbHVyZVxuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDb21waWxhdGlvbiBmYWlsZWQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IFR5cGUgbWlzbWF0Y2gnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucm9sbGJhY2tQZXJmb3JtZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMyMjogVHlwZSBtaXNtYXRjaCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBpbnZhbGlkIGxpbmUgbnVtYmVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDk5OSwgLy8gSW52YWxpZCBsaW5lIG51bWJlclxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpOyAvLyBPbmx5IDEgbGluZVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnNbMF0pLnRvQ29udGFpbignSW52YWxpZCBsaW5lIG51bWJlcicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBwYXR0ZXJuIG5vdCBmb3VuZCBpbiBsaW5lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdzdHJpbmdbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKCdjb25zdCBpdGVtczogYW55W10gPSBbXTsnKTsgLy8gUGF0dGVybiBkb2Vzbid0IG1hdGNoXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9yc1swXSkudG9Db250YWluKCdQYXR0ZXJuIFwic3RyaW5nW11cIiBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhdGNoIFByb2Nlc3NpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgncHJvY2Vzc2VzIG11bHRpcGxlIHJlcGxhY2VtZW50cyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudHM6IFR5cGVSZXBsYWNlbWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdDEudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICdSZWNvcmQ8c3RyaW5nLCB1bmtub3duPicsXG4gICAgICAgICAgcmVwbGFjZW1lbnQ6ICdSZWNvcmQ8c3RyaW5nLCB1bmtub3duPicsXG4gICAgICAgICAgZmlsZVBhdGg6ICd0ZXN0Mi50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChmaWxlUGF0aDogdW5rbm93bikgPT4ge1xuICAgICAgICBpZiAoZmlsZVBhdGguaW5jbHVkZXMoJ3Rlc3QxLnRzJykpIHJldHVybiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107JztcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCd0ZXN0Mi50cycpKSByZXR1cm4gJ2NvbnN0IGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307JztcbiAgICAgICAgcmV0dXJuICdiYWNrdXAgY29udGVudCc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKHJlcGxhY2VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWRSZXBsYWNlbWVudHMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JvbGxzIGJhY2sgYWxsIGNoYW5nZXMgb24gb3ZlcmFsbCBjb21waWxhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRzOiBUeXBlUmVwbGFjZW1lbnRbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QxLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBvdmVyYWxsIGNvbXBpbGF0aW9uIHRvIGZhaWxcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignT3ZlcmFsbCBjb21waWxhdGlvbiBmYWlsZWQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMjI6IE92ZXJhbGwgdHlwZSBlcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLnByb2Nlc3NCYXRjaChyZXBsYWNlbWVudHMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yb2xsYmFja1BlcmZvcm1lZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvQ29udGFpbignZXJyb3IgVFMyMzIyOiBPdmVyYWxsIHR5cGUgZXJyb3InKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2dyb3VwcyByZXBsYWNlbWVudHMgYnkgZmlsZSBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudHM6IFR5cGVSZXBsYWNlbWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgICAgbGluZU51bWJlcjogMixcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ2FueScsXG4gICAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgeDogYW55ID0gMTtcXG5jb25zdCBpdGVtczogYW55W10gPSBbXTsnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKHJlcGxhY2VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZFJlcGxhY2VtZW50cykudG9IYXZlTGVuZ3RoKDIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FmZXR5IFNjb3JlIENhbGN1bGF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ2NhbGN1bGF0ZXMgaGlnaGVyIHNjb3JlcyBmb3IgYXJyYXkgcmVwbGFjZW1lbnRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC43LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIEFjY2VzcyBwcml2YXRlIG1ldGhvZCB0aHJvdWdoIGFueSBjYXN0IGZvciB0ZXN0aW5nXG4gICAgICBjb25zdCBzY29yZSA9IChyZXBsYWNlciBhcyBhbnkpLmNhbGN1bGF0ZVNhZmV0eVNjb3JlKHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChzY29yZSkudG9CZUdyZWF0ZXJUaGFuKDAuNyk7IC8vIFNob3VsZCBiZSBib29zdGVkIGZvciBhcnJheSByZXBsYWNlbWVudFxuICAgIH0pO1xuXG4gICAgdGVzdCgnY2FsY3VsYXRlcyBsb3dlciBzY29yZXMgZm9yIGVycm9yIGhhbmRsaW5nIGNvbnRleHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdjYXRjaCAoZXJyb3I6IHVua25vd24pJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICdjYXRjaCAoZXJyb3I6IHVua25vd24pJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNjb3JlID0gKHJlcGxhY2VyIGFzIGFueSkuY2FsY3VsYXRlU2FmZXR5U2NvcmUocmVwbGFjZW1lbnQpO1xuICAgICAgZXhwZWN0KHNjb3JlKS50b0JlTGVzc1RoYW4oMC44KTsgLy8gU2hvdWxkIGJlIHJlZHVjZWQgZm9yIGVycm9yIGNvbnRleHRcbiAgICB9KTtcblxuICAgIHRlc3QoJ2Jvb3N0cyBzY29yZXMgZm9yIHRlc3QgZmlsZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bicsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC43LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNjb3JlID0gKHJlcGxhY2VyIGFzIGFueSkuY2FsY3VsYXRlU2FmZXR5U2NvcmUocmVwbGFjZW1lbnQpO1xuICAgICAgZXhwZWN0KHNjb3JlKS50b0JlR3JlYXRlclRoYW4oMC43KTsgLy8gU2hvdWxkIGJlIGJvb3N0ZWQgZm9yIHRlc3QgZmlsZXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JvbGxiYWNrIFZlcmlmaWNhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCd2ZXJpZmllcyByb2xsYmFjayBjYXBhYmlsaXR5IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gJ3Rlc3QudHMnO1xuICAgICAgY29uc3QgYmFja3VwUGF0aCA9ICdiYWNrdXAudHMnO1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogdW5rbm93bikgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gZmlsZVBhdGgpIHJldHVybiAnbW9kaWZpZWQgY29udGVudCc7XG4gICAgICAgIGlmIChwYXRoID09PSBiYWNrdXBQYXRoKSByZXR1cm4gJ29yaWdpbmFsIGNvbnRlbnQnO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKHJlcGxhY2VyIGFzIGFueSkudmVyaWZ5Um9sbGJhY2tDYXBhYmlsaXR5KGZpbGVQYXRoLCBiYWNrdXBQYXRoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgbWlzc2luZyBiYWNrdXAgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gJ3Rlc3QudHMnO1xuICAgICAgY29uc3QgYmFja3VwUGF0aCA9ICdtaXNzaW5nLWJhY2t1cC50cyc7XG5cbiAgICAgIG1vY2tGcy5leGlzdHNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogdW5rbm93bikgPT4ge1xuICAgICAgICByZXR1cm4gcGF0aCAhPT0gYmFja3VwUGF0aDsgLy8gQmFja3VwIGRvZXNuJ3QgZXhpc3RcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAocmVwbGFjZXIgYXMgYW55KS52ZXJpZnlSb2xsYmFja0NhcGFiaWxpdHkoZmlsZVBhdGgsIGJhY2t1cFBhdGgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignQmFja3VwIGZpbGUgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0cmF0ZWd5IE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnYWxsb3dzIGFkZGluZyBjdXN0b20gc3RyYXRlZ2llcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbVN0cmF0ZWd5ID0ge1xuICAgICAgICBwYXR0ZXJuOiAvY3VzdG9tX3BhdHRlcm4vZyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICgpID0+ICdjdXN0b21fcmVwbGFjZW1lbnQnLFxuICAgICAgICB2YWxpZGF0b3I6ICgpID0+IHRydWUsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9O1xuXG4gICAgICByZXBsYWNlci5hZGRTdHJhdGVneShjdXN0b21TdHJhdGVneSk7XG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gcmVwbGFjZXIuZ2V0U3RyYXRlZ2llcygpO1xuXG4gICAgICBleHBlY3Qoc3RyYXRlZ2llc1swXSkudG9CZShjdXN0b21TdHJhdGVneSk7IC8vIFNob3VsZCBiZSBmaXJzdCBkdWUgdG8gcHJpb3JpdHkgMFxuICAgIH0pO1xuXG4gICAgdGVzdCgnbWFpbnRhaW5zIHN0cmF0ZWd5IHByaW9yaXR5IG9yZGVyJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IHJlcGxhY2VyLmdldFN0cmF0ZWdpZXMoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJhdGVnaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdChzdHJhdGVnaWVzW2ldLnByaW9yaXR5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKHN0cmF0ZWdpZXNbaSAtIDFdLnByaW9yaXR5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhY2t1cCBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ2NyZWF0ZXMgYmFja3VwcyB3aXRoIHRpbWVzdGFtcCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gJ3Rlc3QudHMnO1xuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ29yaWdpbmFsIGNvbnRlbnQnKTtcblxuICAgICAgY29uc3QgYmFja3VwUGF0aCA9IGF3YWl0IChyZXBsYWNlciBhcyBhbnkpLmNyZWF0ZUJhY2t1cChmaWxlUGF0aCk7XG5cbiAgICAgIGV4cGVjdChiYWNrdXBQYXRoKS50b0NvbnRhaW4oJy50ZXN0LWJhY2t1cHMnKTtcbiAgICAgIGV4cGVjdChiYWNrdXBQYXRoKS50b0NvbnRhaW4oJ3Rlc3QudHMnKTtcbiAgICAgIGV4cGVjdChiYWNrdXBQYXRoKS50b0NvbnRhaW4oJy5iYWNrdXAnKTtcbiAgICAgIGV4cGVjdChtb2NrRnMud3JpdGVGaWxlU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGJhY2t1cFBhdGgsXG4gICAgICAgICdvcmlnaW5hbCBjb250ZW50JyxcbiAgICAgICAgJ3V0ZjgnXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnY2xlYW5zIHVwIG9sZCBiYWNrdXAgZmlsZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvbGREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIG9sZERhdGUuc2V0RGF0ZShvbGREYXRlLmdldERhdGUoKSAtIDEwKTsgLy8gMTAgZGF5cyBvbGRcblxuICAgICAgbW9ja0ZzLnJlYWRkaXJTeW5jLm1vY2tSZXR1cm5WYWx1ZShbJ29sZC5iYWNrdXAnLCAncmVjZW50LmJhY2t1cCcsICdvdGhlci50eHQnXSBhcyBhbnkpO1xuICAgICAgbW9ja0ZzLnN0YXRTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZVBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCdvbGQuYmFja3VwJykpIHtcbiAgICAgICAgICByZXR1cm4geyBtdGltZTogb2xkRGF0ZSB9IGFzIGFueTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtdGltZTogbmV3IERhdGUoKSB9IGFzIGFueTsgLy8gUmVjZW50IGZpbGVcbiAgICAgIH0pO1xuXG4gICAgICByZXBsYWNlci5jbGVhbnVwT2xkQmFja3Vwcyg3KTsgLy8gS2VlcCA3IGRheXNcblxuICAgICAgZXhwZWN0KG1vY2tGcy51bmxpbmtTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgcGF0aC5qb2luKHRlc3RCYWNrdXBEaXIsICdvbGQuYmFja3VwJylcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja0ZzLnVubGlua1N5bmMpLm5vdC50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgcGF0aC5qb2luKHRlc3RCYWNrdXBEaXIsICdyZWNlbnQuYmFja3VwJylcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBhbmQgUmV0cmllcycsICgpID0+IHtcbiAgICB0ZXN0KCdoYW5kbGVzIGZpbGUgc3lzdGVtIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgYmFja3VwIGNyZWF0aW9uIHRvIGZhaWxcbiAgICAgIG1vY2tGcy53cml0ZUZpbGVTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZVBhdGg6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKGZpbGVQYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2t1cCBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4cGVjdCB0aGUgZXJyb3IgdG8gYmUgdGhyb3duIHNpbmNlIGJhY2t1cCBjcmVhdGlvbiBpcyBjcml0aWNhbFxuICAgICAgYXdhaXQgZXhwZWN0KHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpKS5yZWplY3RzLnRvVGhyb3coJ0JhY2t1cCBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY29tcGlsYXRpb24gZXJyb3JzIHdpdGggcm9sbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb21waWxhdGlvbiB0byBmYWlsXG4gICAgICBtb2NrRXhlY1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBpbGF0aW9uIGZhaWxlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3Iuc3Rkb3V0ID0gJ2Vycm9yIFRTMjMyMjogVHlwZSBlcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yb2xsYmFja1BlcmZvcm1lZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvQ29udGFpbignZXJyb3IgVFMyMzIyOiBUeXBlIGVycm9yJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUeXBlU2NyaXB0IENvbXBpbGF0aW9uIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnaGFuZGxlcyBzdWNjZXNzZnVsIGNvbXBpbGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChyZXBsYWNlciBhcyBhbnkpLnZhbGlkYXRlVHlwZVNjcmlwdENvbXBpbGF0aW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdleHRyYWN0cyBUeXBlU2NyaXB0IGVycm9ycyBmcm9tIG91dHB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yT3V0cHV0ID0gYFxuICAgICAgICBzcmMvdGVzdC50cygxMCw1KTogZXJyb3IgVFMyMzIyOiBUeXBlICdzdHJpbmcnIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHR5cGUgJ251bWJlcicuXG4gICAgICAgIHNyYy90ZXN0LnRzKDE1LDEwKTogZXJyb3IgVFMyMzA0OiBDYW5ub3QgZmluZCBuYW1lICd1bmtub3duVmFyaWFibGUnLlxuICAgICAgICBGb3VuZCAyIGVycm9ycy5cbiAgICAgIGA7XG5cbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICBlcnJvci5zdGRvdXQgPSBlcnJvck91dHB1dDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKHJlcGxhY2VyIGFzIGFueSkudmFsaWRhdGVUeXBlU2NyaXB0Q29tcGlsYXRpb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yc1swXSkudG9Db250YWluKCdlcnJvciBUUzIzMjInKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzFdKS50b0NvbnRhaW4oJ2Vycm9yIFRTMjMwNCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb21waWxhdGlvbiB0aW1lb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUaW1lb3V0JykgYXMgYW55O1xuICAgICAgICBlcnJvci5jb2RlID0gJ1RJTUVPVVQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAocmVwbGFjZXIgYXMgYW55KS52YWxpZGF0ZVR5cGVTY3JpcHRDb21waWxhdGlvbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzBdKS50b0NvbnRhaW4oJ1RpbWVvdXQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FkdmFuY2VkIFJlcGxhY2VtZW50IFN0cmF0ZWd5IFBhdHRlcm5zJywgKCkgPT4ge1xuICAgIHRlc3QoJ2luZmVycyBhcnJheSBlbGVtZW50IHR5cGVzIGZyb20gY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBpdGVtczogYW55W10gPSBbXCJoZWxsb1wiLCBcIndvcmxkXCJdOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyQXJyYXlFbGVtZW50VHlwZShjb250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ3N0cmluZycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb21wbGV4IG5lc3RlZCB0eXBlIGluZmVyZW5jZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBsZXhDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgbmVzdGVkOiBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4gPSB7IGl0ZW1zOiBbMSwgMiwgM10gfTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhcnJheVR5cGUgPSAocmVwbGFjZXIgYXMgYW55KS5pbmZlckFycmF5RWxlbWVudFR5cGUoY29tcGxleENvbnRleHQpO1xuICAgICAgY29uc3QgcmVjb3JkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyUmVjb3JkVmFsdWVUeXBlKGNvbXBsZXhDb250ZXh0KTtcblxuICAgICAgZXhwZWN0KGFycmF5VHlwZSkudG9CZSgnbnVtYmVyJyk7XG4gICAgICBleHBlY3QocmVjb3JkVHlwZSkudG9CZSgnbnVtYmVyW10nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2luZmVycyB0eXBlcyBmcm9tIHVzYWdlIHBhdHRlcm5zIGluIHN1cnJvdW5kaW5nIGNvZGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1c2FnZUNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMixcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBkYXRhOiBhbnkgPSBnZXRWYWx1ZSgpOycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtcbiAgICAgICAgICAnZnVuY3Rpb24gZ2V0VmFsdWUoKSB7IHJldHVybiBcInRlc3RcIjsgfScsXG4gICAgICAgICAgJ2NvbnNvbGUubG9nKGRhdGEudG9VcHBlckNhc2UoKSk7JyxcbiAgICAgICAgICAnY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7J1xuICAgICAgICBdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyVmFyaWFibGVUeXBlKHVzYWdlQ29udGV4dCk7XG4gICAgICBleHBlY3QoaW5mZXJyZWRUeXBlKS50b0JlKCdzdHJpbmcnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2luZmVycyBSZWNvcmQgdmFsdWUgdHlwZXMgZnJvbSBvYmplY3QgbGl0ZXJhbHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY29uc3QgY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHsgbmFtZTogXCJ0ZXN0XCIsIGNvdW50OiA0MiB9OycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyUmVjb3JkVmFsdWVUeXBlKGNvbnRleHQpO1xuICAgICAgZXhwZWN0KFsnc3RyaW5nJywgJ251bWJlcicsICd1bmtub3duJ10pLnRvQ29udGFpbihpbmZlcnJlZFR5cGUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW5mZXJzIGZ1bmN0aW9uIHBhcmFtZXRlciB0eXBlcyBmcm9tIHBhcmFtZXRlciBuYW1lcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudDogdW5rbm93bikgeyB9JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uQ09NUE9ORU5ULFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgYW55KS5pbmZlckZ1bmN0aW9uUGFyYW1ldGVyVHlwZShjb250ZXh0LCAnZXZlbnQnKTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ0V2ZW50Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdpbmZlcnMgcmV0dXJuIHR5cGVzIGZyb20gZnVuY3Rpb24gY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdmdW5jdGlvbiBpc1ZhbGlkKCk6IGFueSB7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogWycgIHJldHVybiB0cnVlOyddLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlVUSUxJVFksXG4gICAgICAgICAgaW50ZW50aW9uYWxpdHlIaW50czogW10sXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZXM6IFtdLFxuICAgICAgICAgIHByZXNlcnZhdGlvblJlYXNvbnM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZmVycmVkVHlwZSA9IChyZXBsYWNlciBhcyBhbnkpLmluZmVyUmV0dXJuVHlwZShjb250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ2Jvb2xlYW4nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgZXJyb3IgaGFuZGxpbmcgY29udGV4dHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JDb250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaXNFcnJvckNvbnRleHQgPSAocmVwbGFjZXIgYXMgYW55KS5pc0luRXJyb3JIYW5kbGluZ0NvbnRleHQoZXJyb3JDb250ZXh0KTtcbiAgICAgIGV4cGVjdChpc0Vycm9yQ29udGV4dCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RldGVjdHMgZXh0ZXJuYWwgQVBJIGNvbnRleHRzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGFwaUNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCByZXNwb25zZTogYW55ID0gYXdhaXQgZmV0Y2goXCIvYXBpL2RhdGFcIik7JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uU0VSVklDRSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaXNBcGlDb250ZXh0ID0gKHJlcGxhY2VyIGFzIGFueSkuaXNFeHRlcm5hbEFwaUNvbnRleHQoYXBpQ29udGV4dCk7XG4gICAgICBleHBlY3QoaXNBcGlDb250ZXh0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnYXBwbGllcyBkb21haW4tc3BlY2lmaWMgdHlwZSBpbmZlcmVuY2UgZm9yIGFzdHJvbG9naWNhbCBjb250ZXh0JywgKCkgPT4ge1xuICAgICAgY29uc3QgYXN0cm9Db250ZXh0OiBDbGFzc2lmaWNhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGZpbGVQYXRoOiAnYXN0cm9sb2d5LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBwbGFuZXRhcnlQb3NpdGlvbnM6IGFueVtdID0gW107JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogWydwb3NpdGlvbnMucHVzaChcIm1hcnNcIik7J10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uQVNUUk9MT0dJQ0FMLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmZlcnJlZFR5cGUgPSAocmVwbGFjZXIgYXMgYW55KS5pbmZlckFycmF5RWxlbWVudFR5cGUoYXN0cm9Db250ZXh0KTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ3N0cmluZycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnYXBwbGllcyBkb21haW4tc3BlY2lmaWMgdHlwZSBpbmZlcmVuY2UgZm9yIHJlY2lwZSBjb250ZXh0JywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVjaXBlQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3JlY2lwZS50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvZGVTbmlwcGV0OiAnZnVuY3Rpb24gcHJvY2Vzc0luZ3JlZGllbnQoaW5ncmVkaWVudDogdW5rbm93bikgeycsXG4gICAgICAgIHN1cnJvdW5kaW5nTGluZXM6IFtdLFxuICAgICAgICBoYXNFeGlzdGluZ0NvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpc0luVGVzdEZpbGU6IGZhbHNlLFxuICAgICAgICBkb21haW5Db250ZXh0OiB7XG4gICAgICAgICAgZG9tYWluOiBDb2RlRG9tYWluLlJFQ0lQRSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaW5mZXJyZWRUeXBlID0gKHJlcGxhY2VyIGFzIGFueSkuaW5mZXJGdW5jdGlvblBhcmFtZXRlclR5cGUocmVjaXBlQ29udGV4dCwgJ2luZ3JlZGllbnQnKTtcbiAgICAgIGV4cGVjdChpbmZlcnJlZFR5cGUpLnRvQmUoJ0luZ3JlZGllbnQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY29tcGxleCByZXBsYWNlbWVudCBwYXR0ZXJucyB3aXRoIHZhbGlkYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ29udGV4dDogQ2xhc3NpZmljYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb2RlU25pcHBldDogJ2Z1bmN0aW9uIHByb2Nlc3MoZGF0YTogdW5rbm93bik6IGFueSB7IHJldHVybiBkYXRhOyB9JyxcbiAgICAgICAgc3Vycm91bmRpbmdMaW5lczogW10sXG4gICAgICAgIGhhc0V4aXN0aW5nQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGlzSW5UZXN0RmlsZTogZmFsc2UsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IHtcbiAgICAgICAgICBkb21haW46IENvZGVEb21haW4uVVRJTElUWSxcbiAgICAgICAgICBpbnRlbnRpb25hbGl0eUhpbnRzOiBbXSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlczogW10sXG4gICAgICAgICAgcHJlc2VydmF0aW9uUmVhc29uczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IHJlcGxhY2VyLmdldFN0cmF0ZWdpZXMoKTtcblxuICAgICAgLy8gVGVzdCBmdW5jdGlvbiBwYXJhbWV0ZXIgc3RyYXRlZ3lcbiAgICAgIGNvbnN0IHBhcmFtU3RyYXRlZ3kgPSBzdHJhdGVnaWVzLmZpbmQocyA9PiBzLnByaW9yaXR5ID09PSA0KTtcbiAgICAgIGV4cGVjdChwYXJhbVN0cmF0ZWd5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHBhcmFtU3RyYXRlZ3k/LnZhbGlkYXRvcihtb2NrQ29udGV4dCkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFRlc3QgcmV0dXJuIHR5cGUgc3RyYXRlZ3lcbiAgICAgIGNvbnN0IHJldHVyblN0cmF0ZWd5ID0gc3RyYXRlZ2llcy5maW5kKHMgPT4gcy5wcmlvcml0eSA9PT0gNSk7XG4gICAgICBleHBlY3QocmV0dXJuU3RyYXRlZ3kpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmV0dXJuU3RyYXRlZ3k/LnZhbGlkYXRvcihtb2NrQ29udGV4dCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wcmVoZW5zaXZlIEVycm9yIFJlY292ZXJ5JywgKCkgPT4ge1xuICAgIHRlc3QoJ2hhbmRsZXMgcGFydGlhbCBiYXRjaCBmYWlsdXJlcyB3aXRoIHNlbGVjdGl2ZSByb2xsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50czogVHlwZVJlcGxhY2VtZW50W10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ3N0cmluZ1tdJyxcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QxLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbmFsOiAnYW55JyxcbiAgICAgICAgICByZXBsYWNlbWVudDogJ0ludmFsaWRUeXBlJywgLy8gVGhpcyBzaG91bGQgY2F1c2UgY29tcGlsYXRpb24gZXJyb3JcbiAgICAgICAgICBmaWxlUGF0aDogJ3Rlc3QyLnRzJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKGZpbGVQYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChmaWxlUGF0aC5pbmNsdWRlcygndGVzdDEudHMnKSkgcmV0dXJuICdjb25zdCBpdGVtczogYW55W10gPSBbXTsnO1xuICAgICAgICBpZiAoZmlsZVBhdGguaW5jbHVkZXMoJ3Rlc3QyLnRzJykpIHJldHVybiAnY29uc3QgZGF0YTogYW55ID0gdmFsdWU7JztcbiAgICAgICAgcmV0dXJuICdiYWNrdXAgY29udGVudCc7XG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBjb21waWxhdGlvbiB0byBmYWlsIGZvciB0aGUgc2Vjb25kIHJlcGxhY2VtZW50XG4gICAgICBsZXQgY29tcGlsYXRpb25DYWxsQ291bnQgPSAwO1xuICAgICAgbW9ja0V4ZWNTeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbXBpbGF0aW9uQ2FsbENvdW50Kys7XG4gICAgICAgIGlmIChjb21waWxhdGlvbkNhbGxDb3VudCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tcGlsYXRpb24gZmFpbGVkJykgYXMgYW55O1xuICAgICAgICAgIGVycm9yLnN0ZG91dCA9ICdlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgXCJJbnZhbGlkVHlwZVwiJztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKHJlcGxhY2VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJvbGxiYWNrUGVyZm9ybWVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21waWxhdGlvbkVycm9ycykudG9Db250YWluKCdlcnJvciBUUzIzMDQ6IENhbm5vdCBmaW5kIG5hbWUgXCJJbnZhbGlkVHlwZVwiJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGZpbGUgc3lzdGVtIHBlcm1pc3Npb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICdyZWFkb25seS50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IGFueVtdID0gW107Jyk7XG4gICAgICBtb2NrRnMud3JpdGVGaWxlU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VBQ0NFUzogcGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QocmVwbGFjZXIuYXBwbHlSZXBsYWNlbWVudChyZXBsYWNlbWVudCkpLnJlamVjdHMudG9UaHJvdygnRUFDQ0VTOiBwZXJtaXNzaW9uIGRlbmllZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBjb3JydXB0ZWQgYmFja3VwIGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKCcuYmFja3VwJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2t1cCBmaWxlIGNvcnJ1cHRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnY29uc3QgaXRlbXM6IGFueVtdID0gW107JztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIG5ldHdvcmsgdGltZW91dHMgZHVyaW5nIHZhbGlkYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ3Rlc3QudHMnLFxuICAgICAgICBsaW5lTnVtYmVyOiAxLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIHZhbGlkYXRpb25SZXF1aXJlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuXG4gICAgICAvLyBNb2NrIHRpbWVvdXQgZXJyb3JcbiAgICAgIG1vY2tFeGVjU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ29tbWFuZCB0aW1lZCBvdXQnKSBhcyBhbnk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnVElNRU9VVCc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tcGlsYXRpb25FcnJvcnMpLnRvQ29udGFpbignQ29tbWFuZCB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIGFuZCBNZW1vcnkgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdoYW5kbGVzIGxhcmdlIGZpbGUgcHJvY2Vzc2luZyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlQ29udGVudCA9ICdjb25zdCBpdGVtczogYW55W10gPSBbXTtcXG4nLnJlcGVhdCgxMDAwMCk7XG4gICAgICBjb25zdCByZXBsYWNlbWVudDogVHlwZVJlcGxhY2VtZW50ID0ge1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogJ2xhcmdlLnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogNTAwMCxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGcy5yZWFkRmlsZVN5bmMubW9ja1JldHVyblZhbHVlKGxhcmdlQ29udGVudCk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBsYWNlci5hcHBseVJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDIwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDIgc2Vjb25kc1xuICAgIH0pO1xuXG4gICAgdGVzdCgnbWFuYWdlcyBtZW1vcnkgZHVyaW5nIGJhdGNoIHByb2Nlc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZUJhdGNoOiBUeXBlUmVwbGFjZW1lbnRbXSA9IEFycmF5KDEwMDApLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICBvcmlnaW5hbDogJ2FueVtdJyxcbiAgICAgICAgcmVwbGFjZW1lbnQ6ICd1bmtub3duW10nLFxuICAgICAgICBmaWxlUGF0aDogYHRlc3Qke2l9LnRzYCxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH0pKTtcblxuICAgICAgbW9ja0ZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ2NvbnN0IGl0ZW1zOiBhbnlbXSA9IFtdOycpO1xuXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbGFjZXIucHJvY2Vzc0JhdGNoKGxhcmdlQmF0Y2gpO1xuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAvLyBNZW1vcnkgdXNhZ2Ugc2hvdWxkbid0IGdyb3cgZXhjZXNzaXZlbHkgKGFsbG93IDEwME1CIGluY3JlYXNlKVxuICAgICAgZXhwZWN0KGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeSkudG9CZUxlc3NUaGFuKDEwMCAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2NsZWFucyB1cCByZXNvdXJjZXMgYWZ0ZXIgcHJvY2Vzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBUeXBlUmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIG9yaWdpbmFsOiAnYW55W10nLFxuICAgICAgICByZXBsYWNlbWVudDogJ3Vua25vd25bXScsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgdmFsaWRhdGlvblJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IGFueVtdID0gW107Jyk7XG5cbiAgICAgIGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQpO1xuXG4gICAgICAvLyBWZXJpZnkgY2xlYW51cCB3YXMgY2FsbGVkXG4gICAgICBleHBlY3QobW9ja0ZzLndyaXRlRmlsZVN5bmMpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgLy8gVGVzdCBiYWNrdXAgY2xlYW51cFxuICAgICAgcmVwbGFjZXIuY2xlYW51cE9sZEJhY2t1cHMoMCk7IC8vIENsZWFuIGFsbCBiYWNrdXBzXG4gICAgICBleHBlY3QobW9ja0ZzLnVubGlua1N5bmMpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVncmF0aW9uIHdpdGggU2FmZXR5IFZhbGlkYXRvcicsICgpID0+IHtcbiAgICB0ZXN0KCdpbnRlZ3JhdGVzIHdpdGggc2FmZXR5IHZhbGlkYXRvciBmb3IgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnlbXScsXG4gICAgICAgIHJlcGxhY2VtZW50OiAndW5rbm93bltdJyxcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbnRleHQ6IENsYXNzaWZpY2F0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICd0ZXN0LnRzJyxcbiAgICAgICAgbGluZU51bWJlcjogMSxcbiAgICAgICAgY29kZVNuaXBwZXQ6ICdjb25zdCBpdGVtczogYW55W10gPSBbXTsnLFxuICAgICAgICBzdXJyb3VuZGluZ0xpbmVzOiBbXSxcbiAgICAgICAgaGFzRXhpc3RpbmdDb21tZW50OiBmYWxzZSxcbiAgICAgICAgaXNJblRlc3RGaWxlOiBmYWxzZSxcbiAgICAgICAgZG9tYWluQ29udGV4dDoge1xuICAgICAgICAgIGRvbWFpbjogQ29kZURvbWFpbi5VVElMSVRZLFxuICAgICAgICAgIGludGVudGlvbmFsaXR5SGludHM6IFtdLFxuICAgICAgICAgIHN1Z2dlc3RlZFR5cGVzOiBbXSxcbiAgICAgICAgICBwcmVzZXJ2YXRpb25SZWFzb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrRnMucmVhZEZpbGVTeW5jLm1vY2tSZXR1cm5WYWx1ZSgnY29uc3QgaXRlbXM6IGFueVtdID0gW107Jyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQocmVwbGFjZW1lbnQsIGNvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncmVzcGVjdHMgc2FmZXR5IHZhbGlkYXRvciByZWNvbW1lbmRhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb3dDb25maWRlbmNlUmVwbGFjZW1lbnQ6IFR5cGVSZXBsYWNlbWVudCA9IHtcbiAgICAgICAgb3JpZ2luYWw6ICdhbnknLFxuICAgICAgICByZXBsYWNlbWVudDogJ3N0cmluZycsXG4gICAgICAgIGZpbGVQYXRoOiAndGVzdC50cycsXG4gICAgICAgIGxpbmVOdW1iZXI6IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuMywgLy8gVmVyeSBsb3cgY29uZmlkZW5jZVxuICAgICAgICB2YWxpZGF0aW9uUmVxdWlyZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGxhY2VyLmFwcGx5UmVwbGFjZW1lbnQobG93Q29uZmlkZW5jZVJlcGxhY2VtZW50KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBpbGF0aW9uRXJyb3JzWzBdKS50b0NvbnRhaW4oJ1NhZmV0eSBzY29yZScpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9