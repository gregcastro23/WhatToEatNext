#!/usr/bin/env node

/**
 * Final Syntax Recovery - Conservative approach
 * Fixes remaining high-frequency patterns safely
 */

const fs = require('fs');
const { execSync } = require('child_process');

// Get error count
function getErrorCount() {
  try {
    const result = execSync('yarn tsc --noEmit --skipLibCheck 2>&1 | grep -c "error TS"',
      { encoding: 'utf8' });
    return parseInt(result.trim());
  } catch (error) {
    return 0;
  }
}

// Get all TypeScript files
function getAllTsFiles() {
  try {
    const result = execSync(`find src/ -name "*.ts" -o -name "*.tsx"`,
      { encoding: 'utf8', cwd: process.cwd() });
    return result.trim().split('\n').filter(f => f.length > 0);
  } catch (error) {
    return [];
  }
}

// Conservative syntax fixes
function conservativeFix(filePath) {
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    const originalContent = content;

    // Fix missing closing braces/parentheses patterns
    content = content.replace(/toBeGreaterThanOrEqual\(0\)\.\s*$/gm, 'toBeGreaterThanOrEqual(0);');
    content = content.replace(/toBeLessThan\(30\);\s*$/gm, 'toBeLessThan(30);');
    content = content.replace(/toBeLessThan\(360\);\s*$/gm, 'toBeLessThan(360);');

    // Fix method chaining issues
    content = content.replace(/expect\(([^)]+)\)([^.;]*)\./g, 'expect($1)$2.');

    // Fix broken expect statements
    content = content.replace(/expect\(([^)]+)\)not\.to/g, 'expect($1).not.to');
    content = content.replace(/expect\(([^)]+)\)\.to([A-Z])/g, 'expect($1).to$2');

    // Fix console.log typos
    content = content.replace(/consolelog\(/g, 'console.log(');
    content = content.replace(/console\.log\s*\(\s*'/g, "console.log('");

    // Fix missing semicolons in property access
    content = content.replace(/\.degree\)\./g, '.degree).');
    content = content.replace(/\.exactLongitude\)\./g, '.exactLongitude).');

    // Fix missing closing statements
    content = content.replace(/\}\s*$/, '}');

    if (content !== originalContent) {
      fs.writeFileSync(filePath, content);
      return true;
    }
    return false;
  } catch (error) {
    console.error(`Error fixing ${filePath}:`, error.message);
    return false;
  }
}

// Main execution
console.log('üîß Final Syntax Recovery - Conservative Approach');

const initialErrors = getErrorCount();
console.log(`üìä Initial errors: ${initialErrors}`);

const allFiles = getAllTsFiles();
console.log(`üìÅ Processing ${allFiles.length} TypeScript files`);

let fixedFiles = 0;
let progress = 0;

// Process files in small batches
const batchSize = 20;
for (let i = 0; i < allFiles.length; i += batchSize) {
  const batch = allFiles.slice(i, i + batchSize);

  for (const file of batch) {
    const fixed = conservativeFix(file);
    if (fixed) {
      fixedFiles++;
    }
  }

  progress += batch.length;
  if (progress % 100 === 0) {
    console.log(`üìä Progress: ${progress}/${allFiles.length} files processed`);
  }
}

const finalErrors = getErrorCount();
const reduction = initialErrors - finalErrors;
const reductionPercent = ((reduction / initialErrors) * 100).toFixed(1);

console.log(`\nüìà Final Recovery Results:`);
console.log(`   Files processed: ${allFiles.length}`);
console.log(`   Files with fixes: ${fixedFiles}`);
console.log(`   Initial errors: ${initialErrors}`);
console.log(`   Final errors: ${finalErrors}`);
console.log(`   Errors reduced: ${reduction}`);
console.log(`   Reduction: ${reductionPercent}%`);

if (finalErrors < 10000) {
  console.log('üéâ Significant progress! Build should be much more stable now.');
} else if (reduction > 5000) {
  console.log('‚úÖ Good progress made! Continue with remaining fixes.');
} else {
  console.log('‚ö†Ô∏è  Limited progress. May need manual intervention for remaining errors.');
}

console.log('\nüéØ Final syntax recovery complete!');