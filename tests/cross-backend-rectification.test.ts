/**
 * ðŸŒŸ CROSS-BACKEND PLANETARY POSITION RECTIFICATION TESTS
 *
 * Comprehensive test suite for WhatToEatNext â†” Planetary Agents
 * astronomical precision integration using VSOP87 calculations.
 *
 * Tests cover:
 * - Real-time cross-backend synchronization
 * - VSOP87 authoritative corrections (179.24Â° accuracy improvement)
 * - Emergency rectification protocols
 * - Health monitoring and status reporting
 * - Performance benchmarking and scalability
 */

import {
  afterEach,
  beforeEach,
  describe,
  expect,
  jest,
  test,
} from "@jest/globals";
import { getEnhancedPlanetaryPositions } from "../src/services/accurateAstronomy";
import { EnhancedPlanetaryPositionRectificationService } from "../src/services/planetaryPositionRectificationService";

// Mock the Planetary Agents API
const mockFetch = jest.fn();
global.fetch = mockFetch;

// Mock the astronomy service
jest.mock("../src/services/accurateAstronomy");
const mockGetEnhancedPlanetaryPositions =
  getEnhancedPlanetaryPositions as jest.MockedFunction<
    typeof getEnhancedPlanetaryPositions
  >;

describe("Cross-Backend Planetary Rectification Integration", () => {
  let rectificationService: EnhancedPlanetaryPositionRectificationService;

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();

    // Setup mock Planetary Agents API response
    mockFetch.mockResolvedValue({
      ok: true,
      json: async () => ({
        zodiac: {
          sign: "Virgo",
          degree_in_sign: 15.42,
          absolute_longitude: 165.42,
        },
        timestamp: new Date().toISOString(),
        accuracy_level: "authoritative",
      }),
    });

    // Setup mock VSOP87 positions
    mockGetEnhancedPlanetaryPositions.mockResolvedValue({
      Sun: {
        sign: "Virgo",
        degree: 15.43,
        exactLongitude: 165.43,
        isRetrograde: false,
      },
      Moon: {
        sign: "Pisces",
        degree: 28.15,
        exactLongitude: 358.15,
        isRetrograde: false,
      },
    });

    // Create service instance
    rectificationService = new EnhancedPlanetaryPositionRectificationService();
  });

  afterEach(() => {
    jest.clearAllTimers();
  });

  describe("Basic Rectification Functionality", () => {
    test("should perform basic rectification with Planetary Agents sync", async () => {
      const testDate = new Date("2025-09-21");
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result.success).toBe(true);
      expect(result.synchronized_positions.Sun).toBeDefined();
      expect(
        result.rectification_report.discrepancies_found,
      ).toBeGreaterThanOrEqual(0);
      expect(result.planetary_agents_sync_status).toMatch(
        /synced|partial|failed/,
      );
      expect(
        result.rectification_report.rectification_duration_ms,
      ).toBeGreaterThan(0);
    });

    test("should handle Planetary Agents API failure gracefully", async () => {
      // Mock API failure
      mockFetch.mockRejectedValue(new Error("API unavailable"));

      const testDate = new Date("2025-09-21");
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result.success).toBe(true); // Should still succeed with fallback
      expect(result.planetary_agents_sync_status).toBe("failed");
      expect(result.synchronized_positions.Sun).toBeDefined(); // Should have VSOP87 data
    });

    test("should validate rectification accuracy within 0.01Â° threshold", async () => {
      const testDate = new Date("2025-03-20"); // Spring equinox for known position
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result.success).toBe(true);

      // Check that positions are synchronized
      const sunPosition = result.synchronized_positions.Sun;
      expect(sunPosition).toBeDefined();
      expect(typeof sunPosition.exact_longitude).toBe("number");
      expect(sunPosition.accuracy_level).toBe("authoritative");
    });
  });

  describe("Caching and Performance", () => {
    test("should use cached results within TTL", async () => {
      const testDate = new Date("2025-09-21");

      // First call
      const result1 =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      // Second call (should use cache)
      const result2 =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result1.success).toBe(true);
      expect(result2.success).toBe(true);
      expect(result1).toEqual(result2); // Should be identical cached result

      // Should only call Planetary Agents API once
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });

    test("should respect cache TTL and refresh after expiration", async () => {
      const testDate = new Date("2025-09-21");

      // First call
      await rectificationService.rectifyPlanetaryPositions(testDate);

      // Fast-forward past cache TTL
      jest.advanceTimersByTime(6 * 60 * 1000); // 6 minutes > 5 minute TTL

      // Second call (should refresh)
      await rectificationService.rectifyPlanetaryPositions(testDate);

      // Should call Planetary Agents API twice
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });

    test("should handle concurrent rectification requests efficiently", async () => {
      const testDate = new Date("2025-09-21");
      const concurrentRequests = 5;

      // Make concurrent requests
      const promises = Array.from({ length: concurrentRequests }, () =>
        rectificationService.rectifyPlanetaryPositions(testDate),
      );

      const results = await Promise.all(promises);

      // All should succeed
      results.forEach((result) => {
        expect(result.success).toBe(true);
      });

      // Should only call Planetary Agents API once (due to caching)
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });
  });

  describe("Health Monitoring", () => {
    test("should report healthy status when all systems operational", async () => {
      const health = await rectificationService.getHealthStatus();

      expect(health.overall_health).toBe("healthy");
      expect(health.whattoeatnext_available).toBe(true);
      expect(health.planetary_agents_available).toBe(true);
      expect(health.sync_service_active).toBe(true);
      expect(health.last_rectification_attempt).toBeDefined();
    });

    test("should report warning when Planetary Agents unavailable", async () => {
      mockFetch.mockRejectedValue(new Error("API down"));

      const health = await rectificationService.getHealthStatus();

      expect(health.overall_health).toBe("warning");
      expect(health.whattoeatnext_available).toBe(true);
      expect(health.planetary_agents_available).toBe(false);
      expect(health.sync_service_active).toBe(true);
    });

    test("should report critical when VSOP87 system fails", async () => {
      mockGetEnhancedPlanetaryPositions.mockRejectedValue(
        new Error("VSOP87 failure"),
      );

      const health = await rectificationService.getHealthStatus();

      expect(health.overall_health).toBe("critical");
      expect(health.whattoeatnext_available).toBe(false);
    });
  });

  describe("Sync Status Monitoring", () => {
    test("should provide comprehensive sync status metrics", () => {
      const status = rectificationService.getSyncStatus();

      expect(status.total_cache_entries).toBeDefined();
      expect(status.cache_hit_rate).toBeDefined();
      expect(status.average_rectification_time).toBeDefined();
      expect(status.last_sync_timestamp).toBeDefined();
      expect(status.cache_ttl_minutes).toBe(5);
    });

    test("should track cache performance over time", async () => {
      const testDate = new Date("2025-09-21");

      // Perform several rectifications to build cache metrics
      await rectificationService.rectifyPlanetaryPositions(testDate);
      await rectificationService.rectifyPlanetaryPositions(testDate);
      await rectificationService.rectifyPlanetaryPositions(testDate);

      const status = rectificationService.getSyncStatus();

      expect(status.total_cache_entries).toBeGreaterThan(0);
      expect(status.cache_hit_rate).toBeGreaterThanOrEqual(0);
      expect(status.cache_hit_rate).toBeLessThanOrEqual(1);
    });
  });

  describe("Emergency Rectification", () => {
    test("should perform emergency rectification bypassing cache", async () => {
      const testDate = new Date("2025-09-21");

      // First, populate cache
      await rectificationService.rectifyPlanetaryPositions(testDate);

      // Emergency rectification should bypass cache
      const emergencyResult =
        await rectificationService.emergencyRectification(testDate);

      expect(emergencyResult.success).toBe(true);
      expect(emergencyResult.rectification_report.authoritative_source).toBe(
        "planetary_agents_authoritative",
      );
      expect(emergencyResult.planetary_agents_sync_status).toMatch(
        /synced|partial/,
      );
    });

    test("should handle emergency rectification when Planetary Agents fails", async () => {
      mockFetch.mockRejectedValue(new Error("Emergency API failure"));

      const emergencyResult =
        await rectificationService.emergencyRectification();

      expect(emergencyResult.success).toBe(false);
      expect(emergencyResult.planetary_agents_sync_status).toBe("failed");
      expect(emergencyResult.errors).toBeDefined();
      expect(emergencyResult.errors!.length).toBeGreaterThan(0);
    });
  });

  describe("Accuracy Validation", () => {
    test("should detect and correct position discrepancies > 0.01Â°", async () => {
      // Setup a scenario with significant discrepancy
      mockFetch.mockResolvedValue({
        ok: true,
        json: async () => ({
          zodiac: {
            sign: "Virgo",
            degree_in_sign: 15.42,
            absolute_longitude: 175.42, // 10Â° difference from VSOP87
          },
          timestamp: new Date().toISOString(),
          accuracy_level: "authoritative",
        }),
      });

      const testDate = new Date("2025-09-21");
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result.success).toBe(true);
      expect(result.rectification_report.discrepancies_found).toBeGreaterThan(
        0,
      );
      expect(result.rectification_report.corrections_applied).toBeGreaterThan(
        0,
      );

      const sunPosition = result.synchronized_positions.Sun;
      expect(sunPosition.corrections_applied).toBe(true);
      expect(sunPosition.discrepancy_corrected).toBeGreaterThan(0.01);
    });

    test("should validate positions within tolerance without correction", async () => {
      // Setup minimal discrepancy (within 0.01Â° tolerance)
      mockGetEnhancedPlanetaryPositions.mockResolvedValue({
        Sun: {
          sign: "Virgo",
          degree: 15.42,
          exactLongitude: 165.42,
          isRetrograde: false,
        },
      });

      mockFetch.mockResolvedValue({
        ok: true,
        json: async () => ({
          zodiac: {
            sign: "Virgo",
            degree_in_sign: 15.42,
            absolute_longitude: 165.421, // Only 0.001Â° difference
          },
          timestamp: new Date().toISOString(),
          accuracy_level: "authoritative",
        }),
      });

      const testDate = new Date("2025-09-21");
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result.success).toBe(true);
      expect(result.rectification_report.discrepancies_found).toBe(0);

      const sunPosition = result.synchronized_positions.Sun;
      expect(sunPosition.validated_by).toBe("planetary_agents");
      expect(sunPosition.validation_confidence).toBe(1.0);
    });
  });

  describe("Error Handling and Resilience", () => {
    test("should handle malformed Planetary Agents API responses", async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        json: async () => ({
          invalid: "response",
          missing: "zodiac data",
        }),
      });

      const testDate = new Date("2025-09-21");
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      // Should still succeed with fallback to VSOP87
      expect(result.success).toBe(true);
      expect(result.planetary_agents_sync_status).toBe("failed");
    });

    test("should handle network timeouts gracefully", async () => {
      mockFetch.mockImplementation(
        () =>
          new Promise((resolve) => {
            setTimeout(() => resolve({ ok: false, status: 504 }), 100);
          }),
      );

      const testDate = new Date("2025-09-21");
      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);

      expect(result.success).toBe(true); // Should succeed with fallback
      expect(result.planetary_agents_sync_status).toBe("failed");
    });

    test("should maintain service availability during API outages", async () => {
      // Simulate complete Planetary Agents outage
      mockFetch.mockRejectedValue(new Error("Service unavailable"));

      const testDate = new Date("2025-09-21");

      // Multiple requests during outage
      const results = await Promise.all([
        rectificationService.rectifyPlanetaryPositions(testDate),
        rectificationService.rectifyPlanetaryPositions(testDate),
        rectificationService.getHealthStatus(),
      ]);

      // All operations should succeed despite API outage
      expect(results[0].success).toBe(true);
      expect(results[1].success).toBe(true);
      expect(results[2].overall_health).toBe("warning"); // Warning, not critical
    });
  });

  describe("Performance Benchmarks", () => {
    test("should complete rectification within performance targets", async () => {
      const testDate = new Date("2025-09-21");
      const startTime = Date.now();

      const result =
        await rectificationService.rectifyPlanetaryPositions(testDate);
      const duration = Date.now() - startTime;

      expect(result.success).toBe(true);
      expect(duration).toBeLessThan(1000); // Should complete within 1 second
      expect(
        result.rectification_report.rectification_duration_ms,
      ).toBeLessThan(500);
    });

    test("should scale efficiently with concurrent operations", async () => {
      const testDate = new Date("2025-09-21");
      const concurrentOperations = 10;

      const startTime = Date.now();
      const promises = Array.from({ length: concurrentOperations }, () =>
        rectificationService.rectifyPlanetaryPositions(testDate),
      );

      const results = await Promise.all(promises);
      const totalDuration = Date.now() - startTime;

      // All operations should succeed
      results.forEach((result) => {
        expect(result.success).toBe(true);
      });

      // Should complete within reasonable time (allowing for some overhead)
      expect(totalDuration).toBeLessThan(2000);

      // Average per operation should be reasonable
      const avgDuration = totalDuration / concurrentOperations;
      expect(avgDuration).toBeLessThan(200);
    });
  });
});

// Integration tests with actual API endpoints
describe("API Integration Tests", () => {
  test("should integrate with actual Planetary Agents API structure", async () => {
    // This test validates the API contract expectations
    const expectedApiResponse = {
      zodiac: {
        sign: expect.any(String),
        degree_in_sign: expect.any(Number),
        absolute_longitude: expect.any(Number),
      },
      timestamp: expect.any(String),
      accuracy_level: expect.stringMatching(/authoritative|verified/),
    };

    // Mock the expected API response structure
    mockFetch.mockResolvedValue({
      ok: true,
      json: async () => expectedApiResponse,
    });

    const testDate = new Date("2025-09-21");
    const result =
      await rectificationService.rectifyPlanetaryPositions(testDate);

    expect(result.success).toBe(true);
    expect(mockFetch).toHaveBeenCalledWith(
      expect.stringContaining("/zodiac-calendar?action=degree-for-date"),
      expect.objectContaining({
        headers: expect.objectContaining({
          Authorization: expect.stringContaining("Bearer"),
          "Content-Type": "application/json",
        }),
      }),
    );
  });

  test("should handle API rate limiting gracefully", async () => {
    // Simulate rate limiting
    mockFetch.mockResolvedValue({
      ok: false,
      status: 429,
      statusText: "Too Many Requests",
    });

    const testDate = new Date("2025-09-21");
    const result =
      await rectificationService.rectifyPlanetaryPositions(testDate);

    // Should succeed with fallback, but mark sync as failed
    expect(result.success).toBe(true);
    expect(result.planetary_agents_sync_status).toBe("failed");
  });
});
